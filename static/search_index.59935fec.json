[{"id":0,"title":"产生式（BNF）","content":"#\n\nTIP\n\n产生式（Production）是上下文无关文法（Context-Free Grammar）的组成部分，用于描述语言的语法规则。\n\n * ","routePath":"/JavaScript/basic/part1","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"单例模式","content":"#\n\n核心思想：\n\n一个类只有一个实例，并提供一个访问他的全局访问接口。\n\n注意：\n\n 1. 单例类只能有一个实例。\n 2. 单例类必须自己创建自己的唯一实例。\n 3. 单例类必须给所有其他对象提供这一实例。\n\n\n介绍#\n\n单例模式（Singleton Pattern）是\n最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象\n被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访\n问点来访问该实例。\n\n\n意图：#\n\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n\n主要解决：#\n\n一个全局使用的类频繁地创建与销毁。\n\n\n何时使用：#\n\n当您想控制实例数目，节省系统资源的时候。\n\n\n如何解决：#\n\n判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n\n\n关键代码：#\n\n构造函数是私有的。\n\n\n应用实例：#\n\n 1. 一个班级只有一个班主任。\n 2. Windows\n    是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n 3. 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n\n\n优点：#\n\n 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n 2. 避免对资源的多重占用（比如写文件操作）。\n\n\n缺点：#\n\n没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n\n使用场景：#\n\n 1. 要求生产唯一序列号。\n 2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n 3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n\n注意事项：#\n\ngetInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance\n被多次实例化。\n\n","routePath":"/JavaScript/design/part1","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":106},{"text":"意图：","id":"意图","depth":3,"charIndex":310},{"text":"主要解决：","id":"主要解决","depth":3,"charIndex":346},{"text":"何时使用：","id":"何时使用","depth":3,"charIndex":374},{"text":"如何解决：","id":"如何解决","depth":3,"charIndex":405},{"text":"关键代码：","id":"关键代码","depth":3,"charIndex":445},{"text":"应用实例：","id":"应用实例","depth":3,"charIndex":465},{"text":"优点：","id":"优点","depth":3,"charIndex":638},{"text":"缺点：","id":"缺点","depth":3,"charIndex":724},{"text":"使用场景：","id":"使用场景","depth":3,"charIndex":780},{"text":"注意事项：","id":"注意事项","depth":3,"charIndex":883}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"工厂模式","content":"#\n\n核心思想：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。\n\n例子： js 中的 document.createElement() 方法；Vue 和 React中的createElement() 方法\n\n\n介绍#\n\n\n意图：#\n\n定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n\n\n主要解决：#\n\n主要解决接口选择的问题。\n\n\n何时使用：#\n\n我们明确地计划不同条件下创建不同实例时。\n\n\n如何解决：#\n\n让其子类实现工厂接口，返回的也是一个抽象的产品。\n\n\n关键代码：#\n\n创建过程在其子类执行。\n\n\n应用实例：#\n\n 1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。\n 2. Hibernate 换数据库只需换方言和驱动就可以。\n\n\n优点：#\n\n 1. 一个调用者想创建一个对象，只要知道其名称就可以了。\n 2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。\n 3. 屏蔽产品的具体实现，调用者只关心产品的接口。\n\n\n缺点：#\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好\n事。\n\n\n使用场景：#\n\n 1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。\n 2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。\n 3. 设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。\n\n\n注意事项：#\n\n作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new\n就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n\n核心角色：#\n\n工厂模式包含以下几个核心角色：\n\n * 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。\n * 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。\n * 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。\n * 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。","routePath":"/JavaScript/design/part2","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":132},{"text":"意图：","id":"意图","depth":3,"charIndex":138},{"text":"主要解决：","id":"主要解决","depth":3,"charIndex":195},{"text":"何时使用：","id":"何时使用","depth":3,"charIndex":218},{"text":"如何解决：","id":"如何解决","depth":3,"charIndex":249},{"text":"关键代码：","id":"关键代码","depth":3,"charIndex":284},{"text":"应用实例：","id":"应用实例","depth":3,"charIndex":306},{"text":"优点：","id":"优点","depth":3,"charIndex":403},{"text":"缺点：","id":"缺点","depth":3,"charIndex":501},{"text":"使用场景：","id":"使用场景","depth":3,"charIndex":593},{"text":"注意事项：","id":"注意事项","depth":3,"charIndex":763},{"text":"核心角色：","id":"核心角色","depth":3,"charIndex":905}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"设计模式","content":"#\n\n\n单例模式#\n\n一个类只有一个实例，并提供一个访问他的全局访问接口。\n\n\n\n\n工厂模式#\n\n根据不同的参数，返回不同类的实例。 核心思想：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。\n\n例子： js 中的 document.createElement() 方法；Vue 和 React中的createElement() 方法\n\n\n策略模式#\n\n利用对象或Map来简化if-else和switch\n\n\n\n\n#","routePath":"/JavaScript/design/part3","lang":"","toc":[{"text":"单例模式","id":"单例模式","depth":3,"charIndex":3},{"text":"工厂模式","id":"工厂模式","depth":3,"charIndex":41},{"text":"策略模式","id":"策略模式","depth":3,"charIndex":196},{"text":"","id":"","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"设计模式","content":"#\n\n\n单例模式#\n\n一个类只有一个实例，并提供一个访问他的全局访问接口。\n\n\n\n\n工厂模式#\n\n根据不同的参数，返回不同类的实例。 核心思想：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。\n\n例子： js 中的 document.createElement() 方法；Vue 和 React中的createElement() 方法\n\n\n策略模式#\n\n利用对象或Map来简化if-else和switch\n\n\n\n\n#","routePath":"/JavaScript/design/part4","lang":"","toc":[{"text":"单例模式","id":"单例模式","depth":3,"charIndex":3},{"text":"工厂模式","id":"工厂模式","depth":3,"charIndex":41},{"text":"策略模式","id":"策略模式","depth":3,"charIndex":196},{"text":"","id":"","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"前端设计模式简介","content":"#\n\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计\n模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。\n\n\n原则#\n\n * 单一职责原则: 一个程序只做好一件事,如果功能过于复杂就拆分开，每个部分保持独立\n * 开放/封闭原则: 对扩展开放，对修改封闭 增加需求时，扩展新代码，而非修改已有代码\n * 里氏替换原则: 子类能覆盖父类 父类能出现的地方子类就能出现\n * 接口隔离原则: 保持接口的单一独立 类似单一职责原则，这里更关注接口\n * 依赖倒转原则: 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现\n * 迪米特法则（最少知识原则）： 对外接口简单，当前类对其他类的知识越少越好。\n\n\n创建型#\n\n 1. 工厂方法模式\n\n 2. 抽象工厂模式\n\n 3. 建造者模式\n\n 4. 原型模式\n\n 5. 单例模式\n\n\n结构型#\n\n 1. 适配器模式\n 2. 装饰器模式\n 3. 代理模式\n 4. 外观模式\n 5. 桥接模式\n 6. 组合模式\n 7. 享元模式\n\n\n行为型#\n\n 1.  策略模式\n 2.  模板方法模式\n 3.  观察者模式\n 4.  迭代器模式\n 5.  责任链模式\n 6.  命令模式\n 7.  备忘录模式\n 8.  状态模式\n 9.  访问者模式\n 10. 中介者模式\n 11. 解释器模式","routePath":"/JavaScript/design/readme","lang":"","toc":[{"text":"原则","id":"原则","depth":2,"charIndex":143},{"text":"创建型","id":"创建型","depth":2,"charIndex":402},{"text":"结构型","id":"结构型","depth":2,"charIndex":464},{"text":"行为型","id":"行为型","depth":2,"charIndex":537}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"let 和 const 命令","content":"声明\n\n本笔记学习自: 阮一峰的《ECMAScript 6 入门教程》\n\n\nlet 和 const 命令#\n\n\nlet#\n\n基本用法 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。不存在变量提升的弊端。\n\n\n\n在for循环中的差异\n\n\n\n\n暂时性死区#\n\n在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n\n\n\n不允许重复声明#\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\n\n块级作用域#\n\n请参考你不知道的JS的作用域\n\n\nconst 命令#\n\nconst声明一个只读的常量。一旦声明，常量的值就不能改变。除此之外，用法和let相同。\n\n\n\nconst一旦声明变量必须初始化\n\n\n\n\n本质#\n\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的\n那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的\n（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\n\n\n\n顶层对象的属性#\n\n顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。\n\n\n\n上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript\n语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而\n属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，wi\nndow对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。\n\nES6\n为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、cl\nass命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。\n\n\nglobalThis 对象#\n\nJavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。\n\n * 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。\n * 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。\n * Node 里面，顶层对象是global，但其他环境都不支持。\n\nES2020\n在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n\n垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。","routePath":"/JavaScript/es6/es6-1","lang":"","toc":[{"text":"let","id":"let","depth":2,"charIndex":55},{"text":"暂时性死区","id":"暂时性死区","depth":3,"charIndex":153},{"text":"不允许重复声明","id":"不允许重复声明","depth":3,"charIndex":239},{"text":"块级作用域","id":"块级作用域","depth":2,"charIndex":276},{"text":"const 命令","id":"const-命令","depth":2,"charIndex":301},{"text":"本质","id":"本质","depth":3,"charIndex":381},{"text":"顶层对象的属性","id":"顶层对象的属性","depth":2,"charIndex":615},{"text":"globalThis 对象","id":"globalthis-对象","depth":3,"charIndex":1112}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"Symbol","content":"#","routePath":"/JavaScript/es6/es6-10","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"Set 与 Map 数据结构","content":"#\n\n\nSet#\n\n\n基本用法#\n\nES6 提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet 本身是一个构造函数，用来生成 Set 数据结构。\n\n\n\n\nSet 实例的属性和方法#\n\nSet 结构的实例有以下属性。\n\n * Set.prototype.constructor ：构造函数，默认就是 Set 函数。\n\n * Set.prototype.size ：返回 Set 实例的成员总数。 Set\n   实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n * Set.prototype.add(value) ：添加某个值，返回 Set 结构本身。\n\n * Set.prototype.delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。\n\n * Set.prototype.has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。\n\n * Set.prototype.clear() ：清除所有成员，没有返回值。\n\nArray.from 方法可以将 Set 结构转为数组。\n\n\n\n\n遍历操作#\n\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\n\n * Set.prototype.keys() ：返回键名的遍历器\n * Set.prototype.values() ：返回键值的遍历器\n * Set.prototype.entries() ：返回键值对的遍历器\n * Set.prototype.forEach() ：使用回调函数遍历每个成员\n\n\nMap#\n\n\n含义和基本用法#\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n为了解决这个问题，ES6 提供了 Map\n数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object\n结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object\n更合适。\n\n\n\n作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组\n\n\n\n\n实例的属性和操作方法#\n\n 1. size 属性\n    \n    size 属性返回 Map 结构的成员总数。\n\n\n\n 2. Map.prototype.set(key, value)\n\nset 方法设置键名 key 对应的键值为 value ，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。\n\n\n\n 3. Map.prototype.get(key)\n\nget 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。\n\n\n\n 4. Map.prototype.has(key)\n\nhas 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\n\n\n 5. Map.prototype.delete(key)\n\ndelete 方法删除某个键，返回 true 。如果删除失败，返回 false 。\n\n\n\n 6. Map.prototype.clear()\n\nclear 方法清除所有成员，没有返回值。\n\n\n\n\n与其他数据结构的互相转换#\n\n 1. Map 转为数组\n\n前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（ ... ）。\n\n\n\n 2. 数组 转为 Map\n\n将数组传入 Map 构造函数，就可以转为 Map。\n\n\n\n 3. Map 转为对象\n\n如果所有 Map 的键都是字符串，它可以无损地转为对象。\n\n\n\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n\n 5. Map 转为 JSON\n\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\n\n\n\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\n\n\n\n 6. JSON 转为 Map\n\nJSON 转为 Map，正常情况下，所有键名都是字符串。\n\n","routePath":"/JavaScript/es6/es6-11","lang":"","toc":[{"text":"Set","id":"set","depth":2,"charIndex":3},{"text":"基本用法","id":"基本用法","depth":3,"charIndex":10},{"text":"Set 实例的属性和方法","id":"set-实例的属性和方法","depth":3,"charIndex":95},{"text":"遍历操作","id":"遍历操作","depth":3,"charIndex":508},{"text":"Map","id":"map","depth":2,"charIndex":694},{"text":"含义和基本用法","id":"含义和基本用法","depth":3,"charIndex":701},{"text":"实例的属性和操作方法","id":"实例的属性和操作方法","depth":3,"charIndex":1011},{"text":"与其他数据结构的互相转换","id":"与其他数据结构的互相转换","depth":3,"charIndex":1453}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"Proxy","content":"#\n\n\n介绍#\n\nProxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n\nProxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy\n这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。这也是Vue3的实现核心实现方法。\n\n\n\n\nProxy 实例的方法#\n\nProxy 支持的拦截操作一共 13 种。\n\n * get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy['foo'] 。\n * set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或\n   proxy['foo'] = v ，返回一个布尔值。\n * has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。\n * deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。\n * ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、\n   Object.getOwnPropertySymbols(proxy) 、 Object.keys(proxy) 、 for...in\n   循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。\n * getOwnPropertyDescriptor(target, propKey)：拦截\n   Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。\n * defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy,\n   propKey, propDesc） 、 Object.defineProperties(proxy, propDescs) ，返回一个布尔值。\n * preventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。\n * getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy) ，返回一个对象。\n * isExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。\n * setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)\n   ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\n * apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args) 、\n   proxy.call(object, ...args) 、 proxy.apply(...) 。\n * construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args) 。\n\n\nget()#\n\nget方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy\n实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\n\n\nget 方法可以继承。\n\n\n\n上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。\n\n\nset()#\n\nset方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。\n\n假定 Person 对象有一个 age 属性，该属性应该是一个不大于 200 的整数，那么可以使用 Proxy 保证 age 的属性值符合要求。\n\n\n\n\napply()#\n\napply方法拦截函数的调用、 call 和 apply 操作。apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（ this\n）和目标对象的参数数组。\n\n\n\n\nhas#\n\nhas方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。has\n方法可以接受两个参数，分别是目标对象、需查询的属性名。\n\n\n\nTIP\n * 如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。\n * has 拦截只对 in 运算符生效，对 for...in 循环不生效，导致不符合要求的属性没有被 for...in 循环所排除。 :::\n\n\nconstruct()#\n\nconstruct方法用于拦截new命令，construct 方法可以接受三个参数。 target ：目标对象 args ：构造函数的参数对象\nnewTarget ：创造实例对象时， new 命令作用的构造函数 下面是拦截对象的写法。\n\n\n\n\ndeleteProperty()#\n\ndeleteProperty方法用于拦截delete 操作，如果这个方法抛出错误或者返回 false ，当前属性就无法被 delete 命令删除。\n\n\n\n\ndefineProperty()#\n\ndefineProperty()方法拦截了 Object.defineProperty()操作。\n\n\n\n\ngetOwnPropertyDescriptor()#\n\ngetOwnPropertyDescriptor()方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者\nundefined 。\n\n\ngetPrototypeOf()#\n\ngetPrototypeOf()方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。\n\n * Object.prototype.proto\n * Object.prototype.isPrototypeOf()\n * Object.getPrototypeOf()\n * Reflect.getPrototypeOf()\n * instanceof\n\n\nisExtensible()#\n\nisExtensible() 方法拦截 Object.isExtensible() 操作。\n\n\nownKeys()#\n\nownKeys() 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n\n * Object.getOwnPropertyNames()\n * Object.getOwnPropertySymbols()\n * Object.keys()\n * for...in 循环\n\n\npreventExtensions()#\n\npreventExtensions()方法拦截 Object.preventExtensions() 。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n\n\nsetPrototypeOf()#\n\nsetPrototypeOf() 方法主要用来拦截 Object.setPrototypeOf()方法。\n\n\nProxy.revocable()#\n\nProxy.revocable() 方法返回一个可取消的 Proxy实例。\n\n\nthis 问题#\n\n虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy\n代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。\n\n\n\n一旦 proxy 代理 target.m ，后者内部的 this 就是指向 proxy ，而不是 target 。","routePath":"/JavaScript/es6/es6-12","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"Proxy 实例的方法","id":"proxy-实例的方法","depth":2,"charIndex":223},{"text":"get()","id":"get","depth":3,"charIndex":1544},{"text":"set()","id":"set","depth":3,"charIndex":1710},{"text":"apply()","id":"apply","depth":3,"charIndex":1864},{"text":"has","id":"has","depth":3,"charIndex":1964},{"text":"construct()","id":"construct","depth":3,"charIndex":2177},{"text":"deleteProperty()","id":"deleteproperty","depth":3,"charIndex":2313},{"text":"defineProperty()","id":"defineproperty","depth":3,"charIndex":2410},{"text":"getOwnPropertyDescriptor()","id":"getownpropertydescriptor","depth":3,"charIndex":2482},{"text":"getPrototypeOf()","id":"getprototypeof","depth":3,"charIndex":2603},{"text":"isExtensible()","id":"isextensible","depth":3,"charIndex":2802},{"text":"ownKeys()","id":"ownkeys","depth":3,"charIndex":2867},{"text":"preventExtensions()","id":"preventextensions","depth":3,"charIndex":3021},{"text":"setPrototypeOf()","id":"setprototypeof","depth":3,"charIndex":3123},{"text":"Proxy.revocable()","id":"proxyrevocable","depth":3,"charIndex":3197},{"text":"this 问题","id":"this-问题","depth":2,"charIndex":3257}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"Reflect","content":"#\n\n\n介绍#\n\nReflect 对象与Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。 Reflect 对象的设计目的有这样几个。\n\n（1） 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty ），放到 Reflect\n对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect\n对象上可以拿到语言内部的方法。\n\n（2） 修改某些 Object 方法的返回结果，让其变得更合理。比如， Object.defineProperty(obj, name, desc)\n在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false 。\n\n\n\n（3） 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name] ，而\nReflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。\n\n\n\n（4） Reflect对象的方法与 Proxy对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让\nProxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在\nReflect 上获取默认行为。\n\n\n\n\n静态方法#\n\n它与 Proxy 对象的方法是一一对应的。下面是对它们的解释。\n\n\nReflect.get(target, name, receiver)#\n\nReflect.get方法查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined","routePath":"/JavaScript/es6/es6-13","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"静态方法","id":"静态方法","depth":2,"charIndex":714},{"text":"Reflect.get(target, name, receiver)","id":"reflectgettarget-name-receiver","depth":3,"charIndex":755}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"Promise 对象","content":"#\n\n\nPromise 的含义#\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6\n将其写进了语言标准，统一了用法，原生提供了 Promise 对象。\n\n所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise\n是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\nPromise 对象有以下两个特点。\n\n 1. 对象的状态不受外界影响。 Promise\n    对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是\n    哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n 2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从\n    pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为\n    resolved（已定型）。如果改变已经发生了，你再对 Promise\n    对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的 resolved 统一只指 fulfilled 状态，不包含 rejected 状态。\n\n\n基本用法#\n\nES6 规定，Promise 对象是一个构造函数，用来生成Promise 实例。\n\n\n\n\nPromise.prototype.then()#\n\nPromise 实例具有then方法，也就是说， then 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise\n实例添加状态改变时的回调函数。前面说过， then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected\n状态的回调函数。\n\nthen 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个\nthen 方法。\n\n\n\n\nPromise.prototype.catch()#\n\nPromise.prototype.catch()方法是 .then(null, rejection)或 .then(undefined,\nrejection)的别名，用于指定发生错误时的回调函数。\n\n\n\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。\n\n\nPromise.prototype.finally()#\n\nfinally()方法用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是 ES2018引入标准的。\n\n\n\n\nPromise.all()#\n\nPromise.all()方法用于将多个Promise 实例，包装成一个新的 Promise 实例。\n\n\n\n\nPromise.race()#\n\nPromise.race() 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。只要其中有一个实例率先改变状态，\n状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给回调函数。\n\n\nPromise.allSettled()#\n\nPromise.allSettled() 方法接受一组 Promise 实例作为参数，包装成一个新的 Promise\n实例。只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected ，包装实例才会结束。该方法由 ES2020 引入。\n\n\nPromise.any()#\n\nPromise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成 fulfilled\n状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected\n状态。该方法目前是一个第三阶段的提案 。 :::warning 注 Promise.any() 跟 Promise.race()\n方法很像，只有一点不同，就是不会因为某个 Promise 变成 rejected 状态而结束。 :::","routePath":"/JavaScript/es6/es6-14","lang":"","toc":[{"text":"Promise 的含义","id":"promise-的含义","depth":2,"charIndex":3},{"text":"基本用法","id":"基本用法","depth":2,"charIndex":758},{"text":"Promise.prototype.then()","id":"promiseprototypethen","depth":2,"charIndex":810},{"text":"Promise.prototype.catch()","id":"promiseprototypecatch","depth":2,"charIndex":1088},{"text":"Promise.prototype.finally()","id":"promiseprototypefinally","depth":2,"charIndex":1286},{"text":"Promise.all()","id":"promiseall","depth":2,"charIndex":1379},{"text":"Promise.race()","id":"promiserace","depth":2,"charIndex":1450},{"text":"Promise.allSettled()","id":"promiseallsettled","depth":2,"charIndex":1581},{"text":"Promise.any()","id":"promiseany","depth":2,"charIndex":1738}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"Class 的基本语法","content":"#\n\n\n简介#\n\n\n类的由来#\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。\n\n\n\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。\n\n基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class\n写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样。\n\n\n\nES6 的类，完全可以看作构造函数的另一种写法。使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。\n\n\n\n构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。\n\n\n\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\n\n\nprototype 对象的 constructor 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\n\n\n\n\nconstructor 方法#\n\nconstructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor\n方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。\n\n\n\n\n类的实例#\n\n生成类的实例的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new ，像函数那样调用 Class ，将会报错。 与 ES5\n一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。 类的所有实例共享一个原型对象。\n\n\n\n\n取值函数（getter）和存值函数（setter）#\n\n与 ES5 一样，在“类”的内部可以使用 get和 set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n\n\n\n属性表达式#\n\n类的属性名，可以采用表达式。\n\n\n\n\nClass 表达式#\n\n与函数一样，类也可以使用表达式的形式定义。\n\n\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是 Me ，但是 Me 只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用\nMyClass 引用。\n\n\n\n:::tip 注意点\n\n 1. 严格模式 类和模块的内部，默认就是严格模式，所以不需要使用 use strict\n    指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6\n    实际上把整个语言升级到了严格模式。\n 2. 不存在提升 类不存在变量提升（hoist），这一点与 ES5 完全不同。\n 3. name 属性 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括 name 属性。\n 4. Generator 方法 如果某个方法之前加上星号（ * ），就表示该方法是一个 Generator 函数。\n 5. this 的指向 类的方法内部如果含有 this ，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 :::\n\n\n静态方法#\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static\n关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\n\n\n上面代码中，静态方法 bar 调用了 this.baz ，这里的 this 指的是 Foo 类，而不是 Foo 的实例，等同于调用 Foo.baz\n。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n父类的静态方法，可以被子类继承。\n\n\n实例属性的新写法#\n\n实例属性除了定义在constructor()方法里面的 this 上面，也可以定义在类的最顶层。\n\n\n\n\n静态属性#\n\n静态属性指的是Class本身的属性，即 Class.propName，而不是定义在实例对象（ this ）上的属性。\n\n\n\n\n私有方法和私有属性#\n\n\n现有的解决方案#\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\n\n\n上面代码中， _bar 方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\n另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n\n\n\n还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个 Symbol 值。\n\n\n\n\n私有属性的提案#\n\n目前，有一个提案，为 class 加了私有属性。方法是在属性名之前，使用 # 表示。\n\n\n\n\nnew.target 属性#\n\nnew是从构造函数生成实例对象的命令。ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new\n命令作用于的那个构造函数。如果构造函数不是通过 new 命令或 Reflect.construct() 调用的， new.target 会返回\nundefined ，因此这个属性可以用来确定构造函数是怎么调用的。\n\n\n\nClass 内部调用 new.target ，返回当前 Class。需要注意的是，子类继承父类时， new.target\n会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\n","routePath":"/JavaScript/es6/es6-15","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"类的由来","id":"类的由来","depth":3,"charIndex":9},{"text":"constructor 方法","id":"constructor-方法","depth":3,"charIndex":520},{"text":"类的实例","id":"类的实例","depth":3,"charIndex":646},{"text":"取值函数（getter）和存值函数（setter）","id":"取值函数getter和存值函数setter","depth":3,"charIndex":810},{"text":"属性表达式","id":"属性表达式","depth":3,"charIndex":904},{"text":"Class 表达式","id":"class-表达式","depth":3,"charIndex":931},{"text":"静态方法","id":"静态方法","depth":2,"charIndex":1454},{"text":"实例属性的新写法","id":"实例属性的新写法","depth":2,"charIndex":1678},{"text":"静态属性","id":"静态属性","depth":2,"charIndex":1742},{"text":"私有方法和私有属性","id":"私有方法和私有属性","depth":2,"charIndex":1812},{"text":"现有的解决方案","id":"现有的解决方案","depth":3,"charIndex":1825},{"text":"私有属性的提案","id":"私有属性的提案","depth":3,"charIndex":2092},{"text":"new.target 属性","id":"newtarget-属性","depth":2,"charIndex":2149}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"Class 的继承","content":"#\n\n\n简介#\n\nClass 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n\n\n子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this\n对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super\n方法，子类就得不到 this 对象。 在子类的构造函数中，只有调用 super 之后，才可以使用 this\n关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。\n\n\n\n父类的静态方法，也会被子类继承。\n\n\nObject.getPrototypeOf()#\n\nObject.getPrototypeOf 方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。\n\nObject.getPrototypeOf(ColorPoint) === Point\n\n\nsuper 关键字#\n\nsuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n\n * super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。\n\n\n\n * super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n","routePath":"/JavaScript/es6/es6-16","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"Object.getPrototypeOf()","id":"objectgetprototypeof","depth":2,"charIndex":324},{"text":"super 关键字","id":"super-关键字","depth":2,"charIndex":459}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"Module 的语法","content":"#\n\n\n概述#\n\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6\n在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\n区别详见随笔笔记/js随笔\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD\n模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n\n\n上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（ _fs ），然后再从这个对象上面读取 3\n个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n\nES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。\n\n\n\n\n严格模式#\n\nES6 的模块自动采用严格模式，不管你有没有在模块头部加上 \"use strict\"; 。 严格模式主要有以下限制。\n\n * 变量必须声明后再使用\n * 函数的参数不能有同名属性，否则报错\n * 不能使用 with 语句\n * 不能对只读属性赋值，否则报错\n * 不能使用前缀 0 表示八进制数，否则报错\n * 不能删除不可删除的属性，否则报错\n * 不能删除变量 delete prop ，会报错，只能删除属性 delete global[prop]\n * eval 不会在它的外层作用域引入变量\n * eval 和 arguments 不能被重新赋值\n * arguments 不会自动反映函数参数的变化\n * 不能使用 arguments.callee\n * 不能使用 arguments.caller\n * 禁止 this 指向全局对象\n * 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈\n * 增加了保留字（比如 protected 、 static 和 interface ）\n\n\nexport 命令#\n\n模块功能主要由两个命令构成：export和import 。 export 命令用于规定模块的对外接口， import 命令用于输入其他模块提供的功能。\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。下面是一个\nJS 文件，里面使用 export 命令输出变量。\n\n\n\n需要特别注意的是， export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n\n\n\n\nimport 命令#\n\n使用export 命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。\n\n","routePath":"/JavaScript/es6/es6-17","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"严格模式","id":"严格模式","depth":2,"charIndex":447},{"text":"export 命令","id":"export-命令","depth":2,"charIndex":918},{"text":"import 命令","id":"import-命令","depth":2,"charIndex":1169}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"Module 的加载实现","content":"#\n\n\n浏览器加载#\n\n\n传统方法#\n\nHTML 网页中，浏览器通过script标签加载 JavaScript 脚本。\n\n\n\n\n加载规则#\n\n浏览器加载 ES6 模块，也使用script标签，但是要加入type=\"module\" 属性。\n\n","routePath":"/JavaScript/es6/es6-18","lang":"","toc":[{"text":"浏览器加载","id":"浏览器加载","depth":2,"charIndex":3},{"text":"传统方法","id":"传统方法","depth":3,"charIndex":12},{"text":"加载规则","id":"加载规则","depth":3,"charIndex":63}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"变量的解构赋值","content":"#\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n\n\n数组的解构赋值#\n\n\n基本用法#\n\n\n\n\n例子#\n\n\n\n注\n\n如果解构不成功，变量的值就等于undefined。\n\n\n不完全解构#\n\n不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n\n\n\n如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。\n\n\n\n\n默认值#\n\n\n\n注\n\nES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效\n\n\n\n\n对象的解构赋值#\n\n解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性\n同名，才能取到正确的值。如果解构失败，变量的值等于undefined。\n\n\n\n\n自定义变量名#\n\n\n\n\n例子#\n\n\n\n\n默认值#\n\n对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。\n\n注\n * 如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n\n\n * 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。\n\n\n\n * 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\n\n\n\n字符串的解构赋值#\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\n\n\n\n数值和布尔值的解构赋值#\n\n解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。\n\n\n\n\n函数参数的解构赋值#\n\n函数的参数也可以使用解构赋值。\n\n\n\n\n默认值#\n\n","routePath":"/JavaScript/es6/es6-2","lang":"","toc":[{"text":"数组的解构赋值","id":"数组的解构赋值","depth":2,"charIndex":43},{"text":"基本用法","id":"基本用法","depth":3,"charIndex":54},{"text":"例子","id":"例子","depth":3,"charIndex":64},{"text":"不完全解构","id":"不完全解构","depth":3,"charIndex":102},{"text":"默认值","id":"默认值","depth":3,"charIndex":215},{"text":"对象的解构赋值","id":"对象的解构赋值","depth":2,"charIndex":296},{"text":"自定义变量名","id":"自定义变量名","depth":3,"charIndex":427},{"text":"例子","id":"例子-1","depth":3,"charIndex":439},{"text":"默认值","id":"默认值-1","depth":3,"charIndex":447},{"text":"字符串的解构赋值","id":"字符串的解构赋值","depth":2,"charIndex":623},{"text":"数值和布尔值的解构赋值","id":"数值和布尔值的解构赋值","depth":2,"charIndex":675},{"text":"函数参数的解构赋值","id":"函数参数的解构赋值","depth":2,"charIndex":768},{"text":"默认值","id":"默认值-2","depth":3,"charIndex":800}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"字符串的扩展","content":"#\n\nES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode\n码点。但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\n\n\n\n\n字符串的遍历器接口#\n\nES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。\n\n\n\n\nJSON.stringify() 的改造#\n\n根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8\n标准的字符串。为了确保返回的是合法的 UTF-8 字符，ES2019\n改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步\n的处理。\n\n\n模板字符串#\n\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。\n\n\n\n上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\n\n\n\nTIP\n\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n\n\n限制#\n\n模板字符串默认会将字符串转义，导致无法嵌入其他语言。","routePath":"/JavaScript/es6/es6-3","lang":"","toc":[{"text":"字符串的遍历器接口","id":"字符串的遍历器接口","depth":2,"charIndex":127},{"text":"JSON.stringify() 的改造","id":"jsonstringify-的改造","depth":2,"charIndex":198},{"text":"模板字符串","id":"模板字符串","depth":2,"charIndex":408},{"text":"限制","id":"限制","depth":3,"charIndex":642}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"字符串的新增方法","content":"#\n\n\nString.fromCodePoint()#\n\nES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。ES6\n提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正\n好与之后的codePointAt()方法相反。\n\n\n\n\nString.raw()#\n\nES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\n\n\ncodePointAt()#\n\nJavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode\n码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 ES6 提供了codePointAt()方法，能够正确处理 4\n个字节储存的字符，返回一个字符的码点\n\n\nnormalize()#\n\n许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode\n提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining\ncharacter），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。\n\n这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 ES6\n提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\n\n\nincludes(), startsWith(), endsWith()#\n\n传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\n\n * includes()：返回布尔值，表示是否找到了参数字符串。\n * startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n * endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\n\n\nTIP\n\n上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n\nrepeat()#\n\nrepeat方法返回一个新字符串，表示将原字符串重复n次。\n\n\n\n\npadStart()，padEnd()#\n\nES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\n\n\n\n\ntrimStart()，trimEnd()#\n\nES2019\n对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd\n()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\n\n\n\n浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。\n\n\nmatchAll()#\n\nmatchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。","routePath":"/JavaScript/es6/es6-4","lang":"","toc":[{"text":"String.fromCodePoint()","id":"stringfromcodepoint","depth":2,"charIndex":3},{"text":"String.raw()","id":"stringraw","depth":2,"charIndex":216},{"text":"codePointAt()","id":"codepointat","depth":2,"charIndex":313},{"text":"normalize()","id":"normalize","depth":2,"charIndex":487},{"text":"includes(), startsWith(), endsWith()","id":"includes-startswith-endswith","depth":2,"charIndex":771},{"text":"repeat()","id":"repeat","depth":2,"charIndex":1074},{"text":"padStart()，padEnd()","id":"padstartpadend","depth":2,"charIndex":1119},{"text":"trimStart()，trimEnd()","id":"trimstarttrimend","depth":2,"charIndex":1223},{"text":"matchAll()","id":"matchall","depth":2,"charIndex":1440}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"正则的扩展","content":"#","routePath":"/JavaScript/es6/es6-5","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"数值的扩展","content":"#\n\n\n二进制和八进制表示法#\n\nES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。从 ES5\n开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。\n\n\n\n\nNumber.isFinite(), Number.isNaN()#\n\nES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。\n\nNumber.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。注意，如果参数类型不是数值，Number.isFinit\ne一律返回false。\n\nNumber.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，Number.isNaN一律返回false。\n\n\n\n\nNumber.parseInt(), Number.parseFloat()#\n\nES6\n将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\n\nNumber.isInteger()#\n\nNumber.isInteger()用来判断一个数值是否为整数。如果参数不是数值，Number.isInteger返回false。\n\n\n\n\nNumber.EPSILON#\n\nES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。\n\nNumber.EPSILON实际上是 JavaScript\n能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计\n算是不精确的。\n\n\n\n\nMath 对象的扩展#\n\nES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。\n\n\nMath.trunc()#\n\nMath.trunc方法用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值。对于空值和无法截取整数的\n值，返回NaN。\n\n\n\n\nMath.sign()#\n\nMath.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。\n\n * 参数为正数，返回+1；\n * 参数为负数，返回-1；\n * 参数为 0，返回0；\n * 参数为-0，返回-0;\n * 其他值，返回NaN。 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。\n\n\n指数运算符#\n\nES2016 新增了一个指数运算符（**）。\n\n\n\n\nBigInt 数据类型#\n\nJavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16\n个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript\n不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。","routePath":"/JavaScript/es6/es6-6","lang":"","toc":[{"text":"二进制和八进制表示法","id":"二进制和八进制表示法","depth":2,"charIndex":3},{"text":"Number.isFinite(), Number.isNaN()","id":"numberisfinite-numberisnan","depth":2,"charIndex":119},{"text":"Number.parseInt(), Number.parseFloat()","id":"numberparseint-numberparsefloat","depth":2,"charIndex":374},{"text":"Number.isInteger()","id":"numberisinteger","depth":2,"charIndex":502},{"text":"Number.EPSILON","id":"numberepsilon","depth":2,"charIndex":593},{"text":"Math 对象的扩展","id":"math-对象的扩展","depth":2,"charIndex":803},{"text":"Math.trunc()","id":"mathtrunc","depth":3,"charIndex":878},{"text":"Math.sign()","id":"mathsign","depth":3,"charIndex":987},{"text":"指数运算符","id":"指数运算符","depth":3,"charIndex":1172},{"text":"BigInt 数据类型","id":"bigint-数据类型","depth":2,"charIndex":1207}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"函数的扩展","content":"#\n\n\n函数参数的默认值#\n\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\n\n\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。参数变量是默认声明的，所以不能用let或const再次声明。\n\n\n\n\n与解构赋值默认值结合使用#\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\n\n\n上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参\n数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\n\n\n\n\n参数默认值的位置#\n\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n\n\n\n上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。如果传入u\nndefined，将触发该参数等于默认值，null则没有这个效果。\n\n\n函数的 length 属性#\n\n指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。\n\n\n\n\n作用域#\n\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值\n时，是不会出现的。\n\n\n\n上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。\n\n\n\n上面代码中，函数f调用时，参数y =\nx形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。\n\n如果此时，全局变量x不存在，就会报错。\n\n\nrest 参数#\n\nES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest\n参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n\n\narguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。re\nst 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。\n\n\n\n注意\n * rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n * 函数的length属性，不包括 rest 参数。 :::\n\n\n严格模式#\n\n从 ES5 开始，函数内部可以设定为严格模式。ES2016\n做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。这样规定的原因是，函数内部的严格模式，同\n时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行\n，但是参数却应该先于函数体执行。\n\n\nname 属性#\n\n函数的name属性，返回该函数的函数名。这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。\n\n\n\n:::tip 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6\n的name属性会返回实际的函数名。\n\n\n\n\n箭头函数#\n\nES6 允许使用“箭头”（=>）定义函数。\n\n\n\n使用注意点\n * 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n * 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n * 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 :::\n\n\n尾调用优化#\n\n尾调用（Tail\nCall）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要是最后一步操作即\n可。\n\n\n\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call\nframe），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用\n帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可\n以了。\n\n\n\n上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(\nx)的调用帧，只保留g(3)的调用帧。\n\n这就叫做“尾调用优化”（Tail call\noptimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”\n的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n\n尾递归#\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack\noverflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n\n\n递归函数的改写#\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数\nfactorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算 5\n的阶乘，需要传入两个参数 5 和 1 ？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n\n\n\n柯里化#\n\n\n\nES6 的函数默认值#\n\n\n\nTIP\n\nES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n\n尾递归优化的实现#\n\n它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\n下面是一个正常的递归函数。\n\n\n\n\n函数参数的尾逗号#\n\nES2017 允许函数的最后一个参数有尾逗号（trailing comma）。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。\n\n\nFunction.prototype.toString()#\n\nES2019 对函数实例的 toString()方法做出了修改。toString() 方法返回函数代码本身，以前会省略注释和空格。\n\n","routePath":"/JavaScript/es6/es6-7","lang":"","toc":[{"text":"函数参数的默认值","id":"函数参数的默认值","depth":2,"charIndex":3},{"text":"与解构赋值默认值结合使用","id":"与解构赋值默认值结合使用","depth":3,"charIndex":117},{"text":"参数默认值的位置","id":"参数默认值的位置","depth":3,"charIndex":287},{"text":"函数的 length 属性","id":"函数的-length-属性","depth":3,"charIndex":479},{"text":"作用域","id":"作用域","depth":3,"charIndex":562},{"text":"rest 参数","id":"rest-参数","depth":2,"charIndex":859},{"text":"严格模式","id":"严格模式","depth":2,"charIndex":1194},{"text":"name 属性","id":"name-属性","depth":2,"charIndex":1412},{"text":"箭头函数","id":"箭头函数","depth":2,"charIndex":1578},{"text":"尾调用优化","id":"尾调用优化","depth":2,"charIndex":1794},{"text":"尾递归","id":"尾递归","depth":3,"charIndex":2469},{"text":"递归函数的改写","id":"递归函数的改写","depth":4,"charIndex":2597},{"text":"尾递归优化的实现","id":"尾递归优化的实现","depth":3,"charIndex":2880},{"text":"函数参数的尾逗号","id":"函数参数的尾逗号","depth":2,"charIndex":2987},{"text":"Function.prototype.toString()","id":"functionprototypetostring","depth":2,"charIndex":3069}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"数组的扩展","content":"#\n\n\n扩展运算符#\n\n扩展运算符（spread）是三个点（ ... ）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\n\n\n\n扩展运算符的应用#\n\n 1. 复制数组\n\n\n\n 2. 合并数组\n\n\n\n 3. 与解构赋值结合\n\n\n\n 4. 字符串转数组\n\n\n\n 5. 实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。\n\n\nArray.from()#\n\n用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象\n\n\n\n\nArray.of()#\n\n用于将一组值，转换为数组。基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n\n\n\n\ncopyWithin()#\n\n\nfind() 和 findIndex()#\n\nfind方法，用于找出第一个符合条件的数组成员. 它的参数是一个回调函数,回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 findIndex\n方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。\n\n\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。\n\n\nfill()#\n\nfill方法使用给定值，填充一个数组。\n\n\n\n\n#","routePath":"/JavaScript/es6/es6-8","lang":"","toc":[{"text":"扩展运算符","id":"扩展运算符","depth":2,"charIndex":3},{"text":"扩展运算符的应用","id":"扩展运算符的应用","depth":3,"charIndex":75},{"text":"Array.from()","id":"arrayfrom","depth":2,"charIndex":222},{"text":"Array.of()","id":"arrayof","depth":2,"charIndex":300},{"text":"copyWithin()","id":"copywithin","depth":2,"charIndex":387},{"text":"find() 和 findIndex()","id":"find-和-findindex","depth":2,"charIndex":403},{"text":"fill()","id":"fill","depth":2,"charIndex":604},{"text":"","id":"","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"对象的扩展","content":"#\n\n\n属性的简洁表示#\n\n\n\n\n属性名表达式#\n\n\n\n注意\n\n属性名表达式和简洁写法不能同时使用。\n\n\n方法的 name 属性#\n\n函数的name属性，返回函数名。对象方法也是函数，因此也有 name 属性。\n\n\n\n如果对象的方法使用了取值函数（ getter ）和存值函数（ setter ），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和\nset 属性上面，返回值是方法名前加上 get 和 set 。\n\n\n\n\n属性的可枚举性和遍历#\n\n\n可枚举性#\n\n引入“可枚举”（ enumerable ）这个概念的最初目的，就是让某些属性可以规避掉 for...in\n操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的 toString 方法，以及数组的 length 属性，就通过“可枚举性”，从而避免被\nfor...in 遍历到。\n\n对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。\nObject.getOwnPropertyDescriptor方法可以获取该属性的描述对象。\n\n\n\n\n属性的遍历#\n\n一共有5 种方法可以遍历对象的属性。\n\n * for...in：循环遍历对象自身的和继承的可枚举属性\n * Object.keys(obj)： 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n * Object.getOwnPropertyNames(obj)： 返回一个数组，包含对象自身的所有属性（不含 Symbol\n   属性，但是包括不可枚举属性）的键名。\n * Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n * Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n\nsuper 关键字#\n\n我们知道， this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super ，指向当前对象的原型对象。\n\n\n\n注意\n\nsuper 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。\n\n\n对象的扩展运算符#\n\n\n解构赋值#\n\n对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷\n贝到新对象上面。\n\n\n\n由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null ，就会报错，因为它们无法转为对象。\n解构赋值必须是最后一个参数，否则会报错。\n\n\n\n注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。\n\n\n扩展运算符#\n\n对象的扩展运算符（ ... ）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n\n\n\n链判断运算符#\n\n在实际编程中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取 message.body.user.firstName\n，安全的写法是写成下面这样。\n\n\n\n这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator） ?. ，简化上面的写法。\n\n\n\n链判断运算符有三种用法。\n\n * obj?.prop // 对象属性\n * obj?.[expr] // 同上\n * func?.(...args) // 函数或对象方法的调用\n\n\n对象的新增方法#\n\n\nObject.is()#\n\nObject.is用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\n\n\nObject.assign()#\n\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）\n\n","routePath":"/JavaScript/es6/es6-9","lang":"","toc":[{"text":"属性的简洁表示","id":"属性的简洁表示","depth":2,"charIndex":3},{"text":"属性名表达式","id":"属性名表达式","depth":2,"charIndex":16},{"text":"方法的 name 属性","id":"方法的-name-属性","depth":2,"charIndex":52},{"text":"属性的可枚举性和遍历","id":"属性的可枚举性和遍历","depth":2,"charIndex":223},{"text":"可枚举性","id":"可枚举性","depth":3,"charIndex":237},{"text":"属性的遍历","id":"属性的遍历","depth":3,"charIndex":477},{"text":"super 关键字","id":"super-关键字","depth":2,"charIndex":840},{"text":"对象的扩展运算符","id":"对象的扩展运算符","depth":2,"charIndex":967},{"text":"解构赋值","id":"解构赋值","depth":3,"charIndex":979},{"text":"扩展运算符","id":"扩展运算符","depth":3,"charIndex":1267},{"text":"链判断运算符","id":"链判断运算符","depth":2,"charIndex":1322},{"text":"对象的新增方法","id":"对象的新增方法","depth":2,"charIndex":1590},{"text":"Object.is()","id":"objectis","depth":3,"charIndex":1601},{"text":"Object.assign()","id":"objectassign","depth":3,"charIndex":1662}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"JAVASCRIPT","content":"#\n\n\nJavaScript实现#","routePath":"/JavaScript/gaoji/p1","lang":"","toc":[{"text":"JavaScript实现","id":"javascript实现","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"TypeScript 概览","content":"#\n\n来自\n\n前端瓶子君 来吧，一起对 TypeScript 扫盲吧！\n\n\nTypeScript 是什么？#\n\n简单理解就是 TypeScript 是增加了类型约束的 JavaScript，并且可以被编译成原生 JavaScript。\n\n * 为什么需要 TypeScript？\n   \n   * a. 与弱类型的 JS 结合，在编译期间增强类型检查，提前发现可能的缺陷\n   \n   * b. 通过强类型约束可以放心地进行多人协作开发，保证项目的可维护性\n   \n   * c. 与代码编辑器集成，提供自动补全、引用跳转等实用功能，提升开发效率\n\n\n基本用法#\n\n下面来看看 TypeScript 的基本用法\n\n\n基本类型#\n\n简单类型介绍#\n\n对于简单类型呢，就是 string、number、boolean、symbol、undefined 和 null，比较基础:\n\n\n\n自动推断类型#\n\n在某些场景，ts 是可以自己推断出类型的，比如:\n\n\n\nduang~ ts 发出了报错:👇\n\n\n\n对函数的返回值","routePath":"/JavaScript/typescript/ts-basic","lang":"","toc":[{"text":"TypeScript 是什么？","id":"typescript-是什么","depth":2,"charIndex":37},{"text":"基本用法","id":"基本用法","depth":2,"charIndex":275},{"text":"基本类型","id":"基本类型","depth":3,"charIndex":307},{"text":"简单类型介绍","id":"简单类型介绍","depth":4,"charIndex":314},{"text":"自动推断类型","id":"自动推断类型","depth":4,"charIndex":389}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"第一部分 作用域和闭包","content":"#\n\n\n1.1 编译原理#\n\n尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。\n但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。\n\n\n\n1.1.1 传统编译语言编译过程#\n\n以JS语言举例\n\n 1. 分词/词法分析 这个过程会将书写的编程字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。 例如：var a =\n    2;。这段程序通常被分解为var、a、=、2、;。空格是否被当作词法单元取决于空格在语言中是否有意义。 :::tip 关于分词和词法分析的区别\n    \n    * 本书中原文的描述中文翻译是：如果词法单元生成器在判断 a\n      是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。\n    * 通过查询资料本人的理解为：词法分析是用来做分词的手段，词法分析的目的是分词。 :::\n\n 2. 解析/语法分析 这个过程将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(AST)\n    抽象语法树类似一个对象，这个对象中存储了对分词的的描述。\n\n 3. 代码生成 将 AST 转换为可执行代码的过程被称为代码生成。\n\n\n1.1.2 JS编译#\n\n简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此， JavaScript 编译器首先会对 var a = 2;\n这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。\n\n\n1.1.3理解作用域#\n\n概念#\n\n 1. 引擎 从头到尾负责整个JS程序的编译及执行过程\n 2. 编译器 负责语法分析及代码生成\n 3. 作用域 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n过程#\n\n以“var a = 2;”为例\n\n 1. 编译器过程\n    1. 遇到var a，编译器会查询作用域中是否存在变量a，如果有则忽略，没有则创建一个变量，并命名为a。这个过程被称为LHS查询。即赋值操作的左侧查询。\n    2. 为引擎生成运行时所需要的代码，这些代码用来处理a = 2这个赋值操作。\n 2. 引擎过程\n    \n    1. 引擎会查询作用域中是否有a这个变量，如果有就直接使用这个变量，如果没有则向上一层作用域中查询。这个过程被称为RHS查询。即赋值操作的非左侧查询。\n    \n    2. 如果最后引擎没有找到a这个变量，则会抛出一个异常 :::tip LHS和RHS\n       LHS的意思是试图找到变量的容器本身，从而可以进行复制，而RHS的目的更强调“取到他的源值”。\n\nGO/AO过程\n\n 1. 创建执行上下文\n 2. 挂载变量（形参）声明 挂载函数声明\n 3. 执行\n\n\n\n结论：LHS 和 RHS 的含义是“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头 （RHS）”。 :::\n\n作用域嵌套#\n\n这一部分很好理解。就是当一个作用域中包含子作用域，那LHS和RHS在进行查询的时候，如果在当前作用域中没有查询到结果，会在外层嵌套作用域中继续查找。\n\n\n1.2 词法作用域#\n\n\n1.2.1 词法阶段#\n\n词法作用域就是定义在词法阶段的作用域\n\n\n\n在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡。\n\n\n\n 1. 包含着整个全局作用域，其中只有一个标识符：foo。\n 2. 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。\n 3. 包含着 bar 所创建的作用域，其中只有一个标识符：c。\n\n遮蔽效应\n * 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作遮蔽效应\n * 抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 ::: ::: 注\n   全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。可以通过形如window.a的方式去查找变量，绕开遮蔽效应 :::\n\n\n1.2.2 欺骗词法#\n\neval方法和with方法。 eval会对js的性能产生影响，不建议使用。 另外一个不推荐使用 eval和with 的原因是会被严格模式所影响（限制）。with\n被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval也被禁止了。\n\n\n1.3 函数作用域和块作用域#\n\n\n1.3.1 函数中的作用域#\n\n函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）\n\n隐藏内部实现#\n\n方法内部内容私有化，可以有效地规避重名带来的冲突\n\n函数作用域#\n\n声明函数名本身就会对所在作用域进行污染，所以在某些时候可以用立即执行函数来包裹方法。\n\n#1.3.2 块级作用域\n\nwith关键字省略。\n\ntry/catch#\n\ncatch会创建一个块级作用域，其中声明的变量只能在catch内部使用。当试图从别处引用时会抛出错误。\n\nlet 和 const#\n\nES6 引入了let 和 const 关键字，提供了除了var 之外的声明变量的方式。 let 和 const 关键字可以将变量绑定到所在的任意作用域中。\n其中两者的区别是 let 可以重新赋值 而const不可以。但是const声明的是对象或者数组，可以用来直接更改内部的属性。 比如const obj = {};\nobj.name = 'wenatie'\n\n\n\n 1. 垃圾收集 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。\n\n\n\n 2. let的for循环\n\n\n\n\n1.4 提升#\n\n\n1.4.1 先有鸡还是先有蛋#\n\n直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。\n\n\n\n\n1.4.2 变量提升#\n\n包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。\n\n\n\n这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了当前作用域的最上面。这个过程就叫作提升。 函数也是同理。\n\n\n\n:::tip not defined 和 undefined 的区别\n\n * not defined是没有定义\n * undefined是定义了没有赋值 :::\n\n\n1.4.3 函数优先#\n\n函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。\n\n\n\n\n1.5 作用域闭包#\n\n当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。\n\n\n\n无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。也就是说我们常用的callback也是闭包\n\n\n1.5.1 模块#","routePath":"/JavaScript/youdontknowjs/part1","lang":"","toc":[{"text":"1.1 编译原理","id":"11-编译原理","depth":2,"charIndex":3},{"text":"1.1.1 传统编译语言编译过程","id":"111-传统编译语言编译过程","depth":3,"charIndex":106},{"text":"1.1.2 JS编译","id":"112-js编译","depth":3,"charIndex":572},{"text":"1.1.3理解作用域","id":"113理解作用域","depth":3,"charIndex":698},{"text":"概念","id":"概念","depth":4,"charIndex":711},{"text":"过程","id":"过程","depth":4,"charIndex":837},{"text":"作用域嵌套","id":"作用域嵌套","depth":4,"charIndex":1307},{"text":"1.2 词法作用域","id":"12-词法作用域","depth":2,"charIndex":1392},{"text":"1.2.1 词法阶段","id":"121-词法阶段","depth":3,"charIndex":1405},{"text":"1.2.2 欺骗词法","id":"122-欺骗词法","depth":3,"charIndex":1797},{"text":"1.3 函数作用域和块作用域","id":"13-函数作用域和块作用域","depth":2,"charIndex":1933},{"text":"1.3.1 函数中的作用域","id":"131-函数中的作用域","depth":3,"charIndex":1951},{"text":"隐藏内部实现","id":"隐藏内部实现","depth":4,"charIndex":2026},{"text":"函数作用域","id":"函数作用域","depth":4,"charIndex":2061},{"text":"try/catch","id":"trycatch","depth":4,"charIndex":2139},{"text":"let 和 const","id":"let-和-const","depth":4,"charIndex":2204},{"text":"1.4 提升","id":"14-提升","depth":2,"charIndex":2464},{"text":"1.4.1 先有鸡还是先有蛋","id":"141-先有鸡还是先有蛋","depth":3,"charIndex":2474},{"text":"1.4.2 变量提升","id":"142-变量提升","depth":3,"charIndex":2564},{"text":"1.4.3 函数优先","id":"143-函数优先","depth":3,"charIndex":2760},{"text":"1.5 作用域闭包","id":"15-作用域闭包","depth":2,"charIndex":2821},{"text":"1.5.1 模块","id":"151-模块","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"第二部分 this和对象原型","content":"#\n\n\n1 关于this#\n\n\n1.1 为什么要用this#\n\n\n\n这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。如果不使用\nthis，那就需要给 identify() 和 speak() 显式传入一个上下文对象\n\n\n\n随着你的使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用\nthis则不会这样。当我们介绍对象和原型时，你就会明白函数可以自动引用合适的上下文对象有多重要。\n\n\n1.2 误解#\n\n1.2.1 指向自身#\n\n人们很容易把 this\n理解成指向函数自身。那么为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。\nJavaScript 的新手开发者通常会认为，既然函数看作一个对象（JavaScript\n中的所有函数都是对象），那就可以在调用函数时存储状态（属性的值）。这是可行的，有些时候也确实有用，但是在本书即将介绍的许多模式中你会发现，除了函数对象还有许多更\n合适存储状态的地方。\n\n不过现在我们先来分析一下这个模式，让大家看到 this 并不像我们所想的那样指向函数本身。\n\n\n\nconsole.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然是 0。显然从字面意思来理解 this\n是错误的。\n\n执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码this.count 中的 this\n并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。\n\n如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。\n\n\n\n还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments.callee\n\n来引用当前正在运行的函数对象。这是唯一一种可以从匿名函数对象内部引用自身的方法。然而，更好的方式是避免使用匿名函数，至少在需要自引用时使用具名函数（表达式）。a\nrguments.callee 已经被弃用，不应该再使用它。\n\n\n\n然而，这种方法同样回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。另一种方法是强制 this 指向 foo 函数对象：\n\n\n\n1.2.2 它的作用域#\n\n第二种常见的误解是，this 指向函数的作用域。需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 JavaScript\n内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它存在于 JavaScript 引擎内部。\n\n思考一下下面的代码，它试图（但是没有成功）跨越边界，使用 this 来隐式引用函数的词法作用域：\n\n\n\n首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的，我们之后会解释原因。调用 bar() 最自然的方法是省略前面的\nthis，直接使用词法引用标识符。\n\n此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让bar() 可以访问 foo() 作用域里的变量\na。这是不可能实现的，你不能使用 this 来引用一个词法作用域内部的东西。\n\n\n1.3 this到底是什么#\n\nthis 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this\n的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调\n用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。\n\n总而言之，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n\n\n2 this 全面解析#\n\n\n2.1 调用位置#\n\n在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个\nthis 到底引用的是什么？\n\n通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。\n\n最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。\n\n下面我们来看看到底什么是调用栈和调用位置：\n\n\n\n注意我们是如何（从调用栈中）分析出真正的调用位置的，因为它决定了 this 的绑定 :::tip\n你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。\n\n另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。就本例来说，你可以在工具中给\nfoo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条\ndebugger;语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。因此，如果你想要分析 this\n的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 :::\n\n\n2.2 绑定规则#\n\n2.2.1 默认绑定#\n\n首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。\n\n\n\n你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的。\n\n接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this\n指向全局对象。\n\n那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo()\n是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。\n\n如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined\n\n2.2.2 隐式绑定#\n\n另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。\n\n\n\n首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj\n中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj 对象。\n\n然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。\n\n无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this\n绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。\n\n对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：\n\n\n\n隐式丢失#\n\n一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined\n上，取决于是否是严格模式。\n\n\n\n虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar()\n其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n\n\n\n2.2.3 显式绑定#\n\n\n\n2.2.4 new绑定#\n\n在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的： something = new\nMyClass(..);JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中\nnew 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。\n\n在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，\n它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。包括内置对象函数（比如 Number(..)，详情请查看第 3\n章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。\n\n这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”\n\n使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n\n 1. 创建（或者说构造）一个全新的对象。\n 2. 这个新对象会被执行 \"原型\" 连接。\n 3. 这个新对象会绑定到函数调用的 this。\n 4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n\n\n使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。new 是最后一种可以影响函数调用时 this\n绑定行为的方法，我们称之为 new 绑定。\n\n\n2.3 优先级#\n\n现在我们已经了解了函数调用中 this\n绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。但是，如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定优先\n级。 隐式绑定和显式绑定哪个优先级更高？我们来测试一下：\n\n\n\n可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。\n\nWARNING\n\n\n\nnew 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。\n\n在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this\n绑定（无论绑定的对象是什么），并把我们 提供的对象绑定到 this 上。 这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用\nnew 来控制 this 绑定。\n\n\n\n判断this 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断：\n\n 1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo()\n 2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar =\n    foo.call(obj2)\n 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()\n 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()\n    就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 不过……凡事总有例外。\n\n\n2.4 绑定例外#\n\n2.4.1 被忽略的this#\n\n如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值\n在调用时会被忽略，实际应用的是默认绑定规则，那么什么情况下你会传入 null 呢？ 一种非常常见的做法是使用 apply(..)\n来“展开”一个数组，并当作参数传入一个函数。 类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用\n\n\n\n这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你 仍然需要传入一个占位值，这时 null\n可能是一个不错的选择，就像代码所示的那样。 :::tip 尽管本书中未提到，但在 ES6 中，可以用 ... 操作符代替 apply(..) 来“展\n开”数组，foo(...[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6\n中没有柯里化的相关语法，因此还是需要使用 bind(..)。 ::: 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了\nthis（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是\nwindow），这将导致不可预计的后果（比如修改全局对象）。 显而易见，这种方式可能会导致许多难以分析和追踪的 bug。\n\n更安全的this\n\n一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序\n产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized\nzone，非军事区）对象——它就是一个空的非委托的对象（委托在第 5 章和第 6 章介绍）。 如果我们在忽略 this 绑定时总是传入一个 DMZ\n对象，那就什么都不用担心了，因为任何 对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。\n由于这个对象完全是一个空对象，我自己喜欢用变量名 ø（这是数学中表示空集合符号的 小写形式）来表示它。在大多数键盘（比如说 Mac 的 US\n布局键盘）上都可以使用⌥ +o （Option-o）来打出这个符号。有些系统允许你为特殊符号设定快捷键。如果你不喜欢 ø 符\n号或者你的键盘不太容易打出这个符号，那你可以换一个喜欢的名字来称呼它。 无论你叫它什么，在 JavaScript 中创建一个空对象最简单的方法都是\nObject.create(null) （ 详 细 介 绍 请 看 第 5 章 ）。Object.create(null) 和 {} 很 像， 但 是 并 不\n会 创 建 Object. prototype 这个委托，所以它比 {}“更空”：\n\n\n\n使用变量名 ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为 ø 表示 “我希望 this 是空”，这比 null\n的含义更清楚。不过再说一遍，你可以用任何喜欢的名字 来命名 DMZ 对象。\n\n2.4.2 间接引用#\n\n另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生：\n\n\n\n赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者\no.foo()。根据我们之前说过的，这里会应用默认绑定。","routePath":"/JavaScript/youdontknowjs/part2","lang":"","toc":[{"text":"1 关于this","id":"1-关于this","depth":2,"charIndex":3},{"text":"1.1 为什么要用this","id":"11-为什么要用this","depth":3,"charIndex":15},{"text":"1.2 误解","id":"12-误解","depth":3,"charIndex":248},{"text":"1.2.1 指向自身","id":"121-指向自身","depth":4,"charIndex":257},{"text":"1.2.2 它的作用域","id":"122-它的作用域","depth":4,"charIndex":1049},{"text":"1.3 this到底是什么","id":"13-this到底是什么","depth":3,"charIndex":1477},{"text":"2 this 全面解析","id":"2-this-全面解析","depth":2,"charIndex":1726},{"text":"2.1 调用位置","id":"21-调用位置","depth":3,"charIndex":1741},{"text":"2.2 绑定规则","id":"22-绑定规则","depth":3,"charIndex":2339},{"text":"2.2.1 默认绑定","id":"221-默认绑定","depth":4,"charIndex":2350},{"text":"2.2.2 隐式绑定","id":"222-隐式绑定","depth":4,"charIndex":2747},{"text":"2.2.3 显式绑定","id":"223-显式绑定","depth":4,"charIndex":3336},{"text":"2.2.4 new绑定","id":"224-new绑定","depth":4,"charIndex":3351},{"text":"2.3 优先级","id":"23-优先级","depth":3,"charIndex":4076},{"text":"2.4 绑定例外","id":"24-绑定例外","depth":3,"charIndex":4948},{"text":"2.4.1 被忽略的this","id":"241-被忽略的this","depth":4,"charIndex":4959},{"text":"2.4.2 间接引用","id":"242-间接引用","depth":4,"charIndex":6247}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"大模型","content":"#\n\nTIP\n\nChatGLM 部署与微调 官方视频教程 ChatGLM 部署与调优教程","routePath":"/ai/llm/chatglm/part1","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"大模型入门","content":"#\n\n\n词表示#\n\n能让机器理解人类语言的算法，就是词表示。\n\n目标：\n\n * 词的相似度计算\n * 能够发现词之间的关系\n\n\n表示词义的方法#\n\n 1. 过去的时候 用一组相关词词来表示当前次，比如\n    \n    * 反义词近义词。\n    * 相关词，上位词（隶属于什么词）。\n    \n    ::: warning 缺陷\n    \n    1. 词义表达的粒度太粗，无法表达词义的精确性。\n    2. 主观性太高，无法保证准确性。\n    3. 数据吸收问题\n    4. 大量的人工工作 用来维护词典 :::\n\n 2. 现在 用向量来表示词义，比如\n    \n    * 词向量，比如word2vec。\n    * 上下文向量，比如BERT。 :::warning 缺陷\n      1. 随着词表的增加，向量维度会急剧增加，存储需求也会随之增加。\n      2. 出现频次较少的词，其向量表示会非常稀疏，无法准确表达其语义。 :::\n    * 词向量空间。（主要方式）\n\n优势\n\n词义表达的粒度更细，能够表达词义的精确性。\n\n\n语言模型#\n\n语言模型是词表示的基础，是自然语言处理的基础。\n\n\n主要工作#\n\n 1. 计算系列的词成为一句话的概率。\n 2. \n\n\n生成式模型#\n\n生成式模型是","routePath":"/ai/llm/llm-study/part1","lang":"","toc":[{"text":"词表示","id":"词表示","depth":2,"charIndex":3},{"text":"表示词义的方法","id":"表示词义的方法","depth":3,"charIndex":63},{"text":"语言模型","id":"语言模型","depth":2,"charIndex":474},{"text":"主要工作","id":"主要工作","depth":3,"charIndex":507},{"text":"生成式模型","id":"生成式模型","depth":2,"charIndex":541}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"概述","content":"#\n\n 1. 轻量级 JavaEE框架\n 2. 解决企业应用的复杂性\n 3. 核心部分： IOC AOP\n    1. IOC：控制反转，把创建对象交给spring 进行管理\n    2. AOP： 面向切面，不修改源代码进行功能增强\n 4. 特点\n    \n    1. 方便解耦，简化开发\n    \n    2. Aop编程支持\n    \n    3. 方便程序测试\n    \n    4. 方便和其他框架进行整合\n    \n    5. 方便进行事务操作\n    \n    6. 降低API开发难度\n\n下载地址：repo.spring.io\n\n\n创建spring5 工程#\n\n 1. 创建java工程\n\n 2. 导入jar包，基本功能至少包括 beans、context、core、expression、日志\n    \n    \n\n 3. 实现普通代码\n    \n    \n\n 4. 创建spring配置文件，配置文件中配置创建的对象\n    \n    1. 创建项xml文件\n    \n    2. 配置对象创建（我认为是对象的代理）\n       \n       \n\n 5. 进行测试代码编写\n    \n    ","routePath":"/formwork/spring5/part1","lang":"","toc":[{"text":"创建spring5 工程","id":"创建spring5-工程","depth":2,"charIndex":275}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"IOC操作Bean管理","content":"IOC容器#\n\n 1. 控制反转，把对象的创建和对象间的调用过程交给spring管理\n 2. 目的：降低代码耦合\n\n\nIOC 底层原理#\n\n\n过程#\n\n 1. xml配置文件，配置已经创建的对象\n\n 2. 创建工厂类\n    \n    \n\nIOC 接口（BeanFactory）\n\nspring 提供IOC容器实现的两种方式：\n\n\nBeanFactory#\n\n * IOC容器的基本实现，是Spring的内部接口，不提供开发人员进行使用\n * 在加载配置文件时不会创建对象，在获取对象时才会创建\n\n\nApplicationContext#\n\n * BeanFactory的子接口，提供更多更强大的功能，提供给开发人员使用。\n * 加载配置文件时就会把配置文件中的对象创建。\n\n\nIOC操作Bean管理#\n\nBean管理\n\n 1. spring 创建对象，利用xml及反射获取普通对象\n 2. spring 注入属性，利用spring注入JavaBean\n\n\n基于xml#\n\n\n创建对象#\n\n过程同概述中的创建过程。\n\nbean标签中的常用属性#\n\n * id: 获取对象的唯一标识。\n * class: 类的全路径\n * name: 类似id，用的较少\n\nspring 创建对象时，默认执行无参数构造方法进行对象的创建\n\n\n\n注入属性#\n\nDI：依赖注入#\n\n 1. 使用set方法\n    \n    1. 正常创建属性和set方法\n    \n    2. 在配置文件中的bean标签中写property标签\n       \n       \n\n 2. 使用有参构造\n    \n    1. 创建类，定义属性及构造方法\n       \n       \n    \n    2. 在配置文件中进行配置\n       \n       \n\n\n注入其他属性#\n\n 1. 字面量\n    \n    注入空值\n    \n    \n    \n    注入特殊符号\n    \n    \n\n 2. 外部bean\n    \n    1. 创建普通类和对象\n       \n       \n    \n    2. 在调用类中声明被调用类的变量和set方法\n       \n       \n\n 3. 在配置文件中进行配置\n    \n    \n\n 4. 内部bean\n    \n    1. 1. 一对多关系\n       \n       2. 在实体类之间表示\n       \n       3. 配置\n          \n          \n\n内部和外部bean区别\n 1. 配置文件中是使用bean给属性赋值还是用ref给属性赋值\n 2. 内部bean只能被当前bean使用，外部bean可以被多个bean使用\n\n 4. 级联赋值\n    \n    第一种写法：外部bean\n    \n    第二种写法：\n    \n    1. 创建get方法\n    \n    2. 写配置文件\n       \n       \n\n\n注入集合属性#\n\n 1. 创建类及array，list等集合属性，并创建set方法\n\n 2. 配置文件\n    \n    \n\n提取集合属性注入#\n\nutil使用步骤\n\n 1. xmlns:util=\"http://www.springframework.org/schema/util\"\n 2. xsi: schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/util\n    http://www.springframework.org/schema/util/spring-util.xsd\"\n 3. \n\n\n\nFactoryBean#\n\n 1. 普通bean： 在配置文件中定义的bean类型就是返回类型\n 2. 工厂bean：在配置文件中定义的bean和返回的额类型可能不一样\n\n\nbean的作用域#\n\n 1. 设置创建的bean实例是单例还是多个实例\n 2. 默认是单例\n 3. 设置方式 bean标签的scope属性 singleton | prototype | request | session\n\n\nbean生命周期#\n\n 1. 通过构造器 创建bean实例（实例化）\n 2. 为bean的属性设置值或者对其他bean的引用（属性赋值）\n 3. 调用bean的初始化方法（初始化）\n 4. 当容器关闭时，调用bean的销毁的方法（销毁）\n\n\n\n\n\n\nxml 自动装配#\n\n使用bean标签的autowire属性实现自动装配。 autowire常用值：\n\n 1. byName 变量名要和使用的bean id相同\n 2. byType 不能定义多个相同类型的bean\n\n\n外部配置文件#\n\n 1. 新建.properties文件\n 2. 在bean.xml文件中引入 context，使用context引入properties文件\n\n\n\n\n基于注解#\n\nSpring提供的注解\n\n 1. @Component\n 2. @Service\n 3. @Controller\n 4. @Repository\n\n上述注解功能相同，都可以用来创建bean实例\n","routePath":"/formwork/spring5/part2","lang":"","toc":[{"text":"过程","id":"过程","depth":2,"charIndex":70},{"text":"BeanFactory","id":"beanfactory","depth":3,"charIndex":165},{"text":"ApplicationContext","id":"applicationcontext","depth":3,"charIndex":249},{"text":"基于xml","id":"基于xml","depth":2,"charIndex":428},{"text":"创建对象","id":"创建对象","depth":3,"charIndex":437},{"text":"bean标签中的常用属性","id":"bean标签中的常用属性","depth":4,"charIndex":458},{"text":"注入属性","id":"注入属性","depth":3,"charIndex":562},{"text":"DI：依赖注入","id":"di依赖注入","depth":4,"charIndex":569},{"text":"注入其他属性","id":"注入其他属性","depth":3,"charIndex":765},{"text":"注入集合属性","id":"注入集合属性","depth":3,"charIndex":1249},{"text":"提取集合属性注入","id":"提取集合属性注入","depth":4,"charIndex":1312},{"text":"FactoryBean","id":"factorybean","depth":4,"charIndex":1646},{"text":"bean的作用域","id":"bean的作用域","depth":3,"charIndex":1733},{"text":"bean生命周期","id":"bean生命周期","depth":3,"charIndex":1847},{"text":"xml 自动装配","id":"xml-自动装配","depth":3,"charIndex":1972},{"text":"外部配置文件","id":"外部配置文件","depth":3,"charIndex":2082},{"text":"基于注解","id":"基于注解","depth":2,"charIndex":2166}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"概念","content":"#\n\n\n\n\n1、概述#\n\n\n1.1、Spring是什么？#\n\nSpring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化\nJava\n企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Sp\nring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。\n\nSpring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE\n代名词，成为了构建 Java EE 应用的事实标准。\n\n自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring\n6。本课程采用Spring当前最新发布的正式版本6.0.2。\n\n\n\n\n1.2、Spring 的狭义和广义#\n\n在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。\n\n广义的 Spring：Spring 技术栈\n\n广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。\n\n经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring\nFramework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中\nSpring Framework 是其他子项目的基础。\n\n这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。\n\n狭义的 Spring：Spring Framework\n\n狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。\n\nSpring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring\n技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。\n\nSpring 有两个最核心模块： IoC 和 AOP。\n\nIoC：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。\n\nAOP：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP\n用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP\n还解决一些系统层面上的问题，比如日志、事务、权限等。\n\n\n1.3、Spring Framework特点#\n\n * 非侵入式：使用 Spring Framework 开发应用程序时，Spring\n   对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化\n   。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。\n\n * 控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。\n\n * 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。\n\n * 容器：Spring IoC\n   是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发\n   效率。\n\n * 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java\n   注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。\n\n * 一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring\n   旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。\n\n\n1.4、Spring模块组成#\n\n官网地址：https://spring.io/\n\n\n\n\n\n上图中包含了 Spring\n框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。\n\n①Spring Core（核心容器）\n\nspring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念：\nBeans、BeanFactory、BeanDefinitions、ApplicationContext。\n\n * spring-core ：IOC和DI的基本实现\n\n * spring-beans：BeanFactory和Bean的装配管理(BeanFactory)\n\n * spring-context：Spring context上下文，即IOC容器(AppliactionContext)\n\n * spring-expression：spring表达式语言\n\n②Spring AOP\n\n * spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy\n * spring-aspects：集成AspectJ，AOP应用框架\n * spring-instrument：动态Class Loading模块\n\n③Spring Data Access\n\n * spring-jdbc：spring对JDBC的封装，用于简化jdbc操作\n * spring-orm：java对象与数据库数据的映射框架\n * spring-oxm：对象与xml文件的映射框架\n * spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信\n * spring-tx：spring jdbc事务管理\n\n④Spring Web\n\n * spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器\n * spring-webmvc：实现web mvc\n * spring-websocket：与前端的全双工通信协议\n * spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive\n   Web框架，异步，非阻塞，事件驱动的服务\n\n⑤Spring Message\n\n * Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务\n\n⑥Spring test\n\n * spring-test：集成测试支持，主要是对junit的封装\n\n\n1.5、Spring6特点#\n\n1.5.1、版本要求#\n\n（1）Spring6要求JDK最低版本是JDK17\n\n","routePath":"/formwork/spring6/part1","lang":"","toc":[{"text":"1、概述","id":"1概述","depth":2,"charIndex":5},{"text":"1.1、Spring是什么？","id":"11spring是什么","depth":3,"charIndex":13},{"text":"1.2、Spring 的狭义和广义","id":"12spring-的狭义和广义","depth":3,"charIndex":430},{"text":"1.3、Spring Framework特点","id":"13spring-framework特点","depth":3,"charIndex":1246},{"text":"1.4、Spring模块组成","id":"14spring模块组成","depth":3,"charIndex":1939},{"text":"1.5、Spring6特点","id":"15spring6特点","depth":3,"charIndex":3085},{"text":"1.5.1、版本要求","id":"151版本要求","depth":4,"charIndex":3101}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"","content":"","routePath":"/formwork/spring6/part2","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"","content":"","routePath":"/formwork/spring6/spring6","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"父子组件","content":"#\n\n父组件：\n\n\n\n子组件：\n\n","routePath":"/formwork/vue/fzzj","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"生命周期函数","content":"#\n\n","routePath":"/formwork/vue/smzqhs","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"","content":"","routePath":"/formwork/vue/test/test","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"vue实例属性","content":"#\n\n\ndata: 自定义变量#\n\n示例：\n\n\n\n\nmethods: 自定义函数#\n\n示例：\n\n\n\n\ncomponents: 自定义组件#\n\n示例：\n\n\n\n\ncomputed: 计算属性#\n\n示例：\n\n\n\n\nwatch: 计算属性#\n\n示例：\n\n\n\n","routePath":"/formwork/vue/vue-slsx","lang":"","toc":[{"text":"data: 自定义变量","id":"data-自定义变量","depth":2,"charIndex":3},{"text":"methods: 自定义函数","id":"methods-自定义函数","depth":2,"charIndex":25},{"text":"components: 自定义组件","id":"components-自定义组件","depth":2,"charIndex":50},{"text":"computed: 计算属性","id":"computed-计算属性","depth":2,"charIndex":78},{"text":"watch: 计算属性","id":"watch-计算属性","depth":2,"charIndex":103}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"VUE2原理分析","content":"#\n\nMVVM框架的三要素：数据响应式、模板引擎、渲染\n\n 1. 数据响应式：监听数据的变化并在视图中更新\n\n * Object.defineProperty() ---vue2\n * Proxy ---vue3\n\n 2. 模板引擎\n\n * 插值： {{}}\n * 指令： v-bind, v-on, v-model, v-for, v-if\n\n 3. 渲染: 将模板转换为html\n\n * 模板 => vdom => dom\n\n\n数据响应式原理#\n\n简单实现\n\n\n\n此时我们可以监听到对象的更改。这样我们就需要在监听到更改的同时去更新页面上的内容。 现在我们来对上边的方法进行一些修改。\n\n\n\n现在响应式的雏形已经具备了。 现在我们需要实现一个响应式的入口方法\n\n\n\n到此就实现了vue对象的简单响应式\n\n\nVue中的数据响应化#\n\n\n原理分析#\n\n 1. new Vue()首先进行初始化，对data执行响应化处理。这个过程发生在Observer中\n 2. 同时对模板进行编译，倒找其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中\n 3. 定义一个更新函数和watcher，将来对应数据变化时，watcher会调用更新函数\n 4. 由于data的某个key在一个视图中可能出现多次，所以每个key需要一个管家dep管理多个watcher\n 5. data数据发生变化，找到对应的dep，通知所有的watcher执行更新函数。\n\n框架构造函数#\n\n执行初始化操作。\n\n\n\n\n编译#\n\n编译模板中的vue语法，初始化视图，更新视图\n\n\n\n\n收集依赖#\n\n实现思路\n\n 1. 响应式化时为每一个key创建一个依赖Dep\n 2. 初始化时读取某个key，为这个key创建一个观察者watcher\n 3. 触发key的get方法时，将观察者添加到key对应的依赖中\n 4. 当key的set触发时，通过对应的Dep通知其管理所有的观察者进行更新。\n\n","routePath":"/formwork/vue/vueyuanli","lang":"","toc":[{"text":"数据响应式原理","id":"数据响应式原理","depth":2,"charIndex":215},{"text":"Vue中的数据响应化","id":"vue中的数据响应化","depth":2,"charIndex":354},{"text":"原理分析","id":"原理分析","depth":3,"charIndex":368},{"text":"框架构造函数","id":"框架构造函数","depth":4,"charIndex":631},{"text":"编译","id":"编译","depth":3,"charIndex":653},{"text":"收集依赖","id":"收集依赖","depth":3,"charIndex":685}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"样式绑定","content":"#\n\nclass绑定：\n\n 1. 对象语法\n    \n    \n\n 2. 数组语法\n    \n    \n\nstyle绑定：","routePath":"/formwork/vue/ysbd","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"响应式基础","content":"#\n\nTIP\n\nvue的官方文档是一个非常好的学习网站。\n\n\n声明响应式状态#\n\n\nreactive()#\n\n利用reactive函数可以创建一个响应式的对象或者数组。 大致过程如下：\n\n\n\n以上是一个官网的例子，这个例子很好地展示了一个响应式对象声明的过程。\n\n下面是一个在vue模板中的示例。 vue3 可以省略setup方法，使用\n\n这样创建的变量就是响应式的，在js中更改变量的值，dom就会相应的刷新。\n\n深层响应性#\n\n在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。\n\n\n\n也可以直接创建一个浅层响应式对象。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。\n\n\nref()#\n\nreactive() 的局限性#\n\nreactive() API 有两条限制：\n\n 1. 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。\n 2. 因为 Vue\n    的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引\n    用的响应性连接丢失：\n\n\n\nref函数没有任何类型限制，可以创建任意类型的响应式。\n\n\n\nref() 将传入参数的值包装为一个带 .value 属性的 ref 对象：\n\n\n\n这意味这我们修改ref声明的变量时，需要使用xx.value = xx或者xx.value.ff = xx这种形式:\n\n\n\nref 被传递给函数或是从一般对象上被解构时，不会丢失响应性：\n\n\n\n\nref的解包#\n\n\n在模板中的解包#\n\n当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value。下面是之前的计数器例子，用 ref() 代替：\n\n\n\nWARNING\n\n请注意，仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。 例如， object 是顶层属性，但 object.foo 不是。\n\n\n\n\nref 在响应式对象中的解包#\n\n当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样：\n\n\n\n如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：\n\n\n\n\n数组和集合类型的 ref 解包#\n\n跟响应式对象不同，当 ref 作为响应式数组或像 Map 这种原生集合类型的元素被访问时，不会进行解包。\n\n\n\n\n常见问题#\n\n\n要将响应式对象中的某个或多个属性单独提供给外部使用时#\n\n日常开发中经常碰到上述情形，但是直接使用ref的value进行赋值，新创建的响应式并不能与源数据保持同步。 要解决这类问题，有三种解决方式。\n\n 1. 使用toRef/toRefs\n\ntoRef()#\n\n基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。\n\n示例#\n\n\n\ntoRefs()#\n\n将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。\n\n示例#\n\n\n\n 2. 计算属性\n 3. 使用watch进行数据监听","routePath":"/formwork/vue3/reactive/part1","lang":"","toc":[{"text":"声明响应式状态","id":"声明响应式状态","depth":2,"charIndex":30},{"text":"","id":"","depth":3,"charIndex":-1},{"text":"深层响应性","id":"深层响应性","depth":4,"charIndex":207},{"text":"ref()","id":"ref","depth":3,"charIndex":316},{"text":"reactive() 的局限性","id":"reactive-的局限性","depth":4,"charIndex":324},{"text":"ref的解包","id":"ref的解包","depth":2,"charIndex":723},{"text":"在模板中的解包","id":"在模板中的解包","depth":3,"charIndex":733},{"text":"ref 在响应式对象中的解包","id":"ref-在响应式对象中的解包","depth":3,"charIndex":900},{"text":"数组和集合类型的 ref 解包","id":"数组和集合类型的-ref-解包","depth":3,"charIndex":1026},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":1101},{"text":"要将响应式对象中的某个或多个属性单独提供给外部使用时","id":"要将响应式对象中的某个或多个属性单独提供给外部使用时","depth":3,"charIndex":1109},{"text":"toRef()","id":"toref","depth":4,"charIndex":1230},{"text":"toRefs()","id":"torefs","depth":4,"charIndex":1318}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"模板引用","content":"#\n\n虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的\nref attribute：\n\n\n\n使用步骤为：\n\n 1. 在DOM元素或vue组件上使用ref属性，并为其赋值：。\n 2. 在script中使用ref声明一个变量，变量名需要与1中的ref的值相同。const input = ref(null).\n 3. 在组件挂载之后使用ref声明的变量即可获取元素。\n\n\nv-for 中的模板引用#\n\n当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素。","routePath":"/formwork/vue3/reactive/part10","lang":"","toc":[{"text":"v-for 中的模板引用","id":"v-for-中的模板引用","depth":2,"charIndex":238}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"组件基础","content":"#\n\n\n定义一个组件#\n\n每一个.vue都是组件。叫单文件组件。\n\n\n\n\n使用方法#\n\n\n\n\n数据传递#\n\n父组件引用子组件\n\n\n\n子组件\n\n\n\n当然也可以为props标注类型。可以参考官网为props标注类型\n\n\n事件交互#\n\n步骤与数据交互相同，区别在于使用方式。 父组件引用子组件\n\n\n\n子组件\n\n","routePath":"/formwork/vue3/reactive/part11","lang":"","toc":[{"text":"定义一个组件","id":"定义一个组件","depth":2,"charIndex":3},{"text":"使用方法","id":"使用方法","depth":2,"charIndex":36},{"text":"数据传递","id":"数据传递","depth":2,"charIndex":46},{"text":"事件交互","id":"事件交互","depth":2,"charIndex":107}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"组件深入","content":"#\n\n\n组件注册#\n\n\n全局注册#\n\n可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。\n\n\n\napp.component() 方法可以被链式调用：\n\n\n\n\n局部注册#\n\n全局注册虽然很方便，但有以下几个问题：\n\n 1. 全局注册，但并没有被使用的组件无法在生产打包时被自动移除\n    (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。\n 2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可\n    维护性。\n\n相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking\n更加友好。\n\n在使用\n\n如果没有使用\n\n除了使用字符串数组来声明 prop 外，还可以使用对象的形式#\n\n","routePath":"/formwork/vue3/reactive/part12","lang":"","toc":[{"text":"组件注册","id":"组件注册","depth":2,"charIndex":3},{"text":"全局注册","id":"全局注册","depth":3,"charIndex":11},{"text":"局部注册","id":"局部注册","depth":3,"charIndex":106},{"text":"Props","id":"props","depth":2,"charIndex":-1},{"text":"prop 的声明","id":"prop-的声明","depth":3,"charIndex":-1},{"text":"除了使用字符串数组来声明 prop 外，还可以使用对象的形式","id":"除了使用字符串数组来声明-prop-外还可以使用对象的形式","depth":4,"charIndex":424},{"text":"传递 prop 的细节","id":"传递-prop-的细节","depth":3,"charIndex":-1},{"text":"Prop的名字格式","id":"prop的名字格式","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"计算属性","content":"#\n\n模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。这种情况下，计算属性就会更加适合。\n\n\n基础示例#\n\n\n\n这里的模板看起来有些复杂。更重要的是，如果在模板中需要不止一次这样的计算，这样的代码将在模板里重复好多遍。因此推荐使用计算属性来描述依赖响应式状态的复杂逻辑。\n\n\n\n在这里定义了一个计算属性 publishedBooksMessage。computed() 方法默认接收一个 getter 函数，返回值为一个计算属性\nref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref\n也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。\n\nVue 的计算属性会自动追踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当\nauthor.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。\n\n\n可写计算属性#\n\n计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和\nsetter 来创建：\n\n\n\n不要在 getter 中做异步请求或者更改 DOM！\n\n计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。\n\n\n计算属性缓存 vs 方法#\n\n若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应\n式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage\n都会立即返回先前的计算结果，而不用重复执行 getter 函数。\n\n相比之下，方法总是会在重渲染发生时再次执行函数。\n\n为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于\nlist。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。","routePath":"/formwork/vue3/reactive/part2","lang":"","toc":[{"text":"基础示例","id":"基础示例","depth":2,"charIndex":73},{"text":"可写计算属性","id":"可写计算属性","depth":2,"charIndex":473},{"text":"计算属性缓存 vs 方法","id":"计算属性缓存-vs-方法","depth":2,"charIndex":653}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"条件渲染和列表渲染","content":"#\n\n\n条件渲染 v-if#\n\nv-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。 使用逻辑和表达式中的if-else相同\n\n\nv-if#\n\n\n\n\nv-else#\n\n使用 v-else 为 v-if 添加一个“else 区块”。\n\n\n\nTIP\n\n一个 v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则它将不会被识别。\n\n\nv-show#\n\n另一个可以用来按条件显示一个元素的指令是 v-show。其用法与v-if相同.\n\n不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。v-show 不支持在\n元素上使用，也不能和 v-else 搭配使用。\n\n\nv-for#\n\n我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items\n是源数据的数组，而 item 是迭代项的别名.\n\n在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。\n\n\n\nv-for 变量的作用域和下面的 JavaScript 代码很类似：\n\n","routePath":"/formwork/vue3/reactive/part3","lang":"","toc":[{"text":"条件渲染 `v-if`","id":"条件渲染-v-if","depth":2,"charIndex":-1},{"text":"v-if","id":"v-if","depth":3,"charIndex":81},{"text":"v-else","id":"v-else","depth":3,"charIndex":91},{"text":"v-show","id":"v-show","depth":3,"charIndex":195},{"text":"v-for","id":"v-for","depth":2,"charIndex":348}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"侦听器","content":"#\n\n计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。\n\n\n\n\n侦听数据源类型#\n\nwatch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：\n\n\n\n注意，你不能直接侦听响应式对象的属性值，例如:\n\n\n\n\n深层侦听器#\n\n直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的值变更时都会被触发：\n\n\n\n一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：\n\n","routePath":"/formwork/vue3/reactive/part9","lang":"","toc":[{"text":"侦听数据源类型","id":"侦听数据源类型","depth":2,"charIndex":84},{"text":"深层侦听器","id":"深层侦听器","depth":2,"charIndex":205}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"pro git 中文版","content":"#","routePath":"/gongjushu/git/git","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"webpack 基础","content":"#\n\n\n基本配置#\n\n\n\n\nwebpack 打包HTML#\n\n\nwebpack 开发优化#\n\n\nPWA 离线加载#\n\n\nTree Shaking#\n\n\n代码分割#\n\n\n懒加载#\n\n\n多进程打包#\n\nthread-loader\n\n\nexternals#\n\n忽略需要打包到bundle中的库，通过cdn引入\n\n\ndll#","routePath":"/gongjushu/webpack/wp1","lang":"","toc":[{"text":"基本配置","id":"基本配置","depth":2,"charIndex":3},{"text":"webpack 打包HTML","id":"webpack-打包html","depth":2,"charIndex":13},{"text":"webpack 开发优化","id":"webpack-开发优化","depth":2,"charIndex":31},{"text":"PWA 离线加载","id":"pwa-离线加载","depth":3,"charIndex":47},{"text":"Tree Shaking","id":"tree-shaking","depth":3,"charIndex":59},{"text":"代码分割","id":"代码分割","depth":3,"charIndex":75},{"text":"懒加载","id":"懒加载","depth":3,"charIndex":83},{"text":"多进程打包","id":"多进程打包","depth":3,"charIndex":90},{"text":"externals","id":"externals","depth":3,"charIndex":114},{"text":"dll","id":"dll","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"HarmonyOS 简介","content":"#\n\n随着万物互联时代的开启，应用的设备底座将从几十亿手机扩展到数百亿IoT设备。全新的全场景设备体验，正深入改变消费者的使用习惯。\n同时应用开发者也面临设备底座从手机单设备到全场景多设备的转变，全场景多设备的全新底座，为消费者带来万物互联时代更为高效、便捷的体验。\n\n新的场景同时也带来了新的挑战。开发者不仅需要支持更加多样化的设备，还需要支持跨设备的协作。不同设备类型意味着不同的传感器能力、硬件能力、屏幕尺寸、操作系统和开发\n语言，还意味着差异化的交互方式。同时跨设备协作也让开发者面临分布式开发带来的各种复杂性，例如跨设备的网络通信、数据同步等。若采取传统开发模式，适配和管理工作量将\n非常巨大。\n\n当前移动应用开发中遇到的主要挑战包括：\n\n * 针对不同设备上的不同操作系统，重复开发，维护多套版本。\n * 多种语言栈，对人员技能要求高。\n * 多种开发框架，不同的编程范式。\n * 命令式编程，需关注细节，变更频繁，维护成本高。\n\n\n\n与此同时，AI时代全面来临。随着人们对交互和信息获取的智能化要求越来越高，移动设备的计算能力越来越强，在设备侧就能提供AI的相关能力，例如自然语言交互、环境智能\n感知、图像识别等。如何快速地使用这些AI能力，使自己的应用更加智能化，进而更好的服务消费者，也是开发者面临的全新挑战。\n\n移动终端上的应用生态发展到今天也面临着变革。传统厚重的App\n，整体体验好，功能齐全，但开发成本高、周期长，且存在搜索，安装，升级，卸载等一系列需要用户主动关注的显性操作，这些显性操作给用户带来了实质性的使用成本。轻量化、\n可快速达成消费者意图、可独立执行、完成单一功能的程序实体正成为新的趋势。\n\n为了更好的抓住机遇，应对万物互联所带来的一系列挑战，新的应用生态应该具备如下特征：\n\n * 单一设备延伸到多设备：应用一次开发就能在多个设备上运行，软件实体能够从单一设备转移到其他设备上，且多个设备间能够协同运行，给消费者提供全新的分布式体验。\n * 厚重应用模式到轻量化服务模式：提供轻量化的服务，最小化资源消耗，一步直达，快速完成消费者特定场景的任务。\n * 集中化分发到AI加持下的智慧分发：为消费者提供智慧场景服务，实现“服务找人”。\n * 纯软件到软硬芯协同的AI能力：提供软硬芯协同优化的原生AI能力，全面满足应用高性能诉求。\n\n\n\nHarmonyOS是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言，为用户带来简捷，流畅，连续，安全可靠的全场景交互体验。\n\nHarmonyOS结合移动生态发展的趋势，提出了三大技术理念：一次开发，多端部署；可分可合，自由流转；统一生态，原生智能。核心技术理念详细内容可参考《鸿蒙生态应\n用开发白皮书》，此白皮书全面阐释了HarmonyOS生态下应用开发核心理念、关键能力以及创新体验，旨在帮助开发者快速、准确、全面的了解HarmonyOS开发套件\n给开发者提供的能力全景和未来的愿景。\n\n另外，《鸿蒙生态应用开发白皮书》全面阐述了HarmonyOS生态下应用安全核心理念；通过应用开发、应用发布、应用安装运行三个阶段，构建关键安全能力，从始至终贯彻\n应用安全核心理念，帮助开发者快速理解HarmonyOS生态应用安全设计，","routePath":"/harmony/kaifajichu/part1","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"开发环境搭建","content":"#\n\nDevEco Studio支持Windows和macOS系统。\n\n\nWindows环境搭建#\n\n\n运行环境要求#\n\n为保证DevEco Studio正常运行，建议电脑配置满足如下要求：\n\n * 操作系统：Windows10 64位、Windows11 64位\n * 内存：16GB及以上\n * 硬盘：100GB及以上\n * 分辨率：1280*800像素及以上\n\n\n安装DevEco Studio#\n\n 1. 下载完成后，双击下载的“deveco-studio-xxxx.exe”，进入DevEco\n    Studio安装向导。在如下界面选择安装路径，默认安装于C:\\Program\n    Files路径下，也可以单击浏览（B）...指定其他安装路径，然后单击Next。\n 2. 在如下安装选项界面勾选DevEco Studio后，单击Next，直至安装完成。\n 3. 安装完成后，单击Finish完成安装。\n\n说明\n * DevEco Studio提供开箱即用的开发体验，将HarmonyOS\n   SDK、Node.js、Hvigor、OHPM、模拟器平台等进行合一打包，简化DevEco Studio安装配置流程。\n * HarmonyOS SDK已嵌入DevEco Studio中，无需额外下载配置。HarmonyOS SDK可以在DevEco\n   Studio安装位置下DevEco Studio\\sdk目录中查看。如需进行OpenHarmony应用开发，可通过Settings >\n   OpenHarmony SDK页签下载OpenHarmony SDK。\n\n\n诊断开发环境#\n\n为了您开发应用/元服务的良好体验，DevEco\nStudio提供了开发环境诊断的功能，帮助您识别开发环境是否完备。您可以在欢迎页面单击Diagnose进行诊断。如果您已经打开了工程开发界面，也可以在菜单栏单击\nHelp > Diagnostic Tools > Diagnose Development Environment进行诊断。\n\n\n\nDevEco Studio开发环境诊断项包括电脑的配置、网络的连通情况、依赖的工具是否安装等。如果检测结果为未通过，请根据检查项的描述和修复建议进行处理。\n\n\n启用中文化插件#\n\n 1. 单击File > Settings（macOS为DevEco Studio > Preferences ） >\n    Plugins，选择Installed页签，在搜索框输入“Chinese”，搜索结果里将出现Chinese(Simplified)，在右侧单击Enabl\n    e，单击OK。\n\n 2. 在弹窗中单击Restart，重启DevEco Studio后即可生效。","routePath":"/harmony/kaifajichu/part2","lang":"","toc":[{"text":"Windows环境搭建","id":"windows环境搭建","depth":2,"charIndex":36},{"text":"运行环境要求","id":"运行环境要求","depth":3,"charIndex":51},{"text":"安装DevEco Studio","id":"安装deveco-studio","depth":3,"charIndex":184},{"text":"诊断开发环境","id":"诊断开发环境","depth":2,"charIndex":692},{"text":"启用中文化插件","id":"启用中文化插件","depth":2,"charIndex":953}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"创建ArkTS工程","content":"#\n\n 1. 若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File > New >\n    Create Project来创建一个新工程。\n\n 2. 选择Application应用开发（本文以应用开发为例，Atomic Service对应为元服务开发），选择模板“Empty\n    Ability”，点击Next进行下一步配置。 若开发者需要进行Native相关工程的开发，请选择“Native\n    C++”模板，更多模板的使用和说明请见工程模板介绍。\n\n 3. 进入配置工程界面，Compatible SDK表示兼容的最低API Version，此处以选择“5.0.0(12)”为例，其他参数保持默认设置即可。\n\n 4. 点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。\n\n 5. \n\n\nArkTS工程目录结构（Stage模型）#\n\n\n\n * AppScope > app.json5：应用的全局配置信息，详见app.json5配置文件。\n * entry：HarmonyOS工程模块，编译构建生成一个HAP包。\n   * src > main > ets：用于存放ArkTS源码。\n   * src > main > ets > entryability：应用/服务的入口。\n   * src > main > ets > entrybackupability：应用提供扩展的备份恢复能力。\n   * src > main > ets > pages：应用/服务包含的页面。\n   * src > main >\n     resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。\n   * src > main >\n     module.json5：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，\n     详见module.json5配置文件。\n   * build-profile.json5：当前的模块信息 、编译信息配置项，包括buildOption、targets配置等。\n   * hvigorfile.ts：模块级编译构建任务脚本。\n   * obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资\n     产。详见开启代码混淆。\n   * oh-package.json5：用来描述包名、版本、入口文件（类型声明文件）和依赖项等信息。\n * oh_modules：用于存放三方库依赖信息。\n * build-profile.json5：工程级配置信息，包括签名signingConfigs、产品配置products等。其中products中可配置当前\n   运行环境，默认为HarmonyOS。\n * hvigorfile.ts：工程级编译构建任务脚本。\n * oh-package.json5：主要用来描述全局配置，如：依赖覆盖（overrides）、依赖关系重写（overrideDependencyMap）和参\n   数化配置（parameterFile）等。\n\n\n构建第一个页面#\n\n 1. 使用文本组件。\n\nINFO\n\n工程同步完成后，在“Project”窗口，点击“entry > src > main > ets >\npages”，打开“Index.ets”文件，进行页面的编写。\n\n针对本文中使用文本/按钮来实现页面跳转/返回的应用场景，页面均使用Row和Column组件来组建布局。对于更多复杂元素对齐的场景，可选择使用RelativeCo\nntainer组件进行布局。\n\n“Index.ets”文件的示例如下：\n\n\n\n 2. 添加按钮。\n\nINFO\n\n在默认页面基础上，我们添加一个Button组件，作为按钮响应用户点击，从而实现跳转到另一个页面。“Index.ets”文件的示例如下：\n\n\n\n在编辑窗口右上角的侧边工具栏，点击Previewer，打开预览器。第一个页面效果如下图所示：\n\n\n构建第二个页面#\n\n 1. 创建第二个页面。\n\n * 新建第二个页面文件。在“Project”窗口，打开“entry > src > main > ets”，右键点击“pages”文件夹，选择“New >\n   ArkTS File”，命名为“Second”，点击回车键。可以看到文件目录结构如下：\n\n说明\n\n开发者也可以在右键点击“pages”文件夹时，选择“New > Page > Empty\n\nPage”，命名为“Second”，点击“Finish”完成第二个页面的创建。使用此种方式则无需再进行下文中第二个页面路由的手动配置。\n\n * 配置第二个页面的路由。在“Project”窗口，打开“entry > src > main > resources > base >\n   profile”，在main_pages.json文件中的“src”下配置第二个页面的路由“pages/Second”。示例如下：\n   \n   \n\n 2. 添加文本及按钮。 参照第一个页面，在第二个页面添加Text组件、Button组件等，并设置其样式。“Second.ets”文件的示例如下：\n    \n    \n\n\n实现页面间的跳转#\n\n页面间的导航可以通过页面路由router 来实现。页面路由router根据页面url找到目标页面，从而实现跳转。使用页面路由请导入router模块。\n\n如果需要实现更好的转场动效，推荐使用Navigation。\n\n 1. 第一个页面跳转到第二个页面。\n    \n    在第一个页面中，跳转按钮绑定onClick事件，点击按钮时跳转到第二页。“Index.ets”文件的示例如下：\n    \n    \n\n 2. 第二个页面返回到第一个页面。\n\n在第二个页面中，返回按钮绑定onClick事件，点击按钮时返回到第一页。“Second.ets”文件的示例如下：\n\n\n\n 3. 打开Index.ets文件，点击预览器中的 按钮进行刷新。效果如下图所示：\n\n\n\n\n使用真机运行应用#\n\n 1. 将搭载HarmonyOS系统的真机与电脑连接。具体指导及要求，可查看使用本地真机运行应用/服务。\n\n 2. 点击File > Project Structure... > Project > SigningConfigs界面勾选“Support\n    HarmonyOS”和“* Automatically generate signature*”，点击界面提示的“Sign\n    In”，使用华为账号登录。等待自动签名完成后，点击“OK ”即可。如下图所示：\n\n\n\n 3. 在编辑窗口右上角的工具栏，点击 按钮运行。效果如下图所示：\n\n\n\n恭喜您已经基于Stage模型构建完成第一个ArkTS应用，快来探索更多的HarmonyOS功能吧。","routePath":"/harmony/kaifajichu/part3","lang":"","toc":[{"text":"ArkTS工程目录结构（Stage模型）","id":"arkts工程目录结构stage模型","depth":2,"charIndex":396},{"text":"构建第一个页面","id":"构建第一个页面","depth":2,"charIndex":1421},{"text":"构建第二个页面","id":"构建第二个页面","depth":2,"charIndex":1791},{"text":"实现页面间的跳转","id":"实现页面间的跳转","depth":2,"charIndex":2295},{"text":"使用真机运行应用","id":"使用真机运行应用","depth":2,"charIndex":2634}],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"代码编辑","content":"#\n\nDevEco\nStudio支持使用多种语言进行应用/元服务的开发，包括ArkTS、JS和C/C++。在编写应用/元服务阶段，可以通过掌握代码编写的各种常用技巧，来提升编码效率\n。\n\n\n代码高亮#\n\n支持对代码关键字、运算符、字符串、类、标识符、注释等进行高亮显示，您可以打开File > Settings（macOS为DevEco Studio >\nPreferences）面板，在Editor > Color Scheme自定义各字段的高亮显示颜色**。默认情况下，您可以在Language\nDefaults**\n中设置源代码中的各种高亮显示方案，该设置将对所有语言生效；如果您需要针对具体语言的源码高亮显示方案进行定制，可以在左侧边栏选择对应的语言，然后取消“Inheri\nt values from”选项后设置对应的颜色即可。\n\n\n\n\n代码跳转#\n\n在编辑器中，可以按住Ctrl键（macOS为Command\n键），鼠标单击代码中引用的类、方法、参数、变量等名称，自动跳转到定义处。若单击定义处的类、变量等名称，当仅有一处引用时，可直接跳转到引用位置；若有多处引用，在弹\n窗中可以选择想要查看的引用位置。\n\n\n\n\n跨语言跳转#\n\nDevEco\nStudio支持在声明或引用了Native接口的文件中（如d.ts）跨语言跳转其对应的C/C++函数，从而提升混合语言开发时的开发效率。您可以选中接口名称单击右\n键，在弹出的菜单中选择 Go To >\nImplementation(s)（或使用快捷键Ctrl+Alt+B，macOS为****Command**+Option+B**）实现跨语言跳转。\n\n\n\n\n代码格式化#\n\n代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性。默认情况下，DevEco\nStudio已预置了代码格式化的规范，您也可以个性化的设置各个文件的格式化规范，设置方式如下：在File > Settings > Editor > Code\nStyle（macOS为DevEco Studio > Preferences > Editor > Code\nStyle）下，选择需要定制的文件类型，如ArkTS，然后自定义格式化规范即可。\n\n\n\n在使用代码格式化功能时，您可以使用快捷键Ctrl + Alt + L（macOS为Option+Command +L） 可以快速对选定范围的代码进行格式化。\n\n如果在进行格式化时，对于部分代码片段不需要进行自动的格式化处理，可以通过如下方式进行设置：\n\n 1. 在File > Settings >Editor > Code Style（macOS为DevEco Studio > Preferences >\n    Editor > Code Style ），单击“Formatter”，勾选“Turn formatter on/off with markers in\n    code comments”。\n\n\n\n 2. 在不需要进行格式化操作的代码块前增加“//@formatter:off”，并在该代码块的最后增加“//@formatter:on”，即表示对该范围的代码\n    块不需要进行格式化操作。\n    \n    \n\n若工程已配置code-linter.json5文件，选中code-linter.json5文件右键选择Apply CodeLinter Style\nRules，代码格式化规则将与已配置的code-linter.json5文件中相关规则保持一致。code-linter.json5文件配置请参考配置代码检查规则\n。\n\n\n\n\n代码折叠#\n\n支持对代码块的快速折叠和展开，既可以单击编辑器左侧边栏的折叠和展开按钮对代码块进行折叠和展开操作，还可以对选中的代码块单击鼠标右键选择折叠方式，包括折叠、递归折\n叠、全部折叠等操作。\n\n\n\n\n代码快速注释#\n\n支持对选择的代码块进行快速注释，使用快捷键Ctrl+/（macOS为Command+/）进行快速注释。对于已注释的代码块，再次使用快捷键Ctrl+/（macOS\n为Command+/）取消注释。\n\n\n\n\n代码结构树#\n\n使用快捷键Alt + 7 / Ctrl +\nF12（macOS为Command+7）打开代码结构树，快速查看文件代码的结构树，包括全局变量和函数，类成员变量和方法等，并可以跳转到对应代码行。\n\n\n\n\n代码引用查找#\n\n提供Find Usages代码引用查找功能，帮助开发者快速查看某个对象(变量、函数或者类等)被引用的地方，用于后续的代码重构，可以极大的提升开发者的开发效率。\n\n使用方法：在要查找的对象上，单击鼠标右键 > Find Usages或使用快捷键Alt +F7（macOS为Option +\nF7）。可点击图标查看变量赋值位置，点击图标查看变量引用情况。\n\n\n\n\n函数注释生成#\n\n> DevEco Studio支持在函数定义处，快速生成对应的注释。在函数定义的代码块前，输入“/**”+回车键，快速生成注释信息\n\n说明\n\nC++文件同时支持使用“//!”+回车键快速生成注释。\n\n\n\n\n代码查找#\n\n通过对符号、类或文件的即时导航来查找代码。检查调用或类型层次结构，轻松地搜索工程里的所有内容。通过连续点击两次****Shift快捷键，打开代码查找界面，在搜索\n框中输入需要查找内容，下方窗口实时展示搜索结果。双击查找的结果可以快速打开所在文件的位置。\n\n\n\n\n快速查阅API接口及组件参考文档#\n\n在编辑器中调用ArkTS/JS API或组件时，支持在编辑器中快速、精准调取出对应的参考文档。\n\n可在编辑器中，鼠标悬停在需要查阅的接口或组件，弹窗将显示当前接口/组件在不同API版本下的参数等信息，单击弹窗右下角Show in API\nReference，可以快速查阅更详细的API文档。\n\n说明\n\nDevEco Studio集成了离线版API参考类文档，最新版本请参考官网HarmonyOS API参考。\n\n\n\n在弹窗中可以查看：\n\n 1. 使用的API是否涉及权限申请或仅支持在测试框架下使用。\n 2. 使用的接口状态。deprecated标签表示即将废弃的API接口，可使用useinstead标记的API进行替代，请开发时关注。\n\n\n\n\nOptimize Imports功能#\n\n使用编辑器提供的Optimize\nImports，可以快速清除未使用的import，并根据设置的规则对import进行合并或排序。选择文件或目录，使用快捷键Ctrl+Alt+O（macOS为Co\nntrol+Option+O），或单击菜单栏Code > Optimize Imports。\n\n\n\n如需修改优化配置，进入File > Settings... > Editor > Code\nStyle，选择开发语言（当前以ArkTS为例），在Imports标签页中，可选择在优化时是否需合并来自同一模块的import，是否需要对同一条import语句\n导入的元素进行排序，或对多条import语句按模块排序。\n\n\n\n\n父/子类快速跳转#\n\n编辑器支持快速跳转至当前接口、类、方法、属性的子类/父类。点击代码编辑区域左侧的Gutter\nIcons（装订线图标）可以跳转到对应的父/子接口或类。如有多个继承关系，在弹窗的文件列表中选择需要查看的接口/类即可。\n\n * Implemented：支持跳转到对应的实现类或子接口及其对应的属性/方法。\n * Implementing：支持跳转到对应的父接口或父接口的属性/方法。\n * Overridden：支持跳转到对应的子类或子类的属性/方法。\n * Overriding：支持跳转到对应的父类或父类的属性/方法。\n\n\n\n本功能默认开启，可以通过菜单栏进入File > Settings > Editor > General > Gutter\nIcons，通过勾选或取消勾选Implemented、Implementing、Overridden、Overriding四项可以开启或关闭该功能。\n\n\n\n\n查看接口/类的层次结构#\n\n编辑器支持查看当前接口/类父类或子类的层次结构。选中或将光标放置于类/接口名称处，使用快捷键Ctrl+H，或在菜单栏Navigate页签下选择Type\nHierarchy，在弹出的Hierarchy窗口中查看接口/类的继承关系结构。\n\n\n\nHierarchy窗口按钮功能：\n\n图标   功能\n     显示所选类的父类和子类。该功能不支持查看接口的继承关系。\n     显示当前类/接口的父类。\n     显示当前类/接口的子类。\n     按字母顺序对继承关系结构树中的所有同级元素进行排序。\n     更新显示所有的类/接口的继承关系结构。\n     默认双击结构树中类/接口名称时，编辑窗口将跳转至所选类/接口所在的代码位置。勾选该选项后，单击结构树中类/接口名称，即可\n     跳转访问。\n     展开/折叠继承关系结构。\n     锁定当前Hierarchy窗口显示于编辑窗口上。\n     将类/接口的继承关系结构导出到文本文件中。\n     关闭工具窗口。\n\n\n代码自动补全#\n\n提供代码的自动补全能力，编辑器工具会分析上下文，并根据输入的内容，提示可补全的类、方法、字段和关键字的名称等，支持模糊匹配。\n\n自动补齐功能默认按最短路径进行排序，如仅需按照最近使用过的类、方法、字段和关键字等名称提供补全内容排序，可以在File > Settings\n（MacOS为DevEco Studio > Preferences）> Editor > General > Code Completion 中勾选“Sort\nsuggestions by recently used”。\n\n说明\n\n若已勾选代码补齐按最近使用排序但未生效，请检查Code Completion页面，确保“Sort suggestions\nalphabetically”已取消勾选。\n\n\n\n\n\n\n快速覆写父类#\n\nDevEco Studio提供Override\nMethods，辅助开发者根据父类模板快速生成子类方法，提升开发效率。将光标放于子类定义位置，使用快捷键Ctrl+O，或右键单击Generate...，选择Ov\nerride Methods，指定需要覆写的对象（方法、变量等），点击OK将自动生成该对象的覆写代码。\n\n\n\n\n快速生成构造器#\n\n编辑器支持为类快速生成一个对应的构造函数。\n\n在类中使用快捷键Alt+Insert，或单击鼠标右键选择Generate...，在弹窗中选择Constructor，选择一个或多个需要生成构造函数的参数，点击O\nK。若选择Select None，则生成不带参数的构造器。\n\n\n\n\n快速生成get/set方法#\n\n编辑器支持为类成员变量或对象属性快速生成get和set方法。\n\n将光标放置在当前类中，单击右键选择Generate...>Getter and Setter，或者使用快捷键Alt+Insert，在菜单中选择Getter\nand Setter，完成方法快速生成。\n\n\n\n\n快速生成声明信息到Index文件#\n\n编辑器支持将HSP和HAR模块中变量、方法、接口、类等需要对外暴露的信息，通过Generate...>Declarations功能，批量在Index.ets文件\n中进行声明，便于其他模块调用。\n\n在HSP或HAR模块内的文件编辑界面，单击右键选择Generate...>Declarations，或者使用快捷键Alt+Insert，在菜单中选择Declar\nations，按住快捷键Ctrl并选择需要声明的变量名、方法名、接口名、类名等，即可在模块的Index.ets文件中批量生成相应的声明信息。\n\n\n实时检查#\n\n编辑器会实时的进行代码分析，如果输入的语法不符合编码规范，或者出现语义语法错误，将在代码中突出显示错误或警告，将鼠标放置在错误代码处，会提示详细的错误信息。\n\n从DevEco Studio 4.0\nRelease版本开始，当compatibleSdkVersion≥10时，编辑器代码实时检查支持ArkTS性能语法规范检查。\n\n\n\n说明\n\n当前compileSDKVersion≥10且arkTSVersion≥1.1(默认)时ArkTS严格类型检查支持实时检查。\n\n\n代码快速修复#\n\nDevEco Studio支持代码快速修复能力，辅助开发者快速修复ArkTS或C++代码问题。\n\n查看告警信息：使用双击Shift快捷键打开文件查询框，输入problems打开问题工具面板；双击对应告警信息，可以查看告警的具体位置及原因。\n\n快速修复：将光标放在错误告警的位置，可在弹出的悬浮窗中查看问题描述和对应修复方式；单击M****ore\nactions可查看更多修复方法。或是在页面出现灯泡图标时，可点击图标并根据相应建议，实现代码快速修复。\n\n\n\n\nC++快速修复使用演示#\n\n下面通过示例展示C++代码中快速修复功能的使用方法。\n\n\n填充switch语句#\n\n编辑器支持快速修复方式，对C++代码自动补齐switch条件表达式缺失的case条件，提升编码效率。\n\n光标悬浮在switch表达式的条件变量处，点击灯泡图标，在下拉菜单中选择Create missing switch cases，完成缺失的case条件补充。\n\n\n\n\n使用auto替换类型#\n\n编辑器中可以用 auto 替换 iterator，new expression，cast\nexpression的声明类型。光标悬浮在类型名称处，点击灯泡图标，在下拉菜单中选择**Replace the type with\n'auto****'**完成替换。\n\n\n\n\n用？：三元操作符替换if-else#\n\n编辑器中支持将if-else语句替换为？：三元操作符。光标放在if表达式的条件处，左侧出现黄色灯泡图标，点击灯泡图标，在下拉菜单中选择**Replace 'if\nelse' with '?:'**完成替换。\n\n\n\n\n从使用处生成构造函数#\n\n如使用了未定义的构造函数，可通过quickfix方式快速生成相应的构造函数定义。点击构造函数名称，左侧出现红色灯泡后，点击灯泡图标选择**Create new\nconstructor 'xxx'**生成构造函数。\n\n\n\n\n将变量拆分为声明和赋值#\n\n光标点击需要拆分的变量，左侧出现黄色灯泡后，点击灯泡图标选择Split into declaration and\nassignment，将变量的声明赋值语句拆分成声明语句和赋值语句。\n\n\n\n\nCode Linter代码检查#\n\nCode Linter针对ArkTS/TS代码进行最佳实践/编程规范方面的检查。检查规则支持配置，配置方式请参考配置代码检查规则。\n\n开发者可根据扫描结果中告警提示手工修复代码缺陷，或者执行一键式自动修复，在代码开发阶段，确保代码质量。\n\n检查方法：\n\n在已打开的代码编辑器窗口单击右键点击Code Linter，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择Code Linter > Full\nLinter执行代码全量检查。\n\n\n\n如只需对Git工程中增量文件（包含新增/修改/重命名）进行检查，可在commit界面右下角点击齿轮图标，选择Incremental Linter执行增量检查。\n\n\n\n说明\n\n * 若未配置代码检查规则文件，直接执行Code Linter，将按照默认的编程规范规则对.ets文件进行检查。\n * Code Linter不对如下文件及目录进行检查：\n   * src/ohosTest文件夹\n   * src/test文件夹\n   * node_modules文件夹\n   * oh_modules文件夹\n   * build文件夹\n   * .preview文件夹\n   * hvigorfile.ts文件\n   * hvigorfile.js文件\n\n\n配置代码检查规则#\n\n在工程根目录下创建code-linter.json5配置文件，可对于代码检查的范围及对应生效的检查规则进行配置，其中files和ignore配置项共同确定了代码\n检查范围，ruleSet和rules配置项共同确定了生效的规则范围。具体配置项功能如下：\n\nfiles：配置待检查的文件名单，如未指定目录，将检查当前被选中的文件或文件夹中所有的.ets文件。\n\nignore：配置无需检查的文件目录，其指定的目录或文件需使用相对路径格式，相对于code-linter.json5所在工程根目录，例如：build/**/*。\n\nruleSet：配置检查使用的规则集，规则集支持一次导入多条规则。规则详情请参见Code Linter代码检查规则。目前支持的规则集包括：\n\n * 通用规则@typescript-eslint\n\n * 一次开发多端部署规则@cross-device-app-dev\n\n * ArkTS代码风格规则@hw-stylistic\n\n * 安全规则@security\n\n * 性能规则@performance\n\n * 预览规则@previewer\n   \n   说明\n   \n   * 以上规则集均分为all和recommended两种规则集。all规则集是规则全集，包含所有规则；recommended规则集是推荐使用的规则集合。al\n     l规则集包含recommended规则集。\n   * 不在工程根目录新建code-linter.json5文件的情况下，Code\n     Linter默认会检查@performance/recommended和@typescript-eslint/recommended规则集包含的规则。\n\nrules：可以基于ruleSet配置的规则集，新增额外规则项，或修改ruleSet中规则默认配置，例如：将规则集中某条规则告警级别由warn改为error。\n\noverrides：针对工程根目录下部分特定目录或文件，可配置定制化检查的规则。\n\n\n\n\n查看/处理代码检查结果#\n\n扫描完成后，在底部工具面板查看检查结果。勾选Defects中不同告警等级，可分别查看对应告警级别的信息。双击某条告警结果，可以跳转到对应代码缺陷位置；选中告警结\n果时，可以在右侧Defect\nDescription窗口查看告警对应的规则详细说明，其中包含正向和反向示例，并根据其中的建议修改代码；搜索规则时，可设定是否全词匹配和大小写敏感。\n\n单击图标，查看可修复的代码规则，点击代码修复图标，可以一键式批量修复告警，并刷新检查结果。\n\n\n\n屏蔽告警信息：\n\n * 在某些特殊场景下，若扫描结果中出现误报，点击单条告警结果后的Ignore图标**，可以忽略对告警所在行的code\n   linter检查；或勾选文件名称或多条待屏蔽的告警，点击左侧工具面板Ingore**图标批量执行操作；\n * 在文件顶部添加注释/* eslint-disable */可以屏蔽整个文件执行code linter检查，在eslint-disable\n   后加入一个或多个以逗号分隔的规则Id，可以屏蔽具体检查规则；\n * 在需要忽略检查的代码块前后分别添加/* eslint-disable /和/ eslint-enable */添加注释信息，再执行**Code\n   Linter，*将不再显示该代码块扫描结果；在待屏蔽的代码行前一行添加/ eslint-disable-next-line\n   */，也可屏蔽对该代码行的codelinter检查。\n\n如需恢复忽略的报错信息，可以直接删除该行上方的注释，重新执行Code Linter检查。\n\n\n\n导出检查结果：点击工具面板左侧导出按钮，即可导出检查结果到excel文件，包含告警所在行，告警明细，告警级别等信息。\n\n\n\n\n实践说明#\n\n以@typescript-eslint/no-restricted-syntax（使用某类语法时，codelinter告警）、@typescript-eslin\nt/naming-convention（命名风格校验）和@hw-stylistic/file-naming-convention（检查代码文件的命名风格）三个规\n则为例，介绍codelinter配置文件的使用方法。\n\n\n示例1：调用类Foo下bar方法时，Code Linter告警#\n\n在配置文件中定义规则\n\n在ArkTS工程中，pages/Index.ets文件下增加以下用例：\n\n\n\n在工程根目录下新建code-linter.json5文件（文件名不可修改），新增以下配置：\n\n\n\n说明\n\n如需在code-linter.json5文件中配置其他字段，请参见配置代码检查规则。\n\n执行代码检查\n\n对pages/Index.ets文件执行代码检查，检查结果如下：\n\n\n\n\n示例2：对类名Foo的命名风格校验#\n\n在配置文件中定义规则\n\n在ArkTS工程中，pages/Index.ets文件下增加以下用例：\n\n\n\n在工程根目录下新建code-linter.json5文件，新增以下配置：\n\n\n\n字段名称                                   参数说明                           是否必选   类型          支持配置的参数\nselector                               配置要检查的语法                       是      字符串、字符串数组   variable：变量function：函数parameter：参数parameterProperty：参数属性acce\n                                                                                         ssor：get/set方法enumMember：枚举成员classMethod：类方法structMethod：自定义\n                                                                                         组件中的方法objectLiteralMethod：对象方法typeMethod：接口方法classProperty：类\n                                                                                         属性structProperty：自定义组件中的属性objectLiteralProperty：对象属性typeProp\n                                                                                         erty：接口属性class：类struct：自定义组件interface：接口typeAlias：类型别名enum：枚\n                                                                                         举typeParameter：泛型参数default：包含以上所有的类型variableLike：包含variable，\n                                                                                         function，parametermemberLike：包含classProperty，structProperty，\n                                                                                         objectLiteralProperty，typeProperty，parameterProperty\n                                                                                         ，enumMember，classMethod，objectLiteralMethod，typeMethod，acces\n                                                                                         sortypeLike：包含class，struct，interface，typeAlias，enum，typePara\n                                                                                         metermethod：包含classMethod，structMethod，objectLiteralMethod，t\n                                                                                         ypeMethodproperty：包含classProperty，objectLiteralProperty，type\n                                                                                         Property\nformat                                 配置期望的命名风格                      是      字符串数组       camelCase：小驼峰命名风格，比如getName，getID（支持连续大写字母），不支持下划线strictCame\n                                                                                         lCase：严格小驼峰命名风格，除了不支持连续大写字母（getID），其他的和camelCase相同PascalCase\n                                                                                         ：大驼峰命名风格，比如Foo，CC，除了要求第一个字母大写，其他的和camelCase相同StrictPascalCas\n                                                                                         e：大驼峰命名风格，除了不支持连续大写字母（CC），其他的和PascalCase相同snake_case：小写字母+下划\n                                                                                         线+小写字母的命名风格，比如a_a，不支持_a，a_a_UPPER_CASE：大写字母+下划线+大写字母的命名风格，比如\n                                                                                         A_A，不支持_A，A_A_\ncustom                                 配置用户自定义的命名风格                   否      对象          regex：属性必选，配置具体的正则match：属性必选，配置为true表示正则未命中时报错，配置为false表示正则命\n                                                                                         中时报错\nleadingUnderscore/trailingUnderscore   配置是否允许以下划线开头/以下划线结尾的命名风格       否      字符串         allow：允许以一个下划线开头/结尾的命名风格，比如_nameallowDouble：允许以两个下划线开头/结尾的命名\n                                                                                         风格，比如__nameallowSingleOrDouble：允许以一个或者两个下划线开头/结尾的命名风格（allow+\n                                                                                         allowDouble）forbid：禁止以下划线开头/结尾的命名风格，比如_name，__namerequire：必须\n                                                                                         是以下划线开头/结尾的命名风格，比如_name，__namerequireDouble：必须是以两个下划线开头/结尾的命\n                                                                                         名风格，比如__name\nprefix/suffix                          配置固定前缀/后缀的命名风格。如果前缀/后缀未匹配则报错   否      字符串数组       用户自定义前缀/后缀\nfilter                                 过滤特定的命名风格，检查或者不检查正则命中的命名       否      对象          配置格式与custom相似match：设置为true表示只检查正则命中的名字，设置为false表示不检查正则命中的名字r\n                                                                                         egex：设置过滤的正则说明支持直接配置一个字符串，这个字符串配置的是regex，此时match相当于配置的是true。\nmodifiers                              匹配修饰符，只有包含特定修饰符的命名才会检查         否      字符串数组       abstract：匹配abstract关键字override：匹配override关键字private：匹配privat\n                                                                                         e关键字protected：匹配protected关键字static：匹配static关键字async：匹配async关\n                                                                                         键字const：匹配const关键字destructured：匹配解构语法exported：匹配export关键字glo\n                                                                                         bal：匹配全局声明#private：匹配私有符号#public：匹配public级别的访问修饰符requiresQuo\n                                                                                         tes：匹配字符串类型的命名，并且 字符串中包含特殊字符unused：匹配未使用的声明\ntypes                                  匹配类型，只有特定类型的名字才会检查             否      字符串数组       array：数组类型boolean：布尔类型function：函数类型number：数字类型string：字符串类型\n\n说明\n\n以上配置的参数有校验优先级：filter > types > modifiers > validate leading underscore >\nvalidate trailing underscore > validate prefix > validate suffix > validate\ncustom > validate format。\n\n执行代码检查\n\n对pages/Index.ets文件执行代码检查，检查结果如下：\n\n\n\n\n示例3：检查代码文件的命名风格#\n\n在配置文件中定义规则\n\n在ArkTS工程中，pages目录下新建test.ets文件；\n\n在工程根目录下新建code-linter.json5文件，新增以下配置：\n\n\n\n说明\n\n如果selector属性不配置，默认检查代码文件和资源文件的命名风格。\n\n执行代码检查\n\n对pages/test.ets文件执行代码检查，检查结果如下：","routePath":"/harmony/kaifajichu/part4","lang":"","toc":[{"text":"代码高亮","id":"代码高亮","depth":2,"charIndex":94},{"text":"代码跳转","id":"代码跳转","depth":2,"charIndex":373},{"text":"跨语言跳转","id":"跨语言跳转","depth":2,"charIndex":512},{"text":"代码格式化","id":"代码格式化","depth":2,"charIndex":707},{"text":"代码折叠","id":"代码折叠","depth":2,"charIndex":1525},{"text":"代码快速注释","id":"代码快速注释","depth":2,"charIndex":1628},{"text":"代码结构树","id":"代码结构树","depth":2,"charIndex":1739},{"text":"代码引用查找","id":"代码引用查找","depth":2,"charIndex":1847},{"text":"函数注释生成","id":"函数注释生成","depth":2,"charIndex":2036},{"text":"代码查找","id":"代码查找","depth":2,"charIndex":2148},{"text":"快速查阅API接口及组件参考文档","id":"快速查阅api接口及组件参考文档","depth":2,"charIndex":2286},{"text":"Optimize Imports功能","id":"optimize-imports功能","depth":2,"charIndex":2629},{"text":"父/子类快速跳转","id":"父子类快速跳转","depth":2,"charIndex":2958},{"text":"查看接口/类的层次结构","id":"查看接口类的层次结构","depth":2,"charIndex":3372},{"text":"代码自动补全","id":"代码自动补全","depth":2,"charIndex":3826},{"text":"快速覆写父类","id":"快速覆写父类","depth":2,"charIndex":4176},{"text":"快速生成构造器","id":"快速生成构造器","depth":2,"charIndex":4346},{"text":"快速生成get/set方法","id":"快速生成getset方法","depth":2,"charIndex":4494},{"text":"快速生成声明信息到Index文件","id":"快速生成声明信息到index文件","depth":2,"charIndex":4645},{"text":"实时检查","id":"实时检查","depth":2,"charIndex":4916},{"text":"代码快速修复","id":"代码快速修复","depth":2,"charIndex":5158},{"text":"C++快速修复使用演示","id":"c快速修复使用演示","depth":2,"charIndex":5397},{"text":"填充switch语句","id":"填充switch语句","depth":3,"charIndex":5440},{"text":"使用auto替换类型","id":"使用auto替换类型","depth":3,"charIndex":5588},{"text":"用？：三元操作符替换if-else","id":"用三元操作符替换if-else","depth":3,"charIndex":5734},{"text":"从使用处生成构造函数","id":"从使用处生成构造函数","depth":3,"charIndex":5862},{"text":"将变量拆分为声明和赋值","id":"将变量拆分为声明和赋值","depth":3,"charIndex":5986},{"text":"Code Linter代码检查","id":"code-linter代码检查","depth":2,"charIndex":6096},{"text":"配置代码检查规则","id":"配置代码检查规则","depth":2,"charIndex":6665},{"text":"查看/处理代码检查结果","id":"查看处理代码检查结果","depth":2,"charIndex":7530},{"text":"实践说明","id":"实践说明","depth":2,"charIndex":8277},{"text":"示例1：调用类Foo下bar方法时，Code Linter告警","id":"示例1调用类foo下bar方法时code-linter告警","depth":3,"charIndex":8475},{"text":"示例2：对类名Foo的命名风格校验","id":"示例2对类名foo的命名风格校验","depth":3,"charIndex":8702},{"text":"示例3：检查代码文件的命名风格","id":"示例3检查代码文件的命名风格","depth":3,"charIndex":14107}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"预览器的使用","content":"#\n\n\n查看ArkTS/JS预览效果#\n\n预览器支持ArkTS/JS应用/元服务“实时预览”和“动态预览”。\n\n说明\n\n * 预览支持Phone、Tablet、2in1、Car设备的ArkTS工程，支持Litewearable设备的JS工程。\n\n * 预览器功能依赖于电脑显卡的OpenGL版本，OpenGL版本要求为3.2及以上。\n\n * 预览时将不会运行Ability生命周期。\n\n * 预览不支持引用HSP。引用了HSP的模块不支持预览，请直接在HSP内预览或模拟HSP。\n\n * 预览场景下，不支持通过相对路径及绝对路径的方式访问resources目录下的文件。\n\n * 预览不支持组件拖拽。\n\n * 部分API不支持预览，如Ability、App、MultiMedia等模块。\n\n * Richtext、Web、Video、XComponent组件不支持预览。\n\n * 不支持调用C++库的预览。\n\n * har在被应用/元服务使用时真机效果有区别，真机上实际效果应用不显示menubar，元服务显示menubar，但预览器都以不显示menubar为准。若开发\n   har模块时，请注意被元服务使用时预览器效果与真机效果的不同。\n\n * 实时预览：在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果。如果修改了组件的属性，则预览器会\n   实时（亚秒级）刷新预览结果，达到极速预览的效果（当前版本极速预览仅支持ArkTS组件。支持部分数据绑定场景，如@State装饰的变量）。实时预览默认开启，\n   如果不需要实时预览，请单击预览器右上角 按钮，关闭实时预览功能。\n\n说明\n\n开发者修改resources/base/profile目录下的配置文件（如main_pages.json/form_config.json），不支持触发实时预览\n，开发者需要点击重新加载。\n\n\n\n * 动态预览\n   \n   ：在预览器界面，可以在预览器中操作应用/元服务的界面交互动作，如单击、跳转、滑动等，与应用/元服务运行在真机设备上的界面交互体验一致。\n   \n   \n\n以ArkTS为例，使用预览器的方法如下：\n\n 1. 创建或打开一个ArkTS应用/元服务工程。本示例以打开一个本地ArkTS Demo工程为例。\n\n 2. 在工程目录下，打开任意一个.ets文件（JS工程请打开.hml/.css/.js页面）。\n\n 3. 可以通过如下任意一种方式打开预览器开关，显示效果如下图所示：\n    \n    * 通过菜单栏，单击View > Tool Windows > Previewer打开预览器。\n    * 在编辑窗口右上角的侧边工具栏，单击Previewer，打开预览器。\n    \n    \n\n\n查看ArkUI预览效果#\n\nArkUI预览支持页面预览与组件预览，下图中左侧图标为页面预览，右侧图标为组件预览。\n\n\n\n\n页面预览#\n\nArkTS应用/元服务支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现。\n\n@Entry的使用参考如下示例：\n\n\n\n\n组件预览#\n\nArkTS应用/元服务支持组件预览。组件预览支持实时预览，不支持动态图和动态预览。组件预览通过在组件前添加注解@Preview实现，在单个源文件中，最多可以使用\n10个@Preview装饰自定义组件。\n\n@Preview的使用参考如下示例：\n\n\n\n以上示例的组件预览效果如下图所示：\n\n\n\n组件预览默认的预览设备为Phone，若您想查看不同的设备，或者不同的屏幕形状，或者不同设备语言等情况下的组件预览效果，可以通过设置@Preview的参数，指定预\n览设备的相关属性。若不设置@Preview的参数，默认的设备属性如下所示：\n\n\n\n请注意，如果被预览的组件是依赖参数注入的组件，建议的预览方式是：定义一个组件片段，在该片段中声明将要预览的组件，以及该组件依赖的入参，并在组件片段上标注@Pre\nview注解，以表明将预览该片段中的内容。例如，要预览如下组件：\n\n\n\n建议按如下方式预览：\n\n\n\n\nInspector双向预览#\n\nDevEco\nStudio提供HarmonyOS应用/元服务的UI预览界面与源代码文件间的双向预览功能，支持ets文件与预览器界面的双向预览。使用双向预览功能时，需要在预览器\n界面单击图标打开双向预览功能。\n\n说明\n\n暂不支持服务卡片的双向预览功能。\n\n\n\n开启双向预览功能后，支持代码编辑器、UI界面和Component Tree组件树三者之间的联动：\n\n * 选中预览器UI界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。\n\n * 选中布局文件中的代码块，则在UI界面会高亮显示，组件树上的组件节点也会呈现被选中的状态。\n\n * 选中组件树中的组件，则对应的代码块和UI界面也会高亮显示。\n\n\n\n在预览界面还可以通过组件的属性面板修改可修改的属性或样式，在预览界面修改后，预览器会自动同步到代码编辑器中修改源码，并实时的刷新UI界面；同样的，如果在代码编辑\n器中修改源码，也会实时刷新UI界面，并更新组件树信息及组件属性。\n\n说明\n\n * 如果组件有做数据绑定，则其属性不支持在属性面板修改。\n * 如果界面有使用动画效果或者带动画效果组件，则其属性不支持在属性面板修改。\n * 多设备预览时，不支持双向预览。","routePath":"/harmony/kaifajichu/part5","lang":"","toc":[{"text":"查看ArkTS/JS预览效果","id":"查看arktsjs预览效果","depth":2,"charIndex":3},{"text":"**查看ArkUI预览效果**","id":"查看arkui预览效果","depth":2,"charIndex":-1},{"text":"页面预览","id":"页面预览","depth":2,"charIndex":1243},{"text":"组件预览","id":"组件预览","depth":2,"charIndex":1319},{"text":"**Inspector双向预览**","id":"inspector双向预览","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"**ArkTS语言介绍**","content":"ArkTS语言介绍#\n\nArkTS是一种为构建高性能应用而设计的编程语言。ArkTS在继承TypeScript语法的基础上进行了优化，以提供更高的性能和开发效率。\n\n随着移动设备在人们的日常生活中变得越来越普遍，许多编程语言在设计之初没有考虑到移动设备，导致应用的运行缓慢、低效、功耗大，针对移动环境的编程语言优化需求也越来越\n大。ArkTS是专为解决这些问题而设计的，聚焦于提高运行效率。\n\n目前流行的编程语言TypeScript是在JavaScript基础上通过添加类型定义扩展而来的，而ArkTS则是TypeScript的进一步扩展。TypeScr\nipt深受开发者的喜爱，因为它提供了一种更结构化的JavaScript编码方法。ArkTS旨在保持TypeScript的大部分语法，为现有的TypeScript\n开发者实现无缝过渡，让移动开发者快速上手ArkTS。\n\nArkTS的一大特性是它专注于低运行时开销。ArkTS对TypeScript的动态类型特性施加了更严格的限制，以减少运行时开销，提高执行效率。通过取消动态类型特\n性，ArkTS代码能更有效地被运行前编译和优化，从而实现更快的应用启动和更低的功耗。\n\n与JavaScript的互通性是ArkTS语言设计中的关键考虑因素。鉴于许多移动应用开发者希望重用其TypeScript和JavaScript代码和库，ArkT\nS提供了与JavaScript的无缝互通，使开发者可以很容易地将JavaScript代码集成到他们的应用中。这意味着开发者可以利用现有的代码和库进行ArkTS开\n发。\n\n为了确保应用开发的最佳体验，ArkTS提供对方舟开发框架ArkUI的声明式语法和其他特性的支持。由于此部分特性不在既有TypeScript的范围内，因此我们在《\nArkUI支持》一章中提供了详细的ArkUI示例。\n\n本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，使开发者能够使用ArkTS高效构建高性能的移动应用。\n\n如需更详细了解ArkTS语言，可见ArkTS具体指南 和DevEco Studio。\n\n\n基本知识#\n\n\n声明#\n\nArkTS通过声明引入变量、常量、函数和类型。\n\n变量声明\n\n以关键字let开头的声明引入变量，该变量在程序执行期间可以具有不同的值。\n\n\n\n常量声明\n\n以关键字const开头的声明引入只读常量，该常量只能被赋值一次。\n\n\n\n对常量重新赋值会造成编译时错误。\n\n自动类型推断\n\n由于ArkTS是一种静态类型语言，所有数据的类型都必须在编译时确定。\n\n但是，如果一个变量或常量的声明包含了初始值，那么开发者就不需要显式指定其类型。ArkTS规范中列举了所有允许自动推断类型的场景。\n\n以下示例中，两条声明语句都是有效的，两个变量都是string类型：\n\n\n\n\n类型#\n\nnumber类型\n\nArkTS提供number类型，任何整数和浮点数都可以被赋给此类型的变量。\n\n数字字面量包括整数字面量和十进制浮点数字面量。\n\n整数字面量包括以下类别：\n\n * 由数字序列组成的十进制整数。例如：0、117、-345\n * 以0x（或0X）开头的十六进制整数，可以包含数字（0-9）和字母a-f或A-F。例如：0x1123、0x00111、-0xF1A7\n * 以0o（或0O）开头的八进制整数，只能包含数字（0-7）。例如：0o777\n * 以0b（或0B）开头的二进制整数，只能包含数字0和1。例如：0b11、0b0011、-0b11\n\n浮点字面量包括以下：\n\n * 十进制整数，可为有符号数（即，前缀为“+”或“-”）；\n * 小数点（“.”）\n * 小数部分（由十进制数字字符串表示）\n * 以“e”或“E”开头的指数部分，后跟有符号（即，前缀为“+”或“-”）或无符号整数。\n\n示例：\n\n\n\nnumber类型在表示大整数时会造成精度丢失。在开发时可以按需使用bigInt类型来确保精度：\n\n\n\nboolean类型\n\nboolean类型由true和false两个逻辑值组成。\n\n通常在条件语句中使用boolean类型的变量：\n\n\n\nstring类型\n\nstring代表字符序列；可以使用转义字符来表示字符。\n\n字符串字面量由单引号（'）或双引号（\"）之间括起来的零个或多个字符组成。字符串字面量还有一特殊形式，是用反向单引号（`）括起来的模板字面量。\n\n\n\nvoid类型\n\nvoid类型用于指定函数没有返回值。\n\n此类型只有一个值，同样是void。由于void是引用类型，因此它可以用于泛型类型参数。\n\n\n\nObject类型\n\nObject类型是所有引用类型的基类型。任何值，包括基本类型的值（它们会被自动装箱），都可以直接被赋给Object类型的变量。object类型则用于表示除基本类\n型外的类型。\n\narray类型\n\narray，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。\n\n数组可由数组复合字面量（即用方括号括起来的零个或多个表达式的列表，其中每个表达式为数组中的一个元素）来赋值。数组的长度由数组中元素的个数来确定。数组中第一个元素\n的索引为0。\n\n以下示例将创建包含三个元素的数组：\n\n\n\nenum类型\n\nenum类型，又称枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。\n\n使用枚举常量时必须以枚举类型名称为前缀。\n\n\n\n常量表达式可以用于显式设置枚举常量的值。\n\n\n\nUnion类型\n\nunion类型，即联合类型，是由多个类型组合成的引用类型。联合类型包含了变量可能的所有类型。\n\n\n\n可以用不同的机制获取联合类型中特定类型的值。\n\n示例：\n\n\n\nAliases类型\n\nAliases类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。\n\n\n\n\n运算符#\n\n赋值运算符\n\n赋值运算符=，使用方式如x=y。\n\n复合赋值运算符将赋值与运算符组合在一起，其中x op = y等于x = x op y。\n\n复合赋值运算符列举如下：+=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、|=、^=。\n\n比较运算符\n\n运算符   说明\n===   如果两个操作数严格相等（对于不同类型的操作数认为是不相等的），则返回true。\n!==   如果两个操作数严格不相等（对于不同类型的操作数认为是不相等的），则返回true。\n==    如果两个操作数相等，则返回true。\n!=    如果两个操作数不相等，则返回true。\n>     如果左操作数大于右操作数，则返回true。\n>=    如果左操作数大于或等于右操作数，则返回true。\n<     如果左操作数小于右操作数，则返回true。\n<=    如果左操作数小于或等于右操作数，则返回true。\n\n算术运算符\n\n一元运算符为-、+、--、++。\n\n二元运算符列举如下：\n\n运算符   说明\n+     加法\n-     减法\n*     乘法\n/     除法\n%     除法后余数\n\n位运算符\n\n运算符       说明\na & b     按位与：如果两个操作数的对应位都为1，则将这个位设置为1，否则设置为0。\na | b     按位或：如果两个操作数的相应位中至少有一个为1，则将这个位设置为1，否则设置为0。\na ^ b     按位异或：如果两个操作数的对应位不同，则将这个位设置为1，否则设置为0。\n~ a       按位非：反转操作数的位。\na << b    左移：将a的二进制表示向左移b位。\na >> b    算术右移：将a的二进制表示向右移b位，带符号扩展。\na >>> b   逻辑右移：将a的二进制表示向右移b位，左边补0。\n\n逻辑运算符\n\n运算符      说明\na && b   逻辑与\na || b   逻辑或\n! a      逻辑非\n\n\n语句#\n\nIf语句\n\nif语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。\n\nelse部分也可能包含if语句。\n\nif语句如下所示：\n\n\n\n条件表达式可以是任何类型。但是对于boolean以外的类型，会进行隐式类型转换：\n\n\n\nSwitch语句\n\n使用switch语句来执行与switch表达式值匹配的代码块。\n\nswitch语句如下所示：\n\n\n\n如果switch表达式的值等于某个label的值，则执行相应的语句。\n\n如果没有任何一个label值与表达式值相匹配，并且switch具有default子句，那么程序会执行default子句对应的代码块。\n\nbreak语句（可选的）允许跳出switch语句并继续执行switch语句之后的语句。\n\n如果没有break语句，则执行switch中的下一个label对应的代码块。\n\n条件表达式\n\n条件表达式由第一个表达式的布尔值来决定返回其它两个表达式中的哪一个。\n\n示例如下：\n\n\n\n如果condition的值为真值（转换后为true的值），则使用expression1作为该表达式的结果；否则，使用expression2。\n\n示例：\n\n\n\nFor语句\n\nfor语句会被重复执行，直到循环退出语句值为false。\n\nfor语句如下所示：\n\n\n\nfor语句的执行流程如下：\n\n1、 执行init表达式（如有）。此表达式通常初始化一个或多个循环计数器。\n\n2、 计算condition。如果它为真值（转换后为true的值），则执行循环主体的语句。如果它为假值（转换后为false的值），则for循环终止。\n\n3、 执行循环主体的语句。\n\n4、 如果有update表达式，则执行该表达式。\n\n5、 回到步骤2。\n\n示例：\n\n\n\nFor-of语句\n\n使用for-of语句可遍历数组或字符串。示例如下：\n\n\n\n示例：\n\n\n\nWhile语句\n\n只要condition为真值（转换后为true的值），while语句就会执行statements语句。示例如下：\n\n\n\n示例：\n\n\n\nDo-while语句\n\n如果condition的值为真值（转换后为true的值），那么statements语句会重复执行。示例如下：\n\n\n\n示例：\n\n\n\nBreak语句\n\n使用break语句可以终止循环语句或switch。\n\n示例：\n\n\n\n如果break语句后带有标识符，则将控制流转移到该标识符所包含的语句块之外。\n\n示例：\n\n\n\nContinue语句\n\ncontinue语句会停止当前循环迭代的执行，并将控制传递给下一个迭代。\n\n示例：\n\n\n\nThrow和Try语句\n\nthrow语句用于抛出异常或错误：\n\n\n\ntry语句用于捕获和处理异常或错误：\n\n\n\n下面的示例中throw和try语句用于处理除数为0的错误：\n\n\n\n支持finally语句：\n\n\n\n\n函数#\n\n\n函数声明#\n\n函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。\n\n以下示例是一个简单的函数，包含两个string类型的参数，返回类型为string：\n\n\n\n在函数声明中，必须为每个参数标记类型。如果参数为可选参数，那么允许在调用函数时省略该参数。函数的最后一个参数可以是rest参数。\n\n\n可选参数#\n\n可选参数的格式可为name?: Type。\n\n\n\n可选参数的另一种形式为设置的参数默认值。如果在函数调用中这个参数被省略了，则会使用此参数的默认值作为实参。\n\n\n\n\nRest参数#\n\n函数的最后一个参数可以是rest参数。使用rest参数时，允许函数或方法接受任意数量的实参。\n\n\n\n\n返回类型#\n\n如果可以从函数体内推断出函数返回类型，则可在函数声明中省略标注返回类型。\n\n\n\n不需要返回值的函数的返回类型可以显式指定为void或省略标注。这类函数不需要返回语句。\n\n以下示例中两种函数声明方式都是有效的：\n\n\n\n\n函数的作用域#\n\n函数中定义的变量和其他实例仅可以在函数内部访问，不能从外部访问。\n\n如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。\n\n\n函数调用#\n\n调用函数以执行其函数体，实参值会赋值给函数的形参。\n\n如果函数定义如下：\n\n\n\n则此函数的调用需要包含两个string类型的参数：\n\n\n\n\n函数类型#\n\n函数类型通常用于定义回调：\n\n\n\n\n箭头函数（又名Lambda函数）#\n\n函数可以定义为箭头函数，例如：\n\n\n\n箭头函数的返回类型可以省略；省略时，返回类型通过函数体推断。\n\n表达式可以指定为箭头函数，使表达更简短，因此以下两种表达方式是等价的：\n\n\n\n\n闭包#\n\n闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。\n\n在下例中，f函数返回了一个闭包，它捕获了count变量，每次调用z，count的值会被保留并递增。\n\n\n\n\n函数重载#\n\n我们可以通过编写重载，指定函数的不同调用方式。具体方法为，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。\n\n\n\n不允许重载函数有相同的名字以及参数列表，否则将会编译报错。\n\n\n类#\n\n类声明引入一个新类型，并定义其字段、方法和构造函数。\n\n在以下示例中，定义了Person类，该类具有字段name和surname、构造函数和方法fullName：\n\n\n\n定义类后，可以使用关键字new创建实例：\n\n\n\n或者，可以使用对象字面量创建实例：\n\n\n\n\n字段#\n\n字段是直接在类中声明的某种类型的变量。\n\n类可以具有实例字段或者静态字段。\n\n实例字段\n\n实例字段存在于类的每个实例上。每个实例都有自己的实例字段集合。\n\n要访问实例字段，需要使用类的实例。\n\n\n\n静态字段\n\n使用关键字static将字段声明为静态。静态字段属于类本身，类的所有实例共享一个静态字段。\n\n要访问静态字段，需要使用类名：\n\n\n\n字段初始化\n\n为了减少运行时的错误和获得更好的执行性能，\n\nArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的strictPropertyInitialization模式一样。\n\n以下代码是在ArkTS中不合法的代码。\n\n\n\n在ArkTS中，应该这样写代码。\n\n\n\n接下来的代码展示了如果name的值可以是undefined，那么应该如何写代码。\n\n\n\ngetter和setter\n\nsetter和getter可用于提供对对象属性的受控访问。\n\n在以下示例中，setter用于禁止将_age属性设置为无效值：\n\n\n\n在类中可以定义getter或者setter。\n\n\n方法#\n\n方法属于类。类可以定义实例方法或者静态方法。静态方法属于类本身，只能访问静态字段。而实例方法既可以访问静态字段，也可以访问实例字段，包括类的私有字段。\n\n实例方法\n\n以下示例说明了实例方法的工作原理。\n\ncalculateArea方法通过将高度乘以宽度来计算矩形的面积：\n\n\n\n必须通过类的实例调用实例方法：\n\n\n\n静态方法\n\n使用关键字static将方法声明为静态。静态方法属于类本身，只能访问静态字段。\n\n静态方法定义了类作为一个整体的公共行为。\n\n必须通过类名调用静态方法：\n\n\n\n继承\n\n一个类可以继承另一个类（称为基类），并使用以下语法实现多个接口：\n\n\n\n继承类继承基类的字段和方法，但不继承构造函数。继承类可以新增定义字段和方法，也可以覆盖其基类定义的方法。\n\n基类也称为“父类”或“超类”。继承类也称为“派生类”或“子类”。\n\n示例：\n\n\n\n包含implements子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。\n\n\n\n父类访问\n\n关键字super可用于访问父类的实例字段、实例方法和构造函数。在实现子类功能时，可以通过该关键字从父类中获取所需接口：\n\n\n\n方法重写\n\n子类可以重写其父类中定义的方法的实现。重写的方法必须具有与原始方法相同的参数类型和相同或派生的返回类型。\n\n\n\n方法重载签名\n\n通过重载签名，指定方法的不同调用。具体方法为，为同一个方法写入多个同名但签名不同的方法头，方法实现紧随其后。\n\n\n\n如果两个重载签名的名称和参数列表均相同，则为错误。\n\n\n构造函数#\n\n类声明可以包含用于初始化对象状态的构造函数。\n\n构造函数定义如下：\n\n\n\n如果未定义构造函数，则会自动创建具有空参数列表的默认构造函数，例如：\n\n\n\n在这种情况下，默认构造函数使用字段类型的默认值来初始化实例中的字段。\n\n派生类的构造函数\n\n构造函数函数体的第一条语句可以使用关键字super来显式调用直接父类的构造函数。\n\n\n\n构造函数重载签名\n\n我们可以通过编写重载签名，指定构造函数的不同调用方式。具体方法为，为同一个构造函数写入多个同名但签名不同的构造函数头，构造函数实现紧随其后。\n\n\n\n如果两个重载签名的名称和参数列表均相同，则为错误。\n\n\n可见性修饰符#\n\n类的方法和属性都可以使用可见性修饰符。\n\n可见性修饰符包括：private、protected和public。默认可见性为public。\n\nPublic（公有）\n\npublic修饰的类成员（字段、方法、构造函数）在程序的任何可访问该类的地方都是可见的。\n\nPrivate（私有）\n\nprivate修饰的成员不能在声明该成员的类之外访问，例如：\n\n\n\nProtected（受保护）\n\nprotected修饰符的作用与private修饰符非常相似，不同点是protected修饰的成员允许在派生类中访问，例如：\n\n\n\n\n对象字面量#\n\n对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替new表达式。\n\n对象字面量的表示方式是：封闭在花括号对({})中的'属性名：值'的列表。\n\n\n\nArkTS是静态类型语言，如上述示例所示，对象字面量只能在可以推导出该字面量类型的上下文中使用。其他正确的例子：\n\n\n\n也可以在数组元素类型或类字段类型中使用：\n\n\n\nRecord类型的对象字面量\n\n泛型Record用于将类型（键类型）的属性映射到另一个类型（值类型）。常用对象字面量来初始化该类型的值：\n\n\n\n类型K可以是字符串类型或数值类型，而V可以是任何类型。\n\n\n\n\n抽象类#\n\n带有修饰符abstract的类称为抽象类。抽象类可用于表示一组更具体的概念所共有的概念。\n\n如果尝试创建抽象类的实例，则会发生编译时的错误：\n\n\n\n抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化。因此，执行抽象类的构造函数和该类非静态字段的字段初始化器：\n\n\n\n抽象方法\n\n带有abstract修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。\n\n只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：\n\n\n\n\n接口#\n\n接口声明引入新类型。接口是定义代码协定的常见方式。\n\n任何一个类的实例只要实现了特定接口，就可以通过该接口实现多态。\n\n接口通常包含属性和方法的声明\n\n示例：\n\n\n\n实现接口的类示例：\n\n\n\n\n接口属性#\n\n接口属性可以是字段、getter、setter或getter和setter组合的形式。\n\n属性字段只是getter/setter对的便捷写法。以下表达方式是等价的：\n\n\n\n实现接口的类也可以使用以下两种方式：\n\n\n\n\n接口继承#\n\n接口可以继承其他接口，如下面的示例所示：\n\n\n\n继承接口包含被继承接口的所有属性和方法，还可以添加自己的属性和方法。\n\n\n抽象类和接口#\n\n抽象类与接口都无法实例化。抽象类是类的抽象，抽象类用来捕捉子类的通用特性，接口是行为的抽象。在ArkTS中抽象类与接口的区别如下：\n\n * 一个类只能继承一个抽象类，而一个类可以实现一个或多个接口；\n * 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；\n * 抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；\n * 抽象类可以有构造函数，而接口不能有构造函数。\n\n\n泛型类型和函数#\n\n泛型类型和函数允许创建的代码在各种类型上运行，而不仅支持单一类型。\n\n\n泛型类和接口#\n\n类和接口可以定义为泛型，将参数添加到类型定义中，如以下示例中的类型参数Element：\n\n\n\n要使用类型CustomStack，必须为每个类型参数指定类型实参：\n\n\n\n编译器在使用泛型类型和函数时会确保类型安全。参见以下示例：\n\n\n\n\n泛型约束#\n\n泛型类型的类型参数可以被限制只能取某些特定的值。例如，MyHashMap这个类中的Key类型参数必须具有hash方法。\n\n\n\n在上面的例子中，Key类型扩展了Hashable，Hashable接口的所有方法都可以为key调用。\n\n\n泛型函数#\n\n使用泛型函数可编写更通用的代码。比如返回数组最后一个元素的函数：\n\n\n\n如果需要为任何数组定义相同的函数，使用类型参数将该函数定义为泛型：\n\n\n\n现在，该函数可以与任何数组一起使用。\n\n在函数调用中，类型实参可以显式或隐式设置：\n\n\n\n\n泛型默认值#\n\n泛型类型的类型参数可以设置默认值。这样可以不指定实际的类型实参，而只使用泛型类型名称。下面的示例展示了类和函数的这一点。\n\n\n\n\n空安全#\n\n默认情况下，ArkTS中的所有类型都是不可为空的，因此类型的值不能为空。这类似于TypeScript的严格空值检查模式（strictNullChecks），但规\n则更严格。\n\n在下面的示例中，所有行都会导致编译时错误：\n\n\n\n可以为空值的变量定义为联合类型T | null。\n\n\n\n\n非空断言运算符#\n\n后缀运算符!可用于断言其操作数为非空。\n\n应用于可空类型的值时，它的编译时类型变为非空类型。例如，类型将从T | null更改为T：\n\n\n\n\n空值合并运算符#\n\n空值合并二元运算符??用于检查左侧表达式的求值是否等于null或者undefined。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。\n\n换句话说，a ?? b等价于三元运算符(a != null && a != undefined) ? a : b。\n\n在以下示例中，getNick方法如果设置了昵称，则返回昵称；否则，返回空字符串：\n\n\n\n\n可选链#\n\n在访问对象属性时，如果该属性是undefined或者null，可选链运算符会返回undefined。\n\n\n\n说明：getSpouseNick的返回类型必须为string | null | undefined，因为该方法可能返回null或者undefined。\n\n可选链可以任意长，可以包含任意数量的?.运算符。\n\n在以下示例中，如果一个Person的实例有不为空的spouse属性，且spouse有不为空的nick属性，则输出spouse.nick。否则，输出undefin\ned：\n\n\n\n\n模块#\n\n程序可划分为多组编译单元或模块。\n\n每个模块都有其自己的作用域，即，在模块中创建的任何声明（变量、函数、类等）在该模块之外都不可见，除非它们被显式导出。\n\n与此相对，从另一个模块导出的变量、函数、类、接口等必须首先导入到模块中。\n\n\n导出#\n\n可以使用关键字export导出顶层的声明。\n\n未导出的声明名称被视为私有名称，只能在声明该名称的模块中使用。\n\n\n\n\n导入#\n\n静态导入\n\n导入声明用于导入从其他模块导出的实体，并在当前模块中提供其绑定。导入声明由两部分组成：\n\n * 导入路径，用于指定导入的模块；\n * 导入绑定，用于定义导入的模块中的可用实体集和使用形式（限定或不限定使用）。\n\n导入绑定可以有几种形式。\n\n假设模块具有路径“./utils”和导出实体“X”和“Y”。\n\n导入绑定* as A表示绑定名称“A”，通过A.name可访问从导入路径指定的模块导出的所有实体：\n\n\n\n导入绑定{ ident1, ..., identN }表示将导出的实体与指定名称绑定，该名称可以用作简单名称：\n\n\n\n如果标识符列表定义了ident as alias，则实体ident将绑定在名称alias下：\n\n\n\n动态导入\n\n应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替静态导入。\n\nimport()语法通常称为动态导入（dynamic import），是一种类似函数的表达式，用来动态导入模块。以这种方式调用，将返回一个promise。\n\n如下例所示，import(modulePath)可以加载模块并返回一个promise，该promise\nresolve为一个包含其所有导出的模块对象。该表达式可以在代码中的任意位置调用。\n\n\n\n如果在异步函数中，可以使用let module = await import(modulePath)。\n\n\n\n那么，可以像下面这样进行动态导入：\n\n\n\n更多的使用动态import的业务场景和使用实例见动态import。\n\n导入HarmonyOS SDK的开放能力\n\nHarmonyOS SDK提供的开放能力（接口）也需要在导入声明后使用。可直接导入接口模块来使用该模块内的所有接口能力，例如：\n\n\n\n从HarmonyOS NEXT Developer Preview\n1版本开始引入Kit概念。SDK对同一个Kit下的接口模块进行了封装，开发者在示例代码中可通过导入Kit的方式来使用Kit所包含的接口能力。其中，Kit封装的接\n口模块可查看SDK目录下Kit子目录中各Kit的定义。\n\n通过导入Kit方式使用开放能力有三种方式：\n\n * 方式一：导入Kit下单个模块的接口能力。例如：\n   \n   \n\n * 方式二：导入Kit下多个模块的接口能力。例如：\n   \n   \n\n * 方式三：导入Kit包含的所有模块的接口能力。例如：\n   \n   \n   \n   其中，“module”为别名，可自定义，然后通过该名称调用模块的接口。\n   \n   说明\n   \n   方式三可能会导入过多无需使用的模块，导致编译后的HAP包太大，占用过多资源，请谨慎使用。\n\n\n顶层语句#\n\n顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。\n\n\n关键字#\n\n\nthis#\n\n关键字this只能在类的实例方法中使用。\n\n示例\n\n\n\n使用限制：\n\n * 不支持this类型\n * 不支持在函数和类的静态方法中使用this\n\n示例\n\n\n\n关键字this的指向:\n\n * 调用实例方法的对象\n * 正在构造的对象","routePath":"/harmony/kaifajichu/part6","lang":"","toc":[{"text":"基本知识","id":"基本知识","depth":2,"charIndex":888},{"text":"声明","id":"声明","depth":3,"charIndex":896},{"text":"类型","id":"类型","depth":3,"charIndex":1180},{"text":"运算符","id":"运算符","depth":3,"charIndex":2417},{"text":"语句","id":"语句","depth":3,"charIndex":3266},{"text":"函数","id":"函数","depth":2,"charIndex":4486},{"text":"函数声明","id":"函数声明","depth":3,"charIndex":4492},{"text":"可选参数","id":"可选参数","depth":3,"charIndex":4644},{"text":"Rest参数","id":"rest参数","depth":3,"charIndex":4734},{"text":"返回类型","id":"返回类型","depth":3,"charIndex":4794},{"text":"函数的作用域","id":"函数的作用域","depth":3,"charIndex":4910},{"text":"函数调用","id":"函数调用","depth":3,"charIndex":4999},{"text":"函数类型","id":"函数类型","depth":3,"charIndex":5076},{"text":"箭头函数（又名Lambda函数）","id":"箭头函数又名lambda函数","depth":3,"charIndex":5101},{"text":"闭包","id":"闭包","depth":3,"charIndex":5211},{"text":"函数重载","id":"函数重载","depth":3,"charIndex":5318},{"text":"类","id":"类","depth":2,"charIndex":5421},{"text":"字段","id":"字段","depth":3,"charIndex":5556},{"text":"方法","id":"方法","depth":3,"charIndex":6026},{"text":"构造函数","id":"构造函数","depth":3,"charIndex":6688},{"text":"可见性修饰符","id":"可见性修饰符","depth":3,"charIndex":6972},{"text":"对象字面量","id":"对象字面量","depth":3,"charIndex":7239},{"text":"抽象类","id":"抽象类","depth":3,"charIndex":7530},{"text":"接口","id":"接口","depth":2,"charIndex":7769},{"text":"接口属性","id":"接口属性","depth":3,"charIndex":7871},{"text":"接口继承","id":"接口继承","depth":3,"charIndex":7987},{"text":"抽象类和接口","id":"抽象类和接口","depth":3,"charIndex":8055},{"text":"泛型类型和函数","id":"泛型类型和函数","depth":2,"charIndex":8272},{"text":"泛型类和接口","id":"泛型类和接口","depth":3,"charIndex":8318},{"text":"泛型约束","id":"泛型约束","depth":3,"charIndex":8445},{"text":"泛型函数","id":"泛型函数","depth":3,"charIndex":8568},{"text":"泛型默认值","id":"泛型默认值","depth":3,"charIndex":8694},{"text":"空安全","id":"空安全","depth":2,"charIndex":8767},{"text":"非空断言运算符","id":"非空断言运算符","depth":3,"charIndex":8915},{"text":"空值合并运算符","id":"空值合并运算符","depth":3,"charIndex":8996},{"text":"可选链","id":"可选链","depth":3,"charIndex":9185},{"text":"模块","id":"模块","depth":2,"charIndex":9437},{"text":"导出","id":"导出","depth":3,"charIndex":9559},{"text":"导入","id":"导入","depth":3,"charIndex":9623},{"text":"顶层语句","id":"顶层语句","depth":3,"charIndex":10762},{"text":"关键字","id":"关键字","depth":2,"charIndex":10837},{"text":"this","id":"this","depth":3,"charIndex":10844}],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"应用程序包概述","content":"#\n\n在基于Stage模型开发应用之前，开发者需要了解应用的设计机制、应用程序包结构等基础知识。\n\n\n应用与应用程序包#\n\n用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。一个应用所对应的软件包文件，称为“应用程序包”。\n\n当前系统提供了应用程序包开发、安装、查询、更新、卸载的管理机制，便于开发者开发和管理应用。同时，系统还屏蔽了不同的芯片平台的差异（包括x86/ARM，32位/6\n4位等），应用程序包在不同的芯片平台都能够安装运行，这使得开发者可以聚焦于应用的功能实现。\n\n\n应用的多Module设计机制#\n\n * 支持模块化开发：\n   一个应用通常会包含多种功能，将不同的功能特性按模块来划分和管理是一种良好的设计方式。在开发过程中，我们可以将每个功能模块作为一个独立的Module进行开发\n   ，Module中可以包含源代码、资源文件、第三方库、配置文件等，每一个Module可以独立编译，实现特定的功能。这种模块化、松耦合的应用管理方式有助于应用\n   的开发、维护与扩展。\n * 支持多设备适配：\n   一个应用往往需要适配多种设备类型，在采用多Module设计的应用中，每个Module都会标注所支持的设备类型。有些Module支持全部类型的设备，有些Mo\n   dule只支持某一种或几种类型的设备（比如平板），那么在应用市场分发应用包时，也能够根据设备类型做精准的筛选和匹配，从而将不同的包合理的组合和部署到对应的\n   设备上。\n\n\nModule类型#\n\nModule按照使用场景可以分为两种类型：\n\n * Ability类型的Module：\n   用于实现应用的功能和特性。每一个Ability类型的Module编译后，会生成一个以.hap为后缀的文件，我们称其为HAP（Harmony Ability\n   Package）包。HAP包可以独立安装和运行，是应用安装的基本单位，一个应用中可以包含一个或多个HAP包，具体包含如下两种类型。\n   \n   * entry类型的Module：应用的主模块，包含应用的入口界面、入口图标和主功能特性，编译后生成entry类型的HAP。每一个应用分发到同一类型的设备\n     上的应用程序包，只能包含唯一一个entry类型的HAP。\n   * feature类型的Module：应用的动态特性模块，编译后生成feature类型的HAP。一个应用中可以包含一个或多个feature类型的HAP，也\n     可以不包含。\n\n * Library类型的Module：\n   用于实现代码和资源的共享。同一个Library类型的Module可以被其他的Module多次引用，合理地使用该类型的Module，能够降低开发和维护成本。\n   Library类型的Module分为Static和Shared两种类型，编译后会生成共享包。\n   \n   * Static Library：静态共享库。编译后会生成一个以.har为后缀的文件，即静态共享包HAR（Harmony Archive）。\n   * Shared Library：动态共享库。编译后会生成一个以.hsp为后缀的文件，即动态共享包HSP（Harmony Shared Package）。\n\n说明\n\n实际上，Shared\nLibrary编译后除了会生成一个.hsp文件，还会生成一个.har文件。这个.har文件中包含了HSP对外导出的接口，应用中的其他模块需要通过.har文件来引\n用HSP的功能。为了表述方便，我们通常认为Shared Library编译后生成HSP。\n\nHAR与HSP两种共享包的主要区别体现在：\n\n共享包类型   编译和运行方式                                                        发布和引用方式\nHAR     HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝。注意：编译HAR时，建议开启混   HAR除了支持应用内引用，还可以独立打包发布，供其他应用引用。\n        淆能力，保护代码资产。\nHSP     HSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份。                           HSP一般随应用进行打包，当前支持应用内和集成态HSP。应用内HSP只支持应用内引用，集成态HSP支持发布到ohpm私仓\n                                                                       和跨应用引用。\n\n图1 HAR和HSP在APP包中的形态示意图\n\n","routePath":"/harmony/kaifajichu/part7","lang":"","toc":[{"text":"应用与应用程序包","id":"应用与应用程序包","depth":2,"charIndex":50},{"text":"应用的多Module设计机制","id":"应用的多module设计机制","depth":2,"charIndex":257},{"text":"Module类型","id":"module类型","depth":2,"charIndex":646}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"UIAbility组件","content":"#\n\n\n概述#\n\nUIAbility组件是一种包含UI的应用组件，主要用于和用户交互。\n\nUIAbility的设计理念：\n\n 1. 原生支持应用组件级的跨端迁移和多端协同。\n 2. 支持多设备和多窗口形态。\n\nUIAbility划分原则与建议：\n\nUIAbility组件是系统调度的基本单元，为应用提供绘制界面的窗口。一个应用可以包含一个或多个UIAbility组件。例如，在支付应用中，可以将入口功能和收付\n款功能分别配置为独立的UIAbility。\n\n每一个UIAbility组件实例都会在最近任务列表中显示一个对应的任务。\n\n对于开发者而言，可以根据具体场景选择单个还是多个UIAbility，划分建议如下：\n\n * 如果开发者希望在任务视图中看到一个任务，建议使用“一个UIAbility+多个页面”的方式，可以避免不必要的资源加载。\n\n * 如果开发者希望在任务视图中看到多个任务，或者需要同时开启多个窗口，建议使用多个UIAbility实现不同的功能。\n   \n   例如，即时通讯类应用中的消息列表与音视频通话采用不同的UIAbility进行开发，既可以方便地切换任务窗口，又可以实现应用的两个任务窗口在一个屏幕上分屏显\n   示。\n\n说明\n\n任务视图用于快速查看和管理当前设备上运行的所有任务或应用。\n\n\n声明配置#\n\n为使应用能够正常使用UIAbility，需要在module.json5配置文件的abilities标签中声明UIAbility的名称、入口、标签等相关信息。\n\n\n\n\nUIAbility组件生命周期#\n\n当用户打开、切换和返回到对应应用时，应用中的UIAbility实例会在其生命周期的不同状态之间转换。UIAbility类提供了一系列回调，通过这些回调可以知道当\n前UIAbility实例的某个状态发生改变，会经过UIAbility实例的创建和销毁，或者UIAbility实例发生了前后台的状态切换。\n\nUIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，如下图所示。\n\n图1 UIAbility生命周期状态\n\n\n\n\n生命周期状态说明#\n\n\nCreate状态#\n\nCreate状态为在应用加载过程中，UIAbility实例创建完成时触发，系统会调用onCreate()回调。可以在该回调中进行页面初始化操作，例如变量定义资源\n加载等，用于后续的UI展示。\n\n\n\n说明\n\nWant是对象间信息传递的载体，可以用于应用组件间的信息传递。Want的详细介绍请参见信息传递载体Want。\n\n\nWindowStageCreate和WindowStageDestroy状态#\n\nUIAbility实例创建完成之后，在进入Foreground之前，系统会创建一个WindowStage。WindowStage创建完成后会进入onWindow\nStageCreate()回调，可以在该回调中设置UI加载、设置WindowStage的事件订阅。\n\n图2 WindowStageCreate和WindowStageDestroy状态\n\n\n\n在onWindowStageCreate()回调中通过loadContent()方法设置应用要加载的页面，并根据需要调用on('windowStageEvent\n')方法订阅WindowStage的事件（获焦/失焦、切到前台/切到后台、前台可交互/前台不可交互）。\n\n说明\n\n不同开发场景下WindowStage事件的时序可能存在差异。\n\n\n\n说明\n\nWindowStage的相关使用请参见窗口开发指导。\n\n对应于onWindowStageCreate()回调。在UIAbility实例销毁之前，则会先进入onWindowStageDestroy()回调，可以在该回调\n中释放UI资源。\n\n\n\n\nWindowStageWillDestroy状态#\n\n对应onWindowStageWillDestroy()回调，在WindowStage销毁前执行，此时WindowStage可以使用。\n\n\n\n说明\n\nWindowStage的相关使用请参见窗口开发指导。\n\n\nForeground和Background状态#\n\nForeground和Background状态分别在UIAbility实例切换至前台和切换至后台时触发，对应于onForeground()回调和onBackgr\nound()回调。\n\nonForeground()回调，在UIAbility的UI可见之前，如UIAbility切换至前台时触发。可以在onForeground()回调中申请系统需要\n的资源，或者重新申请在onBackground()中释放的资源。\n\nonBackground()回调，在UIAbility的UI完全不可见之后，如UIAbility切换至后台时候触发。可以在onBackground()回调中释放\nUI不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。\n\n例如应用在使用过程中需要使用用户定位时，假设应用已获得用户的定位权限授权。在UI显示之前，可以在onForeground()回调中开启定位功能，从而获取到当前的\n位置信息。\n\n当应用切换到后台状态，可以在onBackground()回调中停止定位功能，以节省系统的资源消耗。\n\n\n\n当应用的UIAbility实例已创建，且UIAbility配置为singleton启动模式时，再次调用startAbility()方法启动该UIAbility实\n例时，只会进入该UIAbility的onNewWant()回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。应用可以\n在该回调中更新要加载的资源和数据等，用于后续的UI展示。\n\n\n\n\nDestroy状态#\n\nDestroy状态在UIAbility实例销毁时触发。可以在onDestroy()回调中进行系统资源的释放、数据的保存等操作。\n\n例如，调用terminateSelf()方法停止当前UIAbility实例，执行onDestroy()回调，并完成UIAbility实例的销毁。\n\n","routePath":"/harmony/kaifajichu/part8","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"声明配置","id":"声明配置","depth":2,"charIndex":560},{"text":"**UIAbility组件生命周期**","id":"uiability组件生命周期","depth":2,"charIndex":-1},{"text":"生命周期状态说明","id":"生命周期状态说明","depth":2,"charIndex":907},{"text":"Create状态","id":"create状态","depth":3,"charIndex":919},{"text":"WindowStageCreate和WindowStageDestroy状态","id":"windowstagecreate和windowstagedestroy状态","depth":3,"charIndex":1090},{"text":"WindowStageWillDestroy状态","id":"windowstagewilldestroy状态","depth":3,"charIndex":1606},{"text":"Foreground和Background状态","id":"foreground和background状态","depth":3,"charIndex":1737},{"text":"Destroy状态","id":"destroy状态","depth":3,"charIndex":2426}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"上手指南","content":"#\n\n\n介绍#\n\n鸿蒙开发工具\n\n一站式的 HarmonyOS 应用及元服务开发平台，为你提供代码开发、编译构建及调测等功能。\n\nDevEco Studio Release\n\n开发语言 ArkTS\n\nArkTS 是鸿蒙原生应用的开发语言。它在保持 TypeScript（简称TS）基本语法风格的基础上，通过规范强化静态检查和分析，提升代码健壮性，让你轻松上手。\n\n语法学习\n\n前端组件库 ArUI\n\nArkUI 是一套构建分布式应用界面的声明式 UI 开发框架。它使用简洁的 UI 信息语法、丰富的 UI 组件、实时界面预览工具，提升应用界面开发效率30%。\n\nUI组件库\n\n编译模式 ArkCompiler\n\nArkCompiler 是华为自研的统一编程平台，包含编译器、工具链、运行时等关键部件，支持高级语言在多种芯片平台的编译与运行。\n\n编译模式介绍","routePath":"/harmony/kuaisurumen/part1","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"项目创建","content":"#\n\nTIP\n\n参考HarmonyOS应用开发快速入门\n\n\nStep 1#\n\n打开DevEco Studio，通过如下两种方式，打开工程创建向导界面：\n\n> 如果当前未打开任何工程，可以在DevEco Studio的欢迎页，选择Create Project开始创建一个新工程。\n\n> 如果已经打开了工程，可以在菜单栏选择File > New > Create Project来创建一个新工程。\n\n\nStep 2#\n\n根据工程创建向导，选择创建Application。选择Empty Ability模板，然后单击Next，进入配置界面。\n\n\nStep 3#\n\n配置项目名称。\n\n注意\n\n检查Bundle name和Save location是否与命名一致，一般会根据Project name自行更新，也可以根据需要自行更改。\n\n选择Compatible SDK为5.0.0(12)，在编译构建时，DevEco Studio会根据指定的Compatible SDK版本进行编译打包。\n\n其中，Compatible SDK需要跟随版本变化变更选择。\n\nDevEco Studio会默认勾选除‘Car’以外的全部Device type，保持该选项即可。\n\n\nStep 4#\n\n单击Finish，工具会自动生成示例代码和相关资源。\n\n\nStep 5#\n\n在Project导航栏中选中 entry -> src -> main -> ets -> pages ->\nIndex.ets，即可看到初始创建项目的模板代码。\n\n\n\n其中，\n\n * @Component装饰器装饰了struct关键字声明的数据结构Index。Index被@Component装饰后具备组件化的能力，通过实现build方法\n   描述UI。\n\n * @Entry装饰的@Component将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。\n\n * 界面由RelativeContainer相对布局容器作为根容器，RelativeContainer支持容器内部的子元素设置相对位置关系，适用于界面复杂场景\n   的情况，对多个子组件进行对齐和排列。\n\n * 通过Text组件展示一段文本\n\n * 文本信息由@State装饰器装饰的状态变量message驱动。\n\n * Text组件定义了组件标识id为HelloWorld，用于唯一指定组件。\n\n * 定义字体大小fontSize取值为50；定义文本的字体粗细fontWeight取值为Bold，即字体较粗。\n\n * alignRules属性用于指定设置在相对容器中子组件的对齐规则，仅当父容器为RelativeContainer时生效，在这里定义Text组件横向居中和纵\n   向居中。\n\n\n修改APP的名称#\n\n修改entry/src/main/resources/zh_CN/element/string.json文件，修改EntryAbility_label的valu\ne。\n\n\n修改APP的图标#\n\n替换entry/src/main/resources/base/media文件夹中的background.png和foreground.png图片。","routePath":"/harmony/kuaisurumen/part2","lang":"","toc":[{"text":"Step 1","id":"step-1","depth":2,"charIndex":-1},{"text":"Step 2","id":"step-2","depth":2,"charIndex":198},{"text":"Step 3","id":"step-3","depth":2,"charIndex":269},{"text":"Step 4","id":"step-4","depth":2,"charIndex":524},{"text":"Step 5","id":"step-5","depth":2,"charIndex":562},{"text":"修改APP的名称","id":"修改app的名称","depth":2,"charIndex":1167},{"text":"修改APP的图标","id":"修改app的图标","depth":2,"charIndex":1264}],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"写一个小demo","content":"#\n\n实现如下页面：\n\n\n分析#\n\n在上图中，我们将页面内的结构抽象三大部分。其中，第1部分为轮播图部分，第2部分为赋能套件部分，第3部分为入门教程部分。\n\n * 顶部的标题部分\n * 轮播图部分：可自动播放、展示多张图片的组件，命名为Banner，每一个元素为BannerItem\n * 赋能套件部分：横向可滑动的组件，命名为Enablement ，由多个EnablementItem组成。\n * 入门教程部分：纵向可滑动的组件，命名为Tutorial ，由多个TutorialItem组成。\n\n\n实现#\n\n\n页面整体布局#\n\n容器\n\n页面整体布局沿垂直方向布局，根容器使用Column。Column容器可以使组件内的元素沿垂直方向布局。\n\n\n\n\n顶部的标题部分#\n\nTIP\n\n首先将Text组件宽度设置为占满屏幕（100%），并设置文本对齐属性为Start，文本在Text组件内会向左对齐。设置文本左边距，padding属性可以设置内容\n器向内的边距，此处设置左边距（left）为16。\n\n\n\n\n轮播图部分：Swiper组件提供滑动轮播显示的能力。#\n\nSwiper 循环的Item#\n\n根据设计图可以看到快速入门Banner运营位由多张图片资源构成，于是我们可以在Index.ets文件中创建一个BannerClass类，用于表示每张图片资源的数\n据结构。\n\n\n\n静态资源#\n\n将Resource文件夹中的所有图片资源放置在entry/src/main/resources/base/media路径下，我们可使用$r('app.media\n.filename') 的方式将该路径下的图片读取到Image组件内。\n\n创建一个组件#\n\n创建一个Banner组件，使用@Component\n进行装饰。定义需要渲染的Banner图片数据源。使用刚刚创建的BannerClass构建出bannerList数组，如代码中，在bannerList中构建了六个\nBannerClass实例。\n\n\n\n列表循环渲染#\n\nTIP\n\n使用Swiper组件作为外层容器。使用ForEach进行列表循环渲染。循环渲染一个Image组件。\n\nForEach#\n\n参数              类型                                      介绍\narr             Array                                   一个任意类型的数组arr\nitemGenerator   (item: any, index?: number) => void     该函数会按序取到数组中的每一个项，生成函数体中的组件。\nkeyGenerator    (item: any, index?: number) => string   这个函数关键的作用就在于通过标识每一个实际的组件，当数组元素变化触发页面更新时，能通过对比标识来判断组件是否存在，是否需\n                                                        要创建新的对应的组件，达成增量渲染，而非全量的重新渲染，以提高渲染效率，所以建议在使用ForEach循环渲染传入该参数\n\n\n\n设置Swiper组件的属性#\n\nTIP\n\nautoPlay控制是否自动轮播子组件，loop属性控制是否循环播放，indicator属性自定义导航点的位置和样式。\n\n\n\n\n赋能套件部分#\n\nTIP\n\n整体为上下结构。下部的列表为横向结构，可以横向滚动。列表的单个Item为纵向结构，包含图片、标题、描述。\n\n创建容器#\n\n创建一个 EnablementView 组件\n\n\n\n创建文字标题和横向滚动区域#\n\nTIP\n\nGrid组件为网格容器，由“行”和“列”分割的单元格所组成，其中容器内各条目对应一个GridItem组件。如果仅设置行、列数量与占比中的一个，网格单元将按照设置\n的方向排列，超出Grid显示区域后，Grid拥有可滚动能力。在这部分，可以设置单行显示，则赋能套件部分可以横向滑动。\n\n\n\n创建GridItem和每个Item的数据结构#\n\n\n\n\n入门教程区域#\n\nTIP\n\n列表是一种复杂的容器，当列表项达到一定数量，内容超过屏幕大小时，可以自动提供滚动功能。它适合用于呈现同类数据类型或数据类型集，使用列表可以轻松高效地显示结构化、\n可滚动的信息。\n\n入门教程区域也是由上至下的布局，也可以考虑采用Column组件作为外部容器组件。其中包含一行文本，以及多个结构类似的内容，我们就可以采用List组件进行组织。\n\n\n\n实现ListItem内容#\n\nTIP\n\n在组件中定义标题（title）和简介（brief）。它们的类型都是string，赋值分别为“Step1 快速入门介绍” 和\n“本篇教程实现了快速入门——一个用于了解和学习HarmonyOS的应用程序\n”。布局整体为左右布局，左边为两个文本，这个两个文本沿垂直方向排列。可以最外层使用Row容器，使文本和图片左右排列。左边文本可以使用Column容器垂直排列ti\ntle和brief文本。\n\n\n\n实现list列表#\n\n","routePath":"/harmony/kuaisurumen/part3","lang":"","toc":[{"text":"分析","id":"分析","depth":2,"charIndex":12},{"text":"实现","id":"实现","depth":2,"charIndex":249},{"text":"页面整体布局","id":"页面整体布局","depth":3,"charIndex":255},{"text":"顶部的标题部分","id":"顶部的标题部分","depth":3,"charIndex":324},{"text":"轮播图部分：Swiper组件提供滑动轮播显示的能力。","id":"轮播图部分swiper组件提供滑动轮播显示的能力","depth":3,"charIndex":449},{"text":"Swiper 循环的Item","id":"swiper-循环的item","depth":4,"charIndex":478},{"text":"静态资源","id":"静态资源","depth":4,"charIndex":584},{"text":"创建一个组件","id":"创建一个组件","depth":4,"charIndex":709},{"text":"列表循环渲染","id":"列表循环渲染","depth":4,"charIndex":843},{"text":"设置Swiper组件的属性","id":"设置swiper组件的属性","depth":4,"charIndex":1366},{"text":"赋能套件部分","id":"赋能套件部分","depth":3,"charIndex":1451},{"text":"创建容器","id":"创建容器","depth":4,"charIndex":1519},{"text":"创建文字标题和横向滚动区域","id":"创建文字标题和横向滚动区域","depth":4,"charIndex":1552},{"text":"创建GridItem和每个Item的数据结构","id":"创建griditem和每个item的数据结构","depth":4,"charIndex":1716},{"text":"入门教程区域","id":"入门教程区域","depth":3,"charIndex":1744},{"text":"实现ListItem内容","id":"实现listitem内容","depth":4,"charIndex":1931},{"text":"实现list列表","id":"实现list列表","depth":4,"charIndex":2148}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"应用架构设计基础","content":"#\n\n\nMVVM模式#\n\nArkUI采取MVVM = Model + View +\nViewModel模式，其中状态管理模块起到的就是ViewModel的作用，将数据与视图绑定在一起，更新数据的时候直接更新视图。\n\nTIP\n\nArkUI中，model为我们定义的数据结构和数据来源，通过ArkUI提供的装饰器@State等装饰对应的数据，就提供了响应式能力，model数据的变化能够触发\nUI的更新。\n\n\n目录#\n\n目录结构\n\n为了让代码更加清晰，容易维护，我们需要对代码进行分层管理，常见的数据结构放置在model文件夹中，UI组件放置在view文件夹中，并以对应的组件名命名。\n\n * 建立model文件夹。在entry/src/main/ets文件夹下点击右键 - > new - > Directory。文件夹命名为model。\n   \n   > model文件夹用于存储数据模型。它表示组件或其他相关业务逻辑之间传输的数据，是对原始数据的进一步处理。\n\n * 创建view文件夹，用于存储UI组件.在entry/src/main/ets文件夹下点击右键 - > new - >\n   Directory，命名为view，用于存放页面相关的自定义组件。\n\n\n三层架构#\n\nTIP\n\n官网三层架构介绍\n\n前面我们介绍了MVVM的目录组织方式，一般适用于单个模块内文件组织，为了更好地适配复杂应用的开发，建议采用三层架构的方式对整个应用的功能进行模块化，实现高内聚、\n低耦合开发。前面我们介绍了MVVM的目录组织方式，一般适用于单个模块内文件组织，为了更好地适配复杂应用的开发，建议采用三层架构的方式对整个应用的功能进行模块化，\n实现高内聚、低耦合开发。\n\n\n三层架构设计#\n\n“一次开发，多端部署”推荐在应用开发过程中使用如下的“三层工程结构”\n\n三层工程结构如下\n\n * commons（公共能力层）：用于存放公共基础能力集合（如工具库、公共配置等）。commons层可编译成一个或多个HAR包或HSP包，只可以被produc\n   ts和features依赖，不可以反向依赖。\n * features（基础特性层）：用于存放基础特性集合（如应用中相对独立的各个功能的UI及业务逻辑实现等）。各个feature高内聚、低耦合、可定制，供产品\n   灵活部署。不需要单独部署的feature通常编译为HAR包或HSP包，供products或其它feature使用。需要单独部署的feature通常编译为F\n   eature类型的HAP包，和products下Entry类型的HAP包进行组合部署。features层可以横向调用及依赖common层，同时可以被pro\n   ducts层不同设备形态的HAP所依赖，但是不能反向依赖products层。\n * products（产品定制层）：用于针对不同设备形态进行功能和特性集成。products层各个子目录各自编译为一个Entry类型的HAP包，作为应用主入口\n   。products层不可以横向调用。","routePath":"/harmony/kuaisurumen/part4","lang":"","toc":[{"text":"MVVM模式","id":"mvvm模式","depth":2,"charIndex":3},{"text":"目录","id":"目录","depth":3,"charIndex":202},{"text":"三层架构","id":"三层架构","depth":2,"charIndex":532},{"text":"三层架构设计","id":"三层架构设计","depth":3,"charIndex":731}],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"知识地图","content":"#\n\n\n了解HarmonyOS#\n\n\nHarmonyOS介绍#\n\n * HarmonyOS简介\n * 鸿蒙生态应用开发白皮书\n * 鸿蒙生态应用安全技术白皮书\n\n\n获取最新套件#\n\n * HarmonyOS开发套件\n * HarmonyOS赋能套件\n\n\n快速入门#\n\n * 鸿蒙应用开发快速入门\n\n\n应用体验设计#\n\n\nUX设计#\n\n * 布局设计\n\n * 动效设计\n\n * 交互设计\n\n\nHarmonyOS特征设计#\n\n一次开发， 多端部署#\n\n * 一多工程管理\n\n * 一多常用布局能力\n\n * 一多典型布局场景\n\n * 多设备交互归一\n\n * 一多垂域案例\n\n自由流转#\n\n * 自由流转\n * 应用接续\n * 媒体播控\n * 跨设备拖拽\n * 跨设备剪贴板\n * \n\n\n业务场景与解决方案#\n\n行业场景#\n\n * 新闻阅读类\n\n * 出行导航类\n\n * 社交通讯类\n\n\n应用架构#\n\n\n架构#\n\n * 分层架构设计\n\n * 模块化设计\n\n * 应用并发设计\n\n * 应用导航设计\n\n * 切片编程设计\n\n\n应用质量#\n\n\n体验设计#\n\n * 基础功能和兼容性体验建议\n * 稳定性体验建议\n * 性能体验建议\n * 功耗体验建议\n * 安全隐私体验建议\n * UX体验建议\n\n\n技术质量#\n\n性能#\n\n * 应用流畅体验设计\n * 合理使用布局\n * 状态管理最佳实践\n * Web场景性能优化指导\n * 帧率和丢帧分析\n\n功耗#\n\n * 省电和深色模式下低功耗设计\n * 可变帧率能力\n * 合理使用后台任务\n * 合理使用后台硬件资源\n * 合理使用后台软件资源\n\n隐私与安全#\n\n * 应用隐私保护\n * 应用数据安全\n * 应用安全编码实践\n * 应用资产保护设计\n * 应用代码混淆\n\n运维#\n\n * 故障定位指导\n\n\n开发工具#\n\n\nDevEco Studio#\n\n开发阶段#\n\n * 环境准备\n * 工程管理\n * 代码编辑\n * 界面预览\n\n编译调试阶段#\n\n * 编译构建\n\n签名#\n\n * 签名服务\n\n调试运行#\n\n * 应用运行\n * 应用调试\n * 性能分析\n\n测试#\n\n * 应用测试\n\n发布#\n\n * 应用发布\n\n命令行#\n\n * 命令行工具\n\n\n功能开发#\n\n\n应用框架开发#\n\n程序包结构#\n\n * 程序包结构\n * HAR包的创建和引用\n * HSP包的创建和引用\n\n程序框架#\n\n * 程序框架的亮点/特征\n * 应用组件概念\n * UIAbility组件生命周期\n * UIAbility组件启动\n * UIAbility组件与UI的数据通信\n\nArkTS语言#\n\n * TS到ArkTS适配指导\n * TaskPool和Worker的对比\n * 动态import\n * 语言基础类库\n * 方舟字节码基本原理\n\nNDK开发#\n\n * Node-API跨语言交互\n * NDK工程构建\n * 异步开发\n * 三方SO库移植\n * CPP Crash故障定位\n\nUI框架#\n\n * 使用Navigation导航\n * 构建列表布局\n * 开发沉浸式页面\n * 控制软键盘弹出\n * 开发自定义弹窗\n\n本地数据和文件#\n\n * 轻量级数据持久化\n * 关系型数据库存储\n * 跨设备数据同步\n * 应用数据备份恢复\n * 跨应用数据共享\n * 分布式文件访问\n * 用户文件访问\n * 应用文件访问\n * 文件压缩\n * 系统空间统计\n\nWeb#\n\n * Web组件\n * WebView\n * 使用Web组件加载页面\n * 同层渲染\n * 在应用代码中开启Web调试\n\n\n系统开发#\n\n网络#\n\n * 网络连接管理\n * HTTP数据请求\n * WebSocket连接\n * Socket 连接\n * MDNS管理\n\n安全#\n\n * 加解密算法框架\n * 应用权限申请\n * 通用密钥库\n * 设备证书服务\n * 关键资产存储服务\n\n\n媒体开发#\n\n拍照和图片#\n\n * 双路预览\n * 人脸检测\n * 通用文字识别\n * 预览图像实时获取\n * 系统相机拍照\n * 显示图片\n * 图片编码\n * 图片解码\n * EXIF信息读取\n * 图片压缩\n\n音频和视频#\n\n * AVRecoder录像\n * 音频编解码\n * 音频焦点监听\n * AVPlayer音频播放\n * 音频元数据获取\n * 视频编解码\n * 视频投播\n * AVPlayer视频播放\n * AVPlayer视频控制\n * AVPlayer全屏播放\n\n图形开发#\n\n * 2D图形绘制\n * 3D图形绘制\n * OpenGL图形渲染\n * XComponent自定义绘制\n * 图像变换\n * 图形加速服务\n * GPU加速引擎服务\n\n应用服务开发#\n\n * 华为账号服务\n * 推送服务\n * 实况窗服务\n * 广告服务\n * 应用市场服务\n * 应用内支付服务\n * 华为支付服务\n * 位置服务\n * 地图服务\n * 运动健康服务\n * 联系人服务\n * 游戏服务\n\n\nAI功能开发#\n\n意图框架#\n\n * HarmonyOS意图框架\n\n\n应用测试#\n\n\n单元测试和UI测试#\n\n自动化测试框架#\n\n * 自动化测试框架\n\nUI测试#\n\n * 测试脚本快速开发入门\n\n应用专项测试#\n\n * DevEco Testing\n\n\n上架与分发#\n\n应用发布#\n\n * 发布前测试\n * 发布HarmonyOS应用\n * 分阶段发布","routePath":"/harmony/part0","lang":"","toc":[{"text":"了解HarmonyOS","id":"了解harmonyos","depth":2,"charIndex":3},{"text":"HarmonyOS介绍","id":"harmonyos介绍","depth":3,"charIndex":18},{"text":"获取最新套件","id":"获取最新套件","depth":3,"charIndex":81},{"text":"快速入门","id":"快速入门","depth":3,"charIndex":126},{"text":"应用体验设计","id":"应用体验设计","depth":2,"charIndex":149},{"text":"UX设计","id":"ux设计","depth":3,"charIndex":159},{"text":"HarmonyOS特征设计","id":"harmonyos特征设计","depth":3,"charIndex":194},{"text":"一次开发， 多端部署","id":"一次开发-多端部署","depth":4,"charIndex":210},{"text":"自由流转","id":"自由流转","depth":4,"charIndex":283},{"text":"业务场景与解决方案","id":"业务场景与解决方案","depth":3,"charIndex":339},{"text":"行业场景","id":"行业场景","depth":4,"charIndex":351},{"text":"应用架构","id":"应用架构","depth":2,"charIndex":389},{"text":"架构","id":"架构","depth":3,"charIndex":397},{"text":"应用质量","id":"应用质量","depth":2,"charIndex":457},{"text":"体验设计","id":"体验设计","depth":3,"charIndex":465},{"text":"技术质量","id":"技术质量","depth":3,"charIndex":543},{"text":"性能","id":"性能","depth":4,"charIndex":550},{"text":"功耗","id":"功耗","depth":4,"charIndex":616},{"text":"隐私与安全","id":"隐私与安全","depth":4,"charIndex":689},{"text":"运维","id":"运维","depth":4,"charIndex":752},{"text":"开发工具","id":"开发工具","depth":2,"charIndex":769},{"text":"DevEco Studio","id":"deveco-studio","depth":3,"charIndex":777},{"text":"开发阶段","id":"开发阶段","depth":4,"charIndex":793},{"text":"编译调试阶段","id":"编译调试阶段","depth":4,"charIndex":833},{"text":"签名","id":"签名","depth":4,"charIndex":851},{"text":"调试运行","id":"调试运行","depth":4,"charIndex":865},{"text":"测试","id":"测试","depth":4,"charIndex":897},{"text":"发布","id":"发布","depth":4,"charIndex":911},{"text":"命令行","id":"命令行","depth":4,"charIndex":925},{"text":"功能开发","id":"功能开发","depth":2,"charIndex":942},{"text":"应用框架开发","id":"应用框架开发","depth":3,"charIndex":950},{"text":"程序包结构","id":"程序包结构","depth":4,"charIndex":959},{"text":"程序框架","id":"程序框架","depth":4,"charIndex":1005},{"text":"ArkTS语言","id":"arkts语言","depth":4,"charIndex":1096},{"text":"NDK开发","id":"ndk开发","depth":4,"charIndex":1180},{"text":"UI框架","id":"ui框架","depth":4,"charIndex":1253},{"text":"本地数据和文件","id":"本地数据和文件","depth":4,"charIndex":1322},{"text":"Web","id":"web","depth":4,"charIndex":1440},{"text":"系统开发","id":"系统开发","depth":3,"charIndex":1508},{"text":"网络","id":"网络","depth":4,"charIndex":1515},{"text":"安全","id":"安全","depth":4,"charIndex":1581},{"text":"媒体开发","id":"媒体开发","depth":3,"charIndex":1640},{"text":"拍照和图片","id":"拍照和图片","depth":4,"charIndex":1647},{"text":"音频和视频","id":"音频和视频","depth":4,"charIndex":1748},{"text":"图形开发","id":"图形开发","depth":4,"charIndex":1883},{"text":"应用服务开发","id":"应用服务开发","depth":4,"charIndex":1975},{"text":"AI功能开发","id":"ai功能开发","depth":3,"charIndex":2095},{"text":"意图框架","id":"意图框架","depth":4,"charIndex":2104},{"text":"应用测试","id":"应用测试","depth":2,"charIndex":2130},{"text":"单元测试和UI测试","id":"单元测试和ui测试","depth":3,"charIndex":2138},{"text":"自动化测试框架","id":"自动化测试框架","depth":4,"charIndex":2150},{"text":"UI测试","id":"ui测试","depth":4,"charIndex":2172},{"text":"应用专项测试","id":"应用专项测试","depth":4,"charIndex":2194},{"text":"上架与分发","id":"上架与分发","depth":3,"charIndex":2223},{"text":"应用发布","id":"应用发布","depth":4,"charIndex":2231}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"学习路线","content":"#\n\n\n基础#\n\n * HarmonyOS介绍\n * DevEco Studio的使用\n * ArkTS语法介绍\n * 应用程序框架基础\n * 从简单的页面开始\n * 构建更加丰富的页面\n * 从网络获取数据\n * 保存应用数据\n\n\n中级#\n\n * 应用程序框架进阶\n * ArkUI进阶\n * 合理使用动画和转场\n * Web组件和WebView\n * 给应用添加通知和提醒\n * Native适配开发\n * 三方库的基本使用\n * HarmonyOS SDK开放能力简介\n * 质量建议与测试指南\n * 应用/元服务上架\n\n\n高级#\n\n * 一次开发，多端部署\n * 自由流转\n * 应用性能优化\n * 应用开发安全\n * 应用DFX能力介绍","routePath":"/harmony/studyLine/part1","lang":"","toc":[{"text":"基础","id":"基础","depth":2,"charIndex":3},{"text":"中级","id":"中级","depth":2,"charIndex":116},{"text":"高级","id":"高级","depth":2,"charIndex":264}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"一些常用CSS","content":"#\n\n\n媒体查询#\n\n\n\n\n媒体类型#\n\n值        描述\nall      默认。用于所有媒体类型设备。\nprint    用于打印机。\nscreen   用于计算机屏幕、平板电脑、智能手机等。\nspeech   用于朗读页面的屏幕阅读器。\n\n\n媒体特性#\n\n值                              描述\nany-hover                      是否有任何可用的输入机制允许用户（将鼠标等）悬停在元素上？在 Media Queries Level 4 中被添加。\nany-pointer                    可用的输入机制中是否有任何指针设备，如果有，它的精度如何？在 Media Queries Level 4 中被添加。\naspect-ratio                   视口（viewport）的宽高比。\ncolor                          输出设备每个像素的比特值，常见的有 8、16、32 位。如果设备不支持输出彩色，则该值为 0。\ncolor-gamut                    用户代理和输出设备大致程度上支持的色域。在 Media Queries Level 4 中被添加。\ncolor-index                    输出设备的颜色查询表（color lookup table）中的条目数量。如果设备不使用颜色查询表，则该值为 0。\ndevice-aspect-ratio            输出设备的宽高比。已在 Media Queries Level 4 中被弃用。\ndevice-height                  输出设备渲染表面（如屏幕）的高度。已在 Media Queries Level 4 中被弃用。\ndevice-width                   输出设备渲染表面（如屏幕）的宽度。已在 Media Queries Level 4 中被弃用。\ndisplay-mode                   应用程序的显示模式，如 web app 的 manifest 中的 display 成员所指定在 Web App\n                               Manifest spec 被定义。\nforced-colors                  检测是用户代理否限制调色板。在 Media Queries Level 5 中被添加。\ngrid                           输出设备使用网格屏幕还是点阵屏幕？\nheight                         视口（viewport）的高度。\nhover                          主输入机制是否允许用户将鼠标悬停在元素上？在 Media Queries Level 4 中被添加。\ninverted-colors                浏览器或者底层操作系统是否反转了颜色。在 Media Queries Level 5 中被添加。\nlight-level                    当前环境光水平。在 Media Queries Level 5 中被添加。\nmax-aspect-ratio               显示区域的宽度和高度之间的最大比例。\nmax-color                      输出设备每个颜色分量的最大位数。\nmax-color-index                设备可以显示的最大颜色数。\nmax-height                     显示区域的最大高度，例如浏览器窗口。\nmax-monochrome                 单色（灰度）设备上每种“颜色”的最大位数。\nmax-resolution                 设备的最大分辨率，使用 dpi 或 dpcm。\nmax-width                      显示区域的最大宽度，例如浏览器窗口。\nmin-aspect-ratio               显示区域的宽度和高度之间的最小比例。\nmin-color                      输出设备每个颜色分量的最小位数。\nmin-color-index                设备可以显示的最小颜色数。\nmin-height                     显示区域的最小高度，例如浏览器窗口。\nmin-monochrome                 单色（灰度）设备上每种“颜色”的最小位数。\nmin-resolution                 设备的最低分辨率，使用 dpi 或 dpcm。\nmin-width                      显示区域的最小宽度，例如浏览器窗口。\nmonochrome                     输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为 0。\norientation                    视窗（viewport）的旋转方向（横屏还是竖屏模式）。\noverflow-block                 输出设备如何处理沿块轴溢出视口(viewport)的内容。在 Media Queries Level 4 中被添加。\noverflow-inline                沿内联轴溢出视口(viewport)的内容是否可以滚动？在 Media Queries Level 4 中被添加。\npointer                        主要输入机制是一个指针设备吗？如果是，它的精度如何？在 Media Queries Level 4 中被添加。\nprefers-color-scheme           探测用户倾向于选择亮色还是暗色的配色方案。在 Media Queries Level 5 中被添加。\nprefers-contrast               探测用户是否有向系统要求提高或降低相近颜色之间的对比度。在 Media Queries Level 5 中被添加。\nprefers-reduced-motion         用户是否希望页面上出现更少的动态效果。在 Media Queries Level 5 中被添加。\nprefers-reduced-transparency   用户是否倾向于选择更低的透明度。在 Media Queries Level 5 中被添加。\nresolution                     输出设备的分辨率，使用 dpi 或 dpcm。\nscan                           输出设备的扫描过程（适用于电视等）。\nscripting                      探测脚本（例如 JavaScript）是否可用。在 Media Queries Level 5 中被添加。\nupdate                         输出设备更新内容的渲染结果的频率。在 Media Queries Level 4 中被添加。\nwidth                          视窗（viewport）的宽度。\n\n\n文字渐变色#\n\n","routePath":"/notes/CSS/CSSchangyong","lang":"","toc":[{"text":"媒体查询","id":"媒体查询","depth":2,"charIndex":3},{"text":"媒体类型","id":"媒体类型","depth":3,"charIndex":13},{"text":"媒体特性","id":"媒体特性","depth":3,"charIndex":126},{"text":"文字渐变色","id":"文字渐变色","depth":2,"charIndex":3159}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"自动高度","content":"#\n\n以vue示例\n\n","routePath":"/notes/CSS/autoheight","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"css 权重","content":"#\n\ncss权重指的是css6大基础选择符的优先级，优先级高的css样式会覆盖优先级底的css样式，优先级越高说明权重越高，反之亦然。\n\n\ncss 6大选择器#\n\n * id选择器\n * 类选择器\n * 属性选择器\n * 伪类和为元素选择器\n * 标签选择器\n * 通配符选择器\n\n\ncss权重计算规则#\n\n计算css权重是有一定规则的，根据w3c制定的css规范，css权重计算规则如下：\n\n * !important为10000\n * style为1000\n * 计算选择符中id选择器的数量，一个id为一个a，一个a为100\n * 计算类和属性选择器的数量，一个选择器为一个b，一个b为10\n * 标签和伪对象选择器数量，一个选择器为一个c，一个c为1\n * 通配符选择器忽略不计\n\n\n优先级问题#\n\n下面列表中，选择器类型的优先级是递增的：\n\n * 类型选择器（例如，h1）和伪元素（例如，::before）\n\n * 类选择器（例如，.example），属性选择器（例如，[type=\"radio\"]）和伪类（例如，:hover）\n\n * ID 选择器（例如，#example）。\n\n注意\n 1. 用数字表示只是说明思想，一万个class也不如一个id权值高\n 2. 通配选择器（universal selector）（*）关系选择器（combinator）（+、>、~、\" \"、||）和 否定伪类（negation\n    pseudo-class）（:not()）对优先级没有影响。（但是，在 :not() 内部声明的选择器会影响优先级）。","routePath":"/notes/CSS/css-selector","lang":"","toc":[{"text":"css 6大选择器","id":"css-6大选择器","depth":2,"charIndex":69},{"text":"css权重计算规则","id":"css权重计算规则","depth":2,"charIndex":141},{"text":"优先级问题","id":"优先级问题","depth":2,"charIndex":345}],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"弹性盒子模型","content":"#\n\nFlex是Flexible Box的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 :::tip\n设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。position定位不受影响。 :::\n\n\n基本概念#\n\n容器: 被设为display: flex的元素 主轴: 默认为容器的水平轴 交叉轴: 与主轴垂直的轴\n\n\n将元素设置为弹性盒子#\n\n\n\n\n容器的属性#\n\n * flex-direction: 属性决定主轴的方向（即项目的排列方向）。\n   * row: 主轴为水平方向，起点在左端\n   * row-reverse: 主轴为水平方向，起点在右端\n   * column: 主轴为垂直方向，起点在上沿。\n   * column-reverse: 主轴为垂直方向，起点在下沿。\n\n--------------------------------------------------------------------------------\n\n * flex-wrap: 默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n   * nowrap: （默认）不换行。\n   * wrap: 换行，第一行在上方\n   * wrap-reverse: 换行，第一行在下方\n\n--------------------------------------------------------------------------------\n\n * flex-flow: 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n\n--------------------------------------------------------------------------------\n\n * justify-content: 属性定义了项目在主轴上的对齐方式。\n   * flex-start: （默认值）起点对齐\n   * flex-end: 终点对齐\n   * center: 居中\n   * space-between: 两端对齐，项目之间的间隔都相等。\n   * space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n--------------------------------------------------------------------------------\n\n * align-items: 属性定义项目在交叉轴上如何对齐。\n   * flex-start: 交叉轴的起点对齐。\n   * flex-end: 交叉轴的终点对齐。\n   * center: 交叉轴的中点对齐。\n   * baseline: 项目的第一行文字的基线对齐。\n   * stretch（默认值）: 如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n--------------------------------------------------------------------------------\n\n * align-content: 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n   * flex-start: 与交叉轴的起点对齐。\n   * flex-end: 与交叉轴的终点对齐。\n   * center: 与交叉轴的中点对齐。\n   * space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布。\n   * space-around: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n   * stretch（默认值）: 轴线占满整个交叉轴。\n\n\n项目的属性#\n\n * order: 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n--------------------------------------------------------------------------------\n\n * flex-grow: 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n   如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余\n   空间将比其他项多一倍。\n\n--------------------------------------------------------------------------------\n\n * flex-shrink: 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n   如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，\n   前者不缩小。\n\n--------------------------------------------------------------------------------\n\n * flex-basis: 属性定义了在分配多余空间之前，项目占据的主轴空间（main\n   size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n   可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n--------------------------------------------------------------------------------\n\n * flex: 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n--------------------------------------------------------------------------------\n\n * align-self:\n   属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元\n   素，则等同于stretch。","routePath":"/notes/CSS/flex","lang":"","toc":[{"text":"基本概念","id":"基本概念","depth":2,"charIndex":144},{"text":"将元素设置为弹性盒子","id":"将元素设置为弹性盒子","depth":2,"charIndex":204},{"text":"容器的属性","id":"容器的属性","depth":2,"charIndex":220},{"text":"项目的属性","id":"项目的属性","depth":2,"charIndex":1649}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"网格布局入门","content":"#","routePath":"/notes/CSS/grid","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"长列表渲染优化","content":"#\n\n今天咱们来看两个可以 直接提升渲染性能的 CSS 属性。\n\ncontent-visibility contain-intrinsic-size 这两个 CSS 属性，主要针对 长列表渲染。\n\n\ncontent-visibility#\n\nTIP\n\ncontent-visibility是CSS新增的属性，主要用来提高页面渲染性能，它可以控制一个元素是否渲染其内容，并且允许浏览器跳过这些元素的布局与渲染。\n\n * visible: 默认值，没有效果。元素的内容被正常布局和呈现\n * hidden: 元素跳过它的内容。跳过的内容不能被用户代理功能访问.\n   例如在页面中查找、标签顺序导航等，也不能被选择或聚焦。这类似于给内容设置display: none。\n * auto：该元素打开布局包含、样式包含和绘制包含。如果该元素与用户不相关，它也会跳过其内容。\n   与hidden不同，跳过的内容必须仍可正常用于用户代理功能，例如在页面中查找、tab 顺序导航等，并且必须正常可聚焦和可选择。\n\n\ncontent-visibility: hidden手动管理可见性#\n\n上面说到content-visibility: hidden的效果与display: none类似，但其实两者还是有比较大的区别的：\n\n * content-visibility: hidden 只是隐藏了子元素，自身不会被隐藏\n * content-visibility: hidden\n   隐藏内容的渲染状态会被缓存，所以当它被移除或者设为可见时，浏览器不会重新渲染，而是会应用缓存，所以对于需要频繁切换显示隐藏的元素，这个属性能够极大地提高渲\n   染性能。\n\n\ncontent-visibility: auto 跳过渲染工作#\n\n我们仔细想想，页面上虽然会有很多元素，但是它们会同时呈现在用户眼前吗？很显然是不会的。\n\n用户每次能够真实看到就只有设备可见区那些内容，对于非可见区的内容只要页面不发生滚动，用户就永远看不到。虽然用户看不到，但浏览器却会实实在在的去渲染，以至于浪费大\n量的性能。所以我们得想办法让浏览器不渲染非可视区的内容就能够达到提高页面渲染性能的效果。\n\n此时就可以直接使用 content-visibility: auto 它可以用来跳过屏幕外的内容渲染，对于这种有大量离屏内容的长列表，可以大大减少页面渲染时间。\n\n首先是没有添加content-visibility: auto的效果，无论这些元素是否在可视区，都会被渲染\n\n\ncontain-intrinsic-size 救场#\n\n页面在滚动过程中滚动条一直抖动，这是一个不能接受的体验问题，为了更好地实现content-visibility，浏览器需要应用size containment\n以确保内容的渲染结果不会以任何方式影响元素的大小。 这意味着该元素将像空的一样布局。如果元素没有在常规块布局中指定的高度，那么它将是0高度。\n\n这个时候我们可以使用contain-intrinsic-size来指定的元素自然大小，确保我们未渲染子元素的 div 仍然占据空间，同时也保留延迟渲染的好处。\n\n我们只需要给添加了content-visibility:auto的元素添加上contain-intrinsic-size就能够解决滚动条抖动的问题。\n当然，这个高度约接近真实渲染的高度，效果会越好，如果实在无法知道准确的高度，我们也可以给一个大概的值，也会使滚动条的问题相对减少。","routePath":"/notes/CSS/longlist","lang":"","toc":[{"text":"content-visibility","id":"content-visibility","depth":2,"charIndex":99},{"text":"content-visibility: hidden手动管理可见性","id":"content-visibility-hidden手动管理可见性","depth":2,"charIndex":451},{"text":"content-visibility: auto 跳过渲染工作","id":"content-visibility-auto-跳过渲染工作","depth":2,"charIndex":723},{"text":"contain-intrinsic-size 救场","id":"contain-intrinsic-size-救场","depth":2,"charIndex":1067}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"JS事件-beforeunload","content":"#\n\n\n用法#\n\n\n\nWARNING\n\n页面加载完成后，如果用户未对页面进行操作，比如“点击”、“输入”等等，onbeforeunload将不会被执行","routePath":"/notes/JS/beforeunload","lang":"","toc":[{"text":"用法","id":"用法","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"npm包打补丁","content":"#\n\n:::tip 参考地址：临时修改npm库 ::: 使用patch-package和postinstall-postinstall\n\n\n步骤#\n\n 1. 添加库 yarn add patch-package postinstall-postinstall -D\n 2. 修改文件 修改需要修改的文件\n 3. 创建布丁，package-name是修改的包名 npx patch-package package-name\n 4. package.json中scripts添加\n\n","routePath":"/notes/JS/buding","lang":"","toc":[{"text":"步骤","id":"步骤","depth":2,"charIndex":69}],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"宏任务、微任务、队列和计划","content":"#\n\nJS 执行顺序：\n运行js脚本，运行中发现宏任务，新建宏任务队列，发现微任务，新建微任务队列，执行完毕当前js脚本，如果有微任务，则运行所有当前宏任务列表中的微任务，运行完毕后，\n执行下一个宏任务，执行过程和js 脚本中的运行逻辑相同。\n\n知识点：promise中的then回调函数 会加入到当前宏任务的微任务列表中","routePath":"/notes/JS/hwdj","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"Commonjs、CMD、ESM和AMD","content":"#\n\n模块化的开发方式可以提供代码复用率，方便进行代码的管理。通常来说，一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有C\nommonJS、AMD、CMD以及ES6的模块系统。\n\n\nCommonJS#\n\nNodeJS是CommonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使\n用时，用module.exports 定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。\n\n\n\nCommonJS用同步的方式加载模块。在服务端，模块文件都存放在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步\n加载。\n\nexports和module.export区别：\n * exports：对于本身来讲是一个变量（对象），它不是module的引用，它是{}的引用，它指向module.exports的{}模块。只能使用.语法\n   向外暴露变量。\n * module.exports：module是一个变量，指向一块内存，exports是module中的一个属性，存储在内存中，然后exports属性指向{}\n   模块。既可以使用.语法，也可以使用=直接赋值。\n\n\nAMD和require.js#\n\nAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介\n绍用require.js实现AMD规范的模块化：用require.config() 指定引用路径等，用definde()定义模块，用require()加载模块。\n\n首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。\n\n\n\n引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一\n参数。\n\n\n\n\nCMD和sea.js#\n\nCMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生\n的。\n\n\n\n\nES6 Module#\n\nES6\n在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。ex\nport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n\n\nES6 模块的特征：\n * 严格模式：ES6 的模块自动采用严格模式\n * import read-only特性： import的属性是只读的，不能赋值，类似于const的特性\n * export/import提升：\n   import/export必须位于模块顶级，不能位于作用域内；其次对于模块内的import/export会提升到模块顶部，这是在编译阶段完成的\n\n\nES6 模块与 CommonJS 模块的差异#\n\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n * CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n * ES6 模块的运行机制与 CommonJS 不一样。JS\n   引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话\n   说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6\n   模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口\n\n * 运行时加载: CommonJS模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n * 编译时加载:\n   ES6模块不是对象，而是通过export命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个\n   模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。\n\n首先看个CommonJS输出拷贝的例子：\n\n\n\n所谓输出拷贝，如果了解过 NodeJS 或者 webpack 对 CommonJS\n的实现（不了解可以看这篇文章），就会知道：exports对象是模块内外的唯一关联， CommonJS\n输出的内容，就是exports对象的属性，模块运行结束，属性就确定了。 再看ES6 Module输出的例子：\n\n\n\n以上就是 ES6 Module 输出引用和 CommonJS 输出值的区别，模块内部引用的变化，会反应在外部，这是 ES6 Module 的规范。\n\n\n总结#\n\n 1. AMD/CMD/CommonJs 是js模块化开发的规范，对应的实现是require.js/sea.js/Node.js\n\n 2. CommonJs 主要针对服务端，AMD/CMD/ES\n    Module主要针对浏览器端，容易混淆的是AMD/CMD。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就\n    是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提\n    前将所需要的模块文件并行加载好。）\n\n 3. AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个\n    模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。\n\n 4. AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。\n    AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。\n    AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。\n    CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。\n    CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。（\n    PS：重新看这篇文章，发现这里写的不是很准确。确切来说，JS是单线程，所有JS文件执行时间叠加在AMD和CMD中是一样的。但是CMD是使用时执行，没法利\n    用空闲时间，而AMD是文件加载好就执行，往往可以利用一些空闲时间。这么来看，CMD比AMD的优点还是很明显的，毕竟AMD加载好的时候也未必就是JS引擎的\n    空闲时间！）\n\n 5. CommonJS 和 ES Module 区别：CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n 6. 如何使用？CommonJs的话，因为NodeJS就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过script标签引入require.\n    js，CMD则是引入sea.js","routePath":"/notes/JS/modules","lang":"","toc":[{"text":"CommonJS","id":"commonjs","depth":2,"charIndex":112},{"text":"AMD和require.js","id":"amd和requirejs","depth":2,"charIndex":580},{"text":"CMD和sea.js","id":"cmd和seajs","depth":2,"charIndex":928},{"text":"ES6 Module","id":"es6-module","depth":2,"charIndex":1029},{"text":"ES6 模块与 CommonJS 模块的差异","id":"es6-模块与-commonjs-模块的差异","depth":2,"charIndex":1357},{"text":"总结","id":"总结","depth":2,"charIndex":2185}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"JS 预编译","content":"#\n\n预编译分为全局预编译和局部预编译，全局预编译发生在页面加载完成时执行，而局部预编译发生在函数执行的前一刻。\n\n\njs运行三步曲#\n\n 1. 语法分析\n 2. 预编译\n 3. 解释执行\n\n\n全局预编译过程#\n\n 1. 创建一个GO对象 --> Global Object\n 2. 找变量声明作为GO的属性名，并赋值为undefined；（若名称相同则写一个并赋值undefined）；\n 3. 找函数声明，赋值为函数体（若函数名与上面某个变量相等时，则用函数体覆盖）；\n\n\n函数预编译过程#\n\n 1. 创建一个AO对象 --> AO:执行期上下文 Activation Object\n 2. 找形参和变量声明，将变量名和形参名作为AO的属性名，并赋值为undefined；（若名称相同则写一个并赋值undefined）；\n 3. 将形参和实参统一（将实参值赋给AO中与形参相同的属性）；\n 4. 找函数声明，赋值为函数体（若函数名与上面某个变量相等时，则用函数体覆盖）；","routePath":"/notes/JS/pro-compile","lang":"","toc":[{"text":"js运行三步曲","id":"js运行三步曲","depth":2,"charIndex":58},{"text":"全局预编译过程","id":"全局预编译过程","depth":2,"charIndex":96},{"text":"函数预编译过程","id":"函数预编译过程","depth":2,"charIndex":238}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"一些常用的方法","content":"#\n\n\n防抖#\n\n\n\n\n节流#\n\n\n\n\n大小写转换#\n\n\n\n\n数组去重#\n\n\n\n\n存储操作#\n\n\n\n\n深拷贝#\n\n\n遍历#\n\n深度优先#\n\n\n\n广度优先#\n\n","routePath":"/notes/JS/usually-functions","lang":"","toc":[{"text":"防抖","id":"防抖","depth":3,"charIndex":3},{"text":"节流","id":"节流","depth":3,"charIndex":11},{"text":"大小写转换","id":"大小写转换","depth":3,"charIndex":19},{"text":"数组去重","id":"数组去重","depth":3,"charIndex":30},{"text":"存储操作","id":"存储操作","depth":3,"charIndex":40},{"text":"深拷贝","id":"深拷贝","depth":3,"charIndex":50},{"text":"遍历","id":"遍历","depth":3,"charIndex":57},{"text":"深度优先","id":"深度优先","depth":4,"charIndex":62},{"text":"广度优先","id":"广度优先","depth":4,"charIndex":71}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"vue 项目性能优化","content":"#\n\n\n性能优化标准#\n\n既然说性能优化，那他总得有一个公认的标准，这就是我们很多次听到的Lighthouse\n\n\nLighthouse#\n\nlighthouse是 Google Chrome 推出的一款开源自动化工具，它可以搜集多个现代网页性能指标，分析 Web\n应用的性能并生成报告，为开发人员进行性能优化的提供了参考方向。说起Lighthouse在现代的谷歌浏览器中业已经集成\n\n他可以通过几个指标分析出我们的页面性能:\n\n * 首次内容绘制（First Contentful Paint）。即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。\n * 可交互时间（Time to Interactive）。指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。\n * 速度指标（Speed\n   Index）。衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。\n * 总阻塞时间（Total Blocking Time）。指First Contentful Paint 首次内容绘制 (FCP)与Time to\n   Interactive 可交互时间 (TTI)之间的总时间\n * 最大内容绘制（Largest Contentful Paint）。度量标准报告视口内可见的最大图像或文本块的呈现时间\n * 累积布局偏移（# Cumulative Layout\n   Shift）。衡量的是页面整个生命周期中每次元素发生的非预期布局偏移得分的总和。每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了LS（Layout\n   Shift）。\n\n提示\n\n在一般情况下，由于性能监控平台的和本地平台的差异，本地可能要达到70分，线上才有可能达到及格的状态,如果有性能优化的需求时，大家酌情处理即可\n\n\n通用常规优化手段#\n\nlighthouse的的牛x之处就是它能找出你页面中的一些常规的性能瓶颈，并提出优化建议，比如：\n\n于是针对这些优化建议，我们需要做一些常规的优化：\n\n * 修改被延迟图片的加载时机.\n * 设置明确的图片大小.\n * 精简DOM结构.\n * 提供较小的 JS 载荷减少为解析、编译和执行 JS 而花费的时间。\n\n\n通用性能优化分析#\n\n我们知道lighthouse 中有六个性能指标，而在这六个指标中，LCP、 FCP、speed index、 这三个指数尤为重要，因为在一般情况下\n这个三个指标会影响 TTI、TBT、CLS 的分数\n\n\nFCP（First Contentful Paint）#\n\n顾名思义就是首次内容绘制，也就是页面最开始绘制内容的时间，但是由于我们现在开发的页面都是spa应用，所以，框架层面的初始化是一定会有一定的性能损耗的，以vue-\ncli 搭建的脚手架为例，当我初始化空的脚手架，打包后上传cdn部署，FCP 就会从0.8s提上到1.5秒，由此可见vue 的diff\n也不是免费的他也会有性能上的损耗\n\n在优化页面的内容之前我们声明三个前提:\n\n 1. 提高FCP的时间其实就是在优化关键渲染路径\n\n 2. 如果它是一个样式文件（CSS文件），浏览器就必须在渲染页面之前完全解析它（这就是为什么说CSS具有渲染阻碍性）\n\n 3. 如果它是一个脚本文件（JavaScript文件），浏览器必须：停止解析，下载脚本，并运行它。只有在这之后，它才能继续解析，因为 JavaScript\n    脚本可以改变页面内容（特别是HTML）。（这就是为什么说JavaScript阻塞解析）\n\n针对以上的用例测试，我们发现，无论我们怎么优化，框架本身的性能损耗是无法抹除的，我们唯一能做的就是让框架更早的去执行初始化，并且初始化更少的内容，可做的优化手段\n如下：\n\n 1. 所有初始化用不到的js 文件全部走异步加载，也就是加上defer或者asnyc\n    ，并且一些需要走cdn的第三方插件需要放在页面底部（因为放在顶部，他的解析会阻止html 的解析，从而影响css 等文件的下载，这也是雅虎军规的一条）\n 2. js 文件拆包，以vue-cli 为例，一般情况下我们可以通过cli的配置 splitChunks\n    做代码分割，将一些第三方的包走cdn，或者拆包。如果有路由的情况下将路由做拆包处理，保证每个路由只加载当前路由对应的js代码\n 3. 优化文件大小 减少字体包、css文件、以及js文件的大小（当然这些 脚手架默认都已经做了）\n 4. 优化项目结构，每个组件的初始化都是有性能损耗的，在在保证可维护性的基础上，尽量减少初始化组件的加载数量\n 5. 网络协议层面的优化，这个优化手段需要服务端配合纯前端已经无法达到，在现在云服务器盛行的时代,自家单位一般都会默认在云服务器中开启这些优化手段，比如开启g\n    zip，使用cdn 等等\n\n其实说来说去，提高FCP 的核心只有理念之后两个减少初始化视图内容和减少初始化下载资源大小\n\n未完待续。。。","routePath":"/notes/JS/vue-webpack-optimize","lang":"","toc":[{"text":"性能优化标准","id":"性能优化标准","depth":2,"charIndex":3},{"text":"Lighthouse","id":"lighthouse","depth":3,"charIndex":57},{"text":"通用常规优化手段","id":"通用常规优化手段","depth":2,"charIndex":820},{"text":"通用性能优化分析","id":"通用性能优化分析","depth":2,"charIndex":989},{"text":"FCP（First Contentful Paint）","id":"fcpfirst-contentful-paint","depth":3,"charIndex":1102}],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"WEBPACK 常用优化技巧","content":"#\n\n\n分析打包数据#\n\n * friendly-errors-webpack-plugins 插件可以在打包过程中输出错误、警告等信息，并且可以生成一个包含打包数据的报告。\n * webpack-bundle-analyzer 插件可以生成一个包含打包数据的报告，并以可视化的方式展示出来。\n * speed-measure-webpack-plugin 插件可以测量各个插件和loader的耗时，从而帮助优化构建过程。\n * webpack-chart 插件可以生成一个包含打包数据的图表，从而帮助优化构建过程。\n * webpack-dashboard 插件可以生成一个包含打包数据的仪表盘，从而帮助优化构建过程。\n * webpack-visualizer 插件可以生成一个包含打包数据的可视化视图，从而帮助优化构建过程。\n\n\n构建时间优化#\n\n\nthread-loader#\n\n多进程打包，可以大大提高构建的速度，使用方法是将thread-loader放在比较费时间的loader之前，比如babel-loader\n\n建议\n\n由于启动项目和打包项目都需要加速，所以配置在webpack.base.js\n\n\n\n\n\n\ncache-loader#\n\n缓存资源，提高二次构建的速度，使用方法是将cache-loader放在比较费时间的loader之前，比如babel-loader\n\n建议\n\n由于启动项目和打包项目都需要加速，所以配置在webpack.base.js\n\n\n\n\n\n\n开启热更新#\n\n比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间\n\n建议\n\n只用于开发中，所以配置在webpack.dev.js。HMR模块中文文档\n\n全部配置参考\n\n\n\n其他代码和框架#\n\n社区还提供许多其他 loader 和示例，可以使 HMR 与各种框架和库平滑地进行交互……\n\n * React Hot Loader: 实时调整 react 组件。\n * Vue Loader: 此 loader 支持 vue 组件的 HMR，提供开箱即用体验。\n * Elm Hot webpack Loader: 支持 Elm 编程语言的 HMR。\n * Angular HMR: 没有必要使用 loader！直接修改 NgModule 主文件就够了，它可以完全控制 HMR API。\n * Svelte Loader: 此 loader 开箱即用地支持 Svelte 组件的热更新。\n\n\nexclude & include#\n\n * exclude：不需要处理的文件\n * include：需要处理的文件 合理设置这两个属性，可以大大提高构建速度\n\n建议\n\n由于启动项目和打包项目都需要加速，所以配置在webpack.base.js\n\n\n\n\n构建区分环境#\n\n区分环境去构建是非常重要的，我们要明确知道，开发环境时我们需要哪些配置，不需要哪些配置；而最终打包生产环境时又需要哪些配置，不需要哪些配置：\n\n * 开发环境：去除代码压缩、gzip、体积分析等优化的配置，大大提高构建速度\n * 生产环境：需要代码压缩、gzip、体积分析等优化的配置，大大降低最终项目打包体积\n\n\n提升webpack版本#\n\nwebpack版本越新，打包的效果肯定更好\n\n\n打包体积优化#\n\n\nCSS代码压缩#\n\nCSS代码压缩使用css-minimizer-webpack-plugin，效果包括压缩、去重\n\n建议\n\n代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在webpack.prod.js中配置\n\n\n\n\n\n\nJS代码压缩#\n\nJS代码压缩使用terser-webpack-plugin，实现打包后JS代码的压缩\n\n建议\n\n代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在webpack.prod.js中配置\n\n\n\n\n\n\ntree-shaking#\n\ntree-shaking简单说作用就是：只打包用到的代码，没用到的代码不打包，而webpack5默认开启tree-shaking，当打包的mode为produc\ntion时，自动开启tree-shaking进行优化.\n\n\nsource-map类型#\n\nsource-map的作用是：方便你报错的时候能定位到错误代码的位置。它的体积不容小觑，所以对于不同环境设置不同的类型是很有必要的。\n\n * 开发环境\n\n开发环境的时候我们需要能精准定位错误代码的位置\n\n\n\n * 生产环境\n   \n   生产环境，我们想开启source-map，但是又不想体积太大，那么可以换一种类型\n\n\n\n\n打包体积分析#\n\n使用webpack-bundle-analyzer可以审查打包后的体积分布，进而进行相应的体积优化 :::tip 建议\n代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在webpack.prod.js中配置 :::\n\n\n\n\n\n\n用户体验优化#\n\n模块懒加载 如果不进行模块懒加载\n的话，最后整个项目代码都会被打包到一个js文件里，单个js文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用模块懒加载\n之后，大js文件会分成多个小js文件，网页加载时会按需加载，大大提升首屏加载速度\n\n\n\n\nGzip#\n\n开启Gzip后，大大提高用户的页面加载速度，因为gzip的体积比原文件小很多，当然需要后端的配合，使用compression-webpack-plugin\n:::tip 建议 代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在webpack.prod.js中配置 :::\n\n\n\n\n\n\n小图片转base64#\n\n对于一些小图片，可以转 ，这样可以减少用户的http网络请求次数，提高用户的体验。webpack5中url-loader已被废弃，改用asset-module\n\n建议\n\n在webpack.base.js中配置\n\n\n\n\n合理配置hash#\n\n我们要保证，改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的\n目的\n\n建议\n\n在webpack.base.js中配置\n\n","routePath":"/notes/JS/webpack-optimize","lang":"","toc":[{"text":"分析打包数据","id":"分析打包数据","depth":2,"charIndex":3},{"text":"构建时间优化","id":"构建时间优化","depth":2,"charIndex":367},{"text":"thread-loader","id":"thread-loader","depth":3,"charIndex":377},{"text":"cache-loader","id":"cache-loader","depth":3,"charIndex":511},{"text":"开启热更新","id":"开启热更新","depth":3,"charIndex":640},{"text":"其他代码和框架","id":"其他代码和框架","depth":4,"charIndex":771},{"text":"exclude & include","id":"exclude--include","depth":3,"charIndex":1078},{"text":"构建区分环境","id":"构建区分环境","depth":3,"charIndex":1205},{"text":"提升webpack版本","id":"提升webpack版本","depth":3,"charIndex":1372},{"text":"打包体积优化","id":"打包体积优化","depth":2,"charIndex":1410},{"text":"CSS代码压缩","id":"css代码压缩","depth":3,"charIndex":1420},{"text":"JS代码压缩","id":"js代码压缩","depth":3,"charIndex":1536},{"text":"tree-shaking","id":"tree-shaking","depth":3,"charIndex":1646},{"text":"source-map类型","id":"source-map类型","depth":3,"charIndex":1772},{"text":"打包体积分析","id":"打包体积分析","depth":3,"charIndex":1951},{"text":"用户体验优化","id":"用户体验优化","depth":2,"charIndex":2077},{"text":"Gzip","id":"gzip","depth":3,"charIndex":2217},{"text":"小图片转base64","id":"小图片转base64","depth":3,"charIndex":2369},{"text":"合理配置hash","id":"合理配置hash","depth":3,"charIndex":2491}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"跨域","content":"#\n\n当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 :::tip\n出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能\n都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互\n。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。 :::\n\n\n非同源限制#\n\n * 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB\n * 无法接触非同源网页的 DOM\n * 无法向非同源地址发送 AJAX 请求\n\n\n如何实现跨域请求#\n\n\njsonp#\n\nJSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript\ncallback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。 利用了 script 不受同源策略的限制，实现了跨域请求\n\n缺点：只能 get 方式，易受到 XSS攻击\n\n\nCORS（Cross-Origin Resource Sharing）,跨域资源共享#\n\n当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；\n\n后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；\n\n浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错\n\n缺点：忽略 cookie，浏览器版本有一定要求\n\n\n代理跨域请求#\n\n前端向发送请求，经过代理，请求需要的服务器资源\n\n缺点：需要额外的代理服务器\n\n\nHtml5 postMessage 方法#\n\n允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递\n\n缺点：浏览器版本要求，部分浏览器要配置放开跨域限制\n\n\n修改 document.domain 跨子域#\n\n相同主域名下的不同子域名资源，设置 document.domain 为 相同的一级域名\n\n缺点：只能是同一一级域名；相同协议；相同端口\n\n\n基于 Html5 websocket 协议#\n\nwebsocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求\n\n缺点：浏览器一定版本要求，服务器需要支持 websocket 协议\n\n\ndocument.xxx + iframe#\n\n通过 iframe 是浏览器非同源标签，加载内容中转，传到当前页面的属性中\n\n缺点：页面的属性值有大小限制\n\n\n前端常用代理#\n\n\nwebpack#\n\n\n\n\nvite#\n\n","routePath":"/notes/browser/kuayu","lang":"","toc":[{"text":"非同源限制","id":"非同源限制","depth":2,"charIndex":276},{"text":"如何实现跨域请求","id":"如何实现跨域请求","depth":2,"charIndex":372},{"text":"jsonp","id":"jsonp","depth":3,"charIndex":384},{"text":"CORS（Cross-Origin Resource Sharing）,跨域资源共享","id":"corscross-origin-resource-sharing跨域资源共享","depth":3,"charIndex":563},{"text":"代理跨域请求","id":"代理跨域请求","depth":3,"charIndex":833},{"text":"Html5 postMessage 方法","id":"html5-postmessage-方法","depth":3,"charIndex":883},{"text":"修改 document.domain 跨子域","id":"修改-documentdomain-跨子域","depth":3,"charIndex":978},{"text":"基于 Html5 websocket 协议","id":"基于-html5-websocket-协议","depth":3,"charIndex":1073},{"text":"document.xxx + iframe","id":"documentxxx--iframe","depth":3,"charIndex":1188},{"text":"前端常用代理","id":"前端常用代理","depth":2,"charIndex":1268},{"text":"webpack","id":"webpack","depth":3,"charIndex":1278},{"text":"vite","id":"vite","depth":3,"charIndex":1291}],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"回流和重绘","content":"#\n\n\n浏览器渲染机制#\n\n浏览器采用流式布局模型（Flow Based Layout） 浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM\n合并就 产生了渲染树（Render Tree）。 有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大\n小和位置，最后把节点绘制到页面上。 由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完 成，但 table\n及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同 等元素的时间，这也是为什么要避免使用 table 布局的原因之一。\n\n\n重绘#\n\n由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为 重绘，例如 outline, visibility,\ncolor、background-color 等，重绘的代价是高昂的， 因为浏览器必须验证 DOM 树上其他节点元素的可见性。\n\n\n回流#\n\n回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键 因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的\n回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素 的随后的回流。\n\nTIP\n\n回流必定会发生重绘，重绘不一定会引发回流。\n\n\n优化#\n\n浏览器优化#\n\n现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在 队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你获取布局信\n息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏 览器也会强制清空队列，触发回流与重绘来确保返回正确的值。\n\n主要包括以下属性或方法：\n\n * offsetTop、offsetLeft、offsetWidth、offsetHeight\n * scrollTop、scrollLeft、scrollWidth、scrollHeight\n * clientTop、clientLeft、clientWidth、clientHeight\n * width、height\n * getComputedStyle()\n * getBoundingClientRect()\n\n所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。\n\n减少重绘与回流#\n\nCSS#\n\n1、使用 transform 替代 top 2、使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回\n流（改变了布局 3、避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。 4、尽可能在 DOM 树的最末端改变\nclass，回流是不可避免的，但可以减少其影 响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响 尽可能少的节点。\n5、避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。\n\nJavaScript#\n\n1、避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。 2、避免频繁操作 DOM，创建一个\ndocument Fragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。\n3、避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个 变量缓存起来。 4、对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素\n及后续元素频繁回流。","routePath":"/notes/browser/layout","lang":"","toc":[{"text":"浏览器渲染机制","id":"浏览器渲染机制","depth":3,"charIndex":3},{"text":"重绘","id":"重绘","depth":3,"charIndex":295},{"text":"回流","id":"回流","depth":3,"charIndex":428},{"text":"优化","id":"优化","depth":3,"charIndex":578},{"text":"浏览器优化","id":"浏览器优化","depth":4,"charIndex":583},{"text":"减少重绘与回流","id":"减少重绘与回流","depth":4,"charIndex":992}],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"浏览器刷新过程","content":"#\n\n浏览器刷新做的只是重新加载网页数据【强制刷新的区别只是不使用浏览器缓存下来的HTML、JS数据，所有本页面用到的HTML、JS都需要重新向服务器获取】，并重新解\n析生成 DOM 树，当然还同时会重新解释执行 JavaScript 代码，之后重新绘制页面，注册绑定事件，之前页面在活动的时候对 JavaScript\n变量做的数据赋值数据都会消失。\n\n\n相关浏览器事件#\n\n * onbeforeunload：浏览器的刷新和关闭之前执行的方法\n * onunload：已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。\n * onload：资源已加载时被触发。","routePath":"/notes/browser/refresh","lang":"","toc":[{"text":"相关浏览器事件","id":"相关浏览器事件","depth":3,"charIndex":177}],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"路由","content":"#\n\nURL到函数的映射。路由的映射函数通常是进行一些DOM的显示隐藏操作。当访问不同路径时，就会显示不同的页面组件。\n\n优点：访问不同页面时，仅仅只是变换了路径而已，没有网络延迟，提升了用户体验。\n\n缺点：使用浏览器的前进后退时，会重新发送请求，没有合理的利用缓存，不利于SEO。\n\n\n前端路由两种主要实现方案#\n\n * hash：hash实现就是基于location.hash来实现的，早期前端路由都是用hash。location.hash的值就是URL中#后面的内容。\n * history API：更美观的实现URL的变化，由H5提供的history\n   API。最主要的API：history.pushState()、history.replaceState()。这两个API可以在不刷新的情况下，操作浏览器\n   的历史记录。区别：pushState()是会增加新的历史记录，而replaceState()是替换当前的历史记录。都接受三个参数（state，title，\n   URL）。\n\n\nhash和history的区别#\n\nHASH                          HISTORY\n兼容更好                          更正式美观\n只修改#后面内容                      可以设置同源下任意URL\n新值不能与旧值相同，一样的不会触发动作将记录添加到栈中   新旧值可以相同，pushSate该添加的会添加到栈中\n对服务器无需改动                      刷新时，若服务器没有响应数据或资源，会404。需要对服务器做一些改造，对不同的路由进行相应的设置。\n更改时不会发送请求                     会向服务器发送请求，避免404服务器应该做处理。当匹配不到资源时，应返回同一个html页面","routePath":"/notes/browser/route","lang":"","toc":[{"text":"前端路由两种主要实现方案","id":"前端路由两种主要实现方案","depth":2,"charIndex":143},{"text":"hash和history的区别","id":"hash和history的区别","depth":2,"charIndex":452}],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"本地储存","content":"#\n\nSessionStorage 和 LocalStorage 使用操作基本类似，两者最主要的区别在于生命周期不同。\n\nSessionStorage 顾名思义就是存在与会话阶段，当会话结束时，SessionStorage 存储的数据即会失效。\n当前标签页关闭，即代表当前会话结束，当前页面的sessionStorage就会清空。而刷新和强制刷新并不会对sessionStorage产生影响。\n\n相比之下 LocalStorage 生命周期就很长了，LocalStorage\n是可以一直存活的，哪怕是你关闭浏览器，他依然存在。除非人为手动删除，所以我们可以将一些需要永久性存储的数据放置在 LocalStorage 中。","routePath":"/notes/browser/storage","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"XMLHttpRequest,fetch和axios","content":"#\n\n\nXMLHttpRequest#\n\n属性或方法                说明\nonreadystatechange   方法，当readyState属性发生变化时触发\nreadyState           一个短整型数字，代表请求的状态码\nresponse             返回响应体\nresponseText         返回DOMString，是一个响应文本，包含请求的响应。失败时是null\nresponseType         响应的类型\nstatus               代表响应的状态，即浏览器状态码\nstatusText           响应状态文本\ntimeout              请求的最大请求时间\nupload               代表上传进度\nabort                方法，用于中止请求\nopen                 方法，初始化请求。只能在js代码中使用，如果在native code中初始化，请使用openRequest（）\nsend                 方法，发送请求\nsetRequestHeader     方法，设置请求头，必须在open和send之间进行设置\n                     \n\nreadyState说明\n\n值   状态                 描述\n0   UNSENT             代理被创建，但尚未调用 open() 方法。\n1   OPENED             open() 方法已经被调用。\n2   HEADERS_RECEIVED   send() 方法已经被调用，并且头部和状态已经可获得。\n3   LOADING            下载中； responseText 属性已经包含部分数据。\n4   DONE               下载操作已完成。\n\n实现一个简单的ajax\n\n\n\n实现一个简单的fetch\n\n\n\n从url到页面渲染的全过程\n\n 1. DNS域名接续\n    \n    DNS服务器解析域名，获取ip地址\n\n 2. 三次握手\n    \n    进行tcp连接\n    \n    第一次：客户端给服务端发送一个SYN报文，并指定初始化序列号。服务端收到时会得到客户端的发送能力和服务端的接受能力正常的结论\n    \n    第二次：服务端收到报文后回应答一个报文给客户端。客户端收到后，会得到服务端的发送能力，接受能力 客户端的接受能力正常。\n    \n    第三次：客户端再次发送一个报文。服务端收到后确认客户端的接受能力正常\n    \n    三次握手目的：确认客户端和服务端确认对方的发送和接受能力是否正常\n\n 3. 浏览器发送http请求\n\n 4. 服务器处理http请求\n\n 5. 浏览器解析并渲染界面\n    \n    1. 解析html，构建DOM树\n    2. 解析css，生成css规则树\n    3. 合并DOM树和CSS规则，生成render树\n    4. 布局render树，进行各元素的尺寸位置的计算\n    5. 回值render树，回值页面像素信息\n\n 6. 断开连接 4次挥手","routePath":"/notes/browser/xmlhttprequest","lang":"","toc":[{"text":"XMLHttpRequest","id":"xmlhttprequest","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"在linux上安装node","content":"#\n\n\n解压缩方式#\n\n 1. 下载node安装包。Linux 二进制文件 (x64) v16.15.0\n 2. 将安装包复制到linux上。\n 3. 解压安装包\n\n\n\n 4. 建立软连接\n\n\n\n\n常用linux命令#\n\n\n压缩文件#\n\n\n\n\n查看文件夹#\n\n\n\n\n修改环境变量#\n\n","routePath":"/notes/node/linuxinstallnode","lang":"","toc":[{"text":"解压缩方式","id":"解压缩方式","depth":2,"charIndex":3},{"text":"常用linux命令","id":"常用linux命令","depth":2,"charIndex":98},{"text":"压缩文件","id":"压缩文件","depth":3,"charIndex":111},{"text":"查看文件夹","id":"查看文件夹","depth":3,"charIndex":121},{"text":"修改环境变量","id":"修改环境变量","depth":3,"charIndex":132}],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"node 常用命令","content":"#\n\n\nnrm#\n\n\n\n\nnpx#\n\nnpx 的一个重要的特性是，无需先安装命令即可运行命令。","routePath":"/notes/node/node","lang":"","toc":[{"text":"nrm","id":"nrm","depth":2,"charIndex":3},{"text":"npx","id":"npx","depth":2,"charIndex":12}],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"1 概述","content":"#\n\n\n1.1 简介#\n\n> 概念\n\nElasticsearch(简称ES)，是一个分布式、RESTful风格的搜索和数据分析引擎。\n\n> 优点\n\n * 查询和分析：可以自定义搜索方式，分析大规模数据\n * 查询速度快\n * 可扩展性强：可以实现水平扩展，能够自动管理索引和查询在集群中的分布方式\n * 查询结果具有内容相关度：可以对搜索结果进行排序，以优化向用户显示结果的方式\n * 具有弹性设计：ES可以检测硬件故障等相关故障，确保集群和数据的安全性和可用性\n\n\n1.2 全文搜索引擎#\n\n> 工作原理\n\n计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置。当用户查询时，检索程序就根据实现建立的索引进行查找，并将查找结\n果反馈给用户。这个过程类似于通过字典中的检索字表查字的过程。\n\n\n1.3 Lucene介绍#\n\nLucene是Apache软件基金会Jakarta项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够全文索引和搜寻，是一个成熟的免费的开源工具。Luc\nene只是提供一个全文搜索功能类库的核心工具包。\n\n目前市面上流行的搜索引擎软件，主要有两个：Elasticsearch和Solr。二者都是基于Lucene搭建的，可以独立部署启动的搜素引擎软件服务。\n\n> Elasticsearch VS Solr\n\n * 当单纯的对已有数据进行搜索时，Solr更快；\n * 当实时建立索引时，Solr会产生io阻塞，查询性能较差，Elasticsearch具有明显的优势。\n * 随着数据的增加，Solr的效率会变得更低\n\n\n1.4 倒排索引#\n\n\n\n> 正排索引 VS 倒排索引\n\n * 正排索引：根据id查记录\n * 倒排索引：根据记录的分词找id，再根据id返回整条记录\n\n> 倒排索引步骤\n\n * 根据词条进行分析，同时记录文档索引位置\n * 将词条相同的数据进行合并\n * 对词条进行排序\n\n> 搜索过程\n\n先将搜索词语进行分词，分词后在倒排索引列表查询文档位置（docId），然后根据docId查询文档数据。","routePath":"/tang/Elasticsearch/01_Elasticsearch概述","lang":"","toc":[{"text":"1.1 简介","id":"11-简介","depth":2,"charIndex":3},{"text":"1.2 全文搜索引擎","id":"12-全文搜索引擎","depth":2,"charIndex":233},{"text":"1.3 Lucene介绍","id":"13-lucene介绍","depth":2,"charIndex":368},{"text":"1.4 倒排索引","id":"14-倒排索引","depth":2,"charIndex":696}],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"2 ES相关工具的安装与使用","content":"#\n\n\n2.1 Elasticsearch：7.8.0#\n\n * 解压即可使用。\n\n * 可以在config/jvm.options修改虚拟机配置：在22行和23行改成“512m”\n\n * 双击bin/elasticsearch.bat即可完成启动\n\n * 通过 http://localhost:9200 进行访问测试\n\n\n2.2 Kibana：7.8.0#\n\nKibana是Elastic · stack官方提供的客户端，有自动补全的代码提示功能。\n\n * 解压即可使用。\n * 修改配置文件config/kibana.yml：\n * 使用cmd命令行启动：\n * 通过 http://localhost:5601 访问测试：\n * 使用：\n\n\n2.3 安装ik分词器：7.8.0#\n\n下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.8.0\n/elasticsearch-analysis-ik-7.8.0.zip\n\n * 安装：将压缩包复制到es安装路径下的plugins文件夹下，解压，并将文件夹名称改为“ik”，最后删除压缩包，如下：\n\n * 重启es和kibana\n\n * 测试：","routePath":"/tang/Elasticsearch/02_Elasticsearch相关工具的安装与使用","lang":"","toc":[{"text":"2.1 Elasticsearch：7.8.0","id":"21-elasticsearch780","depth":2,"charIndex":3},{"text":"2.2 Kibana：7.8.0","id":"22-kibana780","depth":2,"charIndex":162},{"text":"2.3 安装ik分词器：7.8.0","id":"23-安装ik分词器780","depth":2,"charIndex":324}],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"3 核心概念","content":"#\n\n\n3.1 ES VS MySQL#\n\n\n\n其中，Index可以看做一个库，Types相当于表，Documents相当于表的行。但是Types的概念已被逐渐弱化，ES6.X中，一个index下已经只能包含\n一个type，ES7.X中Types中的概念已被删除。\n\n\n3.2 索引（库） Index#\n\n一个索引就是一个拥有几分相似特征的文档的集合\n\n\n3.3 类型 Type#\n\n在7.x中默认不再支持自定义索引类型，默认类型为_doc\n\n\n3.4 文档 Document#\n\n一个文档是一个可被索引的基础信息单元，也就是一条数据。\n\n文档以JSON格式来存储。\n\n在一个index/type中可以存放任意多个文档。\n\n\n3.5 字段 Field#\n\n相当于数据表的字段，对文档数据根据不同属性进行的分类标识。\n\n\n3.6 映射 Mapping#\n\nmapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是都被索引等。\n\n可以类比于MySQL创建表字段时，给字段添加的约束。","routePath":"/tang/Elasticsearch/03_Elasticsearch核心概念","lang":"","toc":[{"text":"3.1 ES VS MySQL","id":"31-es-vs-mysql","depth":2,"charIndex":3},{"text":"3.2 索引（库） Index","id":"32-索引库-index","depth":2,"charIndex":134},{"text":"3.3 类型 Type","id":"33-类型-type","depth":2,"charIndex":177},{"text":"3.4 文档 Document","id":"34-文档-document","depth":2,"charIndex":222},{"text":"3.5 字段 Field","id":"35-字段-field","depth":2,"charIndex":312},{"text":"3.6 映射 Mapping","id":"36-映射-mapping","depth":2,"charIndex":359}],"domain":"","frontmatter":{},"version":""},{"id":90,"title":"4 es基本操作","content":"#\n\n\n4.1 分词器#\n\n常用的是ik中文分词器。\n\n\n4.2 索引操作#\n\n\n4.2.1 创建索引#\n\n> 直接指定索引名\n\n\n\n\n\n> 指定主副分片数\n\n分片只有在集群中才有效果，且主副分片分布在不同节点中。\n\n\n\n\n\n\n4.2.2 查看索引#\n\n> 查看所有索引\n\n\n\n\n\n> 查单个索引\n\n\n\n\n\n\n4.2.3 删除索引#\n\n\n\n\n\n\n4.3 文档操作#\n\n\n4.3.1 创建文档#\n\n\n\n\n\n\n4.3.2 查看文档#\n\n\n\n\n\n\n4.3.3 修改文档#\n\n\n\n\n\n\n4.3.4 修改局部属性#\n\n\n\n\n\n\n4.3.5 删除文档#\n\n\n\n\n\n注意：\n\n * 删除后，调用文档查看接口，返回的found值为false\n * 调用查询所有索引接口，可看到当前索引下的文档数为1。\n * 以上说明，执行删除文档操作后，es并没有立刻将数据删除。\n\n\n4.3.6 批量操作#\n\n\n\n注意：以上单个json对象不允许换行\n\n> 批量添加\n\n\n\n> 批量删除\n\n\n\n\n4.4 映射#\n\n> 概念\n\n有了索引，就相当于有了数据库中的database。\n\n索引库中的映射，类似于database中的表结构（table）。创建数据库表需要设置字段名称、类型、长度、约束等，索引库也一样，需要知道这个类型下有哪些字段，每\n个字段都有哪些约束信息，这就叫做映射。\n\n映射是可以自动创建的。 在向文档中插入第一条数据的时候，默认创建映射。\n\n\n4.4.1 查看映射#\n\n\n\n\n\n\n4.4.2 动态映射#\n\n> 概念\n\n映射是可以自动创建的。在文档写入ES时，会根据文档字段自动识别类型，这种机制被称为动态映射。\n\n> 映射规则对应\n\n数据           对应类型\nnull         字段不添加\ntrue或false   boolean\n字符串          text\n数值           long\n小数           float\n日期           date\n\n> 注意\n\n很少有使用动态映射的\n\n\n4.4.3 静态映射#\n\n> 概念\n\n静态映射是指在ES中事先定义好映射，即手动映射，包含文档的各终端类型、分词器等，这就是静态映射。\n\n一般都会选择使用静态映射。\n\n> 创建映射举例\n\n\n\n> 说明：type分类如下\n\n * 字符串类型：text（支持分词）、keyword（不支持分词）\n   * text：字符串类型。该类型被用来索引长文本，在创建索引前就会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来\n     排序和聚合。\n   * keyword：字符串类型。该类型不能分词，可以被用来检索过滤、排序和聚合。keyword不可用text进行分词模糊检索。\n * 数值型：long、integer、short、byte、double、float\n * 日期型：date\n * 布尔型：boolean","routePath":"/tang/Elasticsearch/04_Elasticsearch基本操作","lang":"","toc":[{"text":"4.1 分词器","id":"41-分词器","depth":2,"charIndex":3},{"text":"4.2 索引操作","id":"42-索引操作","depth":2,"charIndex":28},{"text":"4.2.1 创建索引","id":"421-创建索引","depth":3,"charIndex":40},{"text":"4.2.2 查看索引","id":"422-查看索引","depth":3,"charIndex":113},{"text":"4.2.3 删除索引","id":"423-删除索引","depth":3,"charIndex":154},{"text":"4.3 文档操作","id":"43-文档操作","depth":2,"charIndex":172},{"text":"4.3.1 创建文档","id":"431-创建文档","depth":3,"charIndex":184},{"text":"4.3.2 查看文档","id":"432-查看文档","depth":3,"charIndex":202},{"text":"4.3.3 修改文档","id":"433-修改文档","depth":3,"charIndex":220},{"text":"4.3.4 修改局部属性","id":"434-修改局部属性","depth":3,"charIndex":238},{"text":"4.3.5 删除文档","id":"435-删除文档","depth":3,"charIndex":258},{"text":"4.3.6 批量操作","id":"436-批量操作","depth":3,"charIndex":376},{"text":"4.4 映射","id":"44-映射","depth":2,"charIndex":432},{"text":"4.4.1 查看映射","id":"441-查看映射","depth":3,"charIndex":614},{"text":"4.4.2 动态映射","id":"442-动态映射","depth":3,"charIndex":632},{"text":"4.4.3 静态映射","id":"443-静态映射","depth":3,"charIndex":860}],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"5 DSL高级查询","content":"#\n\n\n5.1 DSL 概述#\n\n> 定义\n\nQuery DSL概述：领域专用语言，es提供了基于JSON的DSL来定义查询。即ES专用查询语句。\n\n> 关键字概览\n\n\n\n> 准备数据\n\n\n\n\n5.2 DSL使用-单条件查询#\n\n\n5.2.1 查询所有（match_all）#\n\n\n\n或\n\n\n\n\n5.2.2 匹配查询（match）#\n\n\n\n\n\n\n5.2.3 补充：条件删除#\n\n将查询到的记录删除\n\n\n\n\n5.2.4 多字段匹配#\n\n\n\n\n\n\n5.2.5 前缀匹配#\n\n> 概念\n\n前缀匹配是说，在分词结果中，如果某个分词的前缀和要查询的信息一样，就会将该记录返回。\n\n比如，“华为手机”的分词结果是[“华为”、“手机”]。当使用前缀查询输入的查询信息是“手机”或者“手”等时，会将该记录返回；当输入的查询信息是“机”时，该记录无\n法返回。\n\n\n\n\n\n\n5.2.6 关键字精确查询（term）#\n\n> term\n\n查询信息不会进行分词\n\n\n\n\n\n\n5.2.7 多关键字精确查询（terms）#\n\n\n\n\n\n\n5.2.8 范围查询（range）#\n\n> range\n\n * gte：大于等于\n * lte：小于等于\n * gt：大于\n * lt：小于\n\n\n\n\n\n\n5.2.9 指定返回字段#\n\nquery同级增加_source进行过滤。\n\n\n\n\n\n\n5.3 DSL使用-组合条件查询#\n\n> 语法\n\nbool各条件之间都有and、or或no的关系。\n\n * must：各个条件都必须满足，即所有条件是and关系\n * should：各个条件有一个满足即可，即各条件是or关系\n * must_not：不满足所有条件，即各条件是no关系\n * filter：与must效果等同，但不计算得分，效率更高点\n * 如果must和should同时存在，会对must结果和should结果取交集\n\n\n5.3.1 must#\n\n\n\n\n\n\n5.3.2 should#\n\n\n\n\n\n\n5.3.3 must_not#\n\n很少用\n\n\n\n\n\n\n5.3.4 filter#\n\n不会计算分数。在不需要排名的时候才使用，效率比must快一些。\n\n\n\n\n\n\n5.4 DSL使用-聚合查询（指标聚合）#\n\n> 概念\n\n允许使用者对es文档进行统计分析，类似于关系型数据库中的group by。此外还有许多其他聚合查询，如取最大值、平均值等。\n\nes的聚合查询和MySQL的group by效率差不多，但是es的优点是它是分布式的。真正做数据分析的时候，还需要考虑具体情况：\n\n * 如果是非结构化的数据，如日志分析、用户行为分析，则考虑使用es的聚合查询\n * 如果是结构化数据，考虑使用关系型数据库\n\n> 指标聚合关键字\n\n * max 最大值\n * min 最小值\n * avg 平均值\n * sum 求和\n * stats 统计\n\n> 语法\n\n\n\n> 举例：max\n\n\n\n> 举例：stats\n\n\n\n\n5.5 DSL使用-聚合查询（桶聚合）#\n\n> 概念\n\n桶聚合相当于mysql的group by\n\n> 桶聚合关键字\n\n * terms\n\n\n5.5.1 桶聚合的基本使用#\n\n> 语法\n\n\n\n> 举例：terms基本使用\n\n\n\n\n5.5.2 桶聚合的下钻#\n\n对桶聚合还可以继续下钻，即桶聚合和指标聚合的组合使用\n\n> 语法\n\n\n\n","routePath":"/tang/Elasticsearch/05_Elasticsearch DSL高级查询","lang":"","toc":[{"text":"5.1 DSL 概述","id":"51-dsl-概述","depth":2,"charIndex":3},{"text":"5.2 DSL使用-单条件查询","id":"52-dsl使用-单条件查询","depth":2,"charIndex":96},{"text":"5.2.1 查询所有（match_all）","id":"521-查询所有match_all","depth":3,"charIndex":115},{"text":"5.2.2 匹配查询（match）","id":"522-匹配查询match","depth":3,"charIndex":147},{"text":"5.2.3 补充：条件删除","id":"523-补充条件删除","depth":3,"charIndex":172},{"text":"5.2.4 多字段匹配","id":"524-多字段匹配","depth":3,"charIndex":202},{"text":"5.2.5 前缀匹配","id":"525-前缀匹配","depth":3,"charIndex":221},{"text":"5.2.6 关键字精确查询（term）","id":"526-关键字精确查询term","depth":2,"charIndex":376},{"text":"5.2.7 多关键字精确查询（terms）","id":"527-多关键字精确查询terms","depth":3,"charIndex":423},{"text":"5.2.8 范围查询（range）","id":"528-范围查询range","depth":3,"charIndex":452},{"text":"5.2.9 指定返回字段","id":"529-指定返回字段","depth":3,"charIndex":529},{"text":"5.3 DSL使用-组合条件查询","id":"53-dsl使用-组合条件查询","depth":2,"charIndex":572},{"text":"5.3.1 must","id":"531-must","depth":3,"charIndex":792},{"text":"5.3.2 should","id":"532-should","depth":3,"charIndex":810},{"text":"5.3.3 must_not","id":"533-must_not","depth":3,"charIndex":830},{"text":"5.3.4 filter","id":"534-filter","depth":3,"charIndex":857},{"text":"5.4 DSL使用-聚合查询（指标聚合）","id":"54-dsl使用-聚合查询指标聚合","depth":2,"charIndex":910},{"text":"5.5 DSL使用-聚合查询（桶聚合）","id":"55-dsl使用-聚合查询桶聚合","depth":2,"charIndex":1234},{"text":"5.5.1 桶聚合的基本使用","id":"551-桶聚合的基本使用","depth":3,"charIndex":1305},{"text":"5.5.2 桶聚合的下钻","id":"552-桶聚合的下钻","depth":3,"charIndex":1349}],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"6 进阶查询","content":"#\n\n\n6.1 排序#\n\n> 关键字\n\nsort\n\n> 语法\n\n\n\n> 举例\n\n\n\n\n6.2 分页#\n\n\n6.2.1 from、size分页#\n\n> 关键字\n\n * from：起始索引值，默认从0开始。from = (pageNum - 1) * size\n * size：每页显示多少条\n\n> 语法\n\n\n\n> 举例\n\n\n\n\n6.2.2 scoll分页#\n\n> 概念\n\n滚动查询的意思是指如果获取的数据特别多，那我们可以分批获取数据。\n给服务器一个处理请求的时间，在该时间内，一次性查询出来所有满足条件的数据，保存到内存中，分批次进行获取。所以每次进行查询的时候都要传递一个系统的处理时间。类似于\n关系型数据库中的游标 。\n\n第一次查询：返回相关数据的同时，还是返回一个_scroll_id，该时间内，数据有变动不受影响。\n\n第n次查询（n>1）：在相关时间内，body体只传_scroll_id即可实现翻页效果\n\n> 关键字\n\n * scroll：指明服务器处理时间\n * size：每页显示多少条\n\n> 语法\n\n注意：两次查询接口不一样\n\n\n\n> 举例\n\n\n\n\n6.3 高亮#\n\n> 关键字\n\n * highlight\n * highlight.pre_tags：高亮前缀。\n * highlight.post_tags：高亮后缀。\n * highlight.fields：配置需要高亮的属性\n\n> 语法\n\n注意：highlight.fields中的字段必须是query中被检索的字段\n\n\n\n> 举例\n\n\n\n\n6.4 近似查询#\n\n简单了解，中文用不上。\n\n> 概念\n\n近似查询指的是返回包含与搜索字词相似的字词的文档。如百度搜索中，某个单词拼写错误，但是会返回正确单词对应的记录。\n\n对中文不适用，只适用于英文。\n\n编辑距离是将一个术语转换为另一个术语所需的一个字符更改的次数。这些更改可以包括：\n\n * 更改字符，如box改为fox\n * 删除字符，如black改为lack\n * 插入字符，如sic改为sick\n * 转置两个相邻字符，如act改为cat\n\n为了找到相似的术语，fuzzy会在指定的编辑距离内创建一组搜索词的所有可能的变体或扩展。然后查询返回每个扩展的完全匹配。\n通过fuzziness修改编辑距离，一般使用默认值AUTO，根据术语的长度生成编辑距离。\n\n> 关键字\n\n * fuzzy\n\n> 语法\n\n\n\n> 举例\n\n","routePath":"/tang/Elasticsearch/06_Elasticsearch进阶查询","lang":"","toc":[{"text":"6.1 排序","id":"61-排序","depth":2,"charIndex":3},{"text":"6.2 分页","id":"62-分页","depth":2,"charIndex":42},{"text":"6.2.1 from、size分页","id":"621-fromsize分页","depth":3,"charIndex":52},{"text":"6.2.2 scoll分页","id":"622-scoll分页","depth":3,"charIndex":162},{"text":"6.3 高亮","id":"63-高亮","depth":2,"charIndex":482},{"text":"6.4 近似查询","id":"64-近似查询","depth":2,"charIndex":656}],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"7 Java API 操作 es","content":"#\n\n> 官方文档\n\nelasticsearch7.8 API 手册\n\n\n7.1 搭建Elasticsearch项目#\n\n\n7.1.1 创建elasticsearch_demo工程#\n\n使用SpringBoot创建elasticsearch_demo项目\n\n\n7.1.2 编写pom.xml文件#\n\n\n\n\n7.1.3 编写配置文件application.properties#\n\n\n\n\n7.1.4 创建Elasticsearch配置类#\n\n\n\n\n7.1.5 创建测试类#\n\n\n\n> 测试方法测试结果：\n\n\n\n\n7.1.6 项目结构#\n\n\n\n\n7.2 索引操作#\n\n索引操作API\n\n\n7.2.1 创建索引#\n\n\n\n\n7.2.2 查询索引#\n\n\n\n\n7.2.3 删除索引#\n\n\n\n\n7.3 文档操作#\n\n文档操作API\n\n\n7.3.1 创建文档#\n\n\n\n\n7.3.2 修改文档#\n\n修改文档时，只会修改传入的属性，未传入的属性保持不变\n\n\n\n\n7.3.3 查询文档#\n\n\n\n\n7.3.4 查询文档中的数据#\n\n仅获取指定id的数据内容，不返回索引信息\n\n\n\n\n7.3.5 删除文档#\n\n\n\n\n7.3.6 批量操作#\n\n\n\n\n7.4 DSL查询#\n\nDSL查询API\n\n> 关键方法\n\n * SearchRequest request = new\n   SearchRequest()：创建request请求。参数为索引名，可不传，可传多个。如果不传参数，表示查询所有索引。\n\n * SearchSourceBuilder searchSourceBuilder = new\n   SearchSourceBuilder()：用来存放request请求的参数。只能存放大部分参数，少部分不支持。\n\n * request.source(searchSourceBuilder)将参数设置到request请求中。\n\n * restHighLevelClient.search(request,\n   RequestOptions.DEFAULT)：发送请求。其中restHighLevelClient是高级客户端RestHighLevelClient的实\n   例。\n\n> 示例代码\n\n * 对所有索引使用match_all查询\n\n\n\n * 对my_index索引使用terms多关键字精确查询，并进行分页、对命中的title进行高亮显示\n\n","routePath":"/tang/Elasticsearch/07_Java API 操作 Elasticsearch","lang":"","toc":[{"text":"7.1 搭建Elasticsearch项目","id":"71-搭建elasticsearch项目","depth":2,"charIndex":36},{"text":"7.1.1 创建elasticsearch_demo工程","id":"711-创建elasticsearch_demo工程","depth":3,"charIndex":61},{"text":"7.1.2 编写pom.xml文件","id":"712-编写pomxml文件","depth":3,"charIndex":129},{"text":"7.1.3 编写配置文件application.properties","id":"713-编写配置文件applicationproperties","depth":3,"charIndex":152},{"text":"7.1.4 创建Elasticsearch配置类","id":"714-创建elasticsearch配置类","depth":3,"charIndex":192},{"text":"7.1.5 创建测试类","id":"715-创建测试类","depth":3,"charIndex":222},{"text":"7.1.6 项目结构","id":"716-项目结构","depth":3,"charIndex":254},{"text":"7.2 索引操作","id":"72-索引操作","depth":2,"charIndex":270},{"text":"7.2.1 创建索引","id":"721-创建索引","depth":3,"charIndex":291},{"text":"7.2.2 查询索引","id":"722-查询索引","depth":3,"charIndex":307},{"text":"7.2.3 删除索引","id":"723-删除索引","depth":3,"charIndex":323},{"text":"7.3 文档操作","id":"73-文档操作","depth":2,"charIndex":339},{"text":"7.3.1 创建文档","id":"731-创建文档","depth":3,"charIndex":360},{"text":"7.3.2 修改文档","id":"732-修改文档","depth":3,"charIndex":376},{"text":"7.3.3 查询文档","id":"733-查询文档","depth":3,"charIndex":420},{"text":"7.3.4 查询文档中的数据","id":"734-查询文档中的数据","depth":3,"charIndex":436},{"text":"7.3.5 删除文档","id":"735-删除文档","depth":3,"charIndex":478},{"text":"7.3.6 批量操作","id":"736-批量操作","depth":3,"charIndex":494},{"text":"7.4 DSL查询","id":"74-dsl查询","depth":2,"charIndex":510}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"8 Spring Data Elasticsearch","content":"#\n\n\n8.1 Spring Data 框架介绍#\n\nSpring Data是一个用于简化数据库、非关系型数据库、索引库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得更加便捷。 Spring\nData可以极大简化JPA（Elasticsearch）的写法，可以在几乎不用写实现的情况下，实现对数据库的访问和操作。 除了CRUD(Create\n新增、Retrieve 检索、Update 更新、 Delete 删除)外，还包括分页、排序等一些常用功能。\n\nSpring Data官网：https://spring.io/projects/spring-data\n\n\n\n\n8.2 Spring Data Elasticsearch 介绍#\n\nSpring Data Elasticsearch基于Spring Data\nAPI简化Elasticsearch操作，将原始操作Elasticsearch的客户端API进行封装。 Spring Data\nElasticsearch的关键功能领域是一个以POJO为中心的模型，用于和Elasticsearch文档进行交互，并轻松编写Repository风格的数据库访\n问。\n\n\n8.3 Spring Data Elasticsearch 版本#\n\n\n\n因本教程使用的Elasticsearch版本号是7.8，但是上图中没有刚好对应的版本号，基于向下兼容的想法，\n考虑使用7.6.2版本的Elasticsearch对应的Spring Data Elasticsearch、Spring Framework、 Spring\nBoot\n\n\n8.4 Spring Data Elasticsearch 使用#\n\n\n8.4.1 创建maven项目#\n\n\n\n\n8.4.2 引入依赖#\n\n\n\n\n8.4.3 创建配置文件#\n\n\n\n\n8.4.4 创建启动类和主目录#\n\n\n\n\n8.4.5 创建配置类#\n\nElasticsearchRestTemplate是Spring Data\nElasticsearch中的一个类，和其他spring项目中的Template类似。\nElasticsearchRestTemplate是基于RestHighLevelClient客户端的，需要继承AbstractElasticsearchCon\nfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient客户端。\n\n\n\n\n8.4.6 添加document映射实体#\n\n\n\n\n8.4.7 创建Dao层数据访问#\n\n\n\n\n8.4.8 创建测试类，进行测试#\n\n\n\n\n8.4.9 使用Spring Data查询方法命名规范自定义查询方法#\n\nSpring Data强大的功能之一就是从存储库方法名称派生动态查询。 Spring\nData致力于减少数据访问层（DAO）的开发量。开发者唯一要做的，就只是声明持久层的接口，其他都交给Spring Data JPA 来完成！\n如果想要实现简单查询条件（即查询某一个实体类或是集合），只要在Dao层接口中按照Spring Data\nJPA规范对方法进行命名，就可以不用写实现方法，Spring Data会将结果直接返回。\n\n> Spring Data Repository 查询方法命名规范\n\n只能用于实现简单查询条件，即查询某一个实体类或是集合。\n\n * 查询方法以 find | read | get 开头\n * 涉及条件查询时，条件的属性用条件关键字连接\n * 条件的属性首字母大写\n * 支持属性的级联查询。若当前类有符合条件的属性，则优先使用，而不使用级联属性。若需要使用级联属性，则属性之间使用_连接\n\n> Spring Data 查询命名规则\n\n关键字                 例子                                                             JPA查询语句（JPQL）\nAnd                 findByLastnameAndFirstName(String lastname, String             where x.lastname = ?0 and x.firstname= ?1\n                    firstname)\nOr                  findByLastnameOrFirstName(String lastname, String firstname)   where x.lastname = ?0 or x.firstname= ?1\nBetween             findByPriceBetween(double lowerPrice, double higherPrice)      where x.price between ?0 and ?1\nLessThan            findByPriceLessThan(double price)                              where x.price < ?0\nGreaterThan         findByPriceGreaterThan(double price)                           where x.price > ?0\nAfter               findCreateTimeAfter(Date date)                                 where x.createTime > ?0\nBefore              findCreateTimeBefore(Date date)                                where x.createTime < ?0\nIsNull              findByAddressIsNull(String address)                            where x.address is null\nIsNotNull,NotNull   findByAddress(Is)NotNull(String address)                       where x.address is not null\nLike                findByLastnameLike(String lastname)                            where x.lastname like ?0 (参数需要手动添加%)\nNotLike             findByLastnameNotLike(String lastname)                         where x.lastname not like ?0 (参数需要手动添加%)\nStartingWith        findByLastnameStartingWith(String prefix)                      where x.lastname like ?0 (参数不需手动添加%，Spring\n                                                                                   Data会在JPQL语句中自动将%添加到字段的最前面)\nEndingWith          findByLastnameEndingWith(String postfix)                       where x.lastname like ?0 (参数不需手动添加%，Spring\n                                                                                   Data会在JPQL语句中自动将%添加到字段的最后面)\nContaining          findByLastnameContaining(String centerStr)                     where x.lastname like ?0 (Spring\n                                                                                   Data会在JPQL语句中自动将%添加到字段的最前边和最后面)\nOrderBy             findByLastnameLikeOrderByAgeDesc(String lastname)              where x.lastname like ?0 order by x.age desc\nNot                 findByLastnameNot(String lastname)                             where x.lastname <> ?0\nIn                  findByAgeIn(Collection ages)                                   where x.age in ?0\nNotIn               findByAgeNotIn(Collection ages)                                where x.age not in ?0\nTrue                findByActiveTrue()                                             where x.active = true\nFalse               findByActiveFalse()                                            where x.active = false\n\n> 自定义方法举例\n\n * 在Dao层类中按照Spring Data Repository 查询方法命名规范定义方法\n\n\n\n * 在测试方法中测试上述方法\n\n\n\n\n8.4.10 使用@Query自定义DSL查询语句#\n\n * 在Dao层类中定义查询方法，并使用@Query注解\n\n\n\n * 在测试方法中测试上述方法\n\n\n\n\n8.4.11 使用ElasticsearchRestTemplate进行查询#\n\n","routePath":"/tang/Elasticsearch/08_Spring Data Elasticsearch","lang":"","toc":[{"text":"8.1 Spring Data 框架介绍","id":"81-spring-data-框架介绍","depth":2,"charIndex":3},{"text":"8.2 Spring Data Elasticsearch 介绍","id":"82-spring-data-elasticsearch-介绍","depth":2,"charIndex":291},{"text":"8.3 Spring Data Elasticsearch 版本","id":"83-spring-data-elasticsearch-版本","depth":2,"charIndex":515},{"text":"8.4 Spring Data Elasticsearch 使用","id":"84-spring-data-elasticsearch-使用","depth":2,"charIndex":693},{"text":"8.4.1 创建maven项目","id":"841-创建maven项目","depth":3,"charIndex":729},{"text":"8.4.2 引入依赖","id":"842-引入依赖","depth":3,"charIndex":750},{"text":"8.4.3 创建配置文件","id":"843-创建配置文件","depth":3,"charIndex":766},{"text":"8.4.4 创建启动类和主目录","id":"844-创建启动类和主目录","depth":3,"charIndex":784},{"text":"8.4.5 创建配置类","id":"845-创建配置类","depth":3,"charIndex":805},{"text":"8.4.6 添加document映射实体","id":"846-添加document映射实体","depth":3,"charIndex":1052},{"text":"8.4.7 创建Dao层数据访问","id":"847-创建dao层数据访问","depth":3,"charIndex":1078},{"text":"8.4.8 创建测试类，进行测试","id":"848-创建测试类进行测试","depth":3,"charIndex":1100},{"text":"8.4.9 使用Spring Data查询方法命名规范自定义查询方法","id":"849-使用spring-data查询方法命名规范自定义查询方法","depth":3,"charIndex":1122},{"text":"8.4.10 使用@Query自定义DSL查询语句","id":"8410-使用query自定义dsl查询语句","depth":3,"charIndex":4400},{"text":"8.4.11 使用ElasticsearchRestTemplate进行查询","id":"8411-使用elasticsearchresttemplate进行查询","depth":3,"charIndex":4480}],"domain":"","frontmatter":{},"version":""},{"id":95,"title":"9 Linux安装ES相关工具","content":"#\n\n\n9.1 安装Elasticsearch#\n\n在Linux服务器上创建/opt/es文件夹，下载Elasticsearch7.8安装包，上传到该文件夹，进行解压即可。\n\n\n\n\n9.2 配置Elasticsearch环境参数#\n\n\n9.2.1 创建用户#\n\nElasticsearch不能直接通过root用户启动，所以需要先创建一个普通用户。\n\n\n\n\n9.2.2 给用户设置sudo权限#\n\n相当于临时给某个用户类似于管理员的权限\n\n\n\n\n\n\n9.2.3 修改普通用户打开文件最大数限制、启动线程数限制#\n\n\n\n\n\n\n9.2.4 为普通用户增大虚拟内存#\n\n\n\n\n9.2.5 使以上配置生效#\n\n\n\n以上步骤完成后，需要重新打开终端，重新登入，才可看到配置生效。\n\n\n9.2.6 修改elasticsearch.yml文件#\n\n需要使用es用户执行以下操作\n\n\n\n\n9.2.7 修改jvm配置#\n\n需要使用es用户执行以下操作\n\n\n\n\n9.3 启动Elasticsearch#\n\n需要使用es用户执行以下操作\n\n\n\n\n9.4 访问Elasticsearch#\n\n\n\n\n\n\n9.5 安装Kibana#\n\n下载Kibana7.8安装包，上传到/opt/es文件夹，进行解压即可。\n\n\n9.6 配置Kibana环境参数#\n\n\n9.6.1 授权#\n\n将kibana-7.8.0的操作权限赋给es用户\n\n\n\n\n9.6.2 修改kibana配置#\n\n修改/opt/es/kibana-7.8.0/config/kibana.yml，内容如下：\n\n\n\n\n9.7 后台运行kibana#\n\n需要使用es用户执行以下操作\n\n\n\n\n9.8 访问kibana#\n\n\n\n\n9.9 安装ik分词器#\n\n在/opt/es/elasticsearch-7.8.0/plugins/文件夹创建ik文件夹。\n下载ik安装包，上传到/opt/es/elasticsearch-7.8.0/plugins/ik文件夹，进行解压。解压后，将安装包删除\n\n\n9.8 ik分词器文件夹授权#\n\n将ik分词器的操作权限赋给es用户\n\n\n\n\n9.9 重启es和kibana#\n\n重启后，ik分词器生效。","routePath":"/tang/Elasticsearch/09_Linux 安装 Elasticsearch","lang":"","toc":[{"text":"9.1 安装Elasticsearch","id":"91-安装elasticsearch","depth":2,"charIndex":3},{"text":"9.2 配置Elasticsearch环境参数","id":"92-配置elasticsearch环境参数","depth":2,"charIndex":90},{"text":"9.2.1 创建用户","id":"921-创建用户","depth":3,"charIndex":117},{"text":"9.2.2 给用户设置sudo权限","id":"922-给用户设置sudo权限","depth":3,"charIndex":177},{"text":"9.2.3 修改普通用户打开文件最大数限制、启动线程数限制","id":"923-修改普通用户打开文件最大数限制启动线程数限制","depth":3,"charIndex":223},{"text":"9.2.4 为普通用户增大虚拟内存","id":"924-为普通用户增大虚拟内存","depth":3,"charIndex":260},{"text":"9.2.5 使以上配置生效","id":"925-使以上配置生效","depth":3,"charIndex":283},{"text":"9.2.6 修改elasticsearch.yml文件","id":"926-修改elasticsearchyml文件","depth":3,"charIndex":335},{"text":"9.2.7 修改jvm配置","id":"927-修改jvm配置","depth":3,"charIndex":384},{"text":"9.3 启动Elasticsearch","id":"93-启动elasticsearch","depth":2,"charIndex":419},{"text":"9.4 访问Elasticsearch","id":"94-访问elasticsearch","depth":2,"charIndex":460},{"text":"9.5 安装Kibana","id":"95-安装kibana","depth":2,"charIndex":487},{"text":"9.6 配置Kibana环境参数","id":"96-配置kibana环境参数","depth":2,"charIndex":541},{"text":"9.6.1 授权","id":"961-授权","depth":3,"charIndex":561},{"text":"9.6.2 修改kibana配置","id":"962-修改kibana配置","depth":3,"charIndex":601},{"text":"9.7 后台运行kibana","id":"97-后台运行kibana","depth":2,"charIndex":671},{"text":"9.8 访问kibana","id":"98-访问kibana","depth":2,"charIndex":707},{"text":"9.9 安装ik分词器","id":"99-安装ik分词器","depth":2,"charIndex":725},{"text":"9.8 ik分词器文件夹授权","id":"98-ik分词器文件夹授权","depth":2,"charIndex":859},{"text":"9.9 重启es和kibana","id":"99-重启es和kibana","depth":2,"charIndex":898}],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"10 CAP定理","content":"#\n\n\n10.1 概念#\n\n * CAP定理，又称布鲁尔定理\n\n * C(Consistency)：一致性。指数据在多个副本之间能够保持一致的特性，在同一时刻是否具有同样的值。 一致性，可以分为强一致性和弱一致性。\n   \n   * 强一致性：在任意时刻，所有节点中的数据都保持一致性。\n   * 弱一致性：数据更新后，如果能容忍短时间内的访问只能访问到部分或者全部访问不到，就是弱一致性。最终一致性就属于弱一致性。\n\n * A(Avaliablity)：可用性。指系统提供的服务必须一直处于可用状态。每次只要收到用户的请求，服务器就必须给出回应。在合理的时间内返回合理的相应（不\n   是错误和超时的响应）。保证服务的可用性，就是搭建集群。\n\n * P(Partition\n   tolerance)：在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但是他们的内部子网络是正常的\n   。从而导致了整个系统的环境被切分成了若干个孤立的分区。分区容错的意思是，区间通信可能失败。\n\n * CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP\n\n\n10.2 CAP取舍策略#\n\nCAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。\n\n策略   分析结果\nCA   满足一致性和可用性，放弃分区容错。说白了，就是一个整体应用，不是分布式应用\nCP   满足一致性和分区容错性，放弃可用性。当系统被分区，为了保证一致性，必须放弃可用性，让系统停掉。如银行系统\nAP   满足可用性和分区容错性，放弃一致性。当系统被分区，为了保证可用性，就必须让节点继续对外服务，这就意味着失去一致性。分布式\n     系统中最常用策略。","routePath":"/tang/Elasticsearch/10_CAP定理","lang":"","toc":[{"text":"10.1 概念","id":"101-概念","depth":2,"charIndex":3},{"text":"10.2 CAP取舍策略","id":"102-cap取舍策略","depth":2,"charIndex":507}],"domain":"","frontmatter":{},"version":""},{"id":97,"title":"11 Elasticsearch集群","content":"#\n\nElasticsearch天生就是分布式的系统。\n\n配置服务器集群时，集群中节点数量没有限制，大于等于2个节点就是集群了。 一般处于高性能及高可用的方面来考虑，集群中的节点数量都是3个以上。\n\n> 为什么要搭建集群\n\n * 单台机器存储容量有限\n * 单服务器容易出现单点故障，无法实现高可用性\n * 单服务的并发处理能力有限\n\n\n11.1 集群安装#\n\n\n11.1.1 搭建方案#\n\n一般集群建议3台机器以上。这里我们就是用3台机器来安装集群环境。\n\n\n11.1.2 复制ES程序#\n\n * 创建elasticsearch-cluster文件夹，重新解压elasticsearch安装包到当前路径下，并将文件夹重命名node1。\n\n * 将ik分词器解压到elasticsearch-cluster/node1/plugins/ik文件夹下，同时删除ik分词器的压缩包文件。\n\n * 修改elasticsearch-cluster/node1/config/jvm.options文件：\n   \n   \n\n * 复制node1两份，分别重命名为node2，node3\n   \n   \n\n\n11.1.3 修改es配置文件#\n\n修改elasticsearch-cluster/node*/config/elasticsearch.yml文件\n\n> node1\n\n\n\n> node2\n\n\n\n> node3\n\n\n\n\n11.1.4 集群的启动与访问测试#\n\n> 集群启动\n\n依次启动node1、node2、node3 3个节点。\n\n注意：不能一块都启动，要保证上一个启动成功，再启动下一个\n\n> 访问测试\n\n浏览器输入http://127.0.0.1:9201/_cat/health?v，查看节点状态。 如果status=green 且\ntotal.node=3，表示集群启动后成功。\n\n\n\n\n11.1.5 kibana的配置与访问测试#\n\n> 修改kibana配置文件并启动\n\n修改kibana-7.8.0-windows-x86_64/config/kibana.yml文件，使kibana指向当前集群。\n\n> kibana访问测试\n\n\n\n\n11.1.6 集群中节点的状态#\n\n> Green\n\n表示所有的主分片和副本分片都已分配，集群100%是可用的。\n\n> Yellow\n\n表示所有的主分片已经分片了，但至少还有一个副本是缺失的。该情况下，不会有数据丢失，搜索结果依然是完整的。\n\n但是，集群的高可用在某种程度上被弱化了。如果更多的分片消失，数据就会丢失了。\n\n可以将该状态想象成一个需要及时调查的警告。\n\n> Red\n\n至少有一个主分片以及它的全部副本分片都在缺失，搜索只能返回部分数据，且分配到这个分片上的写入请求会返回一个异常。\n\n\n11.2 Elasticsearch集群中的核心概念#\n\n\n11.2.1 集群Cluster#\n\n * 一个集群就是由一个或多个服务器节点组织在一起，共用持有整个数据，并一起提供索引和搜索功能。\n * 一个集群有一个唯一的名字表示。当一个新的节点需要加入某个集群时，只能通过该集群的名字加入。\n\n\n11.2.2 节点Node#\n\n * 集群中包含多台服务器，一个节点就是其中的一台服务器。作为集群的一部分，它存储数据，参与集群的索引和搜索功能。\n * 节点也是由名字来标识的。名字会在启动时赋予节点。\n * 一个节点可以通过配置集群名称的方式加入指定的集群。\n * 一个集群中可以有任意多个节点。\n\n\n11.2.3 分片Shards#\n\n * 一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档数据的索引占据1TB的磁盘空间，而任一节点都可能没有这样大的磁盘空间，\n   或者单个节点处理索引请求时响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分为多份的能力，每一份就称为一个分片。\n   当创建索引时，可以指定分片数量。每个分片本身也是一个功能完善且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。\n\n * 分片的作用\n   \n   * 允许水平分割/扩展内容量\n   * 允许在分片上进行分布式的、并行的操作，进而提高性能/吞吐量\n\n * 用户无需关心分片怎样分布、文档怎样聚合和搜索请求，这些都是Elasticsearch管理的。\n\n\n11.2.4 副本Replicas#\n\n * 在一个网络/云环境中，失败随时都有可能发生，在某个分片/节点处于离线状态，或者由于某个原因消失了，这种情况下，有一个故障转移机制是非常必要的。\n   Elasticsearch允许创建分片的一份或多分拷贝，这些拷贝就叫做复制分片，即副本。\n\n * 副本的作用：\n   \n   * 在分片/节点失败的情况下，提供了高可用性。这是因为副本不会与主分片置于同一节点中。\n   * 扩展搜索量/吞吐量，这是因为搜索可以在所有副本上并行运行。\n\n * 可以在创建索引时指定主分片和副本数量。索引创建后，可以改变副本数量，但不能改变主分片数量。默认情况下，在创建索引的时候会被分配1个主分片1个副本。\n\n * 数据的总份数 = 主分片数量 + 主分片数量 * 副本数量\n\n\n11.2.5 分配Allocation#\n\n将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程由master节点完成。即Elasticsearch的分片\n分配和均衡机制。\n\n\n11.2.6 节点类型#\n\nes中的节点分为Master节点、DataNode节点。\n\n * Master节点：\n   \n   * Elasticsearch启动时，会选举出一个master节点。当某个节点启动后，使用Zen\n     Discovery机制找到集群中的其他节点并建立连接（discovery.seed_hosts:[\"host1\", \"host2\",\n     \"host3\"]）, 并从候选主节点中选举出一个主节点（cluster.initial_master_nodes: [\"node1\",\n     \"node2\", \"node3\"]）。\n   * master节点功能：\n     * 管理索引（创建索引、删除索引），分配分配\n     * 维护元数据\n     * 管理集群节点状态\n   * master不负责写入和查询，比较轻量级。一个Elasticsearch集群中，只有一个master节点。在生产环境中，内存可以相对小一点，但是要确保\n     机器的稳定。\n\n * DataNode节点：\n   \n   * DataNode主要功能：\n     \n     * 数据写入\n     * 数据检索\n   \n   * 大部分Elasticsearch的压力都在DataNode节点上，在生产环境中，内存最好分配大一些。\n\n\n11.3 系统架构#\n\n\n\n一个运行中的Elasticsearch实例称为一个节点，而集群是由一个或多个拥有相同集群名称（cluster.name配置相同）的节点组成。\n它们共同承担数据和负载的压力。当有节点加入集群或者从集群中移除时，集群将会重新平均分布所有数据。\n\n当一个节点被选举为主节点时，它将负责管理集群范围内的所有变更，如增加、删除索引，或者增加、移除节点等。\n作为用户，我们可以将请求发送到集群的任何节点，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。\n无论将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回给客户端。 Elasticsearch对这一切的管理都是透明的。","routePath":"/tang/Elasticsearch/11_Elasticsearch集群","lang":"","toc":[{"text":"11.1 集群安装","id":"111-集群安装","depth":2,"charIndex":168},{"text":"11.1.1 搭建方案","id":"1111-搭建方案","depth":3,"charIndex":181},{"text":"11.1.2 复制ES程序","id":"1112-复制es程序","depth":3,"charIndex":230},{"text":"11.1.3 修改es配置文件","id":"1113-修改es配置文件","depth":3,"charIndex":497},{"text":"11.1.4 集群的启动与访问测试","id":"1114-集群的启动与访问测试","depth":3,"charIndex":607},{"text":"11.1.5 kibana的配置与访问测试","id":"1115-kibana的配置与访问测试","depth":3,"charIndex":796},{"text":"11.1.6 集群中节点的状态","id":"1116-集群中节点的状态","depth":3,"charIndex":922},{"text":"11.2 Elasticsearch集群中的核心概念","id":"112-elasticsearch集群中的核心概念","depth":2,"charIndex":1173},{"text":"11.2.1 集群Cluster","id":"1121-集群cluster","depth":3,"charIndex":1203},{"text":"11.2.2 节点Node","id":"1122-节点node","depth":3,"charIndex":1322},{"text":"11.2.3 分片Shards","id":"1123-分片shards","depth":3,"charIndex":1474},{"text":"11.2.4 副本Replicas","id":"1124-副本replicas","depth":3,"charIndex":1822},{"text":"11.2.5 分配Allocation","id":"1125-分配allocation","depth":3,"charIndex":2176},{"text":"11.2.6 节点类型","id":"1126-节点类型","depth":3,"charIndex":2290},{"text":"11.3 系统架构","id":"113-系统架构","depth":2,"charIndex":2871}],"domain":"","frontmatter":{},"version":""},{"id":98,"title":"12 Elasticsearch分片控制与原理","content":"#\n\n\n12.1 分片操作#\n\n> 创建索引时，设置主分片为3，副本为3\n\n\n\n> 修改副本数量\n\n主分片数量不能修改，只能修改副本数量。\n\n\n\n\n12.2 分片控制#\n\n\n12.2.1 写流程#\n\n新建和删除都属于写流程，必须在主分片上完成写操作之后，再复制到相关的副本分片中。\n\n> 写流程示意图\n\n\n\n\n12.2.2 读流程#\n\n> 读流程示意图\n\n\n\n\n12.3 分片原理#\n\n\n12.3.1 倒排索引#\n\n> 倒排索引概念\n\n倒排索引适用于快速的全文检索。\n\n> 正排索引 VS 倒排索引\n\n * 正排索引：搜索引擎会将待搜索的文件第一对应一个文件ID，搜索时将这个ID和搜索关键字进行对应，行程K-V对，然后对关键字进行统计计数。根据ID找词。\n\n * 倒排索引：一个倒排索引由文档中所有不重复词的列表组成，对于每一个词，都有一个包含它的文档的列表。根据词找ID。\n\n> 说明\n\n不论是正排索引还是倒排索引，都是存在磁盘中的，在使用的时候需要先读取到内存中。\n\n> 倒排索引步骤\n\n * 假设有两个文档，文档内容分别如下：\n   \n   * 文档一：The quick brown fox jumped over the lazy dog\n   * 文档二：Quick brown foxes leap over lazy dogs in summer\n\n * 建立倒排索引表，过程如下：\n   \n   * 将两个文档拆分成单独的词，这些词被称为词条或tokens\n   * 创建一张包含所有不重复词条的排序列表（倒排表），然后列出词条出现在哪个文档\n   * 倒排表内容如下：\n   \n   单词       文档列表\n   The      1\n   quick    1,2\n   brown    1\n   fox      1\n   jumped   1\n   over     1\n   the      1\n   lazy     1\n   dog      1\n   Quick    2\n   foxes    2\n   leap     2\n   dogs     2\n   in       2\n   summer   2\n\n * 搜索(假设搜索quick brown)，过程如下：\n   \n   * 首先分别搜索qucik、brown，结果如下\n     \n     单词      文档列表\n     quick   1,2\n     brown   1\n   \n   * 以上结果说明两个文档都匹配。如果使用仅计算匹配词条数量的简单相似性算法，那么，我们可以说文档一比文档二的匹配度更高，文档一的排名比文档二排名更靠前。\n\n\n12.3.2 固定不变的倒排索引#\n\n早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入磁盘。一旦新的索引就绪，旧索引就会被替换，这样最近的变化便可以被检测到。\n\n早期的倒排索引被写入磁盘后是不可变的。\n\n> 不变性有重要的价值：\n\n * 不需要锁。如果从来不更新索引，就不用担心多进程同时修改数据的问题。\n * 一旦索引被读入内核的文件系统缓存，便会留在那里。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。\n * 其他缓存（如filter缓存），在索引的生命周期内始终有效。它们不需要再每次数据改变时被重建。\n * 写入单个大的倒排索引允许数据被压缩，减少磁盘I/O和需要被缓存到内存的索引的使用量。\n\n> 不变性的缺点：\n\n最主要的问题是不能修改。如果想要让一个新的文档可以被索引，则需要重建整个索引。\n这要么对一个索引所能包含的数据量造成了很大的限制，要么对所以呢可被更新的频率造成了很大的限制。\n\n\n12.3.3 动态更新索引#\n\n现阶段使用的是动态更新索引。如微博、哔哩哔哩、各大商城，每天都会有大量新的数据产生，如果固定不变，无法满足互联网用户的需求。\n\n> 如何在保留不变性的前提下，实现倒排索引的更新？\n\n用更多的索引。通过增加新的补充索引来反应新的修改，而不是重写整个倒排索引。每一个倒排索引都会被轮流查询到，从最早的开始查询完后再对结果进行合并。\n\n> 按段索引概念\n\nElasticsearch基于Lucene，Lucene引入了按段索引的概念。 每一段本身都是一个倒排索引。\n索引在Lucene中除了表示所有段的集合外，还增加了提交点的概念，即一个列出了所有已知段的文件。\n\n> 按段索引写入流程\n\n * 1.新文档被收集到内存索引缓存\n * 2.不时地，缓存被提交\n   * 一个新的段（即一个追加的倒排索引）被写入磁盘\n   * 一个新的包含新段名字的提交点被写入磁盘\n   * 磁盘进行同步（所有在文件系统缓存中等待写入的都刷新到磁盘中，以确保它们被写入物理文件）\n * 3.新的段被开启，让它包含的文档可见以被搜索\n * 4.内存缓存被清空，等待接收新的文档\n\n> 按段索引的搜索\n\n当一个查询被触发时，所有已知的端按顺序被查询。\n词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算，这种方式可以用相对较低的成本将新的文档添加到索引。\n\n> 按段索引的删除与修改\n\n段是不可以改变的，所以既不能把文档从段中移除，也不能修改旧的段来反应文档的更新。\n取而代之的是，每个提交点都会包含一个.del文件，文件中会列出这些被删除文档的段信息。\n\n * 删除\n   \n   当一个文档被“删除”时，实际上知识在.del文件中被标记删除。 一个被标记删除的文档仍然可以被查询匹配到，但是它会在最终结果被返回前从结果集中移除。\n\n * 更新\n   \n   当一个文档被更新时，旧版文档被标记删除，文档的新版本被所引导一个新的段中。\n   可能两个版本的文档都会被一个查询匹配到，但被标记删除的文档在结果集返回前被移除。\n\n\n12.3.4 近实时搜索#\n\n> 数据写入流程\n\n\n\n * 分段数据先写入到es内存缓存中，同事文档操作也会记录translog日志\n * es内存的数据对查询不可见，默认间隔1s将内存中的数据写入到文件系统缓存中，这里边的数据对查询可见\n * 文件系统缓存数据间隔30min再将数据刷入磁盘中\n * 如果文件系统缓存数据在没有刷新到磁盘的时候宕机了，可以从translog中恢复数据到磁盘。数据恢复完成后，translog数据也会被清理\n\n\n12.3.5 段合并#\n\n> 背景\n\n由于自动刷新流程每秒都会创建一个新的段，这样会导致短时间内段的数量暴增。 而段数太多会带来较大的麻烦。\n每一个段都会消耗文件的句柄（句柄概念详见本章最后一节）、内存和cpu运行周期。 更重要的是，每个搜索请求都必须轮流检查每个段，所以段越多，搜索越慢。\n\n> 段合并概念\n\nElasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再合并到更大的段。\n\n段合并的时候会将旧的已标记删除的文档从文件系统中清除，被标记删除的文档不会被拷贝的新的大段中。\n\n> 段合并流程\n\n段合并不需要用户做任何事，会在进行索引和搜索时自动进行。\n\n * 1.当索引的时候，刷新操作会创建新的段，并将段打开以供搜索使用\n * 2.合并进程选择一小部分大小相似的段，并在后台将它们合并到更大的段中，这并不会终端索引和搜索\n * 3.合并一旦结束，老的段被删除。过程如下：\n   * 新的段被刷入磁盘，写入一个包含新段且排除旧的和较小的段的新提交点\n   * 新的段被打开，用来搜索\n   * 老的段被删除\n\n合并大的段需要消耗大量的I/O和CPU资源。如果任其发展，会影响搜索性能。\nElasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。\n\n\n12.4 附：句柄#\n\n> 概念\n\n文件句柄（File Handle）是操作系统中用于访问文件的一种数据结构，通常是一个整数或指针。 文件句柄用于表示打开的文件，每个打开的文件都有一个唯一的句柄。\n\n在Linux或Unix系统中，文件句柄是通过系统调用open()打开文件时返回的。 当打开一个文件时，操作系统会为该文件分配一个文件句柄，并将其返回给应用程序。\n应用程序可以使用文件句柄来读取、写入、关闭文件等操作。\n\n> 句柄的组成\n\n * 文件描述符（File\n   Descriptor）：它是一个非负整数，用于表示打开的文件。在Linux和Unix系统中，标准输入、标准输出、标准错误输出的文件描述符分别是0、 1、\n   2\n * 文件状态标志（File Status Flags）：描述文件的状态，如是否可读、可写、是否为阻塞模式等\n * 文件位置指针（File Position Pointer）：标识文件中的当前位置。应用程序可以用它来读取或写入文件。\n\n> 句柄使用注意事项\n\n避免打开过多的文件句柄，从而导致系统的文件描述符资源紧张。","routePath":"/tang/Elasticsearch/12_Elasticsearch分片控制与原理","lang":"","toc":[{"text":"12.1 分片操作","id":"121-分片操作","depth":2,"charIndex":3},{"text":"12.2 分片控制","id":"122-分片控制","depth":2,"charIndex":73},{"text":"12.2.1 写流程","id":"1221-写流程","depth":3,"charIndex":86},{"text":"12.2.2 读流程","id":"1222-读流程","depth":3,"charIndex":154},{"text":"12.3 分片原理","id":"123-分片原理","depth":2,"charIndex":180},{"text":"12.3.1 倒排索引","id":"1231-倒排索引","depth":3,"charIndex":193},{"text":"12.3.2 固定不变的倒排索引","id":"1232-固定不变的倒排索引","depth":3,"charIndex":1132},{"text":"12.3.3 动态更新索引","id":"1233-动态更新索引","depth":3,"charIndex":1572},{"text":"12.3.4 近实时搜索","id":"1234-近实时搜索","depth":3,"charIndex":2451},{"text":"12.3.5 段合并","id":"1235-段合并","depth":3,"charIndex":2673},{"text":"12.4 附：句柄","id":"124-附句柄","depth":2,"charIndex":3246}],"domain":"","frontmatter":{},"version":""},{"id":99,"title":"13 Elasticsearch的优化建议","content":"#\n\n\n13.1 硬件选择#\n\nElasticsearch是基于Lucene的，所有的索引和文档数据都是存储在本地的磁盘中，具体路径可在ES配置文件config/elasticsearch.y\nml中配置，如下：\n\n\n\n磁盘在现代服务器上通常都是瓶颈。Elasticsearch重度使用磁盘，磁盘的吞吐量越大，节点就越稳定。\n\n> 优化磁盘I/O的技巧\n\n * 使用SSD（固态硬盘）\n\n * 使用RAID 0（一种硬盘阵列）：读写速度快，能够提高磁盘容量。但是当一快磁盘故障整个就故障了。不要使用镜像或者奇偶校验RAID，因为副本已经提供该功能。\n\n * 使用多块硬盘，并允许Elasticsearch通过多个path.data目录配置把数据条带化分配到它们上面。\n\n * 不要使用远程挂载的存储，如NFS或者SMB/CIFS\n\n\n13.2 分片策略#\n\n\n13.2.1 合理设置分片数#\n\n> 分片的代价\n\n * 一个分片的底层即为一个Lucene索引，会消耗一定文件句柄、内存以及CPU运转\n * 每一个搜索请求都需要命中索引中的一个分片。如果多个分片处于同一个节点，这些分片就会竞争使用相同的资源\n * 用于计算相关度的词项统计信息是基于分片的。如果分片过多，就会导致很低的相关度\n\n> 分片遵循的原则\n\n * 控制每个分片占用的磁盘容量不超过ES的最大JVN堆栈空间设置（JVM一般不超过32M，参考下面JVM设置原则）。\n   \n   栗子 假设索引的总容量在500G左右，那么分片大小在16个左右即可。当然，最好同时考虑原则2\n\n * 分片数一般不要超过节点数的3倍。\n   \n   说明\n   一般来书一个节点就是一台物理机。如果分片数打打超过节点数，就会造成一个节点上多个分片，处理在索引时会竞争资源外，一旦该节点故障，即使保持了1个以上的副本，\n   同样有可能导致数据丢失，集群无法恢复。\n\n * 主分片、副本、节点最大数的计算公式如下：\n   \n   公式 节点数 <= 主分片数 * (副本数 + 1)\n\n\n13.2.2 推迟分片分配#\n\n对于节点瞬时中断的问题，默认情况下，集群会等待1min来查看节点是否会重新加入。\n如果这个节点在此瞬间重新加入，重新加入的节点会保持现有的分片数据，不会触发新的分片分配。\n这样就可以减少Elasticsearch在自动再平衡可用分片时所带来的的极大开销。\n\n> 延长再均衡时间\n\n通过修改参数delayed_time，延长再均衡时间。可以全局设置，也可以在索引级别修改\n\n\n\n\n13.3 路由选择#\n\n当进行文档查询的时候，Elasticsearch是通过如下公式计算得到文档存放的分片：\n\nshard = hash(routing) % number_of_primary_shards 其中，routing默认值是文档id，也可以采用自定义值。\n\n * 不带routing查询\n   \n   在查询时，因为不知道要查询的数据具体在哪个分片上，所以整个过程分为2个步骤\n   \n   * 分发： 请求到达协调节点后，协调节点将查询请求分发到每个分片上\n   * 聚合： 协调节点搜集到每个分片上的查询结果，将查询结果进行排序，然后将结果返回给用户\n\n * 带routing查询\n   \n   查询时，可以根据routing信息定位到某个分片查询，不需要查询所有分片。\n\n\n13.4 写入速度优化#\n\nES默认配置，是综合了数据可靠性、写入速度、搜索实时性等因素。 实际使用时，可以按照实际情况，进行偏向性的优化。\n\n> 写入速度优化概述\n\n针对搜索性能要求不高，但对写入要求较高的场景，我们需要尽可能的选择恰当的写优化策略。 综合来说，可以考虑一下几个方面来提升索引的性能：\n\n * 在集群正常运行的前提下，如果是集群首次批量导入数据时，可以将副本数设置为0，导入完毕后再将副本数调整为正常值，这样副分片就只需要复制，节约了构建索引的时间\n * 增大Translog flush间隔，目的是降低Iops（即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一）、WriteBlock\n * 增大Index Refresh间隔，以减少I/O，更重要的是减少Segment Merge（段合并）的次数\n * 善用Bulk请求，调整Bulk线程池和队列\n * 优化磁盘的任务均匀情况，将shard尽量均匀分布到物理主机的各个磁盘\n * 优化节点见的任务分布，将任务尽量均匀的发到各个节点\n * 优化Lucene层的索引建立，以降低CPU和IO，如禁用_all字段\n\n> 重要概念\n\n * flush：是指触发lucene commit，也就是将缓存中的数据写入到磁盘，并清空translog日志文件\n * refresh: 是指从内存到文件系统缓存的过程。此时该文档就可以被搜索到，但是该文档还没有存储到磁盘上，如果机器宕机了，数据就会丢失\n\n\n13.4.1 增大Translog flush间隔#\n\n默认情况下，translog的持久化策略为每个请求都flush。对应配置如下：\n\n\n\n这是写入速度的最大因素，但是也只有这样，写操作才有可能是可靠的。\n\n如果系统能够接受一定概率的数据的丢失（如，数据写入主分片成功，尚未复制到副本时，主机断电。由于数据既没有刷到Lucene，translog也没有刷入磁盘，恢复时\n，translog中没有这个数据，导致数据丢失）， 则可以调整translog持久化策略为周期性和一定大小的时候flush。如：\n\n\n\n\n13.4.2 增大Index Refresh间隔#\n\n默认情况下索引的refresh_interval为1s，这意味着数据每隔1s就会从es缓存中写入文件系统缓存中，以保证数据可以被搜索到。\n每次索引的refresh会产生一个新的Lucene段（即segment），segment在符合一定条件后，会自动合并，因此这会导致频繁的segment\nmerge行为。 如果不需要这么高的搜索实时性，应该降低索引refresh周期。\n\n\n\n\n13.4.3 段合并优化#\n\n * 降低段产生的数量\n   \n   * 增大Index Refresh间隔（见13.4.2小节）\n   * 增大分片的indexing buffer\n     * indexing buffer在为doc建立索引时使用，当缓冲满时会刷入磁盘，\n       生成一个新的segment，这是除refresh_interval刷新索引外，另一个生成新segment的机会。\n     * 每个shard有自己的indexing buffer， 配置修改如下\n       \n       \n   * 尽量减少文档的更新操作\n\n * 降低最大段的大小，避免较大的段继续参与merge，节省系统资源，但是最终会有多个段\n   \n   * 增大index.merge.policy.segments_per_tier，默认为10，值越小表示需要越多的merge。\n     \n     另：该值需要大于等于index.merge.policy.max_merge_at_once(表示默认一次最多归并segment的个数，默认为10)\n   \n   * 减小index.merge.policy.max_merged_segment，默认5GB。当段的大小超过此值后，将不再参与merge操作\n\n * 当Index不再有写入操作时，对其进行force merge，最好force merge成1个段。 如此可以提升查询速度，减少内存开销，但是force\n   merge时会消耗大量的I/O、CUP资源\n\n\n13.4.4 善用Bulk请求#\n\n * 当需要执行批量写操作时，Bulk请求比一个索引请求只写单个文档效率高得多，但是Bulk请求的整体字节数最好避免超过几十兆字节，否则会给内存带来极大压力。\n * Bulk线程池和队列的优化：建立索引的过程属于计算密集型任务，应使用固定大小的线程池，来不及处理的任务放到队列中。\n   * 线程池数：CPU核数 + 1，这也是默认配置，可以避免过多的上下文切换\n   * 队列数：队列数可以适当增加，但是一定要严格控制大小，过大的队列导致较高的GC压力，并可能导致FGC频繁发生\n   * 要注意bulk线程池队列的reject情况，出现reject代表ES的bulk队列已满，客户端收到429错误(TOO_MANY_REQUESTS)。\n     不可忽略这个异常，否则写入系统的数据会少于预期。即使客户端正确处理了429错误，我们仍然应该尽量避免产生reject。\n\n\n13.4.5 单节点磁盘间的任务均衡#\n\n * 首先在配置文件conf/Elasticsearch.yml中为path.data配置多个路径来使用多块磁盘，多磁盘带来的并行写的优势可以增加吞吐量\n\n * 多磁盘写入可能会带来任务不均衡的问题，Elasticsearch在分配shard时，落到各磁盘上的shard可能并不均匀。\n   这种不均匀可能会导致某些磁盘繁忙，利用率在较长时间内持续达到100%，而某些磁盘可能使用率很低甚至为0，这种不均匀达到一定程度会对写入性能产生负面影响。\n   \n   对于此种场景，有两种策略可以考虑：\n   \n   * 简单轮询：在系统初始阶段，简单轮询的效果是最均匀的。\n   * 基于可用空间的动态加权轮询：以可用空间作为权重，在磁盘之间加权轮询\n\n\n13.4.6 节点间的任务均衡#\n\n为了节点间的任务尽量均衡，数据写入客户端应该把bulk请求轮询发送到各个节点。此时可以 考虑使用Java API或REST API的bulk接口发送数据。\n\n当使用Java API或REST API的bulk接口发送数据时，客户端将会轮询发送到集群节点，节点列表取决于：\n\n * 使用Java API时，当设置client.transport.sniff为true（默认为false）\n   时，列表为所有数据节点，否则节点列表为构建客户端对象时传入的节点列表。\n * 使用REST API时，列表为构建对象时添加进去的节点。\n\n    在此 建议使用REST API ,Java API会在未来的版本中废弃，REST API有良好的版本兼容性好。 理论上，Java\nAPI在序列化上有性能优势，但是只有在吞吐量非常大时才值得考虑序列化的开销带来的影响， 通常搜索并不是高吞吐量的业务。\n\n观察 bulk 请求在不同节点上的处理情况：\n\n\n\n\n13.4.7 优化索引的建立#\n\n * 自动生成docID，避免es对自定义ID验证操作\n\n * 调整字段Mapping\n   \n   * 减少不必要的字段数量\n   * 将不需要创建索引字段的index属性设置为not_analyzed，对字段不分词或者不建立索引，减少相应的操作，特别是binary类型\n   * 减少字段内容长度\n   * 使用不同的分析器（analyzer），不同分析器之间的运算复杂度也不相同\n\n * 调整_source字段\n   \n   _source字段用于存储doc原始数据，对于部分不需要存储的字段，可以使用includes\n   excludes过滤，或者禁用_source，但是一般实际场景不会禁用。\n\n * 禁用_all\n   \n   _all中包含所有字段分词后的关键词，作用是可以搜索的时候不指定特定的字段，从所有字段中检索。 从ES6.0之后，_all字段默认不启用。\n\n * 对不需要评分的字段禁用Norms\n   \n   Norms字段用于在搜索时计算doc的评分，如果不需要评分，可以将其禁用：\n   \n   ","routePath":"/tang/Elasticsearch/13_Elasticsearch的优化建议","lang":"","toc":[{"text":"13.1 硬件选择","id":"131-硬件选择","depth":2,"charIndex":3},{"text":"13.2 分片策略","id":"132-分片策略","depth":2,"charIndex":366},{"text":"13.2.1 合理设置分片数","id":"1321-合理设置分片数","depth":3,"charIndex":379},{"text":"13.2.2 推迟分片分配","id":"1322-推迟分片分配","depth":3,"charIndex":866},{"text":"13.3 路由选择","id":"133-路由选择","depth":2,"charIndex":1071},{"text":"13.4 写入速度优化","id":"134-写入速度优化","depth":2,"charIndex":1419},{"text":"13.4.1 增大Translog flush间隔","id":"1341-增大translog-flush间隔","depth":3,"charIndex":2057},{"text":"13.4.2 增大Index Refresh间隔","id":"1342-增大index-refresh间隔","depth":3,"charIndex":2312},{"text":"13.4.3 段合并优化","id":"1343-段合并优化","depth":3,"charIndex":2529},{"text":"13.4.4 善用Bulk请求","id":"1344-善用bulk请求","depth":3,"charIndex":3195},{"text":"13.4.5 单节点磁盘间的任务均衡","id":"1345-单节点磁盘间的任务均衡","depth":3,"charIndex":3601},{"text":"13.4.6 节点间的任务均衡","id":"1346-节点间的任务均衡","depth":3,"charIndex":3947},{"text":"13.4.7 优化索引的建立","id":"1347-优化索引的建立","depth":3,"charIndex":4387}],"domain":"","frontmatter":{},"version":""},{"id":100,"title":"jetlinks项目初体验","content":"#\n\n\n1 环境准备#\n\n须安装以下软件：\n\njdk 1.8.0_2xx+\n\nnodeJS v12.xx\n\nnpm v6.xx\n\nElasticsearch 6.8+，\n\nKibana 6.8+\n\nmysql 5.7+\n\nredis 5.x\n\n其中Elasticsearch 和 Kibana版本需要保持一致。\n\n此外，编码工具后端使用IntelliJ IDEA，前端使用WebStorm。\n\n\n2 代码下载#\n\n\n\n\n3 配置文件#\n\n\n3.1 后端代码配置文件#\n\n配置文件地址：jetlinks-standalone/src/main/resources/application.yml\n\n\n\n\n3.2 前端配置文件#\n\n配置后台接口的配置文件：config/proxy.ts\n\n\n\n\n4 运行#\n\n\n4.1 启动mysql与redis#\n\n\n4.2 启动elasticsearch#\n\n执行elasticsearch/bin/elasticsearch.bat。\n\n浏览器访问http://localhost:9200/，页面如下即可：\n\n\n\n\n4.3启动kibana#\n\n执行kibana/bin/kibana.bat。\n\n浏览器访问http://localhost:5601/，页面如下即可：\n\n\n\n\n4.4 通过idea启动后端代码#\n\n> 配置\n\n点击file --> Project Structure --> Project,配置SDK为jdk1.8，Project language level为8。\n\n\n\n> 启动\n\n运行jetlinks-standalone/src/main/java/org...../JetLinksApplication.java\n\n\n4.5 通过webstorm启动前端代码#\n\n\n\n\n5 开发协议包#","routePath":"/tang/IoTPlatform/jetlinks","lang":"","toc":[{"text":"1 环境准备","id":"1-环境准备","depth":2,"charIndex":3},{"text":"2 代码下载","id":"2-代码下载","depth":2,"charIndex":197},{"text":"3 配置文件","id":"3-配置文件","depth":2,"charIndex":209},{"text":"3.1 后端代码配置文件","id":"31-后端代码配置文件","depth":3,"charIndex":219},{"text":"3.2 前端配置文件","id":"32-前端配置文件","depth":3,"charIndex":300},{"text":"4 运行","id":"4-运行","depth":2,"charIndex":345},{"text":"4.1 启动mysql与redis","id":"41-启动mysql与redis","depth":3,"charIndex":353},{"text":"4.2 启动elasticsearch","id":"42-启动elasticsearch","depth":3,"charIndex":374},{"text":"4.3启动kibana","id":"43启动kibana","depth":3,"charIndex":476},{"text":"4.4 通过idea启动后端代码","id":"44-通过idea启动后端代码","depth":3,"charIndex":556},{"text":"4.5 通过webstorm启动前端代码","id":"45-通过webstorm启动前端代码","depth":3,"charIndex":742},{"text":"5 开发协议包","id":"5-开发协议包","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":101,"title":"k8s部署prometheus + grafana","content":"   {{ .Alerts | len }} alert{{ if gt (len .Alerts) 1 }}s{{ end    \n   }} for {{ range .GroupLabels.SortedPairs }} {{ .Name }}={{\n   .Value }} {{ end }}\n   View in {{ template \"__alertmanager\" . }}\n   [{{ .Alerts.Firing | len }}] Firing\n   Labels\n   {{ range .Labels.SortedPairs }}{{ .Name }} = {{ .Value }}\n   {{ end }} {{ if gt (len .Annotations) 0 }}Annotations\n   {{ end }} {{ range .Annotations.SortedPairs }}{{ .Name }} =\n   {{ .Value }}\n   {{ end }} Source\n   ------------------------------------------------------------\n   --------------------\n   [{{ .Alerts.Resolved | len }}] Resolved\n   Labels\n   {{ range .Labels.SortedPairs }}{{ .Name }} = {{ .Value }}\n   {{ end }} {{ if gt (len .Annotations) 0 }}Annotations\n   {{ end }} {{ range .Annotations.SortedPairs }}{{ .Name }} =\n   {{ .Value }}\n   {{ end }} Source\n   \n   Sent by {{ template \"__alertmanager\" . }}","routePath":"/tang/Prometheus/1","lang":"","toc":[{"text":"namespace","id":"namespace","depth":3,"charIndex":-1},{"text":"node-exporter","id":"node-exporter","depth":3,"charIndex":-1},{"text":"k8s组件","id":"k8s组件","depth":3,"charIndex":-1},{"text":"kube-state-metrics","id":"kube-state-metrics","depth":3,"charIndex":-1},{"text":"blackbox-exporter","id":"blackbox-exporter","depth":3,"charIndex":-1},{"text":"dingtalk","id":"dingtalk","depth":3,"charIndex":-1},{"text":"alertmanager","id":"alertmanager","depth":3,"charIndex":-1},{"text":"prometheus","id":"prometheus","depth":3,"charIndex":-1},{"text":"grafana","id":"grafana","depth":3,"charIndex":-1},{"text":"部署","id":"部署","depth":3,"charIndex":-1},{"text":"grafana配置kubernetes数据源","id":"grafana配置kubernetes数据源","depth":3,"charIndex":-1},{"text":"告警测试","id":"告警测试","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"3.其他参考文档","content":"使用Prometheus监控Kubernetes#\n\n以下操作均是在prometheus名称空间内进行。\n\n\n\n\n1.部署Prometheus#\n\n\n1.1 使用ConfigMap管理Prometheus配置#\n\n\n1.1.1创建config.yaml文件#\n\n\n\n\n1.1.2创建ConfigMap#\n\n\n\n\n1.2 使用Deployment部署Prometheus#\n\n\n1.2.1创建prometheus_deploy.yaml文件#\n\n\n\n\n1.2.2 创建prometheus Deployment与Service#\n\n\n\n\n1.3访问Prometheus服务#\n\n\n\n至此，可以通过http://10.1.93.190:30525/ 查看部署的Prometheus服务。\n\n\n\n\n2.Kubernetes下的服务发现#\n\n原理：==Prometheus通过与kubernetes API的交互，实现动态发现kubernetes中部署的所有可监控的目标资源。==\n\n\n2.1kubernetes访问授权#\n\n为了能够让Prometheus能够访问受到认证保护的Kubernetes\nAPI，我们需要对Prometheus进行访问授权。授权方法为：定义ClusterRole并赋予相应访问权限 --->创建ServiceAccount\n--->将ServiceAccount与ClusterRole进行绑定(即创建ClusterRoleBinding)。可以通过yaml文件完成以上操作。\n\n\n2.2.1创建rbac.yaml文件#\n\n注意：ClusterRole是全局的，不需要指定namespace；ServiceAccount是属于特定名称空间的，需要指定名称空间(prometheus)。\n\n\n\n\n2.2.2 访问授权#\n\n\n\n\n2.2使用指定的ServiceAccount创建Pod#\n\n\n2.2.1修改prometheus_deploy.yaml文件#\n\n\n\n\n2.2.2 升级Deployment#\n\n\n\n\n2.2.3 查看证书#\n\n指定ServiceAccount创建的Pod，会自动将用于访问Kubernetes API的CA证书以及当前账户对应的访问令牌文件挂载到Pod实例的\n/var/run/secrets/kubernetes.io/serviceaccount/ 目录下：\n\n\n\n\n2.3服务发现#\n\n目前，Prometheus通过Kubernetes\nAPI目前主要支持5种服务发现模式，包括Node、Service、Pod、Endpoints、Ingress。\n\n\n2.3.1部署Node Exporter#\n\n在Prometheus的架构设计中，Prometheus\nserver并不直接服务监控的特定目标，其主要负责数据的收集、存储以及对外提供数据查询支持。因此，为了能够监控到某些东西(如主机的CPU使用率)，我们需要使用N\node Exporter。==Prometheus周期性的从Node\nExporter暴露的HTTP服务地址(通常是http://IP:port/netrices)拉取监控样本数据。==\n\n2.3.1.1创建node_exporter.yaml文件#\n\n\n\n2.3.1.2创建Node Exporter DaemonSet与Service#\n\n\n\n\n2.3.2修改config.yaml文件#\n\n以下通过修改config.yaml文件实现Prometheus对以上5种服务的监控：\n\n\n\n\n2.3.3更新Prometheus#\n\n\n\n\n2.3.4访问Prometheus服务#\n\n2.3.4.1 访问Service Discovery页面#\n\nPrometheus更新完成后，访问http://10.1.93.190:30525/，通过`Status --->Service\nDiscovery页面，可以查看到Prometheus监控到Kubernetes的Node、Service、Pod、Endpoints、Ingress`\n5种资源对象了。\n\n\n\n2.3.4.2访问Targets页面#\n\n\n\n附：关于以上红色错误信息，可以后期研究prometheus.yml文件中的relabel_configs编写规则进行改正。\n\n\n3.其他参考文档#\n\nk8s 部署prometheus+grafana：https://blog.csdn.net/vic_qxz/article/details/109347645\n\n其中prometheus/config.yaml 文件中的IP需要改成自己的IP。","routePath":"/tang/Prometheus/2","lang":"","toc":[{"text":"1.1 使用ConfigMap管理Prometheus配置","id":"11-使用configmap管理prometheus配置","depth":2,"charIndex":74},{"text":"1.1.1创建config.yaml文件","id":"111创建configyaml文件","depth":3,"charIndex":107},{"text":"1.1.2创建ConfigMap","id":"112创建configmap","depth":3,"charIndex":133},{"text":"1.2 使用Deployment部署Prometheus","id":"12-使用deployment部署prometheus","depth":2,"charIndex":155},{"text":"1.2.1创建prometheus_deploy.yaml文件","id":"121创建prometheus_deployyaml文件","depth":3,"charIndex":187},{"text":"1.2.2 创建prometheus Deployment与Service","id":"122-创建prometheus-deployment与service","depth":3,"charIndex":224},{"text":"1.3访问Prometheus服务","id":"13访问prometheus服务","depth":2,"charIndex":267},{"text":"2.1kubernetes访问授权","id":"21kubernetes访问授权","depth":2,"charIndex":438},{"text":"2.2.1创建rbac.yaml文件","id":"221创建rbacyaml文件","depth":3,"charIndex":650},{"text":"2.2.2 访问授权","id":"222-访问授权","depth":3,"charIndex":756},{"text":"2.2使用指定的ServiceAccount创建Pod","id":"22使用指定的serviceaccount创建pod","depth":2,"charIndex":772},{"text":"2.2.1修改prometheus_deploy.yaml文件","id":"221修改prometheus_deployyaml文件","depth":3,"charIndex":803},{"text":"2.2.2 升级Deployment","id":"222-升级deployment","depth":3,"charIndex":840},{"text":"2.2.3 查看证书","id":"223-查看证书","depth":3,"charIndex":864},{"text":"2.3服务发现","id":"23服务发现","depth":2,"charIndex":1008},{"text":"2.3.1部署Node Exporter","id":"231部署node-exporter","depth":3,"charIndex":1102},{"text":"2.3.1.1创建node_exporter.yaml文件","id":"2311创建node_exporteryaml文件","depth":4,"charIndex":1330},{"text":"2.3.1.2创建Node Exporter DaemonSet与Service","id":"2312创建node-exporter-daemonset与service","depth":4,"charIndex":1364},{"text":"2.3.2修改config.yaml文件","id":"232修改configyaml文件","depth":3,"charIndex":1410},{"text":"2.3.3更新Prometheus","id":"233更新prometheus","depth":3,"charIndex":1480},{"text":"2.3.4访问Prometheus服务","id":"234访问prometheus服务","depth":3,"charIndex":1503},{"text":"2.3.4.1 访问Service Discovery页面","id":"2341-访问service-discovery页面","depth":4,"charIndex":1525},{"text":"2.3.4.2访问Targets页面","id":"2342访问targets页面","depth":4,"charIndex":1712}],"domain":"","frontmatter":{},"version":""},{"id":103,"title":"","content":"","routePath":"/tang/Prometheus/3","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":104,"title":"4.函数","content":"ERROR\n\n%s\n\n\n\n","routePath":"/tang/Python/1","lang":"","toc":[{"text":"2.1标准数据类型","id":"21标准数据类型","depth":2,"charIndex":-1},{"text":"2.2 Python数据类型转换","id":"22-python数据类型转换","depth":2,"charIndex":-1},{"text":"2.3 数字类型Number","id":"23-数字类型number","depth":2,"charIndex":-1},{"text":"2.3.1 数学函数","id":"231-数学函数","depth":3,"charIndex":-1},{"text":"2.3.2  随机函数","id":"232--随机函数","depth":3,"charIndex":-1},{"text":"2.4字符串","id":"24字符串","depth":2,"charIndex":-1},{"text":"2.4.1 字符串格式化","id":"241-字符串格式化","depth":3,"charIndex":-1},{"text":"2.4.1.1 字符串格式化符号","id":"2411-字符串格式化符号","depth":4,"charIndex":-1},{"text":"2.4.1.2 格式化操作符辅助指令","id":"2412-格式化操作符辅助指令","depth":4,"charIndex":-1},{"text":"2.4.1.3 str.format()","id":"2413-strformat","depth":4,"charIndex":-1},{"text":"2.4.2 三引号","id":"242-三引号","depth":3,"charIndex":-1},{"text":"2.4.3 内置函数","id":"243-内置函数","depth":3,"charIndex":-1},{"text":"3.1 时间戳","id":"31-时间戳","depth":2,"charIndex":-1},{"text":"3.2 获取当前时间","id":"32-获取当前时间","depth":2,"charIndex":-1},{"text":"3.3 获取格式化时间","id":"33-获取格式化时间","depth":2,"charIndex":-1},{"text":"4.1 参数传递","id":"41-参数传递","depth":2,"charIndex":-1},{"text":"4.2 参数类型","id":"42-参数类型","depth":2,"charIndex":-1},{"text":"4.3 匿名函数","id":"43-匿名函数","depth":2,"charIndex":-1},{"text":"4.4 return 语句","id":"44-return-语句","depth":2,"charIndex":-1},{"text":"4.5强制位置参数","id":"45强制位置参数","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":105,"title":"1.pip使用清华园下载package","content":"#\n\n","routePath":"/tang/Python/2","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":106,"title":"附：零零散散小知识","content":"事件的修饰符\n\n--------------------------------------------------------------------------------\n\n\n阻止默认事件\n\n点击a标签，只弹出alert，不跳转\n点我提示信息\n\n--------------------------------------------------------------------------------\n\n\n阻止冒泡事件\n\n外层div和内层button都有点击事件showInfo。点击button时，只调用一次showInfo函数\n点我提示信息\n\n--------------------------------------------------------------------------------\n\n\n事件只触发一次\n\n只有在第一次点击button时，才会调用showInfo函数\n点我提示信息\n\n--------------------------------------------------------------------------------\n\n\n使用事件捕获模式\n\n外层div和内层button都有点击事件showMsg。点击button时，先调用外层div的点击事件，再调用内层button的点击事件\n点我提示信息\n\n--------------------------------------------------------------------------------\n\n\n只有event.target是当前操作的元素时，才触发事件\n\n外层div和内层button都有点击事件showMsg。点击button时，不会调用外层div的点击事件，只有点击外层div时才会触发\n点我提示信息\n\n--------------------------------------------------------------------------------\n\n\n事件的默认行为立即执行，无需等待事件回调执行完毕\n\n * 1\n * 2\n * 3\n * 4\n * 5\n * 6\n * 7\n * 8\n\n姓：\n\n名：\n\n全名1：{{fullName1}}\n\n全名2：{{fullName2}}\n\n\n今天天气很{{info}}\n\n切换天气\n\n\nmsg.a的值为：{{msg.a}}\n\n点我执行a+1\nHello, Vue\n\nHello, Vue\n\nHello, Vue\n\nHello, Vue\n\nHello, Vue\n\nHello, Vue\n\n\n\n人员列表\n\n * {{p.name}} -- {{p.age}} -- {{p.sex}}\n\n\n人员列表\n\n * {{p.name}} -- {{p.age}} -- {{p.sex}}\n\n\n人员列表\n\n年龄升序 年龄降序 原顺序\n * {{p.name}} -- {{p.age}} -- {{p.sex}}\n\n\n当前时间为：{{time | timeFormatter}}\n\n\n当前日期为：{{time | timeFormatter('YYYY年MM月DD日') | mySlice}}\n\n\n{{name}}\n\n\n当前的n值是：\n\n\n放大10倍后的n值是：\n\n点我n+1\n\n--------------------------------------------------------------------------------","routePath":"/tang/Vue/1","lang":"","toc":[{"text":"5.1 Object.defineproperty方法","id":"51-objectdefineproperty方法","depth":2,"charIndex":-1},{"text":"5.2 数据代理","id":"52-数据代理","depth":2,"charIndex":-1},{"text":"5.3  Vue中的数据代理","id":"53--vue中的数据代理","depth":2,"charIndex":-1},{"text":"6.1 事件的基本使用","id":"61-事件的基本使用","depth":2,"charIndex":-1},{"text":"6.2 事件修饰符","id":"62-事件修饰符","depth":2,"charIndex":-1},{"text":"6.3 按键修饰符","id":"63-按键修饰符","depth":2,"charIndex":-1},{"text":"8.1 基础监视","id":"81-基础监视","depth":2,"charIndex":-1},{"text":"8.2 深度监视","id":"82-深度监视","depth":2,"charIndex":-1},{"text":"8.3 监视属性和计算属性的对比","id":"83-监视属性和计算属性的对比","depth":2,"charIndex":-1},{"text":"9.1 绑定class样式","id":"91-绑定class样式","depth":2,"charIndex":-1},{"text":"9.2 绑定style样式","id":"92-绑定style样式","depth":2,"charIndex":-1},{"text":"11.1 v-for基本用法","id":"111-v-for基本用法","depth":2,"charIndex":-1},{"text":"11.2 key内部原理","id":"112-key内部原理","depth":2,"charIndex":-1},{"text":"11.3 列表过滤","id":"113-列表过滤","depth":2,"charIndex":-1},{"text":"11.4 列表排序","id":"114-列表排序","depth":2,"charIndex":-1},{"text":"11.5 Vue数据监测原理","id":"115-vue数据监测原理","depth":2,"charIndex":-1},{"text":"1)Vue模板解析时间","id":"1vue模板解析时间","depth":2,"charIndex":-1},{"text":"2)js第三方库","id":"2js第三方库","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":107,"title":"附：零零散散小知识","content":"{{msg}}\n\n--------------------------------------------------------------------------------\n\n--------------------------------------------------------------------------------\n\n","routePath":"/tang/Vue/2","lang":"","toc":[{"text":"1.1 模块","id":"11-模块","depth":2,"charIndex":-1},{"text":"1.2 组件","id":"12-组件","depth":2,"charIndex":-1},{"text":"1.3 模块化","id":"13-模块化","depth":2,"charIndex":-1},{"text":"1.4 组件化","id":"14-组件化","depth":2,"charIndex":-1},{"text":"1.5 非单文件组件","id":"15-非单文件组件","depth":2,"charIndex":-1},{"text":"1.6 单文件组件","id":"16-单文件组件","depth":2,"charIndex":-1},{"text":"2.1 组件的基本使用","id":"21-组件的基本使用","depth":2,"charIndex":-1},{"text":"2.2 组件几个注意点","id":"22-组件几个注意点","depth":2,"charIndex":-1},{"text":"2.3 VueComponent构造函数","id":"23-vuecomponent构造函数","depth":2,"charIndex":-1},{"text":"2.4 一个重要的内置关系","id":"24-一个重要的内置关系","depth":2,"charIndex":-1},{"text":"2.5 单文件组件","id":"25-单文件组件","depth":2,"charIndex":-1},{"text":"3.1 初始化脚手架","id":"31-初始化脚手架","depth":2,"charIndex":-1},{"text":"3.2 vue项目各文件解释","id":"32-vue项目各文件解释","depth":2,"charIndex":-1},{"text":"3.3 main.js中的rander函数解释","id":"33-mainjs中的rander函数解释","depth":2,"charIndex":-1},{"text":"3.4 脚手架文件结构","id":"34-脚手架文件结构","depth":2,"charIndex":-1},{"text":"3.5 vue.config.js配置文件","id":"35-vueconfigjs配置文件","depth":2,"charIndex":-1},{"text":"3.6 ref属性","id":"36-ref属性","depth":2,"charIndex":-1},{"text":"3.7 props配置项","id":"37-props配置项","depth":2,"charIndex":-1},{"text":"3.8 mixin（混入/混合）","id":"38-mixin混入混合","depth":2,"charIndex":-1},{"text":"3.9 插件","id":"39-插件","depth":2,"charIndex":-1},{"text":"3.10 scoped样式","id":"310-scoped样式","depth":2,"charIndex":-1},{"text":"3.11 lang属性","id":"311-lang属性","depth":2,"charIndex":-1},{"text":"3.12 Todo-list案例","id":"312-todo-list案例","depth":2,"charIndex":-1},{"text":"3.13 webStorage","id":"313-webstorage","depth":2,"charIndex":-1},{"text":"3.14 Vue中的自定义事件","id":"314-vue中的自定义事件","depth":2,"charIndex":-1},{"text":"3.15 全局事件总线","id":"315-全局事件总线","depth":2,"charIndex":-1},{"text":"3.16 消息订阅与发布","id":"316-消息订阅与发布","depth":2,"charIndex":-1},{"text":"3.17 $nextTick","id":"317-nexttick","depth":2,"charIndex":-1},{"text":"3.18 过渡与动画","id":"318-过渡与动画","depth":2,"charIndex":-1},{"text":"4.1 vue脚手架配置代理","id":"41-vue脚手架配置代理","depth":2,"charIndex":-1},{"text":"4.2 vue-resource","id":"42-vue-resource","depth":2,"charIndex":-1},{"text":"4.3 slot插槽","id":"43-slot插槽","depth":2,"charIndex":-1},{"text":"5.1 理解vuex","id":"51-理解vuex","depth":2,"charIndex":-1},{"text":"5.2 原理图","id":"52-原理图","depth":2,"charIndex":-1},{"text":"5.3 搭建vuex环境","id":"53-搭建vuex环境","depth":2,"charIndex":-1},{"text":"5.4 getters配置项","id":"54-getters配置项","depth":2,"charIndex":-1},{"text":"5.5 四个map方法的使用","id":"55-四个map方法的使用","depth":2,"charIndex":-1},{"text":"5.5 模块化编程+namespace","id":"55-模块化编程namespace","depth":2,"charIndex":-1},{"text":"6.1 相关概念","id":"61-相关概念","depth":2,"charIndex":-1},{"text":"6.2 基本路由","id":"62-基本路由","depth":2,"charIndex":-1},{"text":"6.3 嵌套（多级）路由","id":"63-嵌套多级路由","depth":2,"charIndex":-1},{"text":"6.4 命名路由","id":"64-命名路由","depth":2,"charIndex":-1},{"text":"6.5 路由传参","id":"65-路由传参","depth":2,"charIndex":-1},{"text":"6.6 路由的props配置","id":"66-路由的props配置","depth":2,"charIndex":-1},{"text":"6.7 router-link的replace属性","id":"67-router-link的replace属性","depth":2,"charIndex":-1},{"text":"6.8 编程式路由导航","id":"68-编程式路由导航","depth":2,"charIndex":-1},{"text":"6.9 缓存路由组件","id":"69-缓存路由组件","depth":2,"charIndex":-1},{"text":"6.10 两个新的生命周期钩子","id":"610-两个新的生命周期钩子","depth":2,"charIndex":-1},{"text":"6.11 路由守卫","id":"611-路由守卫","depth":2,"charIndex":-1},{"text":"6.12 路由器的两种工作模式","id":"612-路由器的两种工作模式","depth":2,"charIndex":-1},{"text":"7.1 移动端","id":"71-移动端","depth":2,"charIndex":-1},{"text":"7.2 PC端","id":"72-pc端","depth":2,"charIndex":-1},{"text":"①组件通信--父传子","id":"组件通信--父传子","depth":2,"charIndex":-1},{"text":"②组件通信--子传父","id":"组件通信--子传父","depth":2,"charIndex":-1},{"text":"③组件通信--兄弟通信","id":"组件通信--兄弟通信","depth":2,"charIndex":-1},{"text":"④函数中用了一个data中没有声明过的变量","id":"函数中用了一个data中没有声明过的变量","depth":2,"charIndex":-1},{"text":"⑤生命周期钩子","id":"生命周期钩子","depth":2,"charIndex":-1},{"text":"⑥ 其他相关知识","id":"-其他相关知识","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":108,"title":"6.Vue3.0和Vue2.x对比","content":"Vue3快速入门#\n\n\n1.创建Vue3.0工程#\n\n\n1.1 使用vue-cli创建#\n\n==创建Vue3工程，需要保证@vue/cli的版本在4.5.0以上==\n\n==官方文档：==https://cli.vuejs.org/zh/guide/creating-a-project.html\n\n\n\n\n1.2使用vite创建#\n\n> vite简介\n\n==vite官网：==https://vitejs.cn/\n\n> 概念\n\n新一代前端构建工具\n\n> 优势\n\n * 开发环境中，无需打包，可快速冷启动\n * 轻量快速的热重载（HMR）\n * 真正的按需编译，不再等待整个应用编译完成\n\n> 传统构建与vite构建对比图\n\n\n\n> 创建过程\n\n\n\n\n1.3 分析工程结构#\n\n==以下分析均使用vue-cli创建的项目==\n\n> main.js文件\n\n\n\n> App.vue文件\n\n\n\n\n2.常用Composition API#\n\n\n2.1 拉开序幕的setup#\n\n> 什么是setup\n\n * Vue3.0中一个新的==配置项==，值为一个函数。\n * 是所有Composition API“表演的舞台”\n * 组件中所用到的数据、方法等，均要配置在setup中\n\n> setup函数的两种返回值\n\n * 返回一个对象：对象中的属性、方法，在模板中均可直接使用（重点关注！！！）\n   \n   \n\n * 返回一个渲染函数：可以自定义渲染内容（了解）\n   \n   \n\n> 注意事项\n\n * 尽量不要与Vue2.x配置混用\n   * Vue2.x配置（data、methods、computed...）可以访问到setup中的属性、方法\n   * setup中不能访问到Vue2.x配置（data、methods、computed...）\n   * 如果重名，setup优先\n * setup不能是一个async函数，因为async函数返回值不再是return的对象，而是promise，模板看不到return对象中的属性（后期也可以返\n   回一个Promise实例，但需要Suspense和异步组件的配合）\n\n\n2.2 ref函数#\n\n> 作用\n\n定义一个响应式数据\n\n> 使用方法\n\n * 声明变量：let xxx = ref(initValue))(创建了一个包含响应式数据的引用对象（reference对象，简称ref对象）)\n   \n   需要引入ref函数：``\n\n * js中操作数据：xxx.value\n\n * 模板中读取数据：\n   xxx\n   (不需要.value)\n\n * 完整代码\n   \n   \n\n> 备注\n\n * ref()接收的数据可以是基本类型，也可以是对象类型\n * 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成\n * 对象类型的数据：内部“求助”了Vue3.0中的一个新函数---reactive函数\n\n\n2.3 reactive函数#\n\n> 作用\n\n定义一个==对象类型==的响应式数据\n\n只能定义对象类型的数据，不能定义基本类型的数据\n\n> 语法\n\n * 声明变量：const 代理对象 = reactive(源对象)\n   \n   需要引入reactive函数：``\n\n * JS使用：console.log(代理对象)\n\n * 模板中使用：\n   {{代理对象}}\n\n==接收一个对象或数组，返回一个代理对象（Proxy的实例对象，简称proxy对象）==\n\n> 说明\n\n * reactive定义的响应式数据是“深层次的”\n * 内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作\n\n\n2.4 Vue3.0中的响应式原理#\n\n> vue2.x的响应式\n\n * 实现原理\n   \n   * 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）\n     \n     \n   \n   * 数组对象：通过重写更新数组的一系列方法来实现拦截（对数据的变更方法进行包裹）\n\n * 存在问题\n   \n   * 新增属性、删除属性，界面不会更新\n     \n     \n   \n   * 直接通过下标修改数组，界面 不会自动更新\n     \n     \n\n> Vue3.0响应式\n\n * 实现原理\n   \n   * 通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等\n   \n   * 通过Reflect（反射）：对源对象的属性进行操作\n     \n     \n\n\n2.5 setup的两个注意点#\n\n> setup执行时机\n\n在beforeCreate之前执行一次，this是undefined\n\n> setup参数\n\n * props：值为对象，包含组件外部传递过来，且在组件内部声明接收了的属性\n   \n   \n\n * contetx：上下文对象，包含以下属性\n   \n   * attrs：值为对象，包含组件外部传递过来，但是props配置没有声明的属性，相当于vue2.x中的vm.$attrs\n   \n   * slots：收到的插槽内容，相当于vue2.x中的vm.$slots\n   \n   * emit：分发自定义事件的函数，相当于vue2.x中的vm.$emit\n\n\n2.6 reactive对比ref#\n\n * 从定义数据的角度对比\n   \n   * ref用来定义基本类型数据\n   * reactive用来定义对象或数组类型数据\n   * 备注：ref也可以用来定义对象或数组类型数据，它内部会通过reactive转化为代理对象\n\n * 从原理的角度对比\n   \n   * ref通过Object.defineProperty()的get和set来实现响应式（数据劫持）\n   * reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据\n\n * 从使用的角度对比\n   \n   * ref定义的数据：js中操作数据需要.value，模板中使用时不需要.value\n   * reactive定义的数据：在js和模板中操作和使用，均不需要.value\n\n\n2.7 计算函数computed#\n\n==与Vue2.x中computed配置功能一致==\n\n> 使用方法\n\n\n\n\n2.8 监视函数watch#\n\n==与vue2.x中的watch配置共一致==\n\n> 两个小“坑”：\n\n * ==监视reactive定义的响应式数据时，oldValue无法正确获取，强制开启了深度监视（deep配置无效）==\n * ==监视reactive定义的响应式数据中的某个属性（对象类型）时，deep配置有效==\n\n> 语法\n\nwatch(prop, function, config)\n\n * prop：要监视的变量\n * function：(newValue, oldValue) => {}，变量发生变化时的回调\n * config：是个对象，编写watch的一些配置，如{immediate: true; deep: true}，可以为空\n\n> 具体代码\n\n\n\n\n2.9 监视函数watchEffect#\n\n> 和watch的对比\n\n * watch既要指明监视的属性，也要指明监视的回调\n * watchEffect不用指明监视的属性，监视回调函数中用到哪个属性，就会监视哪个属性\n\n> 和computed的对比\n\nwatchEffect有点像computed，但二者有如下区别：\n\n * computed注重的是计算出来的值（回调函数的返回值），所以必须要写返回值\n * watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值\n\n> 语法\n\nwatchEffect(() => {})\n\n> 具体代码\n\n\n\n\n2.10 生命周期#\n\n\n\n> 注意\n\nVue3.0可以继续使用Vue2.x中的生命周期钩子，但有两个被更名：\n\n * beforeDestroy改名为beforeUnmount\n * destroyed改名为unmounted\n\n> Vue3.0中Composition API形式的生命周期钩子，与Vue3.0中钩子对应如下\n\n * beforeCreate===>setUp()\n * created===>setUp()\n * beforeMount===>onBeforeMount\n * mounted===>onMounted\n * beforeUpdate===>onBeforeUpdate\n * updated===>onUpdated\n * beforeUnmount===>onBeforeUnmount\n * unmounted===>onUnmounted\n\n\n2.11 自定义hook函数#\n\n> 概念\n\n * hook本质是一个函数，把setup函数中使用的Composition API进行了封装\n * 类似于vue2.x中的mixin\n * 自定义hook的优势：复用代码，让setup中的逻辑更清晰易懂\n * 个人理解：抽取setup中的可以实现某个具体功能的代码，简化setup中的代码，同时也方便后期实现代码的复用\n\n> 具体例子\n\n==需求：获取鼠标点击的点的坐标==\n\n步骤如下：\n\n * 创建src/hooks文件夹，自定义的hook函数都存放在该路径下\n\n * 在src/hooks文件夹下，创建usePoint.js文件(一般hook函数的js文件命名方式均为useXXX.js)\n\n * 在usePoint.js文件中编写函数实现逻辑，并将函数暴露出去，代码如下：\n   \n   \n\n * 使用usePoint.js中的函数\n   \n   \n\n * 最终效果如下\n   \n   \n\n\n2.10 toRefs#\n\n> 作用\n\n创建一个ref对象，其value值指向另一个对象中的某个属性\n\n> 语法\n\nconst name = toRef(对象变量, '变量属性名')\n\n> 应用\n\n要将响应式对象中的某个属性单独提供给外部使用时\n\n> 扩展\n\ntoRefs和toRef功能一致，但可以批量创建多个ref对象，语法：toRefs(对象变量)\n\n==备注：==可以借助toRefs函数，简化模板编码\n\n\n\n\n3.其他Composition API#\n\n\n3.1 shallowReactive与shallowRef#\n\n> shallowReactive\n\n只处理对象最外层属性的响应式（浅响应式）\n\n> shallowRef\n\n只处理基本数据类型的响应式，不进行对象的响应式处理\n\n> 语法\n\n\n\n> 使用场景\n\n * shallowReactive：当一个对象结构比较深，但是只有外层属性才会发生变化\n * shallowRef：如果一个对象有数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换\n\n\n3.2 readonly与shallowReadonly#\n\n> readonly\n\n让一个响应式的数据变为只读（深只读）\n\n> shallowReadonly\n\n让一个响应式数据变为只读（浅只读）\n\n> 语法\n\n\n\n> 应用场景\n\n不希望数据被修改时\n\n> 注意事项\n\nreadonly与shallowReadonly也可以用来定义数据，但是定义出来的数据不是响应式的。如果想让响应式的数据变为只读，只能先用ref或reactiv\ne定义数据，然后再用readonly或者shallowReadonly定义数据变为只读。\n\n\n3.3 toRaw与markRow#\n\n> toRaw\n\n * 作用：将一个由reactive生成的响应式对象转为普通对象\n\n * 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的操作，不会引起页面刷新\n\n * 语法\n   \n   \n\n> markRow\n\n * 作用：标记一个对象，使其永远不会再成为响应式对象\n\n * 使用场景：\n   \n   * 1.有些值不应该被设置为响应式的，例如复杂的第三方类库\n   * 2.当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能\n\n * 语法：\n   \n   \n\n\n3.4 customRef#\n\n> 作用\n\n创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制\n\n> 语法\n\n\n\n> 栗子：自定义ref，实现防抖效果\n\n\n\n\n3.5 provide与inject#\n\n\n\n> 作用\n\n实现==祖组件与后代组件间==通信\n\n> 语法\n\n组组件中用provide选项提供数据，后代组件用inject选线来接收数据\n\n> 语法\n\n * 祖组件：\n   \n   \n\n * 后代组件：\n   \n   \n\n\n3.6 响应式数据的判断#\n\n * isRef：检查一个值是否为一个ref对象\n * isReactive ：检查一个对象是否是由reactive创建的响应式代理\n * isReadonly：检查一个对象是否是由readonly创建的只读代理\n * isProxy：检查一个对象是否是由reactive或者readonly创建的代理\n\n\n4.Composition API的优势#\n\n> Options API 存在的问题\n\n使用传统Options API时，新增或者修改一个需求，就需要在data、methods、computed等中分别进行修改\n\n> Composition API的优势\n\n可以自定义hook函数，更加优雅的组织代码，让功能相关的数据和函数更加有序的组织在一起\n\n\n5.新的组件#\n\n\n5.1 Fragment#\n\n * 在vue2中：组件必须有一个根标签\n * 在Vue3中：组件可以没有根标签。当不写根标签时，vue会将多个标签包含在一个Fragment虚拟元素中\n * 好处：减少标签层级，减少内存占用（理论上）\n\n\n5.2 teleport#\n\n==teleport是将组件html结构移动到指定位置==\n\n\n\n\n5.3 Suspense#\n\n> 使用场景\n\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n> 使用步骤\n\n * 异步引入组件\n   \n   \n\n * 使用Suspense包裹组件，并配置好default和fallback插槽\n   \n   * default：默认插槽。组件往这里边放\n   * fallback：由于各种原因，插槽未加载出来的提示信息往这里边放\n   \n   \n\n> 完整栗子\n\n * APP 组件\n   \n   \n\n * Son组件\n   \n   \n\n\n6.Vue3.0和Vue2.x对比#\n\n * ==全局API的转移==\n   \n   Vue3.0将Vue2.x中的全局API（Vue.xxx）调整到了应用实例（app）上\n   \n   VUE2.X全局API（VUE）           VUE3.0实例API（APP）\n   Vue.config.xxx             app.config.xxx\n   Vue.config.productionTip   移除\n   Vue.component              app.component\n   Vue.directive              app.directive\n   Vue.mixin                  app.mixin\n   Vue.use                    app.use\n   Vue.prototype              app.config.globalProperties\n\n * ==data选项应始终被声明为一个函数==\n\n * ==过渡（动画）类名的改变==\n   \n   VUE2.X       VUE3.0\n   v-enter      v-enter-from\n   v-leave-to   v-leave-to\n   v-leave      v-leave-from\n   v-enter-to   v-enter-to\n\n * ==移除keyCode作为v-on的修饰符，同时也不再支持config.keyCode==\n\n * ==移除v-on.native修饰符，自定义事件用emits属性配置==\n   \n   * 父组件中绑定事件\n     \n     \n   \n   * 子组件中声明自定义事件\n     \n     \n\n * ==移除过滤器filter==\n   \n   过滤器虽然看起来方便，但它需要一个自定义语法，打破大括号内表达式“只是JavaScript”的假设，这不仅有学习成本，还有实现成本！\n   建议用方法调用或者计算属性去替换过滤器。","routePath":"/tang/Vue/3","lang":"","toc":[{"text":"1.1 使用vue-cli创建","id":"11-使用vue-cli创建","depth":2,"charIndex":27},{"text":"1.2使用vite创建","id":"12使用vite创建","depth":2,"charIndex":151},{"text":"1.3 分析工程结构","id":"13-分析工程结构","depth":2,"charIndex":323},{"text":"2.1 拉开序幕的setup","id":"21-拉开序幕的setup","depth":2,"charIndex":415},{"text":"2.2 ref函数","id":"22-ref函数","depth":2,"charIndex":907},{"text":"2.3 reactive函数","id":"23-reactive函数","depth":2,"charIndex":1248},{"text":"2.4 Vue3.0中的响应式原理","id":"24-vue30中的响应式原理","depth":2,"charIndex":1553},{"text":"2.5 setup的两个注意点","id":"25-setup的两个注意点","depth":2,"charIndex":1931},{"text":"2.6 reactive对比ref","id":"26-reactive对比ref","depth":2,"charIndex":2242},{"text":"2.7 计算函数computed","id":"27-计算函数computed","depth":2,"charIndex":2611},{"text":"2.8 监视函数watch","id":"28-监视函数watch","depth":2,"charIndex":2669},{"text":"2.9 监视函数watchEffect","id":"29-监视函数watcheffect","depth":2,"charIndex":3010},{"text":"2.10 生命周期","id":"210-生命周期","depth":2,"charIndex":3295},{"text":"2.11 自定义hook函数","id":"211-自定义hook函数","depth":2,"charIndex":3690},{"text":"2.10 toRefs","id":"210-torefs","depth":2,"charIndex":4114},{"text":"3.1 shallowReactive与shallowRef","id":"31-shallowreactive与shallowref","depth":2,"charIndex":4347},{"text":"3.2 readonly与shallowReadonly","id":"32-readonly与shallowreadonly","depth":2,"charIndex":4577},{"text":"3.3 toRaw与markRow","id":"33-toraw与markrow","depth":2,"charIndex":4841},{"text":"3.4 customRef","id":"34-customref","depth":2,"charIndex":5107},{"text":"3.5 provide与inject","id":"35-provide与inject","depth":2,"charIndex":5193},{"text":"3.6 响应式数据的判断","id":"36-响应式数据的判断","depth":2,"charIndex":5328},{"text":"5.1 Fragment","id":"51-fragment","depth":2,"charIndex":5682},{"text":"5.2 teleport","id":"52-teleport","depth":2,"charIndex":5801},{"text":"5.3 Suspense","id":"53-suspense","depth":2,"charIndex":5850}],"domain":"","frontmatter":{},"version":""},{"id":109,"title":"Docker 进阶","content":"#\n\n\nDocker Compose#\n\n[DaoCloud | Docker 极速下载](http://get.daocloud.io/)\n\n\n简介#\n\n通过YAML文件，定义、运行多个容器。\n\n> 使用Docker Compose的三步骤：\n\n1.定义Dockerfile文件。\n\n2.编写docker-compose.yaml文件\n\n3.启动项目\n\n> 狂神说\n\nCompose是Docker官方开源项目，需要安装！\n\nCompose重要概念：\n\n * 服务Services：单个的容器/应用\n * 项目Project：一组关联的容器\n\n大神福利看\n\n\n安装#\n\n1.下载\n\n可以在http://get.daocloud.io/ 网站中找到国内下载地址\n\n\n\n\n\n2.授权\n\n\n\n3.验证是否安装成功\n\n\n\n\n\n\n体验#\n\n * 官方python计数器应用。Get started with Docker Compose | Docker Documentation\n\n * 搭建WordPress博客应用。Quickstart: Compose and WordPress | Docker Documentation\n\n\nDocker Swarm#\n\nHow nodes work | Docker Documentation\n\n\n安装#\n\n\n\n\nRaft协议#\n\n\n\n> 定义：保证大多数节点存活才可以使用。\n\n如果两主两从，挂了一个主节点，另外一个主节点也不能用了。\n\n如果三住一从，挂了一个主节点，另外两个可以使用；如果挂了两个主节点，另外一个也不能用了。\n\n\n体会#\n\n可以类比k8s。\n\n命令：docker service\n\n\n\n创建服务#\n\n\n\n> dokcer run 和 docker service 对比：\n\n * docker run：容器启动，单机版，不具有扩缩容功能\n * docker service：服务启动，集群操作，具有扩缩容功能\n\n==docker swarm创建的服务随机分配到各个节点上，包括master节点和node节点==\n\n> 副本服务与全局服务\n\n\n\n * 副本服务：只运行在worker节点上\n * 全局服务：既可运行在worker节点上，又可运行在manager节点上。默认为全局服务\n\n==可以使用--mode设置服务规则==\n\n\n\n动态扩缩容#\n\n> 两种方法\n\n * docker service update --replicas\n * docker service scale\n\n\n\n动态更新\n\n灰度发布（金丝雀发布）\n\n\n概念#\n\n> task：容器内的命令，细节任务！\n\n一个service可创建多个副本，每个副本都是一个task任务，每个task任务中运行一个容器。\n\n\n\n\n内部原理#\n\n\n\n\n网络模式#\n\n * Overlay：使得各个节点能够ping通，变成一个集群。\n\n * ingress：特殊的Overlay，具有负载均衡的功能。\n   \n   \n\n\n\n\nDocker Stack#\n\ndocker-compose 单击部署项目。\n\nDocker Stack 集群部署项目。\n\n\n\n\nDocker Secret#\n\n安全！配置密码，证书\n\n\n\n\nDocker Config#\n\n\n\n\n扩展到K8S#\n\n云原生时代\n\n超过10台服务器，首选k8s，而非docker swarm！\n\n先掌握go语言，在学习k8s会更好。\n\njava就是用go语言写的。\n\ngo的效率接近于c语言。","routePath":"/tang/docker/Docker","lang":"","toc":[{"text":"Docker Compose","id":"docker-compose","depth":2,"charIndex":3},{"text":"简介","id":"简介","depth":3,"charIndex":72},{"text":"安装","id":"安装","depth":3,"charIndex":279},{"text":"体验","id":"体验","depth":3,"charIndex":359},{"text":"Docker Swarm","id":"docker-swarm","depth":2,"charIndex":515},{"text":"安装","id":"安装-1","depth":3,"charIndex":570},{"text":"Raft协议","id":"raft协议","depth":3,"charIndex":578},{"text":"体会","id":"体会","depth":3,"charIndex":688},{"text":"创建服务","id":"创建服务","depth":4,"charIndex":724},{"text":"动态扩缩容","id":"动态扩缩容","depth":4,"charIndex":997},{"text":"概念","id":"概念","depth":3,"charIndex":1096},{"text":"内部原理","id":"内部原理","depth":3,"charIndex":1175},{"text":"网络模式","id":"网络模式","depth":3,"charIndex":1185},{"text":"Docker Stack","id":"docker-stack","depth":2,"charIndex":1271},{"text":"Docker Secret","id":"docker-secret","depth":2,"charIndex":1335},{"text":"Docker Config","id":"docker-config","depth":2,"charIndex":1366},{"text":"扩展到K8S","id":"扩展到k8s","depth":2,"charIndex":1385}],"domain":"","frontmatter":{},"version":""},{"id":110,"title":"docker搭建私有镜像仓库","content":"#\n\n\n1.下载镜像仓库镜像，并启动镜像仓库容器#\n\n\n\n\n2.虚拟机配置私有仓库地址#\n\n\n\n\n3.虚拟机重启docker#\n\n\n\n\n4.搭建成果展示#\n\n","routePath":"/tang/docker/docker搭建私有镜像仓库","lang":"","toc":[{"text":"1.下载镜像仓库镜像，并启动镜像仓库容器","id":"1下载镜像仓库镜像并启动镜像仓库容器","depth":2,"charIndex":3},{"text":"2.虚拟机配置私有仓库地址","id":"2虚拟机配置私有仓库地址","depth":2,"charIndex":29},{"text":"3.虚拟机重启docker","id":"3虚拟机重启docker","depth":2,"charIndex":48},{"text":"4.搭建成果展示","id":"4搭建成果展示","depth":2,"charIndex":67}],"domain":"","frontmatter":{},"version":""},{"id":111,"title":"gitlab 常用命令","content":"#\n\n\n1 本地创建分支并推送到远程#\n\n * 首先需要确保本地已有分支是干净的，没有需要commit的。可以使用git status 查看\n\n * 新建本地分支\n   \n   \n\n * 查看一下本地分支\n   \n   \n\n * 将本地分支推送到远程\n   \n   \n\n * 查看所有分支\n   \n   \n\n> 举例\n\n\n\n\n2 删除本地分支#\n\n\n\n\n3 删除远程分支#\n\n * 方法一：向远程分支推送一个空分支\n   \n   \n\n * 方法二：使用delete删除\n   \n   ","routePath":"/tang/gitlab/gitlab-commands","lang":"","toc":[{"text":"1 本地创建分支并推送到远程","id":"1-本地创建分支并推送到远程","depth":2,"charIndex":3},{"text":"2 删除本地分支","id":"2-删除本地分支","depth":2,"charIndex":162},{"text":"3 删除远程分支","id":"3-删除远程分支","depth":2,"charIndex":176}],"domain":"","frontmatter":{},"version":""},{"id":112,"title":"gitlab 报错","content":"#\n\n\n1 gitlab报503错误#\n\n> 报错描述\n\n\n\n> 解决步骤：\n\n1.查看gitlab状态\n\n\n\n\n\n2.从1中看到是gitaly down了，删掉/var/opt/gitlab/gitaly/gitaly.pid文件，重启即可\n\n\n\n","routePath":"/tang/gitlab/gitlab-error","lang":"","toc":[{"text":"1 gitlab报503错误","id":"1-gitlab报503错误","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":113,"title":"0 前言","content":"#\n\n本教程前17个章节涉及到的代码，请点击代码进行下载。","routePath":"/tang/java2/00_前言","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":114,"title":"1 Java语言概述","content":"#\n\n\n1.1 JDK 、JRE、JVM的关系#\n\n> JDK（Java Development Kit ）\n\n即Java开发工具包。\n\nJDK = JRE + Java开发工具（包括编译工具javac.exe、运行工具java.exe、文档工具javadoc.exe、打包工具jar.exe等）\n\n> JRE（Java Runtime Environment ）\n\n即Java运行时环境。\n\nJRE = JVM + Java核心类库\n\n> JDK 、JRE、JVM的关系\n\n","routePath":"/tang/java2/01_Java语言概述","lang":"","toc":[{"text":"1.1 JDK 、JRE、JVM的关系","id":"11-jdk-jrejvm的关系","depth":3,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":115,"title":"2 Java基本语法","content":"#\n\n\n2.1 变量的分类#\n\n> 按照数据类型分\n\n\n\n * 基本数据类型\n   \n   类型        占用存储空间      表数范围                                备注\n   byte      1字节=8bit位   [-128, 127]                         \n   short     2字节         [$-2^{15}$, $2^{15}-1$]             \n   int       4字节         [$-2^{32}$, $2^{32}-1$]             \n   long      8字节         [$-2^{64}$, $2^{64}-1$]             声明变量时，需要在后边加上l或L\n   float     4字节         [$-3.403E^{38}$, $3.403E^{38}$]     单精度，尾数可以精确到7位有效数字；数值范围比long还大\n   double    8字节         [$-1.798E^{308}$, $1.798E^{308}$]   双精度（默认的浮点型）\n   char      2字节（1个字符）   --                                  声明时，通常使一对单引号；char c = '';//编译不通过\n   boolean   --          --                                  取值只能是true或false\n\n * 引用数据类型\n   \n   * 类\n   * 接口\n   * 数组\n\n> 按声明的位置的不同分\n\n\n\n注： 二者在初始化值方面的异同：\n\n * 同：都有声明周期\n * 异：局部变量除形参外，需显示初始化\n\n\n2.2 基本数据类型间的运算规则#\n\n * 自动类型提升\n   \n   byte、char、short-->int-->long-->float-->double\n   \n   结论：\n   \n   * 容量小的数据类型的变量与容量大的做运算时，结果自动提升为容量大的数据类型的数据\n   * 特别的，大概byte、char、short三种类型的变量做运算时，结果为int型\n\n * 强制类型转换\n   \n   强制类型转换，可能会造成经度的损失\n   \n   short s = 128; byte b = (byte)s，b的值为-128，也是一种精度的损失\n\n\n2.3 关于进制#\n\n进制     数值范围      写法         备注\n二进制    0,1       以0b或0B开头   \n十进制    0-9                  \n八进制    0-7       以0开头       \n十六进制   0-9及A-F   以0x或0X开头   A-F不区分大小写\n\n> 二进制\n\n计算机底层都是以补码的形式存储数据。\n\n正数的原码、反码、补码都是一样的，负数的反码是除符号位，对原码各位取反，补码则为反码+1。\n\n\n2.4 ++与--#\n\n * 前++（前--）：先自增（减）1，再运算\n   \n   \n\n * 后++（后--）：先运算，再自增（减）1\n   \n   \n\n++和--不会改变数据类型，如以下代码能正常运行：\n\n\n\n\n2.5 赋值运算符#\n\n=、+=、-=、*=、/=、%=\n\n * +=、-=、*=、/=、%=不会改变数据类型\n   \n   \n\n * 与++相关的计算题\n   \n   \n\n\n2.6 逻辑运算符#\n\n&、 &&、 |、 ||、 !、 ^\n\n * &、 &&的对比\n   \n   &称逻辑与，&&称短路与\n   \n   * 相同点1：二者运算结果相同\n   * 相同点2：当符号左边是true时，二者都会执行符号右边的运算\n   * 不同点：当符号左边是false时，&会继续执行符号右边运算，&&不再执行符号右边的运算\n\n * |、 ||的对比\n   \n   |称逻辑或，||称短路或\n   \n   * 相同点1：二者运算结果相同\n   * 相同点2：当符号左边是false时，二者都会执行符号右边的运算\n   * 不同点：当符号左边是true时，|会继续执行符号右边运算，||不再执行符号右边的运算\n\n开发中推荐使用短路与、短路或\n\n\n2.7 位运算符#\n\n运算符   名称      细节                              备注\n<<    左移运算符   空位补0，被移除的最高位丢弃                  在一定范围内，每向左移1位，相当于 * 2\n>>    右移运算符   若最高位是0，右移后空位补0；若最高位是1，右移后空位补1   在一定范围内，每向右移1位，相当于 / 2\n>>>   无符号右移   最高位无论是0或1，空位都补0                 后边讲\n&     与       每一位只要有0就是0                      \n|     或       每一位只要有1就是1                      \n^     异或      每一位只要不同就是1                      公式：k = (k ^n)^n\n~     取反      包括符号位在内，每一位0变1，1变0              \n\n> 面试题\n> \n> 最高效方式计算2 * 8？\n\n答：2 << 3或 8 << 1\n\n\n2.8 三元运算符#\n\n三元运算符的效率比if-else高。\n\n\n2.9 Scanner类#\n\n> 作用\n\n获取用户输入的变量\n\n> 用法\n\n\n\n\n2.10 switch-case#\n\nswitch中的表达式，只能是一下6种数据类型之一：byte、short、char、int、枚举、String（JDK7之后）\n\n\n2.11 break和continue#\n\n> 二者区别\n\n * break可以用在switch-case语句和循环语句中。continue只能用在循环语句中\n * break是结束当前循环，continue是结束当次循环\n\n> break和continue结束指定标识的循环\n\n\n\n> 其他\n\n也可以使用return关键字结束循环","routePath":"/tang/java2/02_Java基本语法","lang":"","toc":[{"text":"2.1 变量的分类","id":"21-变量的分类","depth":2,"charIndex":3},{"text":"2.2   基本数据类型间的运算规则","id":"22---基本数据类型间的运算规则","depth":2,"charIndex":-1},{"text":"2.3 关于进制","id":"23-关于进制","depth":2,"charIndex":1097},{"text":"2.4 ++与--","id":"24-与--","depth":2,"charIndex":1340},{"text":"2.5 赋值运算符","id":"25-赋值运算符","depth":2,"charIndex":1448},{"text":"2.6 逻辑运算符","id":"26-逻辑运算符","depth":2,"charIndex":1536},{"text":"2.7 位运算符","id":"27-位运算符","depth":2,"charIndex":1867},{"text":"2.8 三元运算符","id":"28-三元运算符","depth":2,"charIndex":2362},{"text":"2.9 Scanner类","id":"29-scanner类","depth":2,"charIndex":2395},{"text":"2.10 switch-case","id":"210-switch-case","depth":2,"charIndex":2436},{"text":"2.11 break和continue","id":"211-break和continue","depth":2,"charIndex":2521}],"domain":"","frontmatter":{},"version":""},{"id":116,"title":"3 Java数组","content":"#\n\n> 数组的特点\n\n * 有序性\n * 存储空间连续\n * 数组是引用类型变量\n * 长度固定，不可更改，一旦初始化完成，数组长度就确定了\n\n\n3.1 一维数组#\n\n> 声明和初始化\n\n * 静态初始化：数组的声明赋值操作同时进行\n * 动态初始化：先声明，再进行赋值操作\n\n\n\n> 获取数组长度\n\n\n\n> 数组的初始化值\n\n * 数组元素是整型（byte、short、int、long）：0\n * 数组元素是浮点型（float、double）：0.0\n * 数组元素是char型：0或'\\u0000'，而非'0'\n * 数组元素是boolean型：false\n * 数组元素为引用类型：null\n\n> 关于数组的打印\n\n * 打印char类型的数组变量：\n   \n   char[] c = new char[]{'a', 'b', 'c'}; System.out.println(c)，结果输出为abc\n\n * 打印非char类型的数组变量：\n   \n   int[] i = new int[]{1, 2, 3}; System.out.println(c)，结果输出为地址值\n\nprintln方法有个专门针对参数是char类型数组的重载。\n\n\n\n> 内存解析\n\n * 内存简化结构\n   \n   \n\n * 一维数组内存举例说明\n   \n   \n\n\n3.2 多维数组#\n\n以二维数组为例\n\n> 理解\n\n可以看成是一维数组array1又作为另外一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，没有多维数组。\n\n> 初始化\n\n * 静态初始化\n * 动态初始化\n\n\n\n> 获取指定位置的元素\n\n\n\n> 获取数组的长度\n\n\n\n> 初始化值\n\n\n\n> 内存解析\n\n\n\n\n3.3 数组的常见算法#\n\n\n3.3.1 复制#\n\n\n\n\n3.3.2 反转#\n\n\n\n\n3.3.3 线性查找#\n\n> 理解\n\n从前往后依次查找。\n\n\n3.3.4 二分法查找#\n\n> 前提\n\n数组是按照由小到大或者由大到小的顺序存储的。\n\n> 代码\n\n\n\n\n3.3.5 排序算法概述#\n\n> 衡量排序算法的优劣\n\n * 时间复杂度：分析关键字的比较次数和记录的移动次数\n * 空间复杂度：分析算法中需要多少辅助内存\n * 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种算法是稳定的\n\n> 排序算法分类\n\n * 内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。\n * 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器（如磁盘）等。外部排序最常见的算法有多路归并排序。\n   可以认为外部排序是由多次内部排序组成的。\n\n> 十大排序算法\n\n * 选择排序\n   \n   将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。\n   \n   * 简单选择排序\n   * 堆排序\n\n * 交换排序\n   \n   * 冒泡排序\n   * 快速排序\n\n * 插入排序\n   \n   * 直接插入排序\n   * 折半插入排序\n   * 希尔排序\n\n * 归并排序\n\n * 桶式排序\n\n * 基数排序\n\n> 算法5大特性\n\n * 输入：有0个或多个输入数据，这些输入必须有清楚的描述和定义\n * 输出：至少有1个或多个输出结果，不可以没有输出\n * 有穷性（有限性）：算法可以在有限的步骤之后会自动结束而不是无线循环，并且每一个步骤可以在可接受的时间内完成\n * 确定性（明确性）：算法中的每一步都有确定的含义，不会出现二义性\n * 可行性（有效性）：算法的每一步骤都是清楚且可行的，能让用户用纸笔计算而求出答案\n\n\n3.3.6 简单选择排序#\n\n> 基本过程\n\n * 在一组元素R[i]到R[n]中选择最小的元素\n * 如果他不是这组元素中的第一个元素，则将其与该组元素中的第一个元素交换\n * 除去具有最小关键字的元素，在剩下的元素中重复以上两步骤，直到元素只有一个为止\n\n> 效率分析\n\n * 比较次数：$(n-1)+(n-2)+...+2+1=n(n-1)/2$\n   \n   无论初始状况如何，在第i趟排序中选择最小元素的时候，都需要做$(n-i)$次比较\n\n * 交换次数：\n   \n   * 最好情况：0次\n     \n     序列恰好为正序时，需要交换0次\n   \n   * 最差情况：${(n-1)}$次\n     \n     如将数组[${5,1,2,3,4}$]按照有小到大的顺序排列，需要移动4次\n\n综上，简单选择排序的时间复杂度为$O(n^{2})$\n\n> 稳定性\n\n由于在直接选择排序中存在不相邻元素的交换，因此它是一个不稳定的排序方法。\n\n比如给定数组[$3,7,3',2,1$]，按照有小到大的顺序排列后的结果为[$1,2,3',3,7$]\n\n> 示例代码\n\n\n\n\n3.3.7 堆排序#\n\n\n3.3.8 冒泡排序#\n\n> 基本思想\n\n对待排序序列从前往后，依次比较相邻元素排序码，如果逆序则交换，使排序码较大的元素逐渐从前往后移动。\n\n> 效率分析\n\n * 比较次数：\n   \n   * 最好情况：$n-1$次\n     \n     此时待排序序列恰好是按照要求的顺序进行排序\n   \n   * 最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$次\n     \n     此时待排序序列恰好是按照要求的顺序的逆序进行排序\n\n * 交换次数：\n   \n   * 最好情况：0次\n     \n     此时待排序序列恰好是按照要求的顺序进行排序\n   \n   * 最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$\n\n> 稳定性\n\n * \n\n> 示例代码\n\n\n\n\n3.3.9 快速排序#\n\n\n3.3.10 插入排序#\n\n\n3.3.10.1 直接插入排序#\n\n\n3.3.10.2 折半插入排序#\n\n\n3.3.12 希尔排序#\n\n\n3.3.13 归并排序#\n\n\n3.3.14 桶式排序#\n\n\n3.3.15 基数排序#\n\n\n3.4 Arrays工具类的使用#\n\n方法                                       作用                          备注\nArrays.equals(Object[] a, Object[] a2)   判读两个数组中的元素是否全相等             全相等，返回true\nArrays.toString(Object[] a)              获取数组中的元素信息                  数组元素之间用\",\"分隔，用\"[]\"包裹\nArrays.fill(Object[] a, Object val)      将指定数值（val）填充到数组中            无返回值\nArrays.sort(Object[] a)                  对数组进行正序排序                   排序完成后，原数组发生改变\nArrays.sort(Object[] a, Comparator c)    对数组排序，顺序由Comparator构造函数决定   基本数据类型不可使用该方法，但对应的封装类型可使用\nArrays.binarySearch(int[] a, int key)    对排序后的数组进行二分法查找              数组必须是已排序好的；返回值小于0表示未找到\n\n\n3.5 数组中的常见异常#\n\n异常                               描述         备注\nArrayIndexOutOfBoundsException   数组下标越界异常   下标小于0也叫数组下标越界\nNullPointerException             空指针异常      // 情况一：int[] arr4 = {49,38,65,97,76,13,27,49}; arr4 = null;\n                                            System.out.println(arr4[1]); // 空指针异常// 情况二：int[][] arr =\n                                            new int[4][]; System.out.println(arr[0][0]);// 空指针异常","routePath":"/tang/java2/03_Java数组","lang":"","toc":[{"text":"3.1 一维数组","id":"31-一维数组","depth":2,"charIndex":73},{"text":"3.2 多维数组","id":"32-多维数组","depth":2,"charIndex":580},{"text":"3.3 数组的常见算法","id":"33-数组的常见算法","depth":2,"charIndex":747},{"text":"3.3.1 复制","id":"331-复制","depth":3,"charIndex":762},{"text":"3.3.2 反转","id":"332-反转","depth":3,"charIndex":776},{"text":"3.3.3 线性查找","id":"333-线性查找","depth":3,"charIndex":790},{"text":"3.3.4 二分法查找","id":"334-二分法查找","depth":3,"charIndex":821},{"text":"3.3.5 排序算法概述","id":"335-排序算法概述","depth":3,"charIndex":874},{"text":"3.3.6 简单选择排序","id":"336-简单选择排序","depth":3,"charIndex":1583},{"text":"3.3.7 堆排序","id":"337-堆排序","depth":3,"charIndex":2074},{"text":"3.3.8 冒泡排序","id":"338-冒泡排序","depth":3,"charIndex":2087},{"text":"3.3.9 快速排序","id":"339-快速排序","depth":3,"charIndex":2441},{"text":"3.3.10 插入排序","id":"3310-插入排序","depth":3,"charIndex":2455},{"text":"3.3.10.1 直接插入排序","id":"33101-直接插入排序","depth":3,"charIndex":2470},{"text":"3.3.10.2 折半插入排序","id":"33102-折半插入排序","depth":3,"charIndex":2489},{"text":"3.3.12 希尔排序","id":"3312-希尔排序","depth":3,"charIndex":2508},{"text":"3.3.13 归并排序","id":"3313-归并排序","depth":3,"charIndex":2523},{"text":"3.3.14 桶式排序","id":"3314-桶式排序","depth":3,"charIndex":2538},{"text":"3.3.15 基数排序","id":"3315-基数排序","depth":3,"charIndex":2553},{"text":"3.4 Arrays工具类的使用","id":"34-arrays工具类的使用","depth":2,"charIndex":2568},{"text":"3.5 数组中的常见异常","id":"35-数组中的常见异常","depth":2,"charIndex":3175}],"domain":"","frontmatter":{},"version":""},{"id":117,"title":"4 面向对象编程（上）","content":"#\n\n\n4.1 面向过程与面向对象#\n\n> 面向过程POP与面向对象OOP\n\n * 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。\n * 面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。\n\n> 面向对象三大特征\n\n * 继承\n * 封装\n * 多态\n\n\n4.2 内存解析#\n\n\n\n * 堆：存放对象实例\n   \n   所有的对象实例和数组都要在堆上分配（Java虚拟机规范中如此描述）\n\n * 栈：存放局部变量等。\n   \n   局部变量表存放了编译期可知长度的各种基本数据类型、对象引用类型（reference类型，值为对象在堆内的首地址）。方法执行完，自动释放。\n   \n   通常所说的栈，是指虚拟机栈。\n\n * 方法区：存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n\n\n4.3 属性和局部变量的对比#\n\n> 相同点\n\n * 定义变量的格式相同：数据类型 变量名 = 变量值\n * 都是先声明，后使用\n * 变量都有其对应的作用域\n\n> 不同点\n\n * 在类中声明的位置不同\n   * 属性：直接定义在类的一对{}中\n   * 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量\n * 关于权限修饰符的不同\n   * 属性：可以在声明属性时，指明其权限\n   * 局部变量：不可以使用权限修饰符\n * 默认初始化值的问题\n   * 属性：类的属性，根据其类型，都有默认初始化值\n     * 整型（byte、short、int、long）：0\n     * 浮点型（float、double）：0.0\n     * 字符型（char）：0 或 '\\u0000'\n     * 布尔型（boolean）：false\n     * 引用数据类型：null\n   * 局部变量：没有初始化值\n * 非static的变量/属性在内存中加载的位置不同\n   * 属性：存放在堆中\n   * 变量：存放在栈空间中\n\n\n4.4 匿名对象#\n\n> 理解\n\nnew出来的对象没有显示的赋值给一个变量。如：\n\n\n\n> 特点\n\n匿名对象只能使用一次。\n\n\n4.5 方法#\n\n\n4.5.1 方法的重载#\n\n> 定义\n\n同一个类中，允许有一个以上的同名方法，只要它们的参数类型或者参数个数不同即可。\n\n\n\n\n4.5.2 可变个数的形参#\n\n> 具体使用\n\n * 可变个数形参的格式： 数据类型 ... 变量名\n\n * 当调用可变个数形参的方法时，传入的参数个数可以是0个，1个，2个，...\n   \n   \n\n> 说明\n\n * 可变个数形参的方法与本类中方法名相同、形参不同的方法之间构成重载。\n\n * 可变个数形参的方法与本类中方法名相同、形参类型也相同的数组之间不构成重载，二者不能共存。\n   \n   \n\n * 可变个数形参的方法中，可变形参必须声明在末尾，且最多只能声明一个可变形参\n\n\n4.5.3 方法形参的传递机制#\n\n * 如果参数是基本数据类型，实参传递给形参的是实参的真实存储的数据值。\n * 如果参数是引用数据类型，实参传递给形参的是实参存储数据的地址值（包含变量的数据类型）。\n\n\n\n\n4.5.4 递归方法#\n\n\n4.6 OOP特征一：封装#\n\n\n4.6.1 封装性的体现#\n\n * 属性私有化，同时提供公共的方法来获取和设置属性\n * 不对外暴露私有方法\n * 单例模式\n\n\n4.6.2 权限修饰符#\n\n> 权限修饰符及其访问权限\n\n修饰符         类内部   同一个包   不同包的子类   同一个工程\nprivate     ✔                     \n（缺省）        ✔     ✔               \nprotected   ✔     ✔      ✔        \npublic      ✔     ✔      ✔        ✔\n\n> 特别说明\n\n * class（外部类）的权限修饰符只可以用public和缺省\n   * public类可以在任意地方被访问\n   * 缺省类只可以被同一个包内部的类访问\n\n\n4.7 构造器#\n\n> 特点\n\n * 名称和类相同\n * 不声明返回值\n * 不能被static、final、synchronized、abstract、native修饰\n * 不能有return语句\n\n> 说明\n\n * 如果没有显示的定义，系统默认提供一个无参构造器（默认构造器的权限和类保持一致）\n * 语法：权限修饰符 类名(形参列表){}\n * 一个类中定义的多个构造器，彼此构成重载\n * 一旦显示的定义了类的构造器没系统就不会再提供默认的构造器\n\n> 作用\n\n * 创建对象\n * 给对象进行初始化\n\n> 属性赋值的顺序\n\n默认初始化 -> 显示初始化 -> 构造器中赋值 -> 通过“对象.方法”或“对象.属性”的方式赋值\n\n> 通过this调用构造器\n\n * 使用this(形参列表)方式，调用本类中指定的其他构造器\n * 构造器中不能通过this(形参列表)方式调用自己\n * 如果一个类中有n个构造器，则最多有n-1个构造器使用了this(形参列表)\n * this(形参列表)必须声明在构造器的首行\n * 构造器内部，最多只能声明一个this(形参列表)，来调用其他构造器\n\n> 通过super调用构造器\n\n * 在子类的构造器中通过super(形参列表)显示调用父类的构造器\n * super(形参列表)的使用必须在子类构造器的首行\n * super(形参列表)与this(形参列表)只能二选一，不可同时出现\n * 在构造器首行，没有super(形参列表)或this(形参列表)，则默认调用的是父类中的空参构造器\n * 在类的多个构造器中，至少有一个类的构造器中使用了super(形参列表)，调用父类构造器\n\n\n4.8 JavaBean#\n\n> 定义\n\nJavaBean是Java语言编写的可重用组件\n\n> JavaBean的特点\n\n * 类是公共的\n * 有一个无参的公共的构造器\n * 有属性，且有对应的get、set方法\n\n\n4.9 UML类图#\n\n\n\n\n4.10 package和import关键字#\n\n> 一些知识的补充\n\n * 如果使用的类或接口是java.lang包下定义的，或者是本包下定义的，则可省略import结构\n\n * import xxx.*时，只能导入本包下的全部结构。当使用xxx子包下的结构时，仍需要import\n\n * import static导入指定类或接口中的静态结构（属性或方法）\n   \n   * 举例：\n     \n     ","routePath":"/tang/java2/04_面向对象编程（上）","lang":"","toc":[{"text":"4.1 面向过程与面向对象","id":"41-面向过程与面向对象","depth":2,"charIndex":3},{"text":"4.2 内存解析","id":"42-内存解析","depth":2,"charIndex":150},{"text":"4.3 属性和局部变量的对比","id":"43-属性和局部变量的对比","depth":2,"charIndex":376},{"text":"4.4 匿名对象","id":"44-匿名对象","depth":2,"charIndex":854},{"text":"4.5 方法","id":"45-方法","depth":2,"charIndex":918},{"text":"4.5.1 方法的重载","id":"451-方法的重载","depth":3,"charIndex":928},{"text":"4.5.2 可变个数的形参","id":"452-可变个数的形参","depth":3,"charIndex":992},{"text":"4.5.3 方法形参的传递机制","id":"453-方法形参的传递机制","depth":3,"charIndex":1236},{"text":"4.5.4 递归方法","id":"454-递归方法","depth":3,"charIndex":1342},{"text":"4.6 OOP特征一：封装","id":"46-oop特征一封装","depth":2,"charIndex":1356},{"text":"4.6.1 封装性的体现","id":"461-封装性的体现","depth":3,"charIndex":1373},{"text":"4.6.2 权限修饰符","id":"462-权限修饰符","depth":3,"charIndex":1438},{"text":"4.7 构造器","id":"47-构造器","depth":2,"charIndex":1738},{"text":"4.8 JavaBean","id":"48-javabean","depth":2,"charIndex":2456},{"text":"4.9 UML类图","id":"49-uml类图","depth":2,"charIndex":2566},{"text":"4.10 package和import关键字","id":"410-package和import关键字","depth":2,"charIndex":2581}],"domain":"","frontmatter":{},"version":""},{"id":118,"title":"5 面向对象编程（中）","content":"#\n\n\n5.1 OOP特征二：继承#\n\n> 使用继承的好处\n\n * 减少了代码的冗余，提高了代码的复用性\n * 便于功能的扩展\n * 为之后多态的使用，提供了前提\n\n> 说明\n\n一旦子类继承了父类，子类就获取到了父类所有的属性和方法。\n\n特别的，父类中声明为private的属性或方法，子类继承父类之后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。\n\n> java.lang.Object类\n\n * 所有的java类都直接或间接的继承于java.lang.Object类\n\n\n5.2 方法的重写#\n\n> 定义\n\n在子类中可以根据需要，对从父类继承来的方法进行改造，也称为方法的覆盖、重置。在程序执行时，子类的方法将覆盖父类的方法。\n\n> 规则\n\n * 子类重写的方法必须和父类被重写的方法具有相同的方法名、参数列表\n * 子类重写的方法的返回值类型不能大于父类被重写方法的返回值类型\n   * 父类被重写的方法的返回值是void，则子类重写时返回值也只能是void\n   * 父类被重写的方法的返回值是A类，则子类重写时返回值可以是A类或者A类的子类\n   * 父类被重写的方法的返回值是基本数据类型，则子类重写时返回值必须是相同的基本数据类型\n * 子类重写的方法使用的访问权限不能小于父类被重写的访问权限\n   * 子类不能重写父类的private方法\n * 子类方法抛出的异常不能大于父类被重写方法的异常\n\n> 注意\n\n方法的重写针对的是非static方法。因为static方法是属于类的，子类无法覆盖父类方法。\n\n\n5.3 子类对象实例化过程#\n\n> 从结果来看（继承性）\n\n子类继承父类以后，就获取了父类中声明的属性和方法。\n\n创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。\n\n> 从过程看\n\n当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参构造\n器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类的结构，子类对象才可调用。\n\n说明：虽然创建子类对象时，调用了父类构造器，但是自始至终就创建一个对象，即为new的子类对象。\n\n\n5.4 OOP特征三： 多态#\n\n> 理解多态性\n\n多态性可以理解为一个事物的多种形态\n\n> 什么是多态性\n\n对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）\n\n\n\n> 多态的使用（即虚拟方法的使用）\n\n有了对象的多态性后，我们在编译期，只能调用父类中声明的方法。在运行时，实际执行的是子类重写的方法。\n\n总结：编译，看左边；运行，看右边\n\n\n\n> 多态使用的前提\n\n * 有类的继承关系\n * 有方法的重写\n\n> 说明\n\n * 对象的多态性，只适用于方法，不适用于属性\n\n\n5.5 Object类的使用#\n\n> 属性\n\n无\n\n> 方法\n\n * equals()：对象比较\n   * 重写原则\n     * 对称性：如果x.equlas(y)返回true，那么y.equlas(x)返回的也应该是true\n     * 自反性：x.equlas(x)必须是true\n     * 传递性：x.equlas(y)返回true，y.equlas(z)返回是true，那么x.equlas(x)也应该是true\n     * 一致性：如果x.equlas(y)返回true，只要x，y值不变，不管重复比较多少次，结果永远是true\n     * x.equlas(null)永远返回false\n     * x.equlas(和x不同类型的对象)永远返回false\n * toString()：将对象转为字符串\n   * 当输出一个对象的引用时，实际就是调用当前对象的toString()\n   * Object类中toString()返回的是实体类名（getClass().getName()) + \"@\" +\n     对象的hashCode(Integer.toHexString(hashCode()))\n   * String、Date、File、包装类都重写了Object的toString()方法，返回的是各自的“实体内容”\n * getClass()\n * hashCode()：获取Hash码\n * clone()\n * finalize()\n * wait()\n * notify()\n * notifyAll()\n\n> 构造器\n\n只有一个空参构造器\n\n\n5.6 包装类的使用#\n\n> 包装类有哪些\n\nByte、Short、Integer、Long、Float、Double、Boolean、Character\n\n> 装箱\n\n基本数据类型 ---> 包装类\n\n * 数值型的（Byte、Short、Integer、Long、Float、Double）举例：\n   \n   \n\n * Boolean额外说明：\n   \n   \n\n> 拆箱\n\n包装类 ---> 基本数据类型\n\n调用包装类Xxx的xxxValue()方法，如：\n\n\n\n> 自动装箱与自动拆箱\n\nJDK 5.0新特性\n\n\n\n> 基本数据类型、包装类 ---> String\n\n因基本数据类型可以自动装箱，包装类可以自动拆箱，所以二者在转为String时，所用到的方法都是一样的。\n\n * 连接运算\n   \n   \n\n * 调用String重载的valueOf(Xxx xxx)\n   \n   \n\n> String ---> 基本数据类型、包装类\n\n * 调用parserXxx(String s)方法\n   \n   \n\n * 特别的，包装类可以调用自己的toString()方法\n   \n   \n\n\n5.7 单元测试#\n\n> 使用步骤\n\n * 引入JUnit 4\n\n * 创建Java类，进行单元测试\n   \n   Java类的要求：此类是public的；此类须提供公共的无参构造器\n\n * 在上述类中声明单元测试方法\n   \n   此单元测试方法的要求：方法的权限是public；没有返回值；没有形参\n\n * 单元测试方法上需要使用注解@Test，并导入org.junit.Test\n\n * 运行：双击方法名->右键，选择Run...或者Debug...\n\n * 执行结果：\n   \n   * 绿条：执行结果没有异常\n   * 红条：执行结果出现异常","routePath":"/tang/java2/05_面向对象编程（中）","lang":"","toc":[{"text":"5.1 OOP特征二：继承","id":"51-oop特征二继承","depth":2,"charIndex":3},{"text":"5.2 方法的重写","id":"52-方法的重写","depth":2,"charIndex":260},{"text":"5.3 子类对象实例化过程","id":"53-子类对象实例化过程","depth":2,"charIndex":684},{"text":"5.4 OOP特征三： 多态","id":"54-oop特征三-多态","depth":2,"charIndex":957},{"text":"5.5 Object类的使用","id":"55-object类的使用","depth":2,"charIndex":1205},{"text":"5.6 包装类的使用","id":"56-包装类的使用","depth":2,"charIndex":1902},{"text":"5.7 单元测试","id":"57-单元测试","depth":2,"charIndex":2403}],"domain":"","frontmatter":{},"version":""},{"id":119,"title":"6 面向对象编程（下）","content":"#\n\n\n6.1 关键字static#\n\n> static修饰属性：静态变量\n\n * 属性，按是否使用static修饰，又分为：\n   \n   * 静态属性\n     （类变量）：我们创建了类的多个对象，多个对象共享同一个静态变量。当对某一个对象修改静态变量时，会导致当其他对象调用该属性时，获得的是被修改过之后的值。\n   * 非静态属性（实例变量）：我们创建了类的多个对象，每一个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会对其他对象的同一个\n     属性值修改。\n\n * static修饰属性的其他说明：\n   \n   * 静态变量随着类的加载而加载，可以通过类.静态变量的方式使用。\n   \n   * 静态变量的加载早于对象的创建。\n   \n   * 由于类只会加载一次，所以静态变量在内存中野只会存在一份，存在于方法区的静态域中。\n   \n   * 调用方法\n     \n          类变量（静态属性）   实例变量（非静态属性）\n     类    ✔           ✘\n     对象   ✔           ✔\n\n> static修饰方法（静态方法）\n\n * 随着类的加载而加载，可以通过类.静态方法(形参列表)的方式调用\n\n * 调用方法\n   \n        静态方法   非静态方法\n   类    ✔      ✘\n   对象   ✔      ✔\n\n * 静态方法不可以调用非静态方法或属性；非静态方法中，既可以调用静态方法或属性又可以调用非静态方法或属性\n\n> static注意点\n\n * 静态方法中，不能使用this和super关键字\n * 关于静态属性和静态方法的使用，可以从声明周期的角度去理解\n\n> static使用场景\n\n * static属性：当属性可以被多个对象所共享，不会随着对象的不同而不同\n * static方法：\n   * 操作静态属性的方法，通常被设置为static的\n   * 工具类的方法，习惯上声明为static的。如Math、Arrays、Collections等工具类中的方法\n\n\n6.2 static应用之单例设计模式#\n\n> 设计模型\n\n * 定义：在大量的实践中总结和理论化之后优选的代码结构、编程风格，以及解决问题的思考方式。\n\n> 设计模式分类（共23个）\n\n * 创造型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式\n * 结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式\n * 行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式\n\n> 单例模式\n\n * 定义：采取一定的方法，保证在整个软件系统中，某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。\n\n * 实现思路：\n   \n   * 将类的构造器的访问权限设置为private\n   * 在该类中声明一个静态方法，用以返回类内部创建的对象（原因：构造器私有，外部无法获取对象实例，但类内部可以产生对象实例，所以只能声明一个公有的静态方法以\n     返回类内部创建的对象）\n   * 该类的变量也必须是静态的（原因：静态方法只能访问类的静态成员变量）\n\n * 实现方式\n   \n   * 饿汉式\n     \n     \n   \n   * 懒汉式\n     \n     \n\n * 区分饿汉式和懒汉式\n   \n   * 饿汉式：\n     * 好处：天生线程安全\n     * 坏处：对象加载时间过长\n   * 懒汉式：\n     * 好处：延迟对象的创建\n     * 坏处：以上写法是线程不安全的（到多线程内容的时候，再修改）\n\n> 单例模式的优点\n\n减少内存的开销\n\n> 单例模式举例\n\n * java.lang.Runtime（饿汉式）\n\n> 单例模式应用场景\n\n * 网站的计数器\n * 应用程序的日志应用\n * 数据库连接池\n * 读取配置文件的类\n * Application\n * Windows的Task Manager（任务管理器）\n * Windows的Recycle Bin（回收站）\n\n\n6.3 理解main方法的语法#\n\n * main()方法是程序的入口\n\n * main()也是一个普通的静态方法\n   \n   可以通过类名.main(参数)的方式被调用\n\n * main()可以作为和控制台交互的方式（之前使用的是Scanner）\n   \n   * 使用idea给main()方法传参\n     \n     * 编写代码，打印main()方法接收的参数：\n       \n       \n     \n     * 设置参数：\n       \n       \n     \n     * 右键运行，控制台即可输出参数：\n       \n       \n   \n   * 使用cmd给main()方法传参：\n     \n     * 代码如上\n     \n     * 运行\n       \n       \n\n\n6.4 类的成员之四：代码块#\n\n> 作用\n\n用来初始化类、对象\n\n> 修饰符\n\n代码块只能使用static来修饰\n\n> 分类\n\n * 静态代码块\n   * 随着类的加载而执行，且只执行一次\n   * 作用：初始化类的信息\n   * 静态代码块的执行时间先与非静态代码块的执行时间\n   * 静态代码块之间的执行顺序是按照代码编写的先后顺序执行\n   * 不可以调用非静态结构（属性和方法）\n * 非静态代码块\n   * 随着对象的创建而执行，且没创建一个对象，就会执行一次\n   * 作用：可以在创建对象时，对对象的属性等进行初始化\n   * 非静态代码块之间的执行顺序是按照代码编写的先后顺序执行\n\n> 属性赋值的顺序\n\n默认初始化 -> 显示初始化/代码块-> 构造器中赋值 -> 通过“对象.方法”或“对象.属性”的方式赋值\n\n\n\n\n6.4 关键字final#\n\n> 作用\n\n可以用来修饰：\n\n * 类：final修饰的类不能被其他类所继承。举例：String类、System类、StringBuffer类\n\n * 方法：final修饰的方法不能被子类重写。举例：Object.getClass()\n\n * 变量：final修饰的变量不能被修改，此时的变量成为“常量”。\n   \n   * 修饰属性：可以赋值的位置有：显示初始化、代码块中初始化、构造器中初始化\n   \n   * 修饰局部变量：\n     \n     尤其是修饰形参时，表明此形参时一个常量，只能在方法体内使用，不能修改\n\n> static final修饰属性\n\n被称为全局常量\n\n\n6.5 抽象类与抽象方法#\n\n> 关键字abstract的使用\n\n可以用来修饰的结构：类、方法\n\n不能修饰：属性、构造器、私有方法、静态方法、final方法、final类\n\n> 抽象类\n\n被abstract修饰的类叫做抽象类。\n\n * 抽象类不能实例化\n * 抽象类中一定有构造器，便于子类实例化的时候调用\n * 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作\n * 包含抽象方法的类，一定是抽象类；反之，抽象类中可以没有抽象方法\n\n> 抽象方法\n\n被abstract修饰的方法叫抽象方法。\n\n\n\n * 抽象方法只有方法的声明，没有方法体\n * 若子类重写了父类中的所有抽象方法后，此子类方可实例化；若子类没有重写父类中的所有抽象方法，则子类也必须声明为一个抽象类\n\n> abstract使用注意事项\n\n * abstract不能用来修饰属性、构造器等结构\n * abstract不能用来修饰private方法、static方法、final方法、final类\n\n> 抽象类的匿名子类\n\n\n\n\n6.6 abstract应用之模板方法设计模式#\n\n抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。\n\n> 解决的问题\n\n * 当功能内部一部分实现是确定的，一部分实现是不确定的。此时可以吧不确定的部分暴露出去，让子类去实现。\n * 即在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同的子类实现。这就是一种模板模\n   式。\n\n> 应用举例\n\n * 数据库访问的链接\n * Junit单元测试\n * JavaWeb的Servlet中doGet、doPost方法\n * Hibernate中模板程序\n * Spring中JDBCTemplate、HibernateTemplate等\n\n\n6.7 接口#\n\n> 定义接口中的成员\n\n * JDK7及以前：只能定义全局常量和抽象方法\n   * 全局常量：public static final修饰的变量。但是public static final可以省略不写\n   * 全局方法：public abstract修饰的方法。但是public static可以省略不写\n * JDK8及以后：可以定义全局常量、抽象方法、静态方法、默认方法\n\n> 接口使用注意事项\n\n * 接口中不能定义构造器。这意味着接口是不可以实例化的。\n * 接口通过让类去实现(implements)的方式来使用。\n   * 如果实现类实现了接口中所有的抽象方法，则此类可以实例化\n   * 否则，实现类需要声明为abstract的\n * Java类可以实现多个接口（多个接口之间用“,”隔开）--->弥补了Java单继承的局限性\n * 当一个Java类既继承类，又实现接口的时候，应该先写继承后写实现\n * 接口与接口之间可以继承（extends），且可以多继承\n * 接口的具体使用，提现了多态性\n * 接口，实际上可以看做是一种规范\n * 接口的主要用途就是被实现类实现，这称为面向接口编程\n * 从本质上讲，接口是一种特殊的抽象类。\n\n> JDK8中接口新特性\n\nJDK8以后，接口既可以定义全局常量、抽象方法，也可以定义静态方法、默认方法。\n\n * 定义静态方法（public static）：接口中定义的静态方法，只能通过接口来调用\n * 定义默认方法（public default）：\n   * 可以通过实现类的对象，调用接口中的默认方法\n   * 实现类可以重写接口的默认方法\n   * 如果子类（或实现类）继承的父类和实现的接口中，声明了同名、同参的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的方法 --->\n     类优先原则\n   * 如果实现类实现了多个接口，且这多个接口中定义了同名、同参的默认方法，在实现类没有重写此方法的情况下，编译报错 ---> 接口冲突\n     * 如果想解决以上冲突，必须在实现类中重写此方法。\n   * 如何在子类（或实现类）的方法中调用父类、接口中被重写的方法？\n     * 调用父类中声明的方法：super.方法\n     * 调用接口中默认的方法：接口名.super.方法\n\n\n6.8 接口应用之代理模式（Proxy）#\n\n> 概述\n\n代理设计就是为其他对象提供一种代理以控制对这个对象的方法。\n\n> 代码示例\n\n以明星和他的小助理为例。明星参加面谈会、签合同、订票、唱歌，都需要通过他的小助理来完成。小助理就是明星的一个代理。\n\n\n\n> 应用场景\n\n * 安全代理：屏蔽对真是角色的直接访问\n * 远程代理：通过代理类处理远程方法调用（RMI）\n * 延迟加载：先加载轻量级的代理对象，真正需要再加载真是对象\n\n> 分类\n\n * 静态代理（静态定义代理对象）\n\n * 动态代理（动态生成代理类）\n   \n   JDK自带的动态代理，需要反射等知识\n\n\n6.9 接口应用之工厂模式#\n\n> 概述\n\n工厂模式实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到高灵活性的目的。\n\n将选择实现类、创建对象统一管理和控制，从而将调用者和实现类解耦。\n\n> 体现的原则\n\n * 开闭原则（OCP）：软件实体对扩展开放，对修改关闭\n * 依赖倒转原则（DIP）：如果A中关联B，那么尽量使得B实现某个接口，然后A与接口发生关系，不与B实现类发生关联关系\n * 迪米特法则（LOD）：不和陌生人说话，有事去中介\n\n> 分类\n\n * 简单工厂模式（静态工厂模式）：用来生产同一等级结构中的任意产品\n   \n   一个工厂类，根据方法名或者参数，返回不同的产品。\n   \n   * 优点：把调用者和创建者分离，实现了解耦\n   * 缺点：对于新增产品，需要修改代码。违反了开闭原则\n\n * 工厂方法模式：用来生产同一等级结构中的固定产品（支持新增任意产品）\n   \n   一个工厂接口，多个不同工厂接口的实现类，根据不同工厂接口的实现类，返回不同的产品。\n   \n   * 缺点：并没有真正的避免代码的改动。当添加新产品时，要么将判断逻辑留在抽象工厂的角色里，要么在客户端将具体工厂类写死。\n\n * 抽象工厂模式：用来生产不同品族的全部产品（对于增加新的产品，无能为力；支持增加产品族）\n   \n   * 和工厂方法模式的区别：在于需要创建对象的复杂程度上。\n\n\n6.10 类的成员之五：内部类#\n\n> 概述\n\nJava中允许将一个类A生命在另一个类B中，则类A就是内部类，类B称为外部类\n\n> 分类\n\n * 成员内部类：分为静态、非静态\n * 局部内部类：可以定义在方法内、代码块内、构造器内\n\n> 成员内部类\n\n * 作用：\n   \n   * 一方面，作为外部类的成员：\n     * 可以调用外部类的属性、方法：外部类名.this.属性/方法\n     * 可以被static修饰\n     * 可以被4种不同的权限修饰（外部类的权限修饰符只可以用public和缺省2种）\n   * 另一方面，作为一个类：\n     * 类内可以定义属性、方法、构造器等\n     * 可以被final修饰，表示不能被继承（言外之意，不使用final，可以被继承）\n     * 可以被abstract修饰，表示不能被实例化\n\n * 注意点：\n   \n   在局部内部类（AA）的方法（show）中，如果调用局部内部类所声明的方法（method）中的局部变量（num），要求此局部变量声明为final(此fina\n   l在JDK8及之后可省)\n   \n   \n\n> 实例化成员内部类对象\n\n * 实例化静态成员内部类对象：外部类.静态内部类 变量名 = new 外部类.静态内部类();\n * 实例化非静态成员内部类对象：先创建外部类对象，再通过外部类对象实例.new 静态内部类()\n * 例子：\n\n\n\n> 在成员内部类中区分调用外部类的结构\n\n见Bird类的display()方法。\n\n\n\n> 开发中局部内部类的使用\n\n","routePath":"/tang/java2/06_面向对象编程（下）","lang":"","toc":[{"text":"6.1 关键字static","id":"61-关键字static","depth":2,"charIndex":3},{"text":"6.2 static应用之单例设计模式","id":"62-static应用之单例设计模式","depth":2,"charIndex":898},{"text":"6.3 理解main方法的语法","id":"63-理解main方法的语法","depth":2,"charIndex":1770},{"text":"6.4 类的成员之四：代码块","id":"64-类的成员之四代码块","depth":2,"charIndex":2133},{"text":"6.4 关键字final","id":"64-关键字final","depth":2,"charIndex":2504},{"text":"6.5 抽象类与抽象方法","id":"65-抽象类与抽象方法","depth":2,"charIndex":2812},{"text":"6.6 abstract应用之模板方法设计模式","id":"66-abstract应用之模板方法设计模式","depth":2,"charIndex":3265},{"text":"6.7 接口","id":"67-接口","depth":2,"charIndex":3641},{"text":"6.8 接口应用之代理模式（Proxy）","id":"68-接口应用之代理模式proxy","depth":2,"charIndex":4637},{"text":"6.9 接口应用之工厂模式","id":"69-接口应用之工厂模式","depth":2,"charIndex":4925},{"text":"6.10 类的成员之五：内部类","id":"610-类的成员之五内部类","depth":2,"charIndex":5530}],"domain":"","frontmatter":{},"version":""},{"id":120,"title":"7 异常处理","content":"#\n\n\n7.1 概述#\n\n> 异常分类\n\n * Error：Java虚拟机无法解决的严重问题。如JVM系统内部错误、资源耗尽（如StackOverflowError栈溢出、OOM堆溢出）等严重情况。一般\n   不编写针对性的代码进行处理。\n * Exception：其它因编程错误或偶然意外的外在因素导致的一般性问题，可以使用针对性的代码进行处理，如：空指针访问、试图读取不存在的文件、网络连接中断、\n   数组下标越界\n   * 分类\n     * 编译时异常\n     * 运行时异常\n\n\n\n> 异常的体系结构\n\njava.lang.Throwable\n\n|------ java.lang.Error：一般不编写针对性的代码处理\n\n|------ java.lang.Exception：可以进行异常的处理\n\n|------ 编译时异常（checked）\n\n|------ IOException\n\n|------ FileNotFoundException\n\n|------ ClassNotFoundException\n\n|------ 运行时异常（unchecked，RuntimeException）\n\n|------ NullPointerException\n\n|------ ArrayIndexOutOfBoundsException\n\n|------ ClassCastException\n\n|------ NumberFormatException\n\n|------ InputMismatchException\n\n...\n\n\n7.2 异常处理#\n\n> 异常处理方式\n\n * try-catch-finally\n * throws + 异常类型\n\n> try-catch-finally使用注意事项\n\n * 当catch捕获多个异常时，如果这些异常之间没有子父类关系，谁在上谁在下都可以。但是如果有子父类关系，子类在前父类在后\n * try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错\n * finally中声明的是一定会被执行的语句。即使catch中又出现异常了，或者是try和catch中有return语句等情况\n * 如果try、catch、finally中都有return，最终返回的是finally中的内容\n\n> 开发中如何选择使用try-catch-finally还是使用throws？\n\n * 如果父类中被重写的方法中没有使用throws的方式处理异常，那么子类重写的方法也不能使用throws，也就是说，如果子类重写的方法有异常，只能使用try-\n   catch-finally的方式处理\n * 执行的方法a中，先后又调用了另外几个方法，这几个方法是递进关系执行的。建议使用throws的方式进行处理a中调用的方法，执行的a方法则可以考虑使用try-\n   catch-finally方式进行处理","routePath":"/tang/java2/07_异常处理","lang":"","toc":[{"text":"7.1 概述","id":"71-概述","depth":2,"charIndex":3},{"text":"7.2 异常处理","id":"72-异常处理","depth":2,"charIndex":675}],"domain":"","frontmatter":{},"version":""},{"id":121,"title":"8 多线程","content":"#\n\n\n8.1 基本概念#\n\n * 程序（program）：是为了完成特定的任务、用某种语言编写的一组指令的集合。即一段静态的代码，静态对象\n\n * 进程（process）：是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程，有他自身的产生、存在和消亡的过程\n   \n   * 程序是静态的，进程是动态的\n   * 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域\n\n * 线程（thread）：进程可以进一步细化为线程，是一个程序内部的一条执行路径\n   \n   * 若一个进程同一时间可以并行执行多个线程，那么这个进程就是支持多线程的\n   * 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小\n   * 一个进程中的多个线程共享相同的方法区、堆，他们从同一堆中分配对象，可以访问相同的变量和对象。这使得线程间通信更简便、高效。但多个线程操作共享的系统资源\n     就会带来安全隐患\n\n * 单核CPU：其实是一种假的多线程，因为他在一个时间单元内，也只能执行一个线程的任务\n\n * 多核CPU：多核CPU才能更好的发挥多线程的效率\n   \n   一个Java应用程序java.exe，其实至少有3个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程\n\n * 并行：多个CPU同事执行多个任务。如：多个人同时做不同的事情\n\n * 并发：一个CPU（采用时间片）同时执行多个任务。如：秒杀，多个人同时做一件事\n\n * 多线程的优点：\n   \n   * 提高应用程序的相应。对图形化界面更有意义，可增强用户体验\n   * 提高计算机系统CPU的利用率\n   * 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改\n\n * 何时需要多线程：\n   \n   * 程序需要同时执行两个或多个任务\n   \n   * 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索。\n     \n     比如点外卖时，手指上划，获取数据和图片加载就是两个线程\n   \n   * 需要一些后台运行的程序时\n\n\n8.2 线程的创建和使用#\n\n更深的课程：45_Callable接口_哔哩哔哩_bilibili\n\n> 线程创建的方法\n\n * 方法一：继承Thread类\n * 方法二：实现Runnable接口\n * 方法三：实现Callable接口（JDK5.0新增）\n * 方法四：使用线程池（JDK5.0新增）\n\n> 方式一：继承Thread类\n\n * 步骤\n   \n   * 创建一个继承Thread类的子类\n   \n   * 在子类中重写Thread的run()方法\n     \n     将线程需要执行的操作，声明在run()方法中\n   \n   * 创建子类的实例对象\n   \n   * 调用子类实例对象的start()方法\n     \n     * start()方法的作用\n       * 启动当前线程\n       * 调用当前线程的run()方法\n     * 不可以让已经start()的线程重新start()。否则会报IllegalThreadStateException\n\n> 方式二：实现Runnable接口\n\n * 步骤\n   \n   * 创建一个实现Runnable接口的类\n   * 实现类中去重写Runnable接口的抽象方法run()\n   * 创建实现类的对象\n   * 将次对象作为参数传递到Thread类的构造器中，创建Thread类对象\n   * 通过Thread类的对象调用run()\n * * 二者的联系如下：\n     * Thread本身也实现了Runnable接口\n   * 相同点：\n     * 两种方式都要重写run()，将线程要执行的逻辑写在run()中\n\n> 方式三：实现Callable接口\n\n * 步骤\n   \n   * 创建一个实现Callable的实现类\n   * 实现call()方法：将此线程需要执行的操作声明在此方法中。call()是可以有返回值的\n   * 创建Callable实现类的对象\n   * 创建FutureTask对象：将上述Callable实现类对象，作为参数传递到FutureTask构造器中\n   * 创建Thread对象并运行：需要将FutureTask对象作为参数传递到Thread构造器中\n   * （可选）获取Callable实现类中call()的返回值：借助FutureTask对象的get()方法获取\n * * 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等\n   * FutureTask是Future接口的唯一实现类\n   * FutureTask同时实现了Runnable、Future接口。既可以作为Runnable被线程执行，又可以作为Future得到Callable中c\n     all()的返回值\n * * 与实现Runnable相比，Callable功能更强大\n     * 相比run()方法，Callable接口中的call()可以有返回值\n     * call()方法可以抛出异常\n     * Callable支持泛型\n     * 需要借助FutureTask类，来获取返回结果\n\n * \n\n> 方式四：使用线程池\n\n * 经常创建和销毁、使用量特别大的资源。如并发情况下的线程，对性能影响很大\n\n * * 提高响应速度（减少了创建新线程的时间）\n   * 降低资源消耗（重复利用线程池中的线程，不需要每次都创建）\n   * 便于线程管理：\n     * corePoolSize：核心池的大小\n     * maximumPoolSize：最大线程数\n     * KeepAliveTime：线程没有任务时最多保持多长时间会终止\n * * ExecutorService：\n   * Executors：\n\n\n8.3 Thread类中的方法#\n\n * start()：启动当前线程；调用当前线程的run()\n * run()：通常都需要重写该方法，将创建的线程要执行的操作声明在此方法中\n * currentThread()：静态方法，返回执行当前代码的线程\n * getName()：获取当前线程的名字\n * setName()：设置当前线程的名字\n * yield()：释放当前CPU的执行权（当然下一个CPU的执行权也有可能被争取到）\n * join()：在线程a中调用线程b的join()，此时线程a就会进入阻塞状态，直到线程b执行完成后，线程a才会结束阻塞状态\n * stop()：已过时。强制结束当前线程，不推荐使用\n * sleep(long millis)：静态方法，让当前线程“睡眠”指定的millis毫秒。在指定的millis毫秒时间内，当前线程是阻塞的装填\n * isAlive()：判断当前线程是否存活\n\n\n8.4 线程的调度#\n\n> CPU调度策略\n\n * 时间片：执行一段时间的A，再去执行一定时间的B，再去执行一定时间的C......\n * 抢占式：高优先级的线程抢占CPU\n\n> Java的调度方法\n\n * 同优先级线程组成先进先出队列，使用时间片策略\n * 对于高优先级的，使用优先调度的抢占式策略\n\n> 线程的优先级\n\n * 线程优先级的等级\n   \n   共10档，有三个常量，如下：\n   \n   * MAX_PRIORITY：10。最大的优先级\n   * MIN_PRIORITY：1。最小的优先级\n   * NORM_PRIORITY：5。默认的优先级\n\n * 涉及的方法\n   \n   * getPriority()：返回线程的优先级\n   * setPriority(int newPriority)：改变线程的优先级\n\n * 说明\n   \n   * 线程创建时，继承父线程的优先级\n   * 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用\n\n\n8.5 线程的分类#\n\nJava中的线程分类两类，一种是守护线程，一种是用户线程。\n\n * 它们几乎在每个方面都是相同的，唯一的区别就是判断JVM何时离开\n * 守护线程是用来服务用户线程的，通过在start()前调用线程实例对象.setDaemon(true)可以把一个用户线程变成一个守护线程\n * Java垃圾回收就是一个典型的守护线程\n * 若JVM中都是守护线程，当前JVM将退出\n\n\n8.6 线程的生命周期#\n\n\n\n\n8.7 线程的同步#\n\n> 线程同步的方法\n\n * 方法一：同步代码块\n * 方法二：同步方法\n * 方法三：使用Lock锁\n\n> 方式一：同步代码块\n\n * 语法：\n   \n   \n\n * 说明\n   \n   * 同步监视器：即锁，任何一个类的对象，都可以充当锁。\n     \n     * 要求：多个线程共用同一把锁\n     \n     * 补充：\n       \n       * 在实现Runnable接口创建多线程的方式中，可以考虑使用this、或者声明一个实现类的属性（该属性是一个类的实例）作为同步监视器\n         \n         \n       \n       * 在继承Thread类创建多线程的方式中，可以考虑使用类名.class、或者声明一个实现类的静态属性（该属性是一个实例）作为同步监视器，不可使用\n         this\n         \n         \n     \n     * 举例：\n       \n       * 在类中声明一个对象，用来作为同步锁\n       * 使用类名.class\n   \n   * 需要被同步的代码：即操作共享数据的代码\n\n> 方式二：同步方法\n\n * 同步方法仍然涉及到同步监视器，只是不需要显示声明\n\n * 非静态的同步方法，同步监视器是this\n   \n   \n\n * 静态的同步方法，同步监视器是类本身\n   \n   \n\n> 方法三：Lock\n\njdk5.0新特性\n\n\n8.8 单例设计模式之线程安全的懒汉式#\n\n\n\n\n8.9 线程的死锁#\n\n> 死锁\n\n * 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，这就造成了线程的死锁\n * 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续\n\n> 死锁产生的必要条件\n\n * 互斥条件：任意一个时刻一个资源只能给一个进程使用\n * 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺\n * 请求和保持条件：进程在申请新资源的同时，继续占用已经分配到的资源\n * 循环等待条件：前一个进程占有后一个进程锁申请的资源，最后一个进程占用第一个进程所申请的资源\n\n> 处理死锁的方法\n\n * 预防死锁\n   \n   * “互斥”条件是无法破坏的\n   * 破坏“不可剥夺”条件：\n     * 方法一：如果占有某些资源的一个进程申请新的资源被拒绝，则该进程必须释放它最初占有的资源。如有必要，只可以再次请求这些资源和其他资源\n     * 方法二：如果一个进程请求当前被另一个进程占有的资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在两个进程优先级不同的条件下，方法二才能预防\n       死锁\n   * 破坏“请求与保持”条件：\n     * 方法一：创建进程时，系统要么满足它申请的所有资源，要么什么都不给。这就会所谓的“一次性分配”\n     * 方法二：要求每个进程申请新的资源时，释放他所占有的资源。\n   * 破坏“循环等待”条件：将系统中所有的资源编号，进程可以在任意时间提出资源申请，但所有申请必须按照资源的编号书序提出。\n\n * 避免死锁\n   \n   * 有序资源分配法：将系统中的资源统一编号，申请时必须按从小到大的顺序\n   * 专门的算法：如银行家算法\n\n * 检测死锁：当死锁发生时，相关机构能够监测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来\n\n * 解除死锁：\n   \n   死锁解除的主要方法有：\n   \n   * 资源剥夺法：挂起某些死锁进程，并抢占他们的资源，将这些资源分配给其他的死锁进程。\n     \n     但是，应该防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。\n   \n   * 撤销进程法：强制撤销部分甚至全部死锁进程，并剥夺他们的资源。\n     \n     撤销的原则可以按照进程的优先级和撤销进程代价的高低进行。\n   \n   * 进程回退法：让一个或者多个进程回退到足以避免死锁的地步，进程回退时资源释放资源。\n     \n     要求系统保持进程的历史信息，设置还原点。\n\n\n8.10 线程的通信#\n\n> 常用方法\n\n以下方法是定义在Object类中的，不是Thread中\n\n * wait()：使线程进入阻塞状态，并释放同步监视器\n * notify()：唤醒被wait的一个线程（优先唤醒有优先级高的）\n * notifyAll()：唤醒所有被wait的线程\n\n> 说明\n\n * wait()、notify()、notifyAll()必须用在同步代码块或者同步方法中\n\n * wait()、notify()、notifyAll()的调用者必须是同步代码块或同步方法中的同步监视器。\n   \n   否则会出现IllegalMonitorStateException异常\n\n * wait()、notify()、notifyAll()是定义在java.lang.Object中的\n\n> 例子\n\n","routePath":"/tang/java2/08_多线程","lang":"","toc":[{"text":"8.1 基本概念","id":"81-基本概念","depth":3,"charIndex":3},{"text":"8.2 线程的创建和使用","id":"82-线程的创建和使用","depth":3,"charIndex":923},{"text":"8.3 Thread类中的方法","id":"83-thread类中的方法","depth":3,"charIndex":2518},{"text":"8.4 线程的调度","id":"84-线程的调度","depth":3,"charIndex":2929},{"text":"8.5 线程的分类","id":"85-线程的分类","depth":3,"charIndex":3370},{"text":"8.6 线程的生命周期","id":"86-线程的生命周期","depth":3,"charIndex":3568},{"text":"8.7 线程的同步","id":"87-线程的同步","depth":3,"charIndex":3585},{"text":"8.8 单例设计模式之线程安全的懒汉式","id":"88-单例设计模式之线程安全的懒汉式","depth":3,"charIndex":4218},{"text":"8.9 线程的死锁","id":"89-线程的死锁","depth":3,"charIndex":4243},{"text":"8.10 线程的通信","id":"810-线程的通信","depth":3,"charIndex":5349}],"domain":"","frontmatter":{},"version":""},{"id":122,"title":"9 Java常用类","content":"#\n\n\n9.1 String#\n\n\n9.1.1 特性#\n\n * String类声明为final的，不可被继承\n\n * 实现了Serializable接口，表示支持序列化\n\n * 实现了Comparable接口，表示可以比较大小\n\n * 内部定义了final char[] value，用来存储字符串数据\n\n * String代表了不可变的字符串序列，简称不可变性，体现如下：\n   \n   * 当对字符串重新赋值时，需要重新指定内存区域进行赋值，不能对内存中原有的字符串内容进行修改\n   * 当对字符串进行连接操作时，也需要重新指定内存区域进行赋值\n   * 当对字符串调用replace()修改字符串时，也需要重新指定内存区域进行赋值\n\n * 通过字面量的方式（区别与new，使用String a=\"abc\";）给一个字符串赋值，此时的字符串的值存在方法区中的字符串常量池中\n   \n   字符串常量池不会存相同内容的字符串\n\n\n9.1.2 String的初始化方式#\n\n * 通过字面量的方式：String s = \"abc\";\n   \n   初始化过程：\n   \n   * 在字符串常量池中创建abc常量\n   * s指向abc常量的地址\n\n * 通过new+构造器的方式：String s = new String(\"abc\");\n   \n   初始化过程：\n   \n   * 在字符串常量池中创建abc常量\n   * 在堆空间中创建String对象，其value属性值为abc常量的地址\n   * s指向堆中创建的String对象\n   \n   面试题：String s = new String(\"abc\")创建了几个对象？\n   \n   答：两个。一个是在堆空间中new了一个String类型的对象，另一个是在常量池中创建了一个char[]\n\n> 引申\n\n * 常量与常量的拼接结果在常量池中（如String s = \"abc\"+\"def\";s指向常量池中的\"abcdef\"），且常量池中不会存在相同内容的常量。\n\n * 常量与变量的拼接、变量与变量的拼接结果在堆空间中（如String s = \"abc\"; String s2 =\n   s1+\"def\";s2指向堆空间，相当于new了一个变量）\n\n * 特别的，如果拼接结果调用了intern()，返回结果在常量池中。\n\n * 例子如下：\n   \n   \n\n\n9.1.3 String常用方法#\n\n * int length()：返回字符串长度\n * char charAt(int index)：返回索引处的字符\n * boolean isEmpty()：判断是否是空字符串\n * String toLowerCase()： 将字符转为小写（）\n * String toUpperCase()： 将字符转为大写\n * String trim()：忽略字符串收尾空格\n * boolean equals(Object obj)：比较字符串的内容是否相等\n * boolean equalsIgnoreCase(Object obj)：忽略大小写，比较字符串的内容是否相等\n * String concat(String str)：将指定字符串连接到此字符串的结尾，等价于“+”\n * int compareTo(String anotherString)：比较两个字符串的大小。返回负数表示当前字符串比指定字符串小。\n * String substring(int beginIndex)：从beginIndex开始截取并返回\n * String substring(int beginIndex, int endIndex)：截取[beginIndex,\n   endIndex)范围内的字符串并返回\n * boolean endsWith(String suffix)：判断字符串是否以指定的字符串结尾\n * boolean startsWith(String suffix)：判断字符串是否以指定的字符串开始\n * boolean startsWith(String suffix, int\n   toffset)：判断字符串从指定的索引位置开始的子字符串是否以指定的字符串开始\n * boolean contains(CharSequence s)：判断是否包含指定字符串\n * int indexOf(String str)：返回指定字符串在当前字符串中第一次出现的索引位置\n * int indexOf(String str, int fromIndex)： 返回指定字符串在当前字符串中第一次出现的索引位置，从指定的下标开始\n * int lastIndexOf(String str)：返回指定字符串在当前字符串中最后一次出现的索引位置\n * int lastI ndexOf(String str, int\n   fromIndex)：返回指定字符串在当前字符串中第一次出现的索引位置，从指定的索引反向搜索\n * String replace(char oldChar, char newChar)：用newChar替换oldChar\n * String replace(CharSequence target, CharSequence\n   replacement)：用replacement替换target\n * String replaceAll(String regex, String\n   replance)：用replacement替换符合正则表达式regex的字符串\n * String replaceFirst(String regex, String\n   replance)：用replacement替换第一个符合正则表达式regex的字符串\n * boolean match(String regex)：判断字符串是否匹配给定的正则表达式\n * String[] split(String regex)：根据给定的正则表达式拆分此字符串\n * String[] split(String regex, int\n   limit)：根据给定的正则表达式拆分此字符串，最多不超过limit个。如果超出，剩下的全都放在最后一个元素中\n\n\n9.1.4 String与部分数据结构之间的转换#\n\n * String与char[]之间的转换\n   * String --> char[]：调用String的toCharArray()\n   * char[] --> String ：调用String的构造器\n * String与byte[]之间的转换\n   * String --> byte[]：调用String的getBytes() --------->相当于编码\n   * byte[] --> String ：调用String的构造器 --------->相当于解码\n\n\n9.1.5 StringBuffer和StringBuilder#\n\n> String、StringBuffer、StringBuilder三者的区别与联系\n\n * String：\n   * 不可变的字符序列；\n * StringBuffer：\n   * 可变的字符序列；\n   * 线程安全的，效率低\n * StringBuilder：（jdk5.0新增）\n   * 可变的字符序列；\n   * 线程不安全的，效率高\n * 三者的联系：\n   * 三者底层都是char[]，但是String是用final修饰的\n\n> 源码分析\n\n以StringBuffer为例\n\n * 构造器\n   \n   * StringBuffer sb = new StringBuffer()：底层创建了一个长度是16的字符数组，即char[] value = new\n     char[16]\n   * StringBuffer sb = new\n     StringBuffer(\"abc\")：底层创建了一个长度是\"abc\".length+16的字符数组，即char[] value = new\n     char[\"abc\".length+16]\n\n * 问题1：sb.length()是多少？\n   \n   答：是字符的真实长度。如StringBuffer sb = new StringBuffer()，sb.length()=0；StringBuffer\n   sb = new StringBuffer(\"abc\")，sb.length()=3\n\n * 问题2：当sb.append(str)长度不够时，是如何扩容的？\n   \n   答：默认情况下是将原来的容量变为原来的2倍+2；如果默认扩容完毕后，长度仍不够，则容量扩容为sd.length()+str.length()；...\n   \n   同时将原有数组中的元素复制到新的数组中。\n   \n   \n\n> StringBuffer常用方法\n\n * StringBuffer append(String var1)：字符串拼接\n\n * StringBuffer delete(int start, int end)：删除[start, end)位置的字符\n\n * StringBuffer replace(int start, int end, String str)：把[start, end)位置的字符替换成str\n\n * StringBuffer insrt(int offset, xxx)：在指定位置插入xxx\n\n * StringBuffer reverse()：字符串反转\n   \n   以上方法都会将原有字符串进行修改。此外StringBuffer还可以调用String的一些方法，如String substring(int\n   beginIndex, int endIndex)，当调用String的方法时，对原有字符串不会修改\n\n> String、StringBuffer、StringBuilder效率对比\n\nString < StringBuffer < StringBuilder\n\n\n9.1.6 JVM中字符串常量池存放位置#\n\n * jdk 1.6：字符串常量池存储在方法区（永久区）\n * jdk 1.7：字符串常量池存储在堆空间\n * jdk 1.8：字符串常量池存储在方法区（元空间）\n\n\n9.2 日期时间的API#\n\n\n9.2.1 JDK8之前的日期时间API#\n\n * java.util.Date及其子类java.sql.Date\n\n * System.currentTimeMillis()：获取当前时间的时间戳\n\n * java.text.SimpleDateFormat：时间格式化\n\n * Calendar：日历类。Calender是Date的升级版\n   \n   说明：获取月份时，一月是0，二月是1，以此类推，十二月是11；获取星期时，周日是1，周一是2，以此类推，周六是7\n   \n   \n\n\n9.2.2 JDK8中新的日期时间API#\n\n> 旧日期时间API存在的问题\n\n * 可变性：日期和时间这样的类应该是不可变的\n * 偏移性：Date中的年份是从1900开始的，月份是从0开始的\n * 格式化：格式化只对Date有用，对Calender不行\n * 线程安全性：Date和Calender都不是线程安全的\n * 不能处理闰秒等\n\n> JDK8新增的日期时间API\n\n * java.time.LocalDate：获取日期\n * java.time.LocalTime：获取时间\n * java.time.LocalDateTime：获取日期+时间\n * java.time.Instant：瞬时，等同于Date中的getTime()\n * java.time.format.DateTimeFormatter：时间格式化\n * 其他API：\n   * java.time.ZoneId：时区相关操作\n   * java.time.ZonedDateTime：带时区的日期时间\n   * java.time.Clock：使用时区提供对当前即时、日期、和时间的访问的时钟\n   * java.time.Duration：用来计算两个时间的间隔，可以获取秒级间隔，也可以获取纳秒级间隔\n   * java.time.Period：用来计算两个日期的间隔\n   * java.time.temporal.TemporalAdjuster：时间校正器。如获取当前日期的下一个工作日等\n   * java.time.temporal.TemporalAdjusters：该类通过静态方法提供了大量的TemporalAdjuster实现\n\n> LocalDate、LocalTime、LocalDateTime的使用\n\n * 实例化\n   \n   * 方法一：使用now()实例化当前时间\n     \n     \n   \n   * 方法二：使用of()实例化指定时间\n     \n     \n\n * 获取属性：getXxx\n   \n   \n\n * 设置属性：withXxx 体现了不可变性\n   \n   \n\n * 对相关属性执行“+”操作：plusXxx() 体现了不可变性\n   \n   \n\n * 对相关属性执行“-”操作：minusXxx() 体现了不可变性\n   \n   \n\n> Instant说明\n\n时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。\n\n从概念上来讲，它知识简单的表示自1970年1月1日0时0分0秒开始的事件数，精确度可达纳秒级。\n\n> Instant的使用\n\n * 实例化\n   \n   * 方法一：使用now()获取当前时间 注：获取到的是本初子午线的时间，与东八区相差8小时\n     \n     \n   \n   * 方法二：使用of(long l)获取指定时间戳对应的时间\n     \n     \n\n * 设置偏移量，获取当前时间 atOffset()\n   \n   \n\n * 获取自1970-01-01 00:00:00开始的毫秒数\n   \n   \n\n> DateTimeFormatter的使用\n\n * 实例化方法一：通过预定义的标准格式，如ISO_LOCAL_TIME、ISO_LOCAL_DATE、ISO_LOCAL_DATE_TIME\n   \n   \n\n * 实例化方法二：通过本地化相关的格式，如DateTimeFormatter.ofLocalizedDateTime()、DateTimeFormatter.\n   ofLocalizedDate()\n   \n   * DateTimeFormatter.ofLocalizedDateTime()适用的参数：\n     \n     * FormatStyle.SHORT\n     * FormatStyle.MEDIUM\n     * FormatStyle.LONG\n   \n   * DateTimeFormatter.ofLocalizedDate()适用的参数：\n     \n     * FormatStyle.SHORT\n     * FormatStyle.MEDIUM\n     * FormatStyle.LONG\n     * FormatStyle.FULL\n   \n   \n\n * 实例化方法三：通过自定义的格式，如DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\") 最常用\n   \n   \n\n\n9.3 Java比较器#\n\n\n9.3.1 Comparable自然排序#\n\n> 重写compareTo(Object o)方法的规则\n\n * 当前对象this > 形参对象obj，返回正数\n\n * 当前对象this < 形参对象obj，返回负数\n\n * 当前对象this = 形参对象obj，返回0\n   \n   tips：如果形参对象不是当前对象对应的类，可以考虑抛出异常！\n\n> 例子\n\n * 自定义类实现Comparable接口，并重写compareTo(Object o)\n   \n   \n\n * 排序测试\n   \n   \n\n\n9.3.2 Comparator定制排序#\n\n> 使用场景\n\n * 元素类型没有实现Comparable接口，且又不方便修改代码\n * 虽实现了Comparable接口，但是compareTo(Object o)方法中的排序规则不适用于当前排序\n\n> 使用方法\n\n实现Comparator接口，并重写compare(Goods o1, Goods o2)方法\n\n重写compare(Goods o1, Goods o2)方法的规则与Comparable接口的compareTo(Object o)规则一致。\n\n> 例子\n\n\n\n\n9.4 BigInteger与BigDecimal#\n\n * BigInteger可以表示不可变的任意精度的整数。\n\n * BigDecimal支持不可变的、任意精度的有符号十进制定点数。","routePath":"/tang/java2/09_Java常用类","lang":"","toc":[{"text":"9.1 String","id":"91-string","depth":2,"charIndex":3},{"text":"9.1.1 特性","id":"911-特性","depth":3,"charIndex":17},{"text":"9.1.2 String的初始化方式","id":"912-string的初始化方式","depth":3,"charIndex":416},{"text":"9.1.3 String常用方法","id":"913-string常用方法","depth":3,"charIndex":1014},{"text":"9.1.4 String与部分数据结构之间的转换","id":"914-string与部分数据结构之间的转换","depth":3,"charIndex":2622},{"text":"9.1.5 StringBuffer和StringBuilder","id":"915-stringbuffer和stringbuilder","depth":3,"charIndex":2890},{"text":"9.1.6 JVM中字符串常量池存放位置","id":"916-jvm中字符串常量池存放位置","depth":3,"charIndex":4222},{"text":"9.2 日期时间的API","id":"92-日期时间的api","depth":2,"charIndex":4329},{"text":"9.2.1 JDK8之前的日期时间API","id":"921-jdk8之前的日期时间api","depth":3,"charIndex":4345},{"text":"9.2.2 JDK8中新的日期时间API","id":"922-jdk8中新的日期时间api","depth":3,"charIndex":4591},{"text":"9.3 Java比较器","id":"93-java比较器","depth":2,"charIndex":6484},{"text":"9.3.1 Comparable自然排序","id":"931-comparable自然排序","depth":3,"charIndex":6499},{"text":"9.3.2 Comparator定制排序","id":"932-comparator定制排序","depth":3,"charIndex":6752},{"text":"9.4  BigInteger与BigDecimal","id":"94--biginteger与bigdecimal","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":123,"title":"10 枚举&注解","content":"#\n\n\n10.1 枚举类#\n\n> 使用场景\n\n * 类的对象只有有限个且确定\n   \n   如周一到周日、支付方式、季节、订单状态等\n\n * 当需要定义一组常量时，强烈建议使用枚举类\n\n\n10.1.1 JDK5.0之前枚举类的使用#\n\n\n\n\n10.1.2 JDK5.0之后枚举类的使用#\n\n\n\n\n10.1.3 java.lang.Enum中常用方法#\n\n * toString()：返回当前对象常量的名称\n   \n   \n\n * values()：返回枚举类型的对象数组。可以借助该方法遍历所有的枚举值\n   \n   \n\n * valueOf(String\n   str)：将字符串转为对应的枚举类的对象。要求字符串必须是枚举类对象的名字，否则报IllegalArgumentException异常\n   \n   \n\n\n10.1.4 使用enum关键字定义的枚举类实现接口#\n\n * 情况一：实现接口，在enum类中实现抽象方法\n   \n   和普通类一样\n   \n   \n\n * 情况二：实现接口，让枚举类的对象分别实现抽象方法\n   \n   \n\n\n10.2 注解#\n\n\n10.2.1 注解（Annotation）概述#\n\n * 注解可以像修饰符一样被使用，可以用于修饰包、类、构造器、方法、成员变量、参数、局部变量的。这些信息被保存在Annotation的“name=value”对\n   中\n\n\n10.2.2 常见的Annotation示例#\n\n> 文档注解\n\n * @Author\n * @Date\n * ...\n\n> JDK内置注解\n\n * @Override：只能用于方法。要求方法是重写的父类方法，或者是实现的接口的方法\n\n * @Deprecated：可以修改类、方法、属性、构造器。表示被修饰的内容已过时，但是仍然可以用\n\n * @SuppressWarning：抑制编译器警告\n   \n   \n\n\n10.2.3 自定义Annotation#\n\n> 步骤\n\n * 注解声明为@interface\n * 内部定义成员，如果只有一个，通常使用value表示\n * 可以指定成员的默认值，用default定义\n * 如果自定义的注解没有成员，表明是一个标识作用\n\n如果注解有成员，在使用注解时，需要指明成员的值。\n\n> 示例\n\n\n\n\n10.2.4 JDK中的元注解#\n\n> 定义：元注解\n\nJDK的元注解是对现有注解进行解释说明的注解\n\n> 引申：元数据\n\n对现有数据修饰的数据。如String name = \"hello\"，“hello”是核心数据，“String”、“name”都是元数据。\n\n> JDK中的元注解\n\n * （关注）@Retention：指明被修饰注解的生命周期。\n   \n   @Retention的value值是RetentionPolicy类型的成员变量。RetentionPolicy枚举类中各个值的含义如下：\n   \n   * RetentionPolicy.SOURCE：源文件中有效，编译器直接丢掉\n   * RetentionPolicy.CLASS（默认）：在class文件中有效，运行时JVM不会保留\n   * RetentionPolicy.RUNTIME：运行时有效。当运行时，JVM会保留注释，程序可以通过反射获取注解\n\n * （关注）@Target：指明被修饰的注解可以修饰哪些元素\n   \n   @Target的value值是ElementType[]。ElementType枚举类常用值如下：\n   \n   * TYPE：可以修饰类、接口、注解、枚举类\n   * FIELD：修饰属性\n   * METHOD：修饰方法\n   * PARAMETER：修饰参数\n   * CONSTRUCTOR：修饰构造器\n   * LOCAL_VARIABLE：修饰局部变量\n   * ANNOTATION_TYPE：修饰注解\n   * PACKAGE：修饰包\n   * TYPE_PARAMETER：JDK8新特性。类型注解\n   * TYPE_USE：JDK8新特性。类型注解。\n\n * （了解）@Documented：表示被修饰的注解将被javadoc工具提取生成文档。默认情况下，javadoc是不包括注解的\n\n * （了解）@Inherited：表示被修饰的注解具有继承性\n   \n   如果一个父类使用了被Inherited修饰的注解，则子类就默认使用了该注解。\n\n\n10.2.5 利用反射获取注解信息#\n\n在反射部分提及\n\n\n10.2.6 JDK8中注解新特性#\n\n10.2.6.1 可重复注解#\n\n在一个类或者属性或其他结构上使用多次相同注解\n\n * JDK8之前实现可重复注解\n   \n   \n\n * JDK8新特性实现可重复注解\n   \n   \n\n10.2.6.2 类型注解#\n\nJDK8之前，注解只能是在声明的地方使用；JDK8之后，注解可以应用在任何地方。\n\nJDK8之后，元注解@Target的参数类型ElementType枚举值多了两个：\n\n * ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如泛型声明）\n   \n   \n\n * ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中\n   \n   ","routePath":"/tang/java2/10_枚举&注解","lang":"","toc":[{"text":"10.1 枚举类","id":"101-枚举类","depth":2,"charIndex":3},{"text":"10.1.1 JDK5.0之前枚举类的使用","id":"1011-jdk50之前枚举类的使用","depth":3,"charIndex":93},{"text":"10.1.2 JDK5.0之后枚举类的使用","id":"1012-jdk50之后枚举类的使用","depth":3,"charIndex":120},{"text":"10.1.3 java.lang.Enum中常用方法","id":"1013-javalangenum中常用方法","depth":3,"charIndex":147},{"text":"10.1.4 使用enum关键字定义的枚举类实现接口","id":"1014-使用enum关键字定义的枚举类实现接口","depth":3,"charIndex":359},{"text":"10.2 注解","id":"102-注解","depth":2,"charIndex":475},{"text":"10.2.1 注解（Annotation）概述","id":"1021-注解annotation概述","depth":3,"charIndex":486},{"text":"10.2.2 常见的Annotation示例","id":"1022-常见的annotation示例","depth":3,"charIndex":600},{"text":"10.2.3 自定义Annotation","id":"1023-自定义annotation","depth":3,"charIndex":808},{"text":"10.2.4 JDK中的元注解","id":"1024-jdk中的元注解","depth":3,"charIndex":972},{"text":"10.2.5 利用反射获取注解信息","id":"1025-利用反射获取注解信息","depth":3,"charIndex":1863},{"text":"10.2.6 JDK8中注解新特性","id":"1026-jdk8中注解新特性","depth":3,"charIndex":1893},{"text":"10.2.6.1 可重复注解","id":"10261-可重复注解","depth":4,"charIndex":1913},{"text":"10.2.6.2 类型注解","id":"10262-类型注解","depth":4,"charIndex":2007}],"domain":"","frontmatter":{},"version":""},{"id":124,"title":"11 Java集合","content":"#\n\n\n11.1 概述#\n\n> 数组在存储多个数据方面的特点\n\n * 数组一旦初始化，长度就确定了\n * 数组一旦定义好，其元素的类型也就确定了\n\n> 数组在存储多个数据方面的缺点\n\n * 数组一旦初始化，长度就不可修改了，无法实现扩容\n * 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便\n * 获取数组中实际元素的个数的需求，数组中没有线程的属性或方法可用\n * 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足\n\n\n11.2 Java集合框架#\n\n> Java集合可以分为Collection和Map两种体系：\n\n * Collection接口：单列集合，用来存储一个一个的对象\n   * List接口：存储的是元素有序、可重复的集合\n     * 实现类：ArrayList、LinkedList、Vector\n   * Set接口：存储的是元素无序、不可重复的集合\n     * 实现类：HashSet、LinkedHashSet、TreeSet\n * Map接口：双列集合，保存具有映射关系“key-value对”的集合\n   * 实现类：HashMap、LinkedHashMap、TreeMap、HashTable、Properties\n\n> 注意事项\n\n * 集合Collection中存储的如果是自定义类的对象，需要自定义类重写的方法：\n   * 如果Collection的实现类是List的子类，需要重写equals()\n   * 如果Collection的实现类是Set的子类HashSet、LinkedHashSet，需要重写equals()和hashCode()\n   * 如果Collection的实现类是Set的子类TreeSet，需要提供排序方法。排序方法的提供有如下两种方法\n     * 放入TreeSet的元素的所在类实现Comparable接口，并重写compareTo()\n     * 创建Comparator实现类，在初始化TreeSet时作为参数传入\n\n\n11.3 Collection接口中的方法#\n\n * add(Object o)： 将元素o添加到集合中\n\n * size()：获取集合中元素的个数\n\n * addAll(Collection c)：将集合c中的元素添加到当前集合中\n\n * isEmpty()：判断当前集合是否为空，即判断当前集合中的size()是否等于0\n\n * clear()：清空集合中的元素\n\n * contains(Object o)：判断当前集合是否包含元素o\n   \n   比较时，调用的是元素o所对应的类的equals()方法\n   \n   \n\n * containsAll(Collection c)：判断c中的元素是否都在当前结合中\n\n * remove(Object o)：在当前集合中删除元素o，返回是否移除成功\n   \n   需要调用元素o所对应的类的equals()\n\n * removeAll(Collection c)：在当前集合中删除集合c中所有元素\n   \n   需要调用c中所有元素对应的类的equals()方法\n\n * retainAll(Collection c)：计算当前集合和集合c的交集（结果赋值给当前集合），返回值为boolean类型，即当前集合和集合c是否有交集\n   \n   如果二者没有交集，当前集合被修改为[]，返回值为false\n\n * equals(Object o)：判断当前集合和o是否相等。\n   \n   调用的是元素o锁对应的类中的equals()\n\n * hashCode()：返回当前对象的hash值\n\n * toArray()：集合 ---> 数组\n   \n   Arrays.asList(Object[] o)：数组 ---> 集合\n   \n   \n\n * iterator()：返回Iterator接口的实例，用于遍历集合元素\n\n\n11.4 Iterator迭代器接口#\n\n> 概述\n\n * Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素\n * GOF给迭代器模式的定义为：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。迭代器模式，就是为容器而生\n * Collection接口继承了java.lang.Iterator接口，该接口有一个iterator()，所有实现了Collection接口的集合类都有一\n   个iterator()， 用以返回一个实现了Iterator接口的对象\n * Iterator仅用于遍历集合\n * 集合对象每次调用iterator()都得到一个全新的迭代对象，默认游标都在集合的第一个元素之前\n\n> 常用方法\n\n * hasNext()：判断是否还有下一个元素\n\n * next()：获取下一个元素\n   \n   * 指针下移\n   * 将下移后的集合位置上的元素返回\n\n * remove()：在遍历的时候，删除集合中的元素。\n   \n   如果还未调用next()或者在上一次调用next()之后已经调用了remove()，再调用remove()，即连续两次调用remove()，会报Illeg\n   alStateException。\n\n> 举例\n\n\n\n\n11.5 List接口#\n\n\n11.5.1 ArrayList源码分析#\n\n> JDK7中的ArrayList\n\n\n\n> JDK8中的ArrayList\n\n\n\n> 小结\n\nJDK7中的ArrayList的对象创建类似于单例的饿汉式，JDK8中的ArrayList对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。\n\n\n11.5.2 LinkedList源码分析#\n\n\n\n其中Node的定义，体现了双向链表的说法。\n\n\n\n\n11.5.3 Vector的源码分析#\n\n\n\n\n11.5.4 List接口中的方法#\n\n * Collection接口中的API仍可用\n * void add(int index, Object ele)：在index位置插入ele元素\n * boolean addAll(int index, Collection eles)：在index位置开始将eles中的元素全部加进来\n * Object get(int index)：获取index位置的元素\n * int indexOf(Object ele)：获取元素ele在集合中首次出现的位置。如果不存在，返回-1\n * int lastindexOf(Object ele)：获取元素ele在集合中最后一次出现的位置。如果不存在，返回-1\n * Object remove(int index)：移除index位置的元素，并返回此元素\n * Object set(int index, Object ele)：将index位置的元素设置为ele\n * List subList(int fromIndex, int toIndex)：返回**[fromIndex,\n   toIndex)**位置处的子集合，原集合没有变化\n\n\n11.6 Set接口#\n\n\n11.6.1 概述#\n\nSet中没有额外定义方法，使用的都是Collection接口中的方法\n\n> 分类\n\n * HashSet：作为Set接口的主要实现类；线程不安全的，可以存储null；底层是数组+链表的结构\n   * LinkedHashSet：作为HashSet的子类，在遍历内部数据时，可以按照添加的顺序遍历\n * TreeSet：底层使用的是二叉树（红黑树）存储，放入TreeSet的元素，必须是同一个类的对象，可以按照添加对象的指定属性进行排序\n\n> Set存储的无序性\n\n以HashSet为例\n\n * 无序性 $\\neq$ 随机性\n * 存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的\n\n> Set存储的不可重复性\n\n以HashSet为例\n\n保证添加的元素按照equals()判断时，不能返回true，确保相同的元素只能添加一个。\n\nSet中存储元素要想实现不可重复性，需要重新该元素对应类的equals()和hashCode()方法。\n\n\n11.6.2 HashSet#\n\n> HashSet添加元素的过程\n\n当向HashSet中添加元素a时，首先调用元素\na所在类的hashCode()，计算元素a的哈希值，接下来用此哈希值通过某种算法计算出在HashSet底层数组中的存放位置（即索引位置），然后判断此位置上是否应\n有元素：\n\n * 如果此位置上没有其他元素，则元素a添加成功；---情况1\n * 如果此位置上有其他元素b（或者以链表形式存在的多个元素），则比较元素a与元素b的哈希值：\n   * 如果hash值不相同，元素a添加成功；---情况2\n   * 如果hash值相同，进而需要调用元素a所在类的equals()：\n     * equals()返回true，元素a添加失败；\n     * equals()返回false，元素a添加成功；---情况3\n\n对于添加成功的情况2和情况3而言，元素a与已经存在指定索引位置上的数据以链表的方式存储。\n\nJDK7：元素a放到数组中，指向原来的元素\n\nJDK8：原来的元素放在数组中，指向a元素\n\n总结：7上8下\n\n> HashSet的特点\n\n * 不能保证元素的顺序排列\n * HashSet不是线程安全的\n * 集合元素可以是null\n\n> HashSet判断两个元素相等的标准\n\n两个对象通过hashCode()比较相等，且两个对象的equals()返回值也相等\n\n> 使用HashSet的主意事项\n\n对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode()，以实现对象相等规则。即“相等的对象必须有相等的散列码（哈希值）”\n\n> 重写hashCode()的基本原则\n\n * 在程序运行时，同一个对象多次调用hashCode()，应该返回相同的值\n * 当两个对象的equals()返回true时，这两个对象的hasCode()的返回值也相等\n * 对象中用作equals()方法比较的属性，都应该用来计算hash值\n\n\n11.6.3 LinkedHashSet#\n\n * LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个变量，用以记录当前数据的前一个数据和后一个数据。\n\n * 在遍历内部数据时，可以按照添加的顺序遍历。\n\n * 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet。\n\n\n11.6.4 TreeSet#\n\n> 特点\n\n * 底层是二叉树（红黑树）\n * 可以按照添加对象的指定属性进行排序\n * 有序，查询比list快\n\n> 注意事项\n\n * 向TreeSet中添加的数据，要求是相同类的对象\n\n * 向TreeSet中添加的数据前，需要定义TreeSet中元素的排序方式：自然排序或者定制排序\n   \n   * 使用自然排序（实现Comparable接口）\n     \n     \n   \n   * 使用定制排序（实现Comparator接口）\n     \n     \n\n> TreeSet中比较两个对象是否相同的标准\n\n * 使用自然排序：比较两个对象是否相同，即为元素所在类的compareTo()返回值是否为0\n * 使用定制排序：比较两个对象是否相同，即为创建的 Comparator实现类中compare()返回值是否是0\n\n\n11.7 Map接口#\n\n\n11.7.1 概述#\n\n> Map接口简介\n\n * Map接口：存储双列数据，存储的是key-value键值对\n   \n   * HashMap类：主要实现类；线程不安全，效率比Hashtable高；可以存储值为null的key和value；底层：数组+链表（JDK7及之前）、数\n     组+链表+红黑树（JDK8）\n     \n     * LinkedHashMap类：比HashMap多了一对“指针”，用来指向前一个和后一个元素，保证在遍历map元素时，可以按照添加的顺序实现遍历；对\n       于频繁的遍历操作，LinkedHashMap效率比HashMap高\n   \n   * TreeMap类：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或者定制排序，要求key是同一个类创建的对象\n     \n     底层使用的是红黑树\n   \n   * Hashtable类：古老实现类；线程安全，效率比HashMap低；不可以存储值为null的key和value\n     \n     * Properties类：常用来处理配置文件。key和value都是String类型\n\n> Map中结构的理解\n\n以HashMap为例\n\n * Map中的key：无序的、不可重复的，使用Set存储所有的key；key所在的类要重写equals()和hashCode()；\n * Map中的value：无序的、可重复的，使用Collection存储所有的value；value所在的类需要重写equals()；\n * 一个键值对构成一个Entry对象；\n * Map中的entry：无序的、不可重复的，使用Set存储所有的entry 。\n\n\n11.7.2 HashMap底层实现原理#\n\n> JDK7中HashMap实现原理\n\n * HashMap map = new HashMap();：实例化之后，底层创建了一个长度是16的一维数组Entry[] table\n * map.add(key1, value1) ：\n   * 首先，调用key1所在类的hashCode()计算key1的哈希值，此哈希值经过某种算法计算后，得到Entry数组中的存放位置\n   * 如果此位置上的数据是空，此时key1-value1存放成功 --->情况1\n   * 如果此位置上的数据不为空，意味着此位置上存在一个或多个数据（以链表形式存在），比较key1和已存在数据的哈希值：\n     * 如果key1的哈希值与此位置上的数据的哈希值都不一样，此时key1-value1存放成功 --->情况2\n     * 如果key1的哈希值与此位置上的某一个数据(key2,value2)的哈希值相同，则调用key1所在类的equals()方法进行比较：\n       * 如果equals()返回false，此时key1-value1存放成功 --->情况3\n       * 如果equals()返回true，使用value1替换value2\n * 补充：关于情况2和情况3，此时key1-value1和原来的数据以链表的形式存在，由key1-value1指向原数据\n * 关于扩容：在不断添加的过程中，会涉及到扩容问题。\n   * 扩容时间：当超出临界值（注意不是数组的长度），且要存放数据的位置非空时，进行扩容\n   * 默认扩容为原来的2倍，并将原有的数据复制过来\n\n> JDK8相较于JDK7在底层实现方面的不同\n\n * HashMap map = new HashMap();：底层没有创建长度为16的数组。且底层数组是Node[]，而非Entry\n\n * map.add(key1, value1) ：如果是首次调用，会先创建长度为16的数组\n\n * JDK7底层结构只有数组+链表，JDK8中底层结构是数组+链表+红黑树。\n   \n   当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所有数据改为使用红黑树\n\n> HashMap中常用常量\n\n * DEFAULT_INITIAL_CAPACITY：HashMap默认容量，16\n * DEFAULT_LOAD_FACTOR：默认加载因子，0.75\n * threshold：扩容的临界值。threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR\n * TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值时，转为红黑树，8\n * MIN_TREEIFY_CAPACITY：Bucket中Node被树化时最小的hash表容量，64\n\n\n11.7.3 LinkedHashMap底层实现原理#\n\nLinkedHashMap底层使用的结构与HashMap相同，唯一的区别是LinkedHashMap内部提供了Entry用来替换HashMap中的Node。\n\nLinkedHashMap.Entry类中比HashMap.Node多了两个变量，用来记录当前元素的前一个和后一个元素，确保能够记录元素的添加顺序\n\n\n\n\n11.7.4 Map接口中的方法#\n\n> 增删改\n\n * Object put(Object key, Object value)：将key-value添加到（修改）当前map中\n * Object putAll(Map m)：将m中的key-value添加到当前map中\n * Object remove(Object key)：移除指定的key的key-value对，并返回对应的value\n * void clear()：清空当前map\n\n> 查询\n\n * Object get(Object key)：获取key对应的value\n * boolean containsKey(Object key)：判断是否包含指定的key\n * boolean containsValue(Object value)：判断是否包含指定的value\n * int size()：返回map中key-value对的个数\n * boolean isEmpty()：判断当前map是否为空\n * boolean equals(Object obj)：判断当前map和obj是否相等\n\n> 遍历\n\n * Set keySet()：返回所有key构成的Set集合\n\n * Collection values()：返回所有的value集合\n\n * Set entrySet()：返回所有的key-value对\n   \n   entrySet()获得的集合中的元素都是Map.Entry，可以强转\n\n\n11.7.5 TreeMap的使用#\n\n * 向TreeMap中添加key-value，需要保证key是由同一个类创建的对象\n * 因需要对key进行排序，因此要么key所在的类需要实现Comparable接口，要么在在创建TreeMap时将Comparator实现类作为参数传入\n\n使用和TreeSet类似。\n\n\n11.7.6 Properties#\n\n * Properties是Hashtable的子类，该对象用于处理属性文件\n\n * Properties的key和value都是String类型\n\n * 例子\n   \n   * jdbc.properties\n     \n     \n   \n   * PropertiesTest.java\n     \n     \n\n\n11.8 Collections工具类#\n\n> 排序相关\n\n * void reverse(List list)：反转list中元素的顺序\n\n * void shuffle(List list)：对list中的元素进行随机排序\n\n * void sort(List list)：按照list中元素的自然顺序进行排序\n\n * void sort(List list, Comparator c)：根据指定的Comparator对list中的元素进行排序\n\n * void swap(List list, int i, int j) ：交换list中第i个和第j个元素的位置\n\n * T max(Collection coll)：根据元素的自然顺序，返回集合中的最大元素\n\n * T max(Collection coll, Comparator comp)：根据指定的Comparator的指定顺序，返回集合中的最大元素\n\n * T min(Collection coll)：根据元素的自然顺序，返回集合中的最小元素\n\n * T min(Collection coll, Comparator comp)：根据指定的Comparator的指定顺序，返回集合中的最小元素\n\n * int frequency(Collection c, Object o)：返回指定集合中指定元素出现的次数\n\n * void copy(List dest, List src)：将src中的内容赋值到的dest中\n   \n   使用此方法时，需要保证dest.size() >= src.size()\n   \n   \n\n * boolean replaceAll(List list, T oldVal, T newVal)：用newVal替换list中的oldVal\n\n> 同步控制\n\nCollections中提供了多个synchronizedXxx()，用来将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。synch\nronizedXxx()的返回结果即为线程安全的。","routePath":"/tang/java2/11_Java集合","lang":"","toc":[{"text":"11.1 概述","id":"111-概述","depth":2,"charIndex":3},{"text":"11.2 Java集合框架","id":"112-java集合框架","depth":2,"charIndex":230},{"text":"11.3 Collection接口中的方法","id":"113-collection接口中的方法","depth":2,"charIndex":872},{"text":"11.4 Iterator迭代器接口","id":"114-iterator迭代器接口","depth":2,"charIndex":1663},{"text":"11.5 List接口","id":"115-list接口","depth":2,"charIndex":2230},{"text":"11.5.1 ArrayList源码分析","id":"1151-arraylist源码分析","depth":3,"charIndex":2245},{"text":"11.5.2 LinkedList源码分析","id":"1152-linkedlist源码分析","depth":3,"charIndex":2393},{"text":"11.5.3 Vector的源码分析","id":"1153-vector的源码分析","depth":3,"charIndex":2445},{"text":"11.5.4 List接口中的方法","id":"1154-list接口中的方法","depth":3,"charIndex":2469},{"text":"11.6 Set接口","id":"116-set接口","depth":2,"charIndex":2987},{"text":"11.6.1 概述","id":"1161-概述","depth":3,"charIndex":3001},{"text":"11.6.2 HashSet","id":"1162-hashset","depth":3,"charIndex":3445},{"text":"11.6.3 LinkedHashSet","id":"1163-linkedhashset","depth":3,"charIndex":4282},{"text":"11.6.4 TreeSet","id":"1164-treeset","depth":3,"charIndex":4449},{"text":"11.7 Map接口","id":"117-map接口","depth":2,"charIndex":4833},{"text":"11.7.1 概述","id":"1171-概述","depth":3,"charIndex":4847},{"text":"11.7.2 HashMap底层实现原理","id":"1172-hashmap底层实现原理","depth":3,"charIndex":5586},{"text":"11.7.3 LinkedHashMap底层实现原理","id":"1173-linkedhashmap底层实现原理","depth":3,"charIndex":6829},{"text":"11.7.4 Map接口中的方法","id":"1174-map接口中的方法","depth":3,"charIndex":7016},{"text":"11.7.5 TreeMap的使用","id":"1175-treemap的使用","depth":3,"charIndex":7656},{"text":"11.7.6 Properties","id":"1176-properties","depth":3,"charIndex":7814},{"text":"11.8 Collections工具类","id":"118-collections工具类","depth":2,"charIndex":7995}],"domain":"","frontmatter":{},"version":""},{"id":125,"title":"12 Java泛型","content":"#\n\n\n12.1 概述#\n\n> 定义\n\n所谓泛型，就是允许在定义类、接口时通过一个标识表明类中某个属性的类型、某个方法的返回值、参数类型。这个类型参数将在使用时（如：继承或者实现这个接口，用这个类型声\n明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。\n\n\n12.2 自定义泛型结构#\n\n> 自定义泛型类、泛型接口\n\n * 泛型类、泛型接口可能有多个参数，此时应该将多个参数放到一对尖括号中，并用逗号隔开。如\n\n * 泛型如果不指定，将被擦除，单行对应的类型均按照Object处理，但不等价于Object\n\n * JDK7中，实例化泛型类时可以简化为：ArrayList list = new ArrayList<>()\n\n * 泛型不能是基本数据类型，可以使用包装类替换\n\n * 泛型类或者泛型接口中，不能在静态方法中使用类的泛型\n   \n   泛型的具体类型需要在类实例化的时候指定，静态方法在类实例化之前就可以被调用\n\n * 异常类不能有泛型\n\n * 创建泛型数组：T[] arr = (T[]) new Object[10]\n   \n   不可以使用 T[] arr = new T[10]\n\n * 父类有泛型，子类可以选择保留泛型，也可以选择指定泛型类型\n   \n   \n   \n   * 子类不保留父类的泛型：按需实现\n     \n     * 没有类型（泛型会被擦除）\n       \n       \n     \n     * 具体类型\n       \n       \n   \n   * 子类保留父类泛型：泛型子类\n     \n     * 全部保留\n       \n       \n     \n     * 部分保留\n       \n       \n\n> 自定义泛型方法\n\n * 泛型方法，是在方法中出现了泛型的结构。该泛型结构与所在类的泛型参数没有任何关系\n   \n   换句话说，泛型方法所在的类是不是泛型类都没有关系\n\n * 泛型方法可以声明为静态的。\n   \n   因为泛型参数是在调用方法的时候确定的，并非实例化类的时候才确定\n\n\n\n\n12.3 泛型在继承方面的体现#\n\n * 类A是类B的父类，G和G不具备子父类关系，二者是并列关系。即：\n   \n   \n   \n   补充：类A是类B的父类(接口)，那么A是B的父类\n   \n   \n\n * 类A是类B的父类，G和G二者共同的父类是G\n\n\n12.4 通配符的使用#\n\n> 类A是类B的父类，G和G二者共同的父类是G\n\n\n\n> 通配符的写入与读取\n\n\n\n> 有限制条件的通配符\n\n * 通配符指定上限\n   \n   上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口。即<=\n\n * 通配符指定下线\n   \n   下限super：使用时指定的类型不能小于操作的类，即>=\n\n * 举例\n   \n   * ? extends A\n     \n     ?可以是类A，也可以是类A的子类\n   \n   * ? super A\n     \n     ?可以是类A，也可以是类A的父类\n   \n   ","routePath":"/tang/java2/12_Java泛型","lang":"","toc":[{"text":"12.1 概述","id":"121-概述","depth":2,"charIndex":3},{"text":"12.2 自定义泛型结构","id":"122-自定义泛型结构","depth":2,"charIndex":136},{"text":"12.3 泛型在继承方面的体现","id":"123-泛型在继承方面的体现","depth":2,"charIndex":888},{"text":"12.4 通配符的使用","id":"124-通配符的使用","depth":2,"charIndex":1017}],"domain":"","frontmatter":{},"version":""},{"id":126,"title":"13 IO流","content":"#\n\n\n13.1 File类的使用#\n\n> 创建File实例\n\n * new File(String filePath)\n * new File(String parentPath, String childPath)\n * new File(File filePath, String childPath)\n\n> File常用方法\n\n * String getAgetAbsolutePath()：获取绝对路径\n\n * String getPath()：获取路径\n   \n   \n\n * String getName()：获取文件名\n\n * String getParent()：获取上层文件目录路径。若无，返回null\n   \n   如果创建文件的时候，使用的是相对路径，返回的是null；如果使用的是绝对路径，则返回该文件的上级路径\n   \n   \n\n * long length()：获取文件长度（单位：字节）\n\n * long lastModified()：获取最后一次的修改时间（单位：毫秒）\n\n * String[] list()：获取指定目录下的所有文件或者文件夹的名称数组\n\n * File[] listFiles()：获取指定目录下的所有文件或者文件夹的File数组\n\n * boolean renameTo(File dest)：把文件重命名为指定的文件路径\n   \n   以file1.renameTo(file2)为例，若想返回true，要保证：\n   \n   * file1在硬盘中真实存在\n   * file2在硬盘中不存在\n\n * boolean isDirectory()：是否是个路径\n\n * boolean isFile()：是否是个文件\n\n * boolean exists()：是否存在\n\n * boolean canRead()：是否可读\n\n * boolean canWrite()：是否可写\n\n * boolean isHidden()：是否隐藏\n\n * boolean createNewFile()：创建文件。如果文件存在，则不创建，返回false\n\n * boolean mkdir()：创建文件目录。如果此目录存在，或者此文件目录的上层目录不存在，就不创建\n\n * boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建\n   \n   如果创建文件或者文件目录没有写盘符，默认在项目路径下\n\n * boolean delete()：删除文件或文件夹\n   \n   * java中的删除不走回收站\n   * 要删除一个文件目录，请注意该文件目录下不能包含文件或者文件目录\n\n\n13.2 IO流原理及流的分类#\n\n> 流的分类\n\n * 按操作的数据单位分：字节流、字符流\n * 按流的流向分：输入流、输出流\n * 按流的角色分：节点流、处理流\n\n（抽象基类）         节点流（文件流）           处理流\nInputStream    FileInputStream    BufferedInputStream\nOutputStream   FileOutputStream   BufferedOutputStream\nReader         FileReader         BufferedReader\nWriter         FileWriter         BufferedWriter\n\n\n13.3 FileReader与FileWriter的使用#\n\n> 使用场景\n\n适用于处理文本文件（.txt，.java，.c，.cpp）的场景。不能用来处理图片等字节数据\n\n> 步骤\n\n * 创建File对象，指明写入、写出的文件\n * 创建输入流FileReader、输出流FileWriter对象\n * 执行写入、写出操作\n * 关闭流(关闭时，先判断流是否为空。不为空的流才执行关闭操作)\n\n> 重点\n\n * FileReader.reader()：每次读取一个字符，返回值为当前字符的ASCII码。如果读到文件末尾，返回-1\n * FileReader.reader.read(char []\n   cbuf)：每次最多读取cbuf.length个字符放到cbuf[]中，返回值是本次读取到的字符的个数。如果读到文件末尾，返回-1\n * new FileWriter(file, false) / new FileWriter(file)：写出时会对原有文件进行覆盖\n * new FileWriter(file, true)：在原有文件基础上追加内容\n\n> 示例\n\n\n\n\n13.4 FileInputStream与FileOutputStream的使用#\n\n> 使用场景\n\n适用于处理非文本文件（.jpg，.png，.mp3，.mp4，.avi，.doc，.ppt）。如果执行复制操作，也可以处理文本文件。\n\n如果用来输出文本文件，有可能出现乱码\n\n> 步骤\n\n * 创建File对象，指明写入、写出的文件\n * 创建输入流FileInputStream、输出流FileOutputStream对象\n * 执行写入、写出操作\n * 关闭流(关闭时，先判断流是否为空。不为空的流才执行关闭操作)\n\n> 示例\n\n\n\n\n13.5 处理流之缓冲流的使用#\n\n> 缓冲流\n\n * BufferedInputStream和BufferedOutputStream\n * BufferedReader和BufferedWriter\n\n> 概述\n\n * 作用：提高流的读取、写入速度\n * 原理：内部提供了一个缓冲区\n * 实现：处理流，就是“套接”在已有的流的基础上\n\n> 步骤\n\n * 实例化File，指明读取、写出的文件\n * 造流\n   * 造节点流\n   * 造处理流\n * 读取文件、写入文件\n * 关闭流\n\n> 重点\n\n * BufferedReader中多了个readLine()，该方法一次返回一行数据，不包括换行符。读取到文件末尾，返回null\n * BufferedWriter中可以使用newLine()实现换行\n * FileInputStream、FileOutputStream实例化时参数也可以传文件路径new FileInputStream(String\n   filePath)、new FileOutputStream(String filePath)\n * BufferedReader、BufferedWriter实例化时参数也可以传文件路径new BufferedReader(String\n   filePath)、new BufferedWriter(String filePath)\n\n> 示例\n\n\n\n\n13.6 处理流之转换流的使用#\n\n> 转换流\n\n * InputStreamReader：将一个字节的输入流转换为字符的输入流。体现为解码\n * OutputStreamReader：将一个字符的输出流转换为字节的输出流。体现为编码\n\n> 概述\n\n * 作用：提供字节流与字符流之间的转换\n\n> 示例\n\n\n\n\n13.7 字符集#\n\n * ASCII：美国标准信息交换码。用一个字节的7位可以表示\n * ISO8895-1：拉丁码表，欧洲码表。用一个字节的8位表示\n * GB2312：中国的中文编码表。最多两个字节编码所有字符\n * GBK：中国的中文编码表升级，融合了更多的中文文字符号（如繁体字）。最多两个字节编码所有字符\n * Unicode：国际标准码，融合了目前人类使用的所有字符，为每一个字符分配唯一的字符。所有文字都用两个字节来表示\n * UTF-8：变长的编码方式。可用1-4的字节来表示一个字符\n\nUnicode字符集只是定义了字符的集合和唯一编号。Unicode编码，是对UTF-8、UTF-16、UTF-32等具体编码的统称，并不是具体的编码方案\n\n\n13.8 处理流之标准的输入、输出流#\n\n> 概述\n\n * System.in: 标准的输入流，默认从键盘输入。类型是InputStream\n * System.out: 标准的输出流，默认从显示器输出。类型是PrintStream\n * 可以通过System.setIn(InputStream in)和System.setOut(PrintStream out)对默认设备进行修改\n\n> 实例\n\n要求：从键盘输入字符串。要求将读取到的整行字符串转成大写并输出，然后继续进行输入操作。直到当输入“e”或者“exit”时，退出程序。\n\n\n\n\n13.9 处理流之打印流#\n\n> 作用\n\n * 实现将基本数据类型的数据格式转化为字符串输出\n * 提供了一系列重载的print()和println()\n\n> 打印流\n\n * PrintStream：字节输出流\n * PrintWriter：字符输出流\n\n> 示例\n\n要求：使用System.out将内容输出到文件中，而非控制台中\n\n\n\n\n13.10 处理流之数据流#\n\n> 数据流\n\n * DataInputStream\n * DataOutputStream\n\n> 作用\n\n用于读取或者写出基本数据类型的变量或字符串。（如将内存中的数据持久化到文件中（写出），在文件中读取数据到内存中（读取））\n\n> 重点\n\n * 文件的读取和写入顺序要一致，否则会报EOFException异常\n * 每当执行DataOutputStream的flush()就会将内存中的数据写入到文件中\n\n> 示例\n\n要求：将内存中的变量写入到文件中，并将文件中的内容读取到变量中，并输出\n\n\n\n\n13.11 处理流之对象流#\n\n> 对象流\n\n * ObjectInputStream\n * ObjectOutputStream\n\n> 作用\n\n用于存储和读取基本数据类型数据或对象的处理流\n\n用到了序列化和反序列化技术\n\n> 示例\n\n要求：\n\n① 序列化过程：将内存中的java对象以二进制流的方式保存到磁盘中或通过网络传输出去\n\n② 反序列化过程：将磁盘或者网络中的二进制流转化为内存中的Java对象\n\n\n\n\n13.12 序列化与反序列化#\n\n> 定义\n\n * 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制\n * 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制\n\n> 对象的序列化机制\n\n对象序列化机制允许把内存中的Java对象转换为平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另外一个网络节点。当其\n它程序获取了这种二进制流，就可以回复称原来的Java对象。\n\n> Java对象序列化的要求\n\n * 需要实现接口：Serializable\n\n * 当前类需要提供一个全局常量serialVersionUID\n   \n   serialVersionUID用来表明类的不同版本之间的兼容性。如果类没有显示定义该静态常量，它的值是Java运行时环境根据类的内部细节自动生成。如果类\n   的属性进行了修改（添加属性或者删除属性），serialVersionUID有可能发生变化。\n\n * 除了当前类需要实现Serializable接口外，还必须保证该类的所有属性也必须是可序列化的\n\n> 注意\n\n\n13.13 随机存取文件流#\n\n> 随机存取文件流-RandomAccessFile\n\n * RandomAccessFile类直接继承Object类，实现了DataInput和DataOutput接口，因此该类既可以读也可以写\n\n * RandomAccessFile支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件\n   \n   * 支持只访问文件的部分内容\n   * 可以向已存在的文件后追加内容\n\n * RandomAccessFile对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针：\n   \n   * long getFilePointer()：获取文件记录指针的当前位置\n   * void seek(long pos)：将文件记录指针定位到pos位置\n\n * RandomAccessFile类写文件时：\n   \n   * 如果文件不存在，会自动创建文件；\n   * 如果文件存在，会在文件开头进行覆盖写入\n\n * RandomAccessFile构造器：\n   \n   * public RandomAccessFile(String name, String mode)\n   * public RandomAccessFile(File file, String mode)\n   \n   在创建RandomAccessFile实例时，需要指定mode参数，该参数指定RandomAccessFile的访问模式：\n   \n   * r：以只读的方式打开。不会创建文件，如果读取不存在的文件，会抛出异常\n   * rw：打开以便读取和写入。文件不存在时，会创建文件\n   * rwd：打开以便读取和写入；同步文件内容的更新\n   * rws：打开以便读取和写入；同步文件内容和元数据的更新\n\n> 应用举例\n\n可以使用RandomAccessFile实现多线程断点下载任务。\n\n下载前，先创建两个临时文件。一个是与被下载文件大小相同的空文件，一个是记录文件指针的位置文件。每次暂停时，都会保存上一次的指针，再次下载时，会继续从上一次的地方\n下载。以此实现断点下载或者上传的功能。\n\n> 示例：使用RandomAccessFile实现图片的复制\n\n\n\n> 示例：使用RandomAccessFile实现在文件中间插入\n\n\n\n\n13.14 NIO.2中Path、Paths、Files类的使用#\n\n> 概述\n\n * NIO：New IO，Non-Blocking IO。是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。\n   NIO与原来的IO有着同样的作用和目的，但是使用的方式完全不同。NIO支持面向缓冲区的（IO是面向流的）、基于通道的IO操作。\n   NIO将以更加高效的方式进行文件的读写操作\n   \n   * Java API中提供了两套NIO，一套是针对标准输入输出的NIO， 一套是网络编程NIO\n     * java.nio.channels.Channel\n       * FileChannel：处理本地文件\n       * SocketChannel：TCP网络编程的客户端的Channel\n       * ServerSocketChannel：TCP网络编程的服务端的Channel\n       * DatagramChannel：UDP网络编程中发送端和接收端的Channel\n\n * NIO.2：JDK7中，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，因此被称为NIO.2\n   \n   * JDK7中引入了如下类：\n     \n     * Path接口：代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以视为File的升级版（如File中的大多数方法在失败的时候只能返\n       回false，并不能提供异常。Path接口弥补了这种不足）\n     \n     * Paths类：Path的工具类\n       \n       * static Path get(String first, String ...more)：用于将多个字符串串连成路径\n       * static Path get(URI uri)：返回指定uri队形的Path路径\n     \n     * Files类：工具类\n\n> Path常用方法\n\n * String toString()：返回调用Path对象的字符串表示形式\n * boolean startsWith(String path)：判断是否以path路径开始\n * boolean endsWith(String path)：判断是否以path路径结束\n * boolean isAbsolute()：判断是否是绝对路径\n * Path getParent()：返回path的父级文件（夹）\n * Path getRoot()：获取path的根路径\n * Path getFileName()：返回与调用Path对象关联的文件名\n * int getNameCount()：返回path根路径后元素的数量\n * Path getName(int index)：返回指定索引index出的路径名\n * Path toAbsolutePath()：返回以当前path的绝对路径的Path对象\n * Path resolve(Path other)：合并两个路径，并返回合并后的Path对象\n * File toFile()：将Path类对象转为File类对象\n\n> Files常用方法\n\n * boolean exists(Path path, LinkOption... options)：判断文件是否存在\n   \n   \n\n * boolean notExists(Path path, LinkOption... options)：判断文件是否不存在\n\n * boolean isDirectory(Path path, LinkOption... options)：判断是否是目录\n\n * boolean isRegularFile(Path path, LinkOption... options)：判断是否是文件\n\n * boolean isHidden(Path path)：判断是否是隐藏文件\n\n * boolean isReadable(Path path)：判断文件是否可读\n\n * boolean isWritable(Path path)：判断文件是否可写\n\n * SeekableByteChannel newByteChannel(Path path, OpenOption...\n   options)：获取与指定文件的连接，options指定打开方式\n\n * DirectoryStream newDirectoryStream(Path dir)：打开dir指定的路径\n\n * InputStream newInputStream(Path path, OpenOption... options)：获取InputStream对象\n\n * OutputStream newOutputStream(Path path, OpenOption... options)：获取Output对象\n\n * LinkOption.NOFOLLOW_LINKS：不遵循符号链接\n\n * StandardOpenOption.READ：以读的方式连接文件\n * StandardOpenOption.WRITE：以写的方式连接文件\n * StandardOpenOption.APPEND：以追加的方式连接文件，不会覆盖文件原本内容，在后面追加\n * StandardOpenOption.TRUNCATE_EXISTING：\n   * 如果文件存在并且以WRITE的方式连接时就会把文件内容清空，文件设置为0字节大小\n   * 如果文件只以READ连接 时，该选项会被忽略\n * StandardOpenOption.CREATE：创建一个文件，如果文件已存在，就打开文件连接。与CREATE_NEW同时存在时该选项会被忽略\n * StandardOpenOption.CREATE_NEW：创建一个文件，如果文件已存在，如果已经存在会抛异常\n * StandardOpenOption.DELETE_ON_CLOSE：通道关闭时删除文件\n * StandardOpenOption.SPARSE：创建稀疏文件，与CREATE_NEW选项配合使用\n * StandardOpenOption.SYNC：要求每次写入要把内容和元数据刷到存储设备上\n * StandardOpenOption.DSYNC：要求每次写入要把内容刷到存储设备上","routePath":"/tang/java2/13_IO流","lang":"","toc":[{"text":"13.1 File类的使用","id":"131-file类的使用","depth":3,"charIndex":3},{"text":"13.2 IO流原理及流的分类","id":"132-io流原理及流的分类","depth":3,"charIndex":1127},{"text":"13.3 FileReader与FileWriter的使用","id":"133-filereader与filewriter的使用","depth":3,"charIndex":1458},{"text":"13.4 FileInputStream与FileOutputStream的使用","id":"134-fileinputstream与fileoutputstream的使用","depth":3,"charIndex":1950},{"text":"13.5 处理流之缓冲流的使用","id":"135-处理流之缓冲流的使用","depth":3,"charIndex":2221},{"text":"13.6 处理流之转换流的使用","id":"136-处理流之转换流的使用","depth":3,"charIndex":2833},{"text":"13.7 字符集","id":"137-字符集","depth":3,"charIndex":2989},{"text":"13.8 处理流之标准的输入、输出流","id":"138-处理流之标准的输入输出流","depth":3,"charIndex":3321},{"text":"13.9 处理流之打印流","id":"139-处理流之打印流","depth":3,"charIndex":3592},{"text":"13.10 处理流之数据流","id":"1310-处理流之数据流","depth":3,"charIndex":3762},{"text":"13.11 处理流之对象流","id":"1311-处理流之对象流","depth":3,"charIndex":4029},{"text":"13.12 序列化与反序列化","id":"1312-序列化与反序列化","depth":3,"charIndex":4236},{"text":"13.13 随机存取文件流","id":"1313-随机存取文件流","depth":3,"charIndex":4734},{"text":"13.14 NIO.2中Path、Paths、Files类的使用","id":"1314-nio2中pathpathsfiles类的使用","depth":3,"charIndex":5743}],"domain":"","frontmatter":{},"version":""},{"id":127,"title":"14 网络编程","content":"#\n\n\n14.1 通信要素1：IP和端口号#\n\n> IP地址：InetAddress\n\n * 作用：用来唯一标识Internet上的计算机\n\n * 在Java中使用InetAddress类代表IP\n\n * IP地址分类1\n   \n   * IPV4：\n   * IPV6：\n\n * IP地址分类2\n   \n   * 公网地址（万维网使用）\n   * 私有地址（局域网使用）\n\n * 本地回路地址：127.0.0.1 对应着localhost\n\n * InetAddress类的使用\n   \n   * 实例化\n     \n     * InetAddress getByName(String\n       host)：根据指定host获取InetAddress对象。host可以是ip地址，也可以是域名\n     * InetAddress getLocalHost()：获取本机InetAddress对象\n   \n   * 两个常用方法\n     \n     * String getHostName()：获取InetAddress对象的主机名\n     * String getHostAddress()：获取InetAddress对象的ip地址\n   \n   * 示例\n     \n     \n\n> 端口号\n\n * 作用：标识正在计算机上正在运行的程序\n * 不同的进程对应不同的端口号\n * 端口号的范围：0~65535\n * 端口分类：\n   * 公认端口：0~1023，被预先定义的服务通信占用\n   * 注册端口：1024，分配给用户进程或应用程序\n   * 动态/私有端口：49152~65535\n * 端口号和IP地址的组合得出一个网络套接字：Socket\n\n\n14.2 通信要素2：网络协议#\n\n> 通信协议分层的思想\n\n同层间可以通信，上一层可以调用下一层，隔层不可以通信\n\n> TCP/IP协议簇\n\n * 传输层协议中有两个非常重要的协议\n   \n   * 传输控制协议TCP\n     \n     * 实用TCP协议前，须先建立TCP连接，行程传输数据通道\n     \n     * 传输前，采用“三次握手”方式，点对点通信，是可靠的\n       \n       * 第一次握手：客户端发送syn报文，并置发送序号为X\n       * 第二次握手：服务端发送syn+ACK报文，并置发送序号为Y，在确认序号为X+1\n       * 第三次握手：客户端发送ACK报文，并置发送序号为Z，在确认序号为Y+1\n       \n       \n     \n     * TCP协议进行通信的两个应用进程：客户端、服务端\n     \n     * 在连接中可以进行大数据量的传输\n     \n     * 传输完毕，需释放已建立的连接，效率低。释放连接需要经历“四次挥手”\n       \n       挥手时，客户端和服务端都可以开始挥手，但是一般都是客户端主动挥手，断开连接\n       \n       * 第一次挥手：主动方发送Fin+ACK报文，并置发送序号为X\n       * 第二次挥手：被动方发送ACK报文，并置发送序号为Z，在确认序号为X+1\n       * 第三次挥手：被动方发送Fin+ACK报文，并置发送序号为Y，在确认序号为X（此时已经断开连接）\n       * 第四次挥手：主动方发送ACK报文，并置发送序号为X，在确认序号为Y（此步骤就是为了去验证是否真的断开连接）\n       \n       \n   \n   * 用户数据报协议UDP\n     \n     * 将数据、源、目的封装成数据包，不需要建立连接\n     * 每个数据报的大小限制在64K内\n     * 发送不管对方是否准备好，接收方收到也不需要确认，故是不可靠的\n     * 可以广播发送\n     * 发送数据结束时无需释放资源，开销小，速度快\n     * 应用场景：可以接受一部分数据的丢失，比如看网络视频，可以接受一部分帧的丢失，但是不能接受卡顿。\n\n * TCP/IP以其两个主要协议传输控制协议（TCP）和网络互联协议（IP）而得名。实际上是一组协议，包括多个具有不同功能且互为关联的协议\n\n * IP协议是网络层的主要协议，支持网络间互连的数据通信\n\n * TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层、应用层\n\n\n14.3 TCP网络编程#\n\n> 例1. 客户端发送信息给服务端，服务端将接收到的数据显示在控制台\n\n【重点难点】：熟悉客户端、服务端Socket的使用\n\n\n\n> 例2. 从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端\n\n【重点难点】\n\n * 使用Socket发送、接收图片\n\n * 服务端给用户端发送反馈，客户端接收\n\n\n\n\n14.4 UDP网络编程#\n\n> 例1. 接收端接收发送端发送的消息，并打印\n\n\n\n\n14.5 URL编程#\n\n> URL\n\n * URL：统一资源定位符，它表示Internet上某一资源的地址\n\n * 是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源\n\n * URL的基本结构由5部分组成：\n   \n   <传输协议>://<主机名>:<端口号>/<资源地址>?参数列表\n\n> URL构造器与常用方法\n\n * URL(String spec)：构造器\n * String getProtocol()：获取URL的协议名\n * String getHost()：获取URL的主机名\n * int getPort()：获取URL的端口号\n * String getPath()：获取URL的文件路径\n * String getFile()：获取URL的文件名\n * String getQuery()：获取URL中的参数\n\n\n\n> 例1. 从url中下载图片并保存到本地\n\n","routePath":"/tang/java2/14_网络编程","lang":"","toc":[{"text":"14.1  通信要素1：IP和端口号","id":"141--通信要素1ip和端口号","depth":3,"charIndex":-1},{"text":"14.2 通信要素2：网络协议","id":"142-通信要素2网络协议","depth":3,"charIndex":739},{"text":"14.3 TCP网络编程","id":"143-tcp网络编程","depth":3,"charIndex":1854},{"text":"14.4 UDP网络编程","id":"144-udp网络编程","depth":3,"charIndex":2030},{"text":"14.5 URL编程","id":"145-url编程","depth":3,"charIndex":2073}],"domain":"","frontmatter":{},"version":""},{"id":128,"title":"15 Java反射机制","content":"#\n\n\n15.1 Java反射机制概述#\n\n> Reflection--反射\n\n * Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期间借助于Reflection\n   API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法\n\n * 加载完类之后，在堆内存的方法区就产生了一个Class类型的对象（一个类只能有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象\n   看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射\n\n * 类加载的方式\n   \n   * 正常方式：引入需要的“包类”名称 ---> 通过new实例化 ---> 取得实例化对象\n   * 反射方式：实例化对象 ---> getClass()方法 ---> 得到完整的“包类”名称\n\n> 反射的特征\n\n动态性\n\n> 静态语言 VS 动态语言\n\n * 动态语言：\n   * 定义：是一类在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或者是其他结构上的变化。通俗来说就是在运行时代码\n     可以根据某些条件改变自身结构。\n   * 举例：Object-C、C#、JavaScript、PHP、Python、Erlang\n * 静态语言：\n   * 定义：运行时结构不可变的语言\n   * 举例：Java、C、C++\n\nJava不是动态语言，但是Java可以称为准动态语。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。\n\n> Java反射机制提供的功能\n\n * 在运行时判断任意一个对象所属的类\n * 在运行时构造任意一个类的对象\n * 在运行时判断任意一个类所具有的成员变量和方法\n * 在运行时获取泛型信息\n * 在运行时调用任意一个对象的成员变量和方法\n * 在运行时处理注解\n * 生成动态代理\n\n> 反射相关的主要API\n\n * java.lang.Class：代表一个类。用来表示一个通用的类，是一个用来描述类的类\n * java.lang.reflect.Method：代表类的方法\n * java.lang.reflect.Field：代表类的成员变量\n * java.lang.reflect.Constructor：代表类的构造器\n * ...\n\n> 疑问1：通过直接new的方式或反射的方式都可以调用公共结构，开发中到底使用哪个？\n\n * 建议使用new的方式，但是不排除使用反射的方式\n * 反射方式使用场景：当编译时不确定new哪个类的对象时\n\n> 疑问2：反射机制与面向对象中的封装性是不是矛盾？如何看待这两个技术？\n\n（封装性是私有的外部不能访问，反射是可以访问私有的属性和方法）\n\n封装性中私有的属性和方法等，外部不能访问，是指的没必要去访问，但是如果一定要访问的话，也是可以访问的。如果非要访问的话，就得使用反射技术了。\n\n\n15.2 java.lang.Class#\n\n> java.lang.Class类的理解与获取\n\n * 类的加载过程：\n   \n   程序经过javac.exe命令后，会生成一个或多个字节码文件（.class结尾），接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某\n   个字节码文件加载到内存中。\n   将字节码文件加载到内存中（或者说使用java.exe命令对字节码文件进行解释运行）的过程就称为类的加载。加载到内存中的类，就称为运行时类，此运行时类，就作\n   为Class的一个实例。\n\n * 换句话说：\n   \n   Class的实例就对应着一个运行时类\n\n * 加载到内存中的运行时类，会缓存一定的时间。在此时间内，可以通过不同的方式来获取此运行时类\n\n * 获取Class实例的方式\n   \n   * 通过运行时类的属性：类.class\n   * 通过运行时类的对象，调用getClass()\n   * 调用Class的静态方法：forName(String className)。其中className是类的完整的“包类”名\n   * 使用类的加载器：ClassLoader\n\n * 获取Class实例方式的例子\n   \n   \n\n> 哪些类型可以有Class对象？\n\n * class：外部类、成员（成员内部类。静态内部类），局部内部类，匿名内部类\n\n * interface：接口\n\n * []：数组\n   \n   \n\n * enum：枚举\n\n * annotation：注解@interface\n\n * primitive type：基本数据类型\n\n * void\n\n> 类的加载过程\n\n当程序主动使用某个类时，如果该类还未被加载到内存中，系统会经过如下三个步骤对该类进行初始化：\n\n * 类的加载：将class文件字节码内容加载到内存中，并将这些静态数据转成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，\n   作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器的参与。\n * {类的链接：将java类的二进制字节码合并到JVM的运行过程中的过程。\n   * 验证：确保加载的类信息符合JVM规范。如：以cafe开头，没有安全方面的内容\n   * 准备：正式为类的static变量分配内存并设置类变量默认初始值，这些内存都将在方法区中进行分配\n   * 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）\n * 类的初始化\n   * 执行类构造器()方法的过程。执行类构造器()是由编译期自动收集类中所有类变量的复制动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构\n     造该类对象的构造器）\n   * 当初始化一个类的时候，如果返现其父类还没初始化，则需要先触发其父类的初始化\n   * 虚拟机会保证一个类的()在多线程环境中被正确加锁和同步\n\n> 类加载器的作用\n\n * 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据执行转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang\n   .Class对象，作为方法区中类数据的访问入口\n\n * 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Cla\n   ss对象\n\n * JVM规范中定义了如下类型的类的加载器：\n   \n   以下几个类加载器的加载原则：执行自底向上检查是否已装载，自顶向下尝试加载类。\n   \n   * Bootstrap\n     Classloader：执行引导类加载器。C++编写的，是JVM自带的类加载器，执行负责Java平台的核心库，用来装载核心类库。该加载器无法直接获取，\n     自然也无法让Bootstrap Classloader加载自己定义的类。\n   * Extension Classloader：执行扩展类加载器。负责执行jre/lib/ext目录下的jar包或者-D java.ext.dirs\n     指定目录下的jar包装入工作库\n   * System Classloader：执行系统类加载器。负责执行java -classpath或者-D java.class.path\n     指定目录下的类与jar包装入工作库，自定义的类也是通过System Classloader加载的\n   * 自定义类加载器\n\n * 获取类的加载器\n   \n   \n\n * 使用FileInputStream和类加载器读取配置文件\n   \n   \n\n\n15.3 创建运行时类的对象#\n\n\n15.3.1 Class newInstance()的使用#\n\n * 作用：创建对应的运行时类。内部调用了运行时类的空参构造器\n\n * 使用newInstance()的要求：\n   \n   * 运行时类必须有空参构造器，否则会报InstantiationException异常\n   * 空参构造器的访问权限得够。可以为缺省、protected、public，通常设置为public。\n\n * 扩展：在JavaBean中要求提供一个public的空参构造器，原因：\n   \n   * 便于通过反射，创建运行时类的对象\n   * 便于子类继承此运行时类，默认调用super()时，保证父类有此构造器\n\n * 举例：\n   \n   \n\n\n15.3.2 体会反射的动态性#\n\nReflection（反射）是被视为动态语言的关键，动态语言就是在运行时代码可以根据某些条件改变自身结构\n\n如下代码中，在编译阶段是无法确定创建哪个对象的。只有在运行时获取到num的数值之后，才能确定创建的到底是哪个对象。这就提现了反射的动态性。\n\n\n\n\n15.4 获取运行时类的完整结构#\n\n\n15.4.1 获取运行时类的属性结构#\n\n> 相关方法\n\n * Field[] getFields()：获取当前运行时类及其父类中public修饰的属性\n * Field[] getDeclaredFields()：获取当前运行时类中声明的所有属性，不包含父类中声明的属性\n\n\n\n> 扩展：获取属性的权限修饰符、数据类型、属性名称\n\n\n\n\n15.4.2 获取运行时类的方法结构#\n\n> 相关方法\n\n * getMethods()：获取当前运行时类及其父类中public修饰的方法\n * getDeclaredMethods()：获取当前运行时类中声明的所有方法，不包含父类中的方法\n\n\n\n> 扩展：获取方法声明的注解、权限修饰符、返回值类型、形参列表、抛出的异常\n\n\n\n\n15.4.3 获取当前运行时类的构造器#\n\n> 相关方法\n\n * getConstructors()：获取当前运行时类中声明为public的构造器，不包含父类构造器\n * getDeclaredConstructors()：获取当前运行时类中的所有构造器，不包含父类构造器\n\n\n\n\n15.4.4 获取当前运行时类的父类#\n\n> 相关方法\n\n * getSuperclass()：获取当前运行时类的父类\n * getGenericSuperclass()：获取当前运行时类带泛型的父类\n\n\n\n\n15.4.5 获取当前运行时类实现的接口#\n\n> 相关方法\n\n * getInterfaces()：获取当前运行时类的接口\n\n\n\n\n15.4.6 获取当前运行时类所在的包#\n\n> 相关方法\n\n * getPackage()：获取当前运行时类所在的包\n\n\n\n\n15.4.7 获取当前运行时类声明的注解#\n\n> 相关方法\n\n * getAnnotations()：获取当前运行时类声明的注解\n\n\n\n\n15.5 调用运行时类的指定结构#\n\n\n15.5.1 调用运行时类的指定属性#\n\n> 相关方法\n\n * getField(String name)：获取指定属性。要求运行时类中属性声明为public。通常不采用此方法\n * getDeclaredField(String name)：获取运行时类中的指定属性\n * setAccessible(boolean flag)：保证当前属性是可访问的\n * set(Object obj, Object value)：设置当前属性的值\n   * obj：指明设置哪个对象的属性\n   * value：此属性的值设置为多少\n * get(Object obj)：获取当前属性的值\n   * obj 指明获取哪个对象\n\n\n\n\n15.5.2 调用运行时类中指定的方法#\n\n> 相关方法\n\n * getDeclaredMethod(String name, Class... parameterTypes)：获取运行时类的指定方法\n   * name：方法名称\n   * parameterTypes：方法的形参列表\n * setAccessible(boolean flag)：保证方法是可以访问的\n * Object invoke(Object obj, Object... args)：执行方法，并获取返回值\n   * obj：指明是哪个对象。当方法是静态方法时，Obj可以为 null，也可以为 运行时类.class\n   * args ：给方法的形参赋值\n   * 返回值： invoke()的返回值即为运行时类中指定方法的返回值。如果运行时类中的方法没有返回值，invoke()的返回值为null\n\n\n\n\n15.5.3 调用运行时类指定的构造器#\n\n> 相关方法\n\n * getDeclaredConstructor(Class... parameterTypes)：获取指定构造器\n * setAccessible(boolean flag)：保证构造器是可以访问的\n * newInstance(Object ... initargs)：调用构造器，创建运行时类对象\n   * initargs：构造器形参列表\n\n\n\n\n15.6 反射的应用：动态代理#\n\n> 代理模式的原理\n\n使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时讲方法调用转到原始对象上。\n\n> 静态代理的缺陷\n\n6.8小节中的代理机制的操作，属于静态代理，特征是代理类和被代理类都是在编译期间确定下来的，不利于程序的扩展。同时，每一个代理类只能为一个（或者一套）接口服务，\n这样一来程序开发中必然产生过多的代理。执行最好是可以通过一个代理类完成全部的代理功能。\n\n> 动态代理\n\n * 定义\n   \n   动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。\n\n * 使用场景\n   \n   * 调试\n   * 远程方法调用\n\n * 相较于静态代理的优点\n   \n   抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法\n\n> 静态代理的使用举例\n\n\n\n> 动态代理的使用举例\n\n","routePath":"/tang/java2/15_Java反射机制","lang":"","toc":[{"text":"15.1 Java反射机制概述","id":"151-java反射机制概述","depth":2,"charIndex":3},{"text":"15.2 java.lang.Class","id":"152-javalangclass","depth":2,"charIndex":1255},{"text":"15.3 创建运行时类的对象","id":"153-创建运行时类的对象","depth":2,"charIndex":3250},{"text":"15.3.1 Class newInstance()的使用","id":"1531-class-newinstance的使用","depth":3,"charIndex":3268},{"text":"15.3.2 体会反射的动态性","id":"1532-体会反射的动态性","depth":3,"charIndex":3585},{"text":"15.4 获取运行时类的完整结构","id":"154-获取运行时类的完整结构","depth":2,"charIndex":3731},{"text":"15.4.1 获取运行时类的属性结构","id":"1541-获取运行时类的属性结构","depth":3,"charIndex":3751},{"text":"15.4.2 获取运行时类的方法结构","id":"1542-获取运行时类的方法结构","depth":3,"charIndex":3921},{"text":"15.4.3 获取当前运行时类的构造器","id":"1543-获取当前运行时类的构造器","depth":3,"charIndex":4087},{"text":"15.4.4 获取当前运行时类的父类","id":"1544-获取当前运行时类的父类","depth":3,"charIndex":4228},{"text":"15.4.5 获取当前运行时类实现的接口","id":"1545-获取当前运行时类实现的接口","depth":3,"charIndex":4333},{"text":"15.4.6 获取当前运行时类所在的包","id":"1546-获取当前运行时类所在的包","depth":3,"charIndex":4399},{"text":"15.4.7 获取当前运行时类声明的注解","id":"1547-获取当前运行时类声明的注解","depth":3,"charIndex":4462},{"text":"15.5 调用运行时类的指定结构","id":"155-调用运行时类的指定结构","depth":2,"charIndex":4531},{"text":"15.5.1 调用运行时类的指定属性","id":"1551-调用运行时类的指定属性","depth":3,"charIndex":4551},{"text":"15.5.2 调用运行时类中指定的方法","id":"1552-调用运行时类中指定的方法","depth":3,"charIndex":4864},{"text":"15.5.3 调用运行时类指定的构造器","id":"1553-调用运行时类指定的构造器","depth":3,"charIndex":5258},{"text":"15.6 反射的应用：动态代理","id":"156-反射的应用动态代理","depth":2,"charIndex":5467}],"domain":"","frontmatter":{},"version":""},{"id":129,"title":"16 Java8新特性","content":"#\n\nJava8中最重要的两大改变：Lambda表达式、Stream API\n\n\n16.1 接口新特性#\n\n> JDK8以后，接口既可以定义全局常量、抽象方法，也可以定义静态方法、默认方法。\n\n * 定义静态方法（public static）：接口中定义的静态方法，只能通过接口来调用\n * 定义默认方法（public default）：\n   * 可以通过实现类的对象，调用接口中的默认方法\n   * 实现类可以重写接口的默认方法\n   * 如果子类（或实现类）继承的父类和实现的接口中，声明了同名、同参的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的方法 --->\n     类优先原则\n   * 如果实现类实现了多个接口，且这多个接口中定义了同名、同参的默认方法，在实现类没有重写此方法的情况下，编译报错 ---> 接口冲突\n     * 如果想解决以上冲突，必须在实现类中重写此方法。\n   * 如何在子类（或实现类）的方法中调用父类、接口中被重写的方法？\n     * 调用父类中声明的方法：super.方法\n     * 调用接口中默认的方法：接口名.super.方法\n\n\n16.2 新的日期时间API#\n\n具体使用见9.2.2 JDK8中新的日期时间API小节\n\n> JDK8新增的日期时间API\n\n * java.time.LocalDate：获取日期\n * java.time.LocalTime：获取时间\n * java.time.LocalDateTime：获取日期+时间\n * java.time.Instant：瞬时，等同于Date中的getTime()\n * java.time.format.DateTimeFormatter：时间格式化\n * 其他API：\n   * java.time.ZoneId：时区相关操作\n   * java.time.ZonedDateTime：带时区的日期时间\n   * java.time.Clock：使用时区提供对当前即时、日期、和时间的访问的时钟\n   * java.time.Duration：用来计算两个时间的间隔，可以获取秒级间隔，也可以获取纳秒级间隔\n   * java.time.Period：用来计算两个日期的间隔\n   * java.time.temporal.TemporalAdjuster：时间校正器。如获取当前日期的下一个工作日等\n   * java.time.temporal.TemporalAdjusters：该类通过静态方法提供了大量的TemporalAdjuster实现\n\n\n16.3 注解新特性#\n\n具体使用见10.2.6 JDK8中注解新特性小节\n\n * 可重复注解：在一个类或者属性或其他结构上使用多次相同注解\n * 类型注解：\n   * JDK8之前，注解只能是在声明的地方使用；JDK8之后，注解可以应用在任何地方。\n   * JDK8之后，元注解@Target的参数类型ElementType枚举值多了两个：\n     * ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如泛型声明）\n     * ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中\n\n\n16.4 Lambda表达式#\n\n> 格式\n\n * ->：lambda操作符 或 箭头操作符\n * -> 左边：lambda形参列表，即接口中抽象方法的形参列表\n * -> 右边：lambda体，即重写的抽象方法的方法体\n\n> 举例\n\n(o1, o2) -> Interger.compare(o1,o2)\n\n> lambda的使用\n\n * -> 左边：\n   * lambda形参列表的参数类型可以省略（类型推断）\n   * 如果lambda形参列表只有一个参数，其一对()可以省略\n * -> 右边：\n   * lambda体应该使用一对{}包裹\n   * 如果lambda体只有一条执行语句（可能是return语句），可以省略一对{}和return关键字（如果省略{}，return必须省略）\n\n> 使用举例\n\n\n\n> lambda表达式的本质\n\n * 接口的要求：接口必须是函数式接口\n * 以前用匿名实现类表示的，现在都可以用Lambda表达式来写\n\n\n16.5 函数式(Functional)接口#\n\n> 定义\n\n如果一个接口中，只声明了一个(抽象)方法，那么这个接口就叫函数式接口。(接口中的方法都是抽象方法)\n\n * 自定义函数式接口时，可以在接口上加上@FunctionalInterface注解。这样可以检查它是否是一个函数式接口\n * 在java.util.function包下定义了Java8的丰富的函数式接口\n\n> Java内置四大核心函数式接口\n\n函数式接口             参数类型   返回类型      用途\nConsumer 消费型接口    T      void      对类型为T的对象应用操作，包含方法：void accept(T t)\nSupplier 供给型接口    无      T         返回类型为T的对象，包含方法：T get()\nFunction 函数型接口    T      R         对类型为T的对象应用操作，并返回R类型的结果，包含方法：R apply(T)\nPredicate 判定型接口   T      boolean   确定类型为T的对象是否满足约束，并返回boolean值，包含方法：boolean test(T t)\n\n\n16.6 方法引用与构造器引用#\n\n\n16.6.1 方法引用#\n\n> 概述\n\n * 当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用\n * 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法应用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以\n   认为是Lambda表达式的一个语法糖\n * 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致\n * 格式：使用操作符::将类（或对象）与方法名分隔开来\n * 三种主要使用情况：(注意，::右侧都是方法名，不需要参数)\n   * 对象::实例方法名\n   * 类::静态方法名\n   * 类::非静态方法名\n\n> 举例\n\n * 情况一：对象 :: 实例方法\n   \n   \n\n * 情况二：类 :: 静态方法\n   \n   \n\n * 情况三：类 :: 静态方法\n   \n   \n\n\n16.6.2 构造器引用#\n\n> 概述\n\n和方法引用类似。\n\n * 使用场景：函数式接口的抽象方法的形参列表和构造器的形参列表一致且抽象方法的返回值即为构造器所属的类的类型\n\n> 使用举例\n\n\n\n\n16.6.3 数组引用#\n\n> 概述\n\n可以将数组引用看做是一个特殊的类，写法与构造器引用一致\n\n> 使用举例\n\n\n\n\n16.7 Stream API#\n\n\n16.7.1 概述#\n\n * Stream API(java.util.stream)把真正的函数式变成风格引入到Java中\n\n * 可以使用Stream API对集合数据进行操作，如过滤、查询、排序等\n\n * 为什么要用Stream API？\n   \n   实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但是对于像MongoDB、Radis等NoSql中获取的数据需要在Java层面去处理。\n\n * Stream和Collection的区别\n   \n   * Collection是一种静态的内存数据结构；Stream是有关计算的\n   * Collection主要是面向内存，存储在内存中；Stream主要是面向CPU，通过CPU实现计算\n\n * 注意：\n   \n   * Stream不会存储数据\n   * Stream不会改变源对象，会返回一个持有结果的新的Stream ---- Stream 的不可变性\n   * Stream操作是延迟执行的。这意味着他们会等到结果的时候才执行\n\n\n16.7.2 Stream的操作三个步骤#\n\n * ①创建Stream\n   \n   一个数据源（如集合、数组），获取一个流\n\n * ②中间操作\n   \n   一个中间操作链，对数据源的数据进行处理\n\n * ③终止操作（终端操作）\n   \n   一旦执行终止操作，就执行中间操作链，并产生结果。之后不会再被使用\n\n\n\n\n16.7.3 Stream的实例化#\n\n * 通过集合实例化\n   \n   * Stream stream()：返回一个顺序流\n   * Stream parallelStream()：返回一个并行流\n\n * 通过数组实例化\n   \n   * 调用Arrays 的static Stream stream(T[] array)方法\n\n * 通过Stream的static Stream of(T... values)方法实例化\n\n * 创建无限流 ---- 用于造数据\n   \n   * 调用Stream的static Stream iterate(final T seed, final UnaryOperator f)方法\n   * 调用Stream的static Stream generate(Supplier s)方法\n\n * 举例说明\n   \n   \n\n\n16.7.4 Stream的中间操作#\n\n多个中间操作可以连接起来行程一个流水线。除非流水线上触发终止操作， 否则中间操作不会执行任何的处理！而是在终止操作时一次性全部处理。 这称为“惰性求值”。\n\n> 筛选与切片\n\n方法                    描述\nfilter(Predicate p)   接收Lambda，从流中排除某些元素\ndistinct()            筛选，通过流元素生成的hasCode()和equals()去除重复元素\nlimit(long maxSize)   截断流，使其元素不超过指定数量\nship(long n)          跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补\n\n> 映射\n\n方法                                                            描述\nmap(Function f)                                               接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。\nflatMap(Function f)                                           接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流。\nmapToDouble(ToDoubleFunction                                  接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream\nf)与flatMapToDouble(ToDoubleFunction f)\nmapToInt(ToIntFunction f)与flatMapToInt(ToIntFunction f)       接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream\nmapToLong(ToLongFunction f)与flatMapToLong(ToLongFunction f)   接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream\n\n答：map(Function f)类似于List中的add()，flatMap(Function f)类似于List中的addAll()。\n\n> 排序\n\n方法                              描述\nsorted()                        产生一个新流，其中按自然顺序排序\nsorted(Comparator comparator)   产生一个新柳，其中按照自定义的Comparator实现定制排序\n\n> 例子\n\n * 测试类：\n   \n   \n\n * 实体类：\n   \n   \n\n\n16.7.5 Stream的终止操作#\n\n> 匹配与查找\n\n方法                      描述\nallMatch(Predicate p)   检查是否匹配所有元素\nanyMatch(Predicate p)   检查是否至少匹配一个元素\nnoneMatch()             检查是否没有匹配所有元素\nfindFirst()             返回第一个元素\nfindAny()               返回当前流中任意元素\ncount()                 返回流中元素总数\nmax(Comparator c)       返回流中最大值\nmin(Comparator c)       返回流中最小值\nforEach(Consumer c)     内部迭代（使用Collection接口需要用户去做迭代的方法，称为外部迭代。相反Stream API使用内部迭代）\n\n> 规约\n\n方法                                 描述\nreduce(T iden, BinaryOperator b)   可以将流中元素反复结合起来，得到一个值。参数iden表示初始值。返回值类型为T\nreduce(BinaryOperator b)           可以将流中元素反复结合起来，得到一个值。返回值类型为Optional\n\nmap和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名\n\n如计算List中员工工资的总和\n\n> 收集\n\n方法                     描述\ncollect(Collector c)   将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法\n\nCollector接口中方法的实现决定了如何对流执行收集的操作（如收集到List、Set、Map）。另外Collectors实用类提供了很多静态方法，可以便捷的\n创建常见收集器实例，常见方法如下：\n\n方法                                         返回值类型                  作用\ntoList()                                   List                   把流中元素收集到List\ntoSet()                                    Set                    把流中元素收集到Set\ntoCollection(Supplier collectionFactory)   Collection             把流中元素收集到创建的集合\ncounting()                                 Long                   计算流中元素的个数\nsummingInt(ToIntFunction mapper)           Integer                对流中元素的整数属性求和\naveragingInt(ToIntFunction mapper)         Double                 对流中元素的整数属性求平均值\nsummarizingInt(ToIntFunction mapper)       IntSummaryStatistics   收集流中Integer属性的统计值，如平均值\n\n> 举例\n\n * 测试类：\n   \n   \n\n * 实体类\n   \n   见16.7.4 中间操作中的实体类。\n\n\n16.8 Optional类#\n\n> 概述\n\nOptional类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。\n原来用null表示一个值不存在，现在Optional可以更好的表达这个概念，并且可以避免空指针异常。Optional中提供了很多方法，这样就不用显示进行空值j检\n测\n\n> Optional相关方法\n\n * 创建Optional类对象\n   * Optional.of(T t)：创建一个Optional实例，t必须非空\n   * Optional.empty()：创建一个空的Optional实例\n   * Optional.ofNullable(T t)：t可以为空\n * 判断Optional容器中是否包含对象\n   * boolean isPresent()：判断是否包含对象\n   * void ifPresent(Consumer c)：如果有值，就执行Consumer接口的实例代码，并且该值会作为参数传给它\n * 获取Optional容器的对象\n   * T get()：如果调用对象包含值，返回该值，否则抛异常\n   * T orElse(T other)：如果有值将其返回，否则返回指定的other对象\n   * T orElseGet(Supplier s)：如果有值将其返回，否则抛出由Supplier接口提供的异常\n\n> 举例：Optional是如何避免空指针的\n\n重要方法：\n\n * Optional ofNullable(T value)：获取Optional实例\n * T orElse(T other)：或uOptiona实例的对象\n\n\n\n\n16.9 try语句的优化#\n\nJava8中可以实现资源的自动关闭，要求执行后要关闭的资源必须在try的一对小括号中初始化，否则编译不通过。\n\n\n\n\n16.10 其他新特性#\n\n * 通用目标类型推断\n * JDK的更新：\n   * 集合的流式操作\n   * 并发\n   * Arrays\n   * Number和Math\n   * IO/NIO的改进\n   * Reflection获取形参名\n   * String：join()\n   * Files\n * 新编译工具：\n   * jjs\n   * jdeps\n * JVM中Metaspace取代PermGen空间","routePath":"/tang/java2/16_Java8新特性","lang":"","toc":[{"text":"16.1 接口新特性","id":"161-接口新特性","depth":2,"charIndex":40},{"text":"16.2 新的日期时间API","id":"162-新的日期时间api","depth":2,"charIndex":501},{"text":"16.3 注解新特性","id":"163-注解新特性","depth":2,"charIndex":1096},{"text":"16.4 Lambda表达式","id":"164-lambda表达式","depth":2,"charIndex":1378},{"text":"16.5 函数式(Functional)接口","id":"165-函数式functional接口","depth":2,"charIndex":1810},{"text":"16.6 方法引用与构造器引用","id":"166-方法引用与构造器引用","depth":2,"charIndex":2344},{"text":"16.6.1 方法引用","id":"1661-方法引用","depth":3,"charIndex":2363},{"text":"16.6.2 构造器引用","id":"1662-构造器引用","depth":3,"charIndex":2771},{"text":"16.6.3 数组引用","id":"1663-数组引用","depth":3,"charIndex":2870},{"text":"16.7 Stream API","id":"167-stream-api","depth":2,"charIndex":2930},{"text":"16.7.1 概述","id":"1671-概述","depth":3,"charIndex":2949},{"text":"16.7.2 Stream的操作三个步骤","id":"1672-stream的操作三个步骤","depth":3,"charIndex":3406},{"text":"16.7.3 Stream的实例化","id":"1673-stream的实例化","depth":3,"charIndex":3566},{"text":"16.7.4 Stream的中间操作","id":"1674-stream的中间操作","depth":3,"charIndex":3950},{"text":"16.7.5 Stream的终止操作","id":"1675-stream的终止操作","depth":3,"charIndex":5205},{"text":"16.8 Optional类","id":"168-optional类","depth":2,"charIndex":6770},{"text":"16.9 try语句的优化","id":"169-try语句的优化","depth":2,"charIndex":7506},{"text":"16.10 其他新特性","id":"1610-其他新特性","depth":2,"charIndex":7581}],"domain":"","frontmatter":{},"version":""},{"id":130,"title":"17 Java9&10&11新特性","content":"#\n\n> 概述\n\n * 从java9开始，java的从以特性驱动的发布周期转变为以时间驱动的发布周期。\n   Java的计划发布周期是6个月，Oracle（在Java11之后）将以三年为周期发布长期支持版本。\n * java9、java10不是长期支持的版本，java11是长期支持的版本。因此可以不用安装java9、java10，直接安装java11就行\n\n\n17.1 Java9新特性#\n\nJava9中最重要的两大改变：模块化系统、jshell命令\n\n> 概述\n\nJava9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的REPL工具（jshell、JDK编译工具）、Java公共API和私有代码，以及安全增\n强、扩展提升、性能管理改善等。可以说Java9是一个庞大的系统工程，完全做了一个整体改变。\n\n> Java9中不得不说的新特性\n\n * 最主要之一：模块化系统\n * 最主要之二：jshell命令\n * 多版本兼容jar包\n * 语法改进之一：接口的私有方法\n * 语法改进之二：钻石操作符(<>)的使用升级\n * 语法改进之三：语法改进：try\n * API改进之一：String存储结构变更\n * API改进之二：便利的集合特性--of()创建只读集合\n * API改进之三：增强的Stream API\n * API改进之四：全新的HTTP客户端API\n * API改进之五：Deprecated的相关API\n * javadoc的HTML5支持\n * JavaScript引擎升级--Nashorn（Java11中被干掉了）\n * java的动态编译器\n\n\n17.1.1 模块化系统#\n\n> 模块化系统提出的背景\n\n谈到Java9大家往往第一个想到的就是Jigsaw项目。Java自出生以来，Java和相关生态在不断丰富的同时，也暴露出一些问题：\n\n * Java运行环境的膨胀和臃肿。每次启动JVM，至少会有30~60MB的内存加载，主要原因是JVM需要加载rt.jar\n * 当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了Java开发和运行效\n   率的提升\n * 很难真正的对代码进行封装，而系统并没有对不同部分（也就是JAR文件）之间的依赖有个明确的概念。每个公共类都可以被类路径下任何其他公共类访问到，这样就导致无\n   意中使用了并不想公开访问的API\n\n> 定义\n\n本质上讲，模块（module）的概念，其实就是package外再裹一层。也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是\n隐藏。因此，模块化使得代码组织上更安全， 因为它可以指定哪些部分可以暴露，哪些部分需要隐藏。\n\n> 优点\n\n * 减少内存的开销\n * 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护\n * 改进Java SE平台，使其可以适应不同大小的计算设备\n * 改进其安全性、可维护性，提高性能\n\n> 例子：在day13模块中使用java9test模块中定义的Person类\n\n * 注意事项：\n   \n   day13模块中使用Person类的类，所在的包不能和Person类所在包名字相同\n\n * 步骤\n   \n   * ①在java9test模块中的src目录下创建module-info.java文件，写明要暴露出去的包(注意是包，不能详细到类)\n   * ②在day13模块的src目录下中创建module-info.java文件，写明要导入的包(注意是包，不能详细到类)\n   * ③在day13模块中使用java9test模块中的类\n\n * 代码\n   \n   * java9test模块中Person类\n     \n     \n   \n   * java9test模块中module-info.java文件\n     \n     \n   \n   * day13模块中module-info.java文件\n     \n     \n   \n   * day13模块中使用Person类\n     \n     \n\n\n17.1.2 Java的REPL工具：jshell命令#\n\n> REPL概念\n\n * 定义：\n   \n   REPL（read-evaluate-print-loop），以交互的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈\n   。\n   \n   之前的java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现\n\n * 设计理念：\n   \n   即写即得，快速运行\n\n * 实现目标：\n   \n   * java9中开始由了REPL工具--jshell。在控制台启动jshell，在没有创建类的情况下，可以直接声明变量、计算表达式、执行语句。\n   * jshell可以从文件中加载语句或者将语句保存到文件中\n   * jshell中可以使用Tab键自动补全\n\n> jshell工具的使用\n\n * 使用控制台打开jshell工具，并尝试打印“hello world”：\n   \n   \n\n * 声明变量：如果变量名被重复定义，后边定义的会覆盖之前的\n   \n   \n\n * 声明方法：如果方法名被重复定义，后边定义的会覆盖之前的\n   \n   \n\n * 方法调用：\n   \n   \n\n * 声明类：\n   \n   \n\n * 引入包：\n   \n   \n\n * 编译时异常的处理：\n   \n   对于编译时异常，jshell在后台会将其隐藏，不会强制程序员捕获\n   \n   \n\n * /help：获取jshell帮助\n\n * /edit：打开编辑窗口。对之前输入的内容编辑完成后，点击Accept按钮编辑内容方可生效\n   \n   \n\n * /vars：列出当前session下定义过的变量\n   \n   \n\n * /methods：列出当前session下定义过的方法\n   \n   \n\n * /list：列出当前session里所有有效的代码片段\n   \n   \n\n * /open：调用外部文件中的java代码\n   \n   java文件中不需要定义类，只需按照jshell工具中的语法编写即可。\n   \n   \n\n * /exit：退出\n   \n   \n\n\n17.1.3 接口的私有方法#\n\nJava8中接口除了抽象方法之外，还可以定义静态方法（静态方法只能接口自己调用，实现类不能调用）、默认方法（实现类可以选择是否重写接口中的默认方法）。\n\nJava9中接口的方法可以定义为private的。私有方法只能在接口内部使用，外部不允许调用。\n\n\n\n\n17.1.4 钻石操作符使用升级#\n\n此外，该特性要与jdk7中新特性--类型推断区分开。\n\n\n\n\n17.1.5 try语句的改进#\n\n在java8和java9中可以实现资源的自动关闭。\n\n * 在java8中，需要关闭的资源的实例化需要在try后边的()中进行。此时\n * 在java9中，需要关闭的资源的实例化可以在try外边实现，try对应的()中写明要关闭的资源。多个资源用 ; 隔开\n\n\n\n\n17.1.6 String存储结构的变更#\n\nString、StringBuilder、StringBuffer(线程安全)底层改用byte[]存储，不在使用char[]\n\n\n17.1.7 新增创建只读集合的方法#\n\n * java9之前创建只读集合--使用Collections.unmodifiableXxx()\n   \n   以List为例。List还可以使用Arrays.asList()创建只读集合\n   \n   \n\n * java9创建只读集合--使用of()方法\n   \n   \n\n\n17.1.8 InputStream加强#\n\n\n\n\n17.1.9 增强的Stream API#\n\nJava9中新增了4个新方法：\n\n * takeWhile()：从开头开始查找满足指定规则的数据，直到找到不满足规则的第一个数据为止，并将这些数据返回\n   \n   \n\n * dropWhile()：与takeWhile()相反。从开头开始查找不满足指定规则的数据，直到找到满足规则的第一个数据为止，并将这些数据返回\n   \n   \n\n * ofNullable()：参数只有一个，且形参变量可以是单个的null\n   \n   \n\n * iterate()：是一个重载方法。重载后的第二个参数可以表示终止条件\n   \n   \n\n\n17.1.10 Optional获取Stream的方法#\n\n\n\n\n17.1.11 JavaScript引擎升级：Nashorn#\n\n * Java8之前使用Rhino解析JavaScript，Java8开始使用Nashorn，在Java9中对Nashorn进行改进--Nashorn为java\n   提供了轻量级的JavaScript运行时\n * Java9包含一个用来解析Nashorn的ECMAScript语法树的API。这个API使得IED和服务端框架不需要依赖Nashorn项目的内部实现类，就\n   能分析ECMAScript代码\n * 在Java11中，Nashorn被一个新的引擎所取代\n\n附：完整的JavaScript实现包含3部分：\n\n * ECMAScript：描述该语言的语法和基本对象\n * DOM：文档对象模型。描述处理网页内容的方法和接口\n * BOM：浏览器对象模型。描述与浏览器进行交互的方法和接口\n\n\n17.2 Java10新特性#\n\nJava10中最重要的改变：局部变量类型推断\n\n> 概述\n\nJava10提供了超过109项新特性，其中包含12个JEP(JDK特性加强协议)，对于程序员来讲，真正的新特性就一个。\n\n\n17.2.1 局部变量类型推断#\n\n> 定义\n\n局部变量类型推断是指，在声明局部变量时，可以根据=右侧的内容推断出变量的类型，此时=左侧不需要再注明变量的类型，直接使用var即可。\n\n例子：\n\n\n\n> 适用场景\n\n * 声明局部变量\n * 增强for循环的遍历操作\n * 普通for循环的遍历操作\n\n\n\n> 不适用场景\n\n * 没有初始化的局部变量\n   \n   \n\n * Lambda表达式中，左边的函数式接口不能声明为var\n   \n   \n\n * 方法引用中，左边函数式接口不能声明为var\n   \n   \n\n * 数组的静态初始化中，当省略右侧数组元素类型时，左侧变量类型不能生命为var\n   \n   \n\n * catch块中，异常类型不能声明为var\n   \n   \n\n * 方法的返回值类型，不能声明为var\n   \n   \n\n * 方法的形参，不能声明为var\n\n * 构造器的形参，不能声明为var\n\n * 类的属性，不能声明为var\n\n> 工作原理\n\n在处理var时，编译器先是看表达式右边部分，并根据右边变量值的类型进行推断，作为左边的类型，然后将该类型写入字节码文件中。\n\n> 注意事项\n\n * var不是关键字。var是一个类型名，也是一个普通的标识符。作为类型名，在编译器需要知道类型的地方才会用到它。作为一个普通的标识符，除了不能用它作为类名外\n   ，声明的变量、方法等都可以使用var来命名\n\n * 这不是JavaScript。JavaScript是一门边解释边运行的语言，是一门动态语言。虽然Java10中引入了var，但是var\n   并不会改变Java是一门静态语言的事实。在遇到var声明的变量时，编译器负责推断出类型，并将其写入字节码文件。var的出现只是简化了程序的编写，对字节码文\n   件没有任何作用。也就是说源文件中用var声明的变量，在字节码中会将var转换为对应的类型，如下图：\n   \n   \n\n\n17.2.2 再次新增创建只读集合的方法#\n\n> 使用方法\n\n\n\n> 注意事项\n\nList copyOf(Collection\ncoll)在返回只读集合时，会先判断coll是不是AbstractImmutableList类型的。如果coll是AbstractImmutableList类型\n的，会将coll直接返回。否则会调用List.of()方法创建一个新的AbstractImmutableList集合并返回。\n\n\n\n\n17.3 Java11新特性#\n\nJava11中最重要的两个改变：引入了两种新的GC，包括Epsilon和ZGC（也许具有跨时代的意义）\n\n\n17.3.1 String新增的方法#\n\n方法                         描述            举例\nboolean isBlank()          判断字符串是否是空白    \" \".isBlank(); // true\nString strip()             去掉首尾空格        \" JavaStack \".strip(); // \"JavaStack\"\nString stripTrailing()     去掉尾部空格        \" JavaStack \".stripTrailing(); // \" JavaStack\"\nString stripLeading()      去掉首部空格        \" JavaStack \".stripLeading(); // \"JavaStack \"\nString repeat(int count)   复制count次字符串   \"Java\".repeat(3); // \"JavaJavaJava\"\nStream lines()             行数统计          \"A\\nB\\nC\".lines().count(); // 3\n\n\n17.3.2 Optional加强#\n\nOptional也新增了几个方法，可以方便的将一个Optional转换成一个Stream，或者当一个空Optional时给它一个替代的。\n\n方法                                                            描述                                              新增的版本\nboolean isEmpty()                                             判断value是否为空（与JDK8中的isPresent()正好相反）             JDK11\nvoid ifPresentOrElse(Consumer action, Runnable emptyAction)   若value非空，执行参数1；否则，执行参数2                         JDK9\nOptional or(Supplier supplier)                                若value非空，返回对应的Optional；否则，返回形参包装的Optional       JDK9\nStream stream()                                               若value非空，返回包含此value的Stream；否则，返回空的Stream        JDK9\nT orElseThrow()                                               若value非空，返回value；否则，抛异常NoSuchElementException   JDK10\n\n\n17.3.3 局部变量类型推断升级#\n\n可以在在var上添加注解\n\n\n\n\n17.4 全新的HTTP客户端API#\n\n> 概述\n\n * HTTP/1.1和HTTP/2（2015年成为标准）两个协议的主要区别\n   \n   二者的主要区别是如何在客户端和服务器之间构建和传输数据。\n   \n   * HTTP/1.1依赖于相应周期\n   * HTTP/2允许服务器“push”数据：它可以发送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载网页至关重要的数据\n\n * 在JDK9中引入Http Client\n   API，该API支持同步和异步，而且在JDK11中对其进行了修改，此时成为正式可用状态。可以在java.net包中找到该API\n\n * 它将替代仅适用于blocking模式的HttpURLConnection(HttpURLConnection是在HTTP1.0的时代创建的)，并提供对\n   WebSocket 和 HTTP/2 的支持。\n\n> 使用举例\n\n\n\n\n17.5 更简化的编译运行程序#\n\n在JDK11之前，运行一个Java源码，需要先编译，再运行。在JDK11中只用一个java命令就可以直接编译运行程序。\n\n> 只用一个java命令就运行程序的要求\n\n * 该方法运行java文件，是去执行源文件中的第一个类，且第一个类必须包含main方法\n * 不可以使用其它源文件中的类\n\n\n17.6 废弃Nashorn引擎#\n\n废除Nashorn JavaScript引擎，有需要可以考虑使用G让AIVM。\n\n\n17.7 ZGC垃圾回收#\n\n> 背景\n\n现代系统中可用的内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存，并且无需长时间的GC暂停时间\n\n> 概念\n\nZGC是一个并发、基于region、压缩型的垃圾回收器，只有root扫描阶段会STW（stop the\nworld），因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。\n\n但是目前还是处于试验阶段，开发环境不建议使用\n\n> 优势\n\n * GC暂停时间不会超过10ms\n * 既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)\n * 和G1相比, 应用吞吐能力不会下降超过15%\n * 为未来的GC功能和利用colord指针以及Load barriers优化奠定基础\n * 初始只支持64位系统\n\n\n17.8 其他新特性#\n\n * Unicode 10\n * Deprecate the Pack200 Tools and API\n * 新的Epsilon垃圾收集器\n * 完全支持Linux容器（包括Docker）\n * 支持G1上的并行完全垃圾收集\n * 最新的HTTPS安全协议TLS 1.3\n * Java Flight Recorder\n\n\n17.9 JDK展望#\n\n * 缺乏一个标准化和轻量级的JSON API\n * 缺乏新的货币API","routePath":"/tang/java2/17_Java9&10&11新特性","lang":"","toc":[{"text":"17.1 Java9新特性","id":"171-java9新特性","depth":2,"charIndex":180},{"text":"17.1.1 模块化系统","id":"1711-模块化系统","depth":3,"charIndex":695},{"text":"17.1.2 Java的REPL工具：jshell命令","id":"1712-java的repl工具jshell命令","depth":3,"charIndex":1751},{"text":"17.1.3 接口的私有方法","id":"1713-接口的私有方法","depth":3,"charIndex":2659},{"text":"17.1.4 钻石操作符使用升级","id":"1714-钻石操作符使用升级","depth":3,"charIndex":2805},{"text":"17.1.5 try语句的改进","id":"1715-try语句的改进","depth":3,"charIndex":2855},{"text":"17.1.6 String存储结构的变更","id":"1716-string存储结构的变更","depth":3,"charIndex":3006},{"text":"17.1.7 新增创建只读集合的方法","id":"1717-新增创建只读集合的方法","depth":3,"charIndex":3094},{"text":"17.1.8 InputStream加强","id":"1718-inputstream加强","depth":3,"charIndex":3255},{"text":"17.1.9 增强的Stream API","id":"1719-增强的stream-api","depth":3,"charIndex":3281},{"text":"17.1.10 Optional获取Stream的方法","id":"17110-optional获取stream的方法","depth":3,"charIndex":3569},{"text":"17.1.11 JavaScript引擎升级：Nashorn","id":"17111-javascript引擎升级nashorn","depth":3,"charIndex":3602},{"text":"17.2 Java10新特性","id":"172-java10新特性","depth":2,"charIndex":3987},{"text":"17.2.1 局部变量类型推断","id":"1721-局部变量类型推断","depth":3,"charIndex":4096},{"text":"17.2.2 再次新增创建只读集合的方法","id":"1722-再次新增创建只读集合的方法","depth":3,"charIndex":4924},{"text":"17.3 Java11新特性","id":"173-java11新特性","depth":2,"charIndex":5136},{"text":"17.3.1 String新增的方法","id":"1731-string新增的方法","depth":3,"charIndex":5207},{"text":"17.3.2 Optional加强","id":"1732-optional加强","depth":3,"charIndex":5742},{"text":"17.3.3 局部变量类型推断升级","id":"1733-局部变量类型推断升级","depth":3,"charIndex":6527},{"text":"17.4 全新的HTTP客户端API","id":"174-全新的http客户端api","depth":2,"charIndex":6564},{"text":"17.5 更简化的编译运行程序","id":"175-更简化的编译运行程序","depth":2,"charIndex":6972},{"text":"17.6 废弃Nashorn引擎","id":"176-废弃nashorn引擎","depth":2,"charIndex":7137},{"text":"17.7 ZGC垃圾回收","id":"177-zgc垃圾回收","depth":2,"charIndex":7198},{"text":"17.8 其他新特性","id":"178-其他新特性","depth":2,"charIndex":7538},{"text":"17.9 JDK展望","id":"179-jdk展望","depth":2,"charIndex":7714}],"domain":"","frontmatter":{},"version":""},{"id":131,"title":"18 JUC并发编程","content":"#\n\n\n18.1.集合类不安全#\n\n\n18.1.1 List不安全#\n\n> 解决方案\n\n * 使用Vector\n   \n   \n\n * 使用Collections.synchronizedList\n   \n   \n\n * 使用CopyOnWriteArrayList----JUC编程\n   \n   \n   \n   CopyOnWriteArrayList和Vector相比，CopyOnWriteArrayList使用Lock实现的同步，Vector使用的是synch\n   ronized，前者效率更高。\n   \n   CopyOnWrite 写入时复制。------ COW 计算机程序设计领域的一种优化策略。\n   \n   \n\n\n18.1.2 Set不安全#\n\n> 解决方案\n\n * 使用Collections.synchronizedSet\n   \n   \n\n * 使用CopyOnWriteArrayList----JUC编程\n   \n   \n\n\n18.1.3 HashMap#\n\n> 解决方案\n\n * 使用Collections.synchronizedMap\n   \n   \n\n * 使用ConcurrentHashMap----JUC编程\n   \n   \n\n\n18.1.4 代码总结#\n\n\n\n\n18.2.Callable#\n\n\n\n细节：\n\n * 有缓存----效率高\n * futureTask.get()可能会发生阻塞\n\n\n18.3.常用辅助类#\n\n\n18.3.1 CountDownLanch#\n\n其实是个减法计数器。\n\n\n\n> 原理\n\ncountDownLatch.countDown()数量减一；\n\ncountDownLatch.await()等待计数器归零，然后再向下执行。\n\n每个线程执行完毕后，调用countDownLatch.countDown()方法，会执行减一操作。\n\n\n18.3.2 CyclicBarrier#\n\n其实是个加法计数器。\n\n\n\n\n18.3.3 Semaphore#\n\n抢车位。一般限流时使用。\n\n\n\n> 原理\n\nsemaphore.acquire();获得。假设已经满了，就会等待，一直到被释放为止。\n\nsemaphore.release();释放。会将当前的信号释放，唤醒正在等待的县程。\n\n> 作用\n\n * 多个共享资源互斥时使用\n * 并发限流，控制最大线程数\n\n\n18.4.线程池#\n\n> 使用线程池的好处\n\n * 降低资源消耗\n * 提高响应速度\n * 可以控制最大线程数\n * 方便管理线程\n\n\n18.4.1 “三大方法”#\n\n\n\n创建线程池不要使用Executors工具类，而是使用底层方法ThreadPoolExecutor。\n\n使用Executors工具类的弊端如下：\n\n * FixedThreadPool和SingleThreadPool：允许请求的队列长度是Integer.MAX_VALUE(约为21亿)，可能会堆积大量请求\n   ，导致OOM。\n * CachedThreadPool和ScheduledThreadPool：允许创建的线程数量是Integer.MAX_VALUE(约为21亿)，可能会创建\n   大量线程，导致OOM。\n\n\n18.4.2 \"七大参数\"#\n\n\n\n\n18.4.3 \"四大拒绝策略\"#\n\n\n\n\n18.4.4 线程池的最大大小如何设置？#\n\n * CPU密集型：电脑CPU几核就是几，可以保持CPU的效率最高\n   \n   使用Runtime.getRuntime().availableProcessors()获取CPU核数！\n\n * IO密集型：程序中十分耗IO的线程数*2\n\n * \n\n\n18.5.ForkJoin#\n\n\n\n\n\n\n18.6.异步回调#\n\n","routePath":"/tang/java2/18_JUC并发编程","lang":"","toc":[{"text":"18.1.集合类不安全","id":"181集合类不安全","depth":2,"charIndex":3},{"text":"18.1.1 List不安全","id":"1811-list不安全","depth":3,"charIndex":18},{"text":"18.1.2 Set不安全","id":"1812-set不安全","depth":3,"charIndex":318},{"text":"18.1.3 HashMap","id":"1813-hashmap","depth":3,"charIndex":429},{"text":"18.1.4 代码总结","id":"1814-代码总结","depth":3,"charIndex":538},{"text":"18.2.Callable","id":"182callable","depth":2,"charIndex":555},{"text":"18.3.常用辅助类","id":"183常用辅助类","depth":2,"charIndex":621},{"text":"18.3.1 CountDownLanch","id":"1831-countdownlanch","depth":3,"charIndex":635},{"text":"18.3.2 CyclicBarrier","id":"1832-cyclicbarrier","depth":3,"charIndex":804},{"text":"18.3.3 Semaphore","id":"1833-semaphore","depth":3,"charIndex":842},{"text":"18.4.线程池","id":"184线程池","depth":2,"charIndex":1013},{"text":"18.4.1 “三大方法”","id":"1841-三大方法","depth":3,"charIndex":1081},{"text":"18.4.2 \"七大参数\"","id":"1842-七大参数","depth":3,"charIndex":1362},{"text":"18.4.3 \"四大拒绝策略\"","id":"1843-四大拒绝策略","depth":3,"charIndex":1381},{"text":"18.4.4 线程池的最大大小如何设置？","id":"1844-线程池的最大大小如何设置","depth":3,"charIndex":1402},{"text":"18.5.ForkJoin","id":"185forkjoin","depth":2,"charIndex":1551},{"text":"18.6.异步回调","id":"186异步回调","depth":2,"charIndex":1572}],"domain":"","frontmatter":{},"version":""},{"id":132,"title":"19 设计模式","content":"#\n\n\n1.七大原则#\n\n> 设计原则的核心思想：\n\n * 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起\n * 针对接口编程，而非针对实现编程\n * 为了交互对象之间的松耦合设计而努力\n\n\n1.1 单一职责原则#\n\n1.1.1 基本介绍#\n\n对类来说，一个类应该只负责一项职责。\n\neg. 某个Dao类既操作user表，又操作order表。这个时候就应该把该Dao类拆分成一个UserDao类、一个OrderDao类。\n\n1.1.2 注意事项和细节#\n\n * 降低类的复杂度，一个类只负责一个一项职责。\n * 提高类的可读性、可维护性\n * 降低变更引起的风险\n * 通常情况下，我们应当遵守单一职责原则。只有逻辑足够简单，才可以在代码级违反单一原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。\n\n\n1.2 接口隔离原则#\n\n1.2.1 基本介绍#\n\n客户端不应该依赖(即使用)它不需要的接口。即一个类对另一个类的依赖应该建立在最小的接口上。\n\n1.2.2 例子#\n\nInterface1中有5个方法，类B和类D是它的实现类。类A通过接口Interface1依赖（使用）类B，使用类B中的fun1、fun2、fun3方法；\n类C通过接口Interface1依赖（使用）类D，使用类D中的fun1、fun4、fun5方法。\n\n1.2.2.1 未遵循接口隔离原则#\n\n\n\n\n\n1.2.2.2 遵循接口隔离原则#\n\n按照隔离接口原则应该这样处理：\n\n将Interface1按照下图所示拆分成3个接口，A通过Interface1、Interface2依赖类B，C通过Interface1、Interface3依赖\n类D。\n\n\n\n\n\n\n1.3 依赖倒转原则#\n\n1.3.1 基本介绍#\n\n * 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n * 抽象不应该依赖细节，细节应该依赖抽象\n * 依赖倒转的中心思想：面向接口编程\n * 依赖倒转原则的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳的多。在java中，抽象指的是接口或抽\n   象类，细节就是具体的实现类。\n * 使用接口或抽象类的目的是制定好规范，而不设计任何具体操作，把展现细节的任务交给他们的实现类。\n * 变量的声明类型尽量是抽象类或接口。这样我们的变量引用和实际对象间，就存在一个缓冲层，有利于程序的扩展和优化。\n * 继承时遵循里氏替换原则\n\n1.3.2 个人理解#\n\n类A在依赖（使用）类B时，不要直接使用类B，而是使用接口1，其中类B需要实现接口1。\n\n1.3.3 例子#\n\n例子 完成Person接收消息的功能\n\n1.3.3.1 没有遵循依赖倒转原则#\n\n\n\n1.3.3.2 遵循依赖倒转原则#\n\n没有使用依赖倒转原则的代码存在的问题： 如果我们获取的对象是微信、短信等，则新增类，同时Person类还应该增加相应的接收方法。\n\n解决：\n引入一个抽象接口IReceiver，表示接收者，使Person和IReceiver产生依赖关系，让Email、WeiXin各自实现IReceiver接口。\n\n\n\n1.3.4 依赖关系传递的三种方式#\n\n> 依赖关系传递的3种方式\n\n * 接口传递\n * 构造方法传递\n * setter方式传递\n\n> 例子\n\n现有一需求，要求实现不同品牌电视机的开机功能。具体功能如下：\n\n * 点击电视的开机按钮后，电视机首先都会判断是否通电。该方法所有品牌都一样。\n * 确定通电后，电视机会点亮屏幕。因不同品牌电视机硬件不同，所以不同品牌的电视机点亮屏幕的方法不同。\n * 电视机屏幕点亮后，开机功能完成\n * 暂时不考虑电视机没通电的情况\n\n * 定义接口IOpenAndClose，电视机的开机或关机方法\n * 定义接口ITV，用来存放不同品牌的电视机的操作\n * 定义类OpenAndClose实现接口IOpenAndClose，OpenAndClose实现开机方法时，需要使用ITV中的点亮屏幕方法\n * 创建特定品牌的电视机类如HaiXinTV，实现海信电视的点亮屏幕的操作\n * 在客户端中测试长虹电视机的开机方法\n\n以下按照接口传递 方式、构造方法传递 方式、 setter传递 方式分别实现以上例子\n\n1.3.4.1 接口传递#\n\n * 电视机操作接口ITV\n\n\n\n * 开关机接口IOpenAndClose\n\n\n\n * 开关机类OpenAndClose\n\n\n\n * 海信牌电视机类HaiXinTV\n\n\n\n * 客户端Client\n\n\n\n1.3.4.2 构造方法传递#\n\n * 电视机操作接口ITV\n\n\n\n * 开关机接口IOpenAndClose\n\n\n\n * 开关机类OpenAndClose\n\n\n\n * 海信牌电视机类HaiXinTV\n\n\n\n * 客户端Client\n\n\n\n1.3.4.3 setter方式传递#\n\n * 电视机操作接口ITV\n\n\n\n * 开关机接口IOpenAndClose\n\n\n\n * 开关机类OpenAndClose\n\n\n\n * 海信牌电视机类HaiXinTV\n\n\n\n * 客户端Client\n\n\n\n1.3.5 注意事项和细节#\n\n * 低层模块尽量都要有抽象类或接口，或者二者都有，程序稳定性更好\n * 变量的类型尽量是抽象类或接口，这样变量的引用和实际对象之间，就存在一个缓冲层，利于程序的烤鱼站\n * 继承时，需要遵循里氏替换原则\n\n\n1.4 里氏替换原则#\n\n1.4.1 里氏替换原则产生的原因#\n\n面向对象中继承的弊端：\n\n * 继承会给程序带来侵入性\n * 继承会降低程序的可移植性\n * 继承增加了对象之间的耦合性\n\n为解决以上弊端，在使用继承时，引出里氏替换原则。\n\n1.4.2 基本介绍#\n\n * 如果S是T的子类型，对于S类型的任意对象，使得以T定义的所有程序P在所有t1对象换成s1对象时，程序P的行为没有发生任何变化。\n   所有引用基类的地方必须能够透明的使用子类。===>对象继承的原则\n\n * 替换的前提：面向对象的多态性，即同一个行为具有多个不同的表现形式或者形态的能力。也可以理解为多条就是同一个接口，拥有多个不同的实现类。\n\n * 在使用继承时，子类尽量不要重写父类方法。\n\n * 里氏替换原则告诉我们：继承实际上让两个类耦合性增强了， 在适当的情况下，可以通过聚合、组合、依赖来解决问题。\n   \n   * 组合\n     \n     \n   \n   * 聚合\n   \n   * 依赖\n\n * 违反里氏替换原则的场景\n   \n   * 子类抛出了基类中未定义的异常\n     \n     以JDK的集合框架为例，如果自定义一个List的派生类，如下：\n     \n     \n     \n     以上例子重写了get方法，抛出了UnsupportedOperationException异常。在JDK源码中，LIst的get方法仅会抛出Index\n     OutOfBoundsException异常（见下面代码），此时子类抛出UnsupportedOperationException异常并不是基类所期待\n     的，所以该子类违反了里氏替换原则。\n     \n     \n   \n   * 子类方法改变了基类方法的语义或者引入了副作用\n     \n     同样，以JDK的集合框架为例，如果自定义一个List的派生类，如下：\n     \n     \n     \n     以上代码中，当下标>list长度时，返回空而非抛出IndexOutOfBoundsException异常，此时子类改变了基类方法的语义。所以该子类也违\n     反了里氏替换原则。\n\n\n1.5 开闭原则#\n\n> 基本介绍\n\n * 开闭原则是编程中最基础、最重要的原则\n * 一个类（软件实体）中，模块和函数应该对扩展开放（即对提供方开放），对修改关闭（即对使用方关闭），即当给类增加新的功能时，尽量不修改代码或者尽可能少修改代码\n   。用抽象架构框架，用实现扩展细节。\n * 当软件需要变化时，尽量通过扩展软件实体的行为来实现改变，而不是通过修改已有的代码来实现变化。\n * 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。\n\n\n1.6 迪米特法则#\n\n> 基本介绍\n\n * 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装到类的内部。对外除了提供的publ\n   ic方法，不对外泄露任何消息。\n * 迪米特法则还有一个更简单的定义：只与直接的朋友通信\n * 直接的朋友：每个对象都与其他对象有耦合关系，只要两个对象之间有耦合关机，我们就说两个对象之间是朋友关系。耦合的方式（依赖、关联、组合、聚合等）。我们称出现\n   成员变量、方法参数、方法返回值中的类为直接朋友。而出现在局部变量中的类不是直接朋友（而是陌生人）。陌生类最好不要以局部变量的形式出现在类的内部。\n * 核心：降低类之间的耦合，但并非完全没有依赖关系\n\n\n1.7 合成复用原则#\n\n> 基本介绍\n\n尽量使用合成/聚合的方式，而不是使用继承。\n\n\n2.UML类图#\n\n\n2.1 基本介绍#\n\n> 定义\n\nUnified modeling language，统一建模语言，是一种用于软件系统分析和设计的语言工具，他帮助软件开发人员进行思考和记录思路的结果。\n\n> 常用符号\n\n\n\n\n2.2 UML类图的画法#\n\n依赖： A在类中用到了B类，则A和B类之间就存在依赖关系。可以是类的成员变量、方法的返回类型、方法接收的参数类型、方法中的局部变量。\n\n\n\n泛化（继承）：泛化就是继承，是依赖关系的特例。\n\n\n\n实现：类实现了接口，是依赖关系的特例。\n\n\n\n关联：指的是类与类之间的联系，是依赖的特例。具有导航性（即双向关系或者单项关系）、多重性（一对一、一对多、多对多）\n\n\n\n聚合：表示整体和部分的关系，整体与部分可以分开（比如电脑中有鼠标和键盘类，但是键盘和鼠标又可以从电脑上拆下来，所以电脑与鼠标、电脑与键盘是聚合关系），是关联关系\n的特例。具有导航性和多重性。\n\n\n\n组合：表示整体和部分的关系，整体与部分不可以分开（比如人中有头和四肢类，但是头和四肢不能从人上拆下来，所以人和头、人和四肢是组合关系。人有身份证，身份证可以从人\n身上拆下来，所以人和身份证是聚合关系）。\n\n\n\n> 聚合与组合\n\n\n\n如果程序中A实体中定义了对IDCard进行级联删除（即删除Person时连同IDCard一起删除），那么IDCard和Person就是组合了。\n\n\n3.设计模式#\n\n\n3.1 概述#\n\n * 设计模式是某类问题的通用解决方案，代表了最佳实践\n * 本质：提高软件的维护性、通用性、扩展性，降低软件的复杂性\n * 分为3种类型：\n   * 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式\n   * 结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式\n   * 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、终结者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式\n\n\n3.2 单例模式#\n\n3.2.1 定义#\n\n即采取一定的方法保证整个软件系统中，对于某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法（静态方法）。\n\n3.2.2 实现方式#\n\n * 饿汉式（静态常量）\n * 饿汉式（静态代码块）\n * 懒汉式（线程不安全）\n * 懒汉式（同步方法）\n * 懒汉式（同步代码块）\n * 双重检查\n * 静态内部类\n * 枚举\n\n3.2.2.1 饿汉式（静态常量）#\n\n\n\n> 分析\n\n * 优点：写法简单，在类装载的时候完成实例化，避免了线程同步问题\n * 缺点：没有用到懒加载效果。如果从始至终没有用到这个实例，则会造成内存浪费。\n\n> 结论\n\n3.2.2.2 饿汉式（静态代码块）#\n\n\n\n> 分析\n\n * 优点：写法简单，在类装载的时候完成实例化，避免了线程同步问题\n * 缺点：没有用到懒加载效果。如果从始至终没有用到这个实例，则会造成内存浪费。\n\n> 结论\n\n3.2.2.3 懒汉式（线程不安全）#\n\n\n\n> 分析\n\n * 优点：起到了懒加载效果\n * 缺点：线程不安全，只能在单例模式下使用\n\n> 结论\n\n实际开发不要使用该方法。\n\n3.2.2.4 懒汉式（同步方法）#\n\n\n\n> 分析\n\n * 优点：起到了懒加载效果，线程安全\n * 缺点：方法进行同步效率太低\n\n> 结论\n\n实际开发不推荐使用。\n\n3.2.2.5 懒汉式（同步代码块）#\n\n\n\n> 分析\n\n本意是优化同步方法的方式，但是实际上并不能起到线程同步的作用。\n\n> 结论\n\n实际开发不能使用。\n\n3.2.2.6 双重检查#\n\n\n\n> 分析\n\n * 优点：线程安全，延时加载，效率高\n\n> 结论\n\n实际开发推荐使用。\n\n3.2.2.7 静态内部类#\n\n> 静态内部类的特点\n\n * 外部类装载的时候，静态内部类并不一定会立即被装载\n * 静态内部类只会在第一次加载类的时候初始化\n\n\n\n> 分析\n\n * 优点：线程安全，利用静态内部类特点实现延迟加载，效率高\n\n> 结论\n\n借助底层JVM类的装载机制保证初始化时只有一个实例，实际开发推荐使用。\n\n3.2.2.8 枚举#\n\n\n\n> 分析\n\n * 优点：线程安全，防止反序列化重新创建新的对象\n\n> 结论\n\n实际开发推荐使用。\n\n3.2.3 源码单例举例#\n\n\n\n3.2.4 使用场景#\n\n * 需要频繁的创建和销毁的对象\n * 创建对象时耗时过多或者耗费资源过多但又经常用到的对象\n * 工具类对象\n * 频繁访问数据库或者文件的对象（如数据源、session工厂等）\n\n\n3.3 工厂模式#\n\n3.3.1 简单工厂模式#\n\n> 基本介绍\n\n * 属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n * 本质：定义了一个创建对象的类，由这个类来封装实例化对象的行为。\n\n * 使用场景：当需要大量的创建某类或者某批对象时，就会用到工厂模式。\n\n * 简单工厂模式也叫静态工厂模式。\n   \n   \n\n3.3.2 工厂方法模式#\n\n> 基本介绍\n\n * 本质：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。\n   \n   \n\n3.3.3 抽象工厂模式#\n\n> 基本介绍\n\n * 本质：定义了一个interface，用于创建或有依赖关系对象的对象簇，无需指明具体的类。\n\n * 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n * 从设计层面看，抽象工厂模式就随对简单工厂模式的进一步抽象----将工厂抽象成两层，即抽象工厂和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂\n   子类，如此便将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。\n   \n   \n\n3.3.4 源码工厂模式举例#\n\n\n\n3.3.5 小结#\n\n> 意义\n\n将实例化对象的代码提取出来，放到一个类中统一管理和维护，以达到和主项目依赖关系的解耦，从而提高项目的可扩展性和可维护性。\n\n> 三种工程模式\n\n * 简单工厂模式\n * 工厂方法模式\n * 抽象工厂模式\n\n> 设计模式的依赖抽象原则\n\n * 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。\n * 不要让类继承具体类，而应继承抽象类或者实现接口。\n * 不要覆盖类中已经实现的方法。\n\n\n3.4 原型模式#\n\n3.4.1 基本介绍#\n\n * 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象\n * 是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道创建细节\n * 工作原理：通过将一个原型对象传给那个要发起创建的对象，这个要发起创建的对象通过请求原型对象拷贝他们自己来实现创建，即对象.clone()\n * 形象理解：孙悟空拔出猴毛，变出其他孙大圣\n\n3.4.2 克隆羊例子#\n\n创建5只属性一样的羊。\n\n> 关键\n\nSheep类实现Cloneable接口，并重写clone()。客户端创建完第一只羊之后，调用clone()方法完成其他4只羊的创建。\n\n\n\n\n\n3.4.3 源码原型模式举例#\n\n\n\n\n\n3.4.4 浅拷贝和深拷贝#\n\n> 浅拷贝\n\n * 基本数据类型：值传递，即将该属性值复制一份给新的对象\n * 引用数据类型（数组、对象等）：引用传递，即指向同一个内存地址\n * 浅拷贝是使用默认的clone()方法来实现的\n\n> 深拷贝\n\n * 深拷贝实现方式：重写clone()或者通过对象实例化(推荐)实现深拷贝\n   \n   > 通过重写clone()方法实现深拷贝\n   \n   \n   \n   \n   \n   > 通过对象的序列化实现深拷贝\n   \n   \n   \n   \n\n3.4.5 小结#\n\n> 原型模式的注意事项和优缺点\n\n * 当创建的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能提高效率\n * 不用重新初始化对象，而是动态的获取对象运行时的状态\n * 如果原式对象的属性增加或者减少，其他克隆对象的也会相应变化，无需修改代码\n * 缺点：需要为每一个类配备一个克隆方法，这对于全新的类来说不是很难，但对已有的类改造时，需要修改源代码，违背了ocp原则\n\n\n3.5 建造者模式#\n\n3.5.1 基本介绍#\n\n * 本质：将产品和产品建造过程解耦\n * 是一种创建型设计模式。它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同属性的对象\n * 建造者模式是一步一步的创建一个复杂对象。它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构造过程\n * 建造者的四个角色\n   * Product(产品)：产品对象\n   * Builder(抽象建造者)：穿件一个Product对象各个部件指定的接口或抽象类\n   * ConcreteBuilder(具体建造者)：实现接口或抽象类，构建和装配各个组件\n   * Director(指挥者)：构建一个使用Builder接口的对象。作用是①隔离客户与对象的生产过程②负责控制产品对象的生产过程。\n\n3.5.2 盖房子例子#\n\n\n\n3.5.3 小结#\n\n> 建造者模式的注意事项和优缺点\n\n * 客户端不比知道产品内部的组成细节，将产品本身与产品床创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n * 每一个具体建造者都是相对独立的，因此可以很方便的替换具体建造者或者增加新的建造者，用户使用不同的具体建造者即可得到不同的对象产品。\n * 可以更加惊喜的控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，是的创建过程更加清晰，也更方便使用程序来控制创建过程。\n * 增加新的具体建造者无须修改原有类库代码，符合开闭原则\n * 使用建造者模式创建的产品一般具有较多的共同点，其组成部分相似。如果产品之间的差异性很大，则不适合使用建造者模式。\n * 抽象工厂模式VS建造者模式\n   * 抽象工厂模式实现对产品家族的创建，一个产品家族是这样一系列的产品：具有不同分类纬度的产品组合，采用抽象工厂模式不需要关系构建过程，之关系什么产品由什么\n     工厂生产即可。抽象工厂模式是一个函数生成一个对象。\n   * 建造者模式是把对象的创建分散开来，不同的方法创建对象不同的组成部分，最终将所有函数结合起来才能生成一个对象。\n\n\n3.6 适配器模式#\n\n3.6.1 基本介绍#\n\n * 定义：适配器模式将某个类的接口转换成客户端期望的另一个接口表示。\n * 目的：兼容。让原本因接口不匹配不能一起工作的两个类可以协同工作。\n * 是一种结构型设计模式\n * 分类：\n   * 类适配器模式\n   * 对象适配器模式\n   * 接口适配器模式\n\n3.6.2 类适配器模式#\n\n * 定义：是一个类(Adapter)，通过继承被适配类，实现目标类的接口，完成被适配类(src)->目标类(dst) 的实现。\n * 优缺点\n   * 缺点：由于java是单继承，类适配器需要继承src类，所以det必须是接口，有一定的局限性\n   * 缺点：src类的方法在Adapter中会暴露出来，也增加了使用的成本\n   * 优点：由于继承了src类，所以它可以根据需求重写src类，使得Adapter的灵活性增强了\n\n3.6.3 对象适配器模式#\n\n * 定义：基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性问题。即：持有src类，实现dst\n   接口（或继承dst类），完成src->dst的适配。\n * 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承类。\n * 对象适配器模式是适配器模式中最常用的一种。\n * 优缺点：\n   * 优点：对象适配器是对类适配器的一种升级。根据合成复用原则，使用组合替代继承，它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。\n   * 缺点：使用成本更低，更灵活。\n\n3.6.4 接口适配器模式#\n\n * 定义： 当不需要全部实现接口提供的方法时，可以先设计一个抽象类实现接口， 并为该接口中每个方法提供一个默认实现（空方法），\n   那么抽象类的子类可有选择的覆盖父类的某些方法来实现需求。\n * 使用场景： 适用于一个接口不想使用其所有方法的情况。\n\n3.6.5 源码适配器模式举例#\n\n适配器模式在SpringMVC中的应用。\n\n\n\n> 例子：手写简单SpringMVC DispatcherServlet.doDispatch()方法\n\n\n\n\n\n3.6.6 小结#\n\n * 按照src是以怎样的形式转给到Adapter被分为3种不同的适配器：\n   * 类适配器：以类给到，在Adapter里，将src当做类，继承\n   * 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有\n   * 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现\n * Adapter模式最大的作用是将原本不兼容的接口融合在一起工作\n\n\n3.7 桥接模式#\n\n3.7.1 基本介绍#\n\n * 定义： 将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。\n * 是一种结构型设计模式\n * 基于类的最小设计原则，通过使用封装、聚合、继承，让不同的类承担不同的职责。\n * 主要特点： 把抽象和行为实现分离开来，从而保持各部分的独立性以及应对他们的功能扩展。\n\n3.7.2 原理图（类图）#\n\n\n\n3.7.3 源码桥接模式举例#\n\nJDBC源码\n\n\n\n3.7.4 小结#\n\n> 桥接模式的优缺点\n\n * 优点实现了抽象和实现部分的分离，极大提供了系统的灵活性，让抽象部分和实现部分独立开来，有助于系统进行分层设计，从而产生更好的结构化系统。\n * 优点对于系统的高层部分，只需要知道抽象部分和实现接口即可，其他交于具体业务来完成。\n * 优点桥接模式替代多层继承，可以减少子类个数，降低系统的管理和维护成本。\n * 缺点桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。\n * 缺点桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围具有一定的局限性。\n\n> 桥接模式应用场景\n\n桥接模式应用场景举例：\n\n * JDBC驱动程序\n * 银行转账系统\n   * 转账分类：网上转账、柜台转账、ATM转账 抽象层\n   * 转账用户类型：普通用户、银卡用户、金卡用户... 实现层\n * 消息管理\n   * 消息类型：即时消息、延时消息 抽象层\n   * 消息分类：手机短信、邮件消息、QQ消息... 实现层\n\n\n3.8 装饰者模式#\n\n3.8.1 基本介绍#\n\n * 定义：动态的将新的功能附加到对象上。在对象功能扩展方面，比继承更有弹性。\n * 体现了开闭原则（ocp）\n\n3.8.2 原理图#\n\n3.8.3 星巴克点餐例子#\n\n咖啡分为\n\n3.8.4源码装饰者模式#","routePath":"/tang/java2/19_设计模式","lang":"","toc":[{"text":"1.七大原则","id":"1七大原则","depth":2,"charIndex":3},{"text":"1.1 单一职责原则","id":"11-单一职责原则","depth":3,"charIndex":111},{"text":"1.1.1 基本介绍","id":"111-基本介绍","depth":4,"charIndex":124},{"text":"1.1.2 注意事项和细节","id":"112-注意事项和细节","depth":4,"charIndex":227},{"text":"1.2 接口隔离原则","id":"12-接口隔离原则","depth":3,"charIndex":373},{"text":"1.2.1 基本介绍","id":"121-基本介绍","depth":4,"charIndex":386},{"text":"1.2.2 例子","id":"122-例子","depth":4,"charIndex":446},{"text":"1.2.2.1 未遵循接口隔离原则","id":"1221-未遵循接口隔离原则","depth":4,"charIndex":585},{"text":"1.2.2.2 遵循接口隔离原则","id":"1222-遵循接口隔离原则","depth":4,"charIndex":609},{"text":"1.3 依赖倒转原则","id":"13-依赖倒转原则","depth":3,"charIndex":736},{"text":"1.3.1 基本介绍","id":"131-基本介绍","depth":4,"charIndex":749},{"text":"1.3.2 个人理解","id":"132-个人理解","depth":4,"charIndex":1055},{"text":"1.3.3 例子","id":"133-例子","depth":4,"charIndex":1112},{"text":"1.3.4 依赖关系传递的三种方式","id":"134-依赖关系传递的三种方式","depth":4,"charIndex":1336},{"text":"1.3.5 注意事项和细节","id":"135-注意事项和细节","depth":4,"charIndex":2171},{"text":"1.4 里氏替换原则","id":"14-里氏替换原则","depth":3,"charIndex":2292},{"text":"1.4.1 里氏替换原则产生的原因","id":"141-里氏替换原则产生的原因","depth":4,"charIndex":2305},{"text":"1.4.2 基本介绍","id":"142-基本介绍","depth":4,"charIndex":2413},{"text":"1.5 开闭原则","id":"15-开闭原则","depth":3,"charIndex":3225},{"text":"1.6 迪米特法则","id":"16-迪米特法则","depth":3,"charIndex":3454},{"text":"1.7 合成复用原则","id":"17-合成复用原则","depth":3,"charIndex":3789},{"text":"2.UML类图","id":"2uml类图","depth":2,"charIndex":3834},{"text":"2.1 基本介绍","id":"21-基本介绍","depth":3,"charIndex":3845},{"text":"2.2 UML类图的画法","id":"22-uml类图的画法","depth":3,"charIndex":3950},{"text":"3.设计模式","id":"3设计模式","depth":2,"charIndex":4435},{"text":"3.1 概述","id":"31-概述","depth":3,"charIndex":4445},{"text":"3.2 单例模式","id":"32-单例模式","depth":3,"charIndex":4688},{"text":"3.2.1 定义","id":"321-定义","depth":4,"charIndex":4699},{"text":"3.2.2 实现方式","id":"322-实现方式","depth":4,"charIndex":4772},{"text":"3.2.3 源码单例举例","id":"323-源码单例举例","depth":4,"charIndex":5639},{"text":"3.2.4 使用场景","id":"324-使用场景","depth":4,"charIndex":5656},{"text":"3.3 工厂模式","id":"33-工厂模式","depth":3,"charIndex":5762},{"text":"3.3.1 简单工厂模式","id":"331-简单工厂模式","depth":4,"charIndex":5773},{"text":"3.3.2 工厂方法模式","id":"332-工厂方法模式","depth":4,"charIndex":5948},{"text":"3.3.3 抽象工厂模式","id":"333-抽象工厂模式","depth":4,"charIndex":6033},{"text":"3.3.4 源码工厂模式举例","id":"334-源码工厂模式举例","depth":4,"charIndex":6265},{"text":"3.3.5 小结","id":"335-小结","depth":4,"charIndex":6284},{"text":"3.4 原型模式","id":"34-原型模式","depth":3,"charIndex":6515},{"text":"3.4.1 基本介绍","id":"341-基本介绍","depth":4,"charIndex":6526},{"text":"3.4.2 克隆羊例子","id":"342-克隆羊例子","depth":4,"charIndex":6717},{"text":"3.4.3 源码原型模式举例","id":"343-源码原型模式举例","depth":4,"charIndex":6822},{"text":"3.4.4 浅拷贝和深拷贝","id":"344-浅拷贝和深拷贝","depth":4,"charIndex":6843},{"text":"3.4.5 小结","id":"345-小结","depth":4,"charIndex":7087},{"text":"3.5 建造者模式","id":"35-建造者模式","depth":3,"charIndex":7291},{"text":"3.5.1 基本介绍","id":"351-基本介绍","depth":4,"charIndex":7303},{"text":"3.5.2 盖房子例子","id":"352-盖房子例子","depth":4,"charIndex":7661},{"text":"3.5.3 小结","id":"353-小结","depth":4,"charIndex":7677},{"text":"3.6 适配器模式","id":"36-适配器模式","depth":3,"charIndex":8182},{"text":"3.6.1 基本介绍","id":"361-基本介绍","depth":4,"charIndex":8194},{"text":"3.6.2 类适配器模式","id":"362-类适配器模式","depth":4,"charIndex":8339},{"text":"3.6.3 对象适配器模式","id":"363-对象适配器模式","depth":4,"charIndex":8569},{"text":"3.6.4 接口适配器模式","id":"364-接口适配器模式","depth":4,"charIndex":8864},{"text":"3.6.5 源码适配器模式举例","id":"365-源码适配器模式举例","depth":4,"charIndex":9008},{"text":"3.6.6 小结","id":"366-小结","depth":4,"charIndex":9107},{"text":"3.7 桥接模式","id":"37-桥接模式","depth":3,"charIndex":9311},{"text":"3.7.1 基本介绍","id":"371-基本介绍","depth":4,"charIndex":9322},{"text":"3.7.2 原理图（类图）","id":"372-原理图类图","depth":4,"charIndex":9475},{"text":"3.7.3 源码桥接模式举例","id":"373-源码桥接模式举例","depth":4,"charIndex":9493},{"text":"3.7.4 小结","id":"374-小结","depth":4,"charIndex":9520},{"text":"3.8 装饰者模式","id":"38-装饰者模式","depth":3,"charIndex":9981},{"text":"3.8.1 基本介绍","id":"381-基本介绍","depth":4,"charIndex":9993},{"text":"3.8.2 原理图","id":"382-原理图","depth":4,"charIndex":10063},{"text":"3.8.3 星巴克点餐例子","id":"383-星巴克点餐例子","depth":4,"charIndex":10075},{"text":"3.8.4源码装饰者模式","id":"384源码装饰者模式","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":133,"title":"20 排序算法","content":"#\n\n\n20.1 排序算法概述#\n\n> 衡量排序算法的优劣\n\n * 时间复杂度：分析关键字的比较次数和记录的移动次数\n * 空间复杂度：分析算法中需要多少辅助内存\n * 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种算法是稳定的\n\n> 排序算法分类\n\n * 内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。\n * 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器（如磁盘）等。外部排序最常见的算法有多路归并排序。\n   可以认为外部排序是由多次内部排序组成的。\n\n> 十大排序算法\n\n * 选择排序\n   \n   将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。\n   \n   * 简单选择排序\n   * 堆排序\n\n * 交换排序\n   \n   * 冒泡排序\n   * 快速排序\n\n * 插入排序\n   \n   * 直接插入排序\n   * 折半插入排序\n   * 希尔排序\n\n * 归并排序\n\n * 桶式排序\n\n * 基数排序\n\n> 算法5大特性\n\n * 输入：有0个或多个输入数据，这些输入必须有清楚的描述和定义\n * 输出：至少有1个或多个输出结果，不可以没有输出\n * 有穷性（有限性）：算法可以在有限的步骤之后会自动结束而不是无线循环，并且每一个步骤可以在可接受的时间内完成\n * 确定性（明确性）：算法中的每一步都有确定的含义，不会出现二义性\n * 可行性（有效性）：算法的每一步骤都是清楚且可行的，能让用户用纸笔计算而求出答案\n\n\n20.2 选择排序#\n\n\n20.2.1 简单选择排序#\n\n> 基本过程\n\n * 在一组元素R[i]到R[n]中选择最小的元素\n * 如果他不是这组元素中的第一个元素，则将其与该组元素中的第一个元素交换\n * 除去具有最小关键字的元素，在剩下的元素中重复以上两步骤，直到元素只有一个为止\n\n> 效率分析\n\n * 比较次数：$(n-1)+(n-2)+...+2+1=n(n-1)/2$\n   \n   无论初始状况如何，在第i趟排序中选择最小元素的时候，都需要做$(n-i)$次比较\n\n * 交换次数：\n   \n   * 最好情况：0次\n     \n     序列恰好为正序时，需要交换0次\n   \n   * 最差情况：${(n-1)}$次\n     \n     如将数组[${5,1,2,3,4}$]按照有小到大的顺序排列，需要移动4次\n\n综上，简单选择排序的时间复杂度为$O(n^{2})$\n\n> 稳定性\n\n不稳定\n\n由于在直接选择排序中存在不相邻元素的交换，因此它是一个不稳定的排序方法。\n\n比如给定数组[$3,7,3',2,1$]，按照有小到大的顺序排列后的结果为[$1,2,3',3,7$]\n\n> 示例代码\n\n\n\n\n20.2.2 堆排序#\n\n\n20.3 交换排序#\n\n\n20.3.1 冒泡排序#\n\n> 基本思想\n\n对待排序序列从前往后，依次比较相邻元素排序码，如果逆序则交换，使排序码较大的元素逐渐从前往后移动。\n\n> 效率分析\n\n * 比较次数：\n   \n   * 最好情况：$n-1$次\n     \n     此时待排序序列恰好是按照要求的顺序进行排序\n   \n   * 最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$次\n     \n     此时待排序序列恰好是按照要求的顺序的逆序进行排序\n\n * 交换次数：\n   \n   * 最好情况：0次\n     \n     此时待排序序列恰好是按照要求的顺序进行排序\n   \n   * 最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$\n\n> 稳定性\n\n> 示例代码\n\n\n\n\n20.3.2 快速排序#\n\n\n20.4 插入排序#\n\n\n20.4.1 直接插入排序#\n\n> 基本过程\n\n * 视R[m]为有序序列\n * 比较R[m+1]和R[m]大小，如果R[m+1] >= R[m]，继续下一循环。否则，进入下一步。\n * 如果R[m+1] < R[m]，比较R[m+1]与R[m]中的元素，将R[m+1]插入合适位置\n\n> 效率分析\n\n\n\n * 最好情况：输入的数组已经排好序\n   \n   时间复杂度为$O(n)$\n\n * 最坏情况：输入的数组恰好是倒序排序\n   \n   时间复杂度为$O(n^{2})$\n\n * 平均情况：数组A[1...j]中,一般元素大于A[j],一般元素小于A[j]，计算起来时间复杂度和最坏请款一致\n   \n   时间复杂度为$O(n^{2})$\n\n> 稳定性\n\n> 示例代码\n\n\n\n\n20.4.2 折半插入排序#\n\n\n20.4.3 希尔排序#\n\n\n20.5 归并排序#\n\n> 基本过程\n\n * 分解：分解待排序的n个元素序列成各有n/2个元素的子序列\n * 解决：使用归并排序递归的排列两个子列\n * 合并：合并两个已排序的子列以产生已排序的答案\n\n> 效率分析--合并步骤的时间复杂度\n\n\n\n合并步骤的时间复杂度：O(n)\n\n> 效率分析--归并排序时间复杂度\n\n * 当归并排序一个元素（一个元素为最小输入）时需要的时间为常量时间。\n\n * 当$n\\geq 1$时，分析运行时间如下：\n   \n   * 分解：分解步骤仅仅计算子数组的中间位置，需要常量时间，因此D(n)=O(1)\n   * 解决：递归算法中是递归的求解将原问题分为2个规模为n/2的子问题，即a=2，b=2\n   * 合并：在【效率分析--合并步骤的时间复杂度】中已知，合并所需的时间C(n)=O(n)\n\n * 综上，归并排序算法最坏情况下时间复杂度公式为\n   \n   （注：分解时间D(n)=O(1)，可以忽略） $$ T(n) = \\begin{cases} O(1), & \\text {$n\\leq 1$}\\\n   2T(n/2)+O(n), & \\text {$n > 1$} \\end{cases} $$\n\n经求解，归并排序算法最坏情况下的时间复杂度为O(nlgn)\n\n> 稳定性\n\n> 示例代码\n\n\n\n\n20.6 桶式排序#\n\n\n20.7 基数排序#\n\n\n20.8 算法设计#\n\n\n20.8.1 分治模式#\n\n> 使用场景\n\n适用于递归算法中\n\n> 思想\n\n将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解\n\n> 步骤\n\n * 分解原问题为若干子问题，这些子问题都是原问题的规模较小的实例\n * 解决这些子问题，递归的求解各个子问题。当子问题规模足够小时，可以直接求解\n * 合并这些子问题的解成原问题的解、\n\n> 分析分治算法的时间复杂度\n\n当一个算法包含自身的递归调用时，可以使用递归方程或递归式来描述其运行时间，该方程根据在最小输入上的运行时间来描述在规模n问题上的总运行时间。然后，通过数学工具来\n求解递归式并给出算法性能的界。\n\n①假设T(n)是规模为n的一个问题的运行时间。\n\n②如果问题足够小(假设对于常量c，n<=c)，则直接求解需要常量时间，记为O(1)。\n\n③当问题比较大时，将原问题分解为a个子问题，每个子问题的规模是原问题的1/b，即子问题的规模为n/b。那么规模为n的问题的运行时间T(n)可以写成：T(n) =\na*T(n/b)。\n\n④假设分解大问题为小问题所需时间为D(n)，小问题的解合并成大问题的解所需时间C(n)，那么，便可以得到递归式： $$ T(n) = \\begin{cases}\nO(1), & \\text {$n\\leq c$}\\ aT(n/b)+D(n)+C(n), & \\text {$n > c$} \\end{cases} $$\n⑤对该递归式求解，即可得到该算法的时间复杂度","routePath":"/tang/java2/20_排序算法","lang":"","toc":[{"text":"20.1 排序算法概述","id":"201-排序算法概述","depth":2,"charIndex":3},{"text":"20.2 选择排序","id":"202-选择排序","depth":2,"charIndex":711},{"text":"20.2.1 简单选择排序","id":"2021-简单选择排序","depth":3,"charIndex":724},{"text":"20.2.2 堆排序","id":"2022-堆排序","depth":3,"charIndex":1221},{"text":"20.3 交换排序","id":"203-交换排序","depth":2,"charIndex":1235},{"text":"20.3.1 冒泡排序","id":"2031-冒泡排序","depth":3,"charIndex":1248},{"text":"20.3.2 快速排序","id":"2032-快速排序","depth":3,"charIndex":1598},{"text":"20.4 插入排序","id":"204-插入排序","depth":2,"charIndex":1613},{"text":"20.4.1 直接插入排序","id":"2041-直接插入排序","depth":3,"charIndex":1626},{"text":"20.4.2 折半插入排序","id":"2042-折半插入排序","depth":3,"charIndex":1967},{"text":"20.4.3 希尔排序","id":"2043-希尔排序","depth":3,"charIndex":1984},{"text":"20.5 归并排序","id":"205-归并排序","depth":2,"charIndex":1999},{"text":"20.6 桶式排序","id":"206-桶式排序","depth":2,"charIndex":2571},{"text":"20.7 基数排序","id":"207-基数排序","depth":2,"charIndex":2584},{"text":"20.8 算法设计","id":"208-算法设计","depth":2,"charIndex":2597},{"text":"20.8.1 分治模式","id":"2081-分治模式","depth":3,"charIndex":2610}],"domain":"","frontmatter":{},"version":""},{"id":134,"title":"99 面试题","content":"#\n\n\n1.最高效方式计算2 * 8？#\n\n答：2 << 3或 8 << 1\n\n\n2.多态是编译时行为还是运行时行为？如何证明？#\n\n答：多态是运行时行为。\n\n证明代码如下：\n\n随机生成index，获取不同的Animal实例。当调用eat()时，在编译期间是看不出来会调用哪一个，只有运行完成后才可以判断到底是调用的哪个类的eat()方法\n。\n\n\n\n\n3.方法的重载与重写#\n\n答：\n\n> 二者的定义细节\n\n * 重载：同一个类中，允许有一个以上的同名方法，只要它们的参数类型或者参数个数不同即可。\n * 重写：在子类中可以根据需要，对从父类继承来的方法进行改造，也称为方法的覆盖、重置。在程序执行时，子类的方法将覆盖父类的方法。\n\n> 从编译运行的角度看\n\n * 重载，是指允许存在多个重名方法，而这些方法的参数列表不同。编译器根据不同的参数列表，对同名方法进行修饰。对于编译器而言，这些同名方法就成了不同的方法，他们\n   的调用地址在编译期就确定了。Java的重载是可以包含父类和子类的，即子类可以重载父类的同名不同餐的方法。\n   \n   所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”。\n\n * 多态（重写），只有等到方法调用那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。\n\n\n4.==和equals()的区别#\n\n答：\n\n * ==\n   \n   * 是一个运算符\n   \n   * 可以使用在基本数据类型和引用数据类型中\n   \n   * 如果比较的是基本类型变量：比较的是两个变量保存的数据是否相等（类型不一定相同）\n     \n     \n   \n   * 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个变量是否指向同一个实体对象。\n     \n     此外，比较引用数据类型的变量的时候，必须保证==左右变量类型一致。如System.out.println(\"hello\" == new\n     java.util.Date())，编译不通过\n\n * equals()\n   \n   * 是一个方法，而非运算符\n   * 只能适用于引用数据类型\n   * Object类中的equals()方法和==的作用是相同的：比较的是两个对象的地址值是否相等\n   * 像String、Date、File、包装类等都重写了Object的equals()方法。重写后，比较的是两个对象的“实体内容”是否相同\n   * 通常情况下，我们自定义的类如果使用equals()的话，也通常比较的是两个对象的“实体内容”是否相同，一般来说都需要对其重写。重写的原则就是比较两个对\n     象的“实体内容”是否相同\n\n\n5.三元运算符与包装类#\n\n如下代码中，o1和o2的输出结果相同吗，分别是什么？\n\n\n\n答：\n\n二者结果不相同。o1输出为1.0，o2输出为1。\n\n分析：\n\n三元运算符:两侧的运算符需要能统一成一个类型，这是在编译过程中就需要确定的（如果:两边分别是int和String，会编译不通过），所以Integer类型变量会提\n升为Double。因此最终o1输出为浮点型的1.0。\n\n\n6.包装类#\n\n如下代码的输出分别是什么？\n\n\n\n答：\n\n以上输出分别是false、true、false。\n\n分析：\n\nInteger内部定义了IntegerCache结构，IntegerCache中定义了一个Integer类型的数组，保存了从[-128,127]范围的整数。如果\n使用自动装箱的方式，且给Integer赋值的范围在[-128,127]内时，可以直接使用数组中的元素，不用再去new了。Integer x =\n128;和Integer y = 128;各自创建了一个对象，因此二者不相等。\n\n\n7.接口-排错题#\n\n * 以下代码是否有问题？如无，输出的内容为多少？\n   \n   \n   \n   答：\n   \n   代码编译不通过。报错信息为“Reference to 'x' is ambiguous, both 'B.x' and 'A.x'\n   match”，意为接口A和接口B中都有x属性，C中对x的引用不明确。可以使用System.out.println(super.x)输出类B中的x，可以使用\n   System.out.println(A.x)输出接口A中的x。\n\n * 以下代码是否有问题？如无，输出的内容是什么？\n   \n   \n   \n   答：\n   \n   代码编译失败。接口中定义的变量是public static final修饰的全局常量，是不可以更改的。\n\n\n8.抽象类和接口的共同点和区别#\n\n * 相同点：\n   * 不能实例化\n   * 都可以定义抽象方法\n * 不同点：\n   * 抽象类有构造器、属性\n   * 接口在JDK7及以前只能定义全局内部类和抽象方法，JDK8之后还可以定义静态方法和默认方法（接口中的方法可以写方法体了，使得接口更像抽象类了），JDK\n     9之后可以定义私有方法\n   * 子类只能继承一个抽象类，但是可以实现多个接口，同样，接口也可以继承多个接口\n\n\n9.throw和throws的区别#\n\n * throw：抛出异常，生成异常对象；用在方法体内\n * throws：捕获异常，是处理异常的一种手段：用在方法的声明处\n\n\n10.final、finally、finalize的区别#\n\n * final：修饰符，可以修饰类、变量、方法。修饰类表示类不能被继承，修饰变量表示变量的值不可以被修改，修饰方法表示不能被子类重写\n * finally：处理异常的一个关键字，和try-catch组合使用，finally代码块中的代码一定会被执行\n * finalize：垃圾回收方法。一个类的finalize()只会被系统自动调用一次，如果对象面临下一次回收，他的finalize()方法不会被再次执行\n\n> 引申\n\n * Collection和Collections的区别\n * String、StringBuffer、StringBuilder的区别\n * ArrayList和LinkedList的区别\n * HashMap和LinkedHashMap的区别\n * 重写和重载的区别\n\n> 拓展\n\n * 抽象类和接口的区别\n * ==和equals()的区别\n * sleep()和wait()的区别\n\n\n11.synchronized和Lock的异同？#\n\n答：\n\n * 相同点：二者都可以解决线程安全问题\n\n * 不同点：\n   \n   * synchronized机制在执行完同步代码之后，自动的释放同步监视器；Lock需要手动加锁（调用lock())、手动释放锁（调用unlock())\n   * synchronized有代码块锁和方法锁；Lock只有代码块锁\n   * 使用Lock，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性\n\n * 二者如何选择\n   \n   Lock > 同步代码块 >同步方法\n\n\n12.sleep()和wait()的异同？#\n\n * 相同点：都会使当前线程进入阻塞状态\n * 不同点：\n   * 两个方法声明的位置不同：sleep()是在Thread中声明的，wait()是在Object中声明的\n   * 调用的要求不同：sleep()可以在任何需要的场景下调用；wait()必须在同步代码块或者同步方法中由同步监视器调用\n   * 关于是否释放锁：如果两个方法都是用在同步代码块或者同步方法中，sleep()不会释放锁，wait()会释放锁\n\n\n13.String拼接相关面试题#\n\n如下代码输出结果是什么？\n\n\n\n答：\n\n\n\n> 分析\n\n * 常量与常量的拼接结果在常量池中（如String s = \"abc\"+\"def\";s指向常量池中的\"abcdef\"），且常量池中不会存在相同内容的常量。\n * 常量与变量的拼接、变量与变量的拼接结果在堆空间中（如String s = \"abc\"; String s2 =\n   s1+\"def\";s2指向堆空间，相当于new了一个变量）\n * 特别的，如果拼接结果调用了intern()，返回结果在常量池中。\n * final 声明的变量是常量，所以s3 == s10\n\n\n14.String值传递相关面试题#\n\n如下代码，输出结果是什么？\n\n\n\n答：\n\n\n\n> 分析\n\n * 如果参数是引用数据类型，实参传递给形参的是实参存储数据的地址值\n   \n   change(String str, char ch[])两个参数都是引用类型，所以传递过去的都是地址值\n\n * 又因String类型的变量是不可变的，所以当对str参数执行str=\"test\n   ok\"操作时，形参str指向新的常量池地址，但是ex.str的地址并没有发生变化，因此ex.str仍为good\n\n * 另外，change方法中是对char[]中的一个元素进行修改，该元素是char类型，是基本数据类型，修改完成后，ch的地址值并没有变化，因此ex.ch值为\n   改动后的值best\n\n\n15.ArrayList、LinkedList、Vector三者的异同#\n\n * 相同点\n   * 三个类都是实现了List接口，存储的数据都是有序的、可重复的\n * 不同点\n   * ArrayList：作为List接口的主要实现类；线程不安全的，效率比Vector高；底层使用的是数组存储\n   * LinkedList：底层使用的是双向链表存储；对于频繁的插入、删除操作，LinkedList的效率比ArrayList效率高\n   * Vector：作为List接口的古老实现类，现在很少使用；线程安全的，效率比ArrayList低；底层使用的是数组存储\n\n\n16.List中remove()相关面试题#\n\n如下代码，输出的分别是什么？\n\n\n\n答：\n\n第一次输出：[1, 2, 4, 5]\n\n第二次输出：[1, 2, 4]\n\n> 解析：\n\nlist.remove(2);删除的是第二个元素\n\nlist.remove(new Integer(5));删除的是元素5\n\n\n17.Set相关面试题#\n\n如下代码分别输出是什么？\n\nTeacher类已重写equals()和hashCode()\n\n\n\n答：\n\n第1次输出：[Teacher{id=1002, name='BB'}, Teacher{id=1001, name='AA'}]\n第2次输出：[Teacher{id=1002, name='BB'}, Teacher{id=1001, name='CC'}]\n第3次输出：[Teacher{id=1002, name='BB'}, Teacher{id=1001, name='CC'},\nTeacher{id=1001, name='CC'}] 第4次输出：[Teacher{id=1002, name='BB'},\nTeacher{id=1001, name='CC'}, Teacher{id=1001, name='CC'}, Teacher{id=1001,\nname='AA'}]\n\n> 解析\n\n第1次输出：略\n\n第2次输出：t1.name改为CC，其hash值变了，在remove的时候比较的是新的hash值处的对象。因为新的hash值处没有元素，所以删除失败。因此输出两\n个元素，且t1的name值是CC\n\n第3次输出：新添加的new Teacher(1001, \"CC\")hash值处没有元素，所以添加成功。因此输出三个元素\n\n第4次输出：新添加的new Teacher(1001, \"AA\")hash值处有元素t1，且t1和新元素不相等，所以添加成功。因此输出4个元素\n\n\n18.HashMap的底层实现原理？#\n\n\n19.HashMap和Hashtable的异同？#\n\n * 相同点：都是作为Map的实现类，用来存储key-value对\n * 不同点：\n   * HashMap：\n     * 是Map的主要实现类；\n     * 线程不安全，效率比Hashtable高\n     * 可以存储值为null的key和value\n   * Hashtable：\n     * 是Map的古老实现类，现在很少用；\n     * 线程安全，效率比HashMap低\n     * 不可以存储值为null的key和value\n\n\n20.加载因子值的大小，对HashMap有什么影响？#\n\n * 加载因子的大小决定了HashMap的数据密度\n * 加载因子越大，密度越大，发生碰撞的几率越高，数组中链表越容易长，造成查询和插入时的比较次数增多，性能会下降\n * 加载因子越小，就越容易发生扩容，数据密度也越小，碰撞的几率也越小，数组中的链表就越短，查询和插入时比较的次数也越小，性能就会越高。但是会浪费一定的内存空间\n   。且经常扩容也影响性能\n * 按照其他语言的参考及研究经验，会考虑将加载因子设置为0.7-0.75，此时平均检索长度接近于常数","routePath":"/tang/java2/99_面试题","lang":"","toc":[{"text":"1.最高效方式计算2 * 8？","id":"1最高效方式计算2--8","depth":2,"charIndex":3},{"text":"2.多态是编译时行为还是运行时行为？如何证明？","id":"2多态是编译时行为还是运行时行为如何证明","depth":2,"charIndex":40},{"text":"3.方法的重载与重写","id":"3方法的重载与重写","depth":2,"charIndex":175},{"text":"4.==和equals()的区别","id":"4和equals的区别","depth":2,"charIndex":586},{"text":"5.三元运算符与包装类","id":"5三元运算符与包装类","depth":2,"charIndex":1163},{"text":"6.包装类","id":"6包装类","depth":2,"charIndex":1352},{"text":"7.接口-排错题","id":"7接口-排错题","depth":2,"charIndex":1607},{"text":"8.抽象类和接口的共同点和区别","id":"8抽象类和接口的共同点和区别","depth":2,"charIndex":1958},{"text":"9.throw和throws的区别","id":"9throw和throws的区别","depth":2,"charIndex":2177},{"text":"10.final、finally、finalize的区别","id":"10finalfinallyfinalize的区别","depth":2,"charIndex":2262},{"text":"11.synchronized和Lock的异同？","id":"11synchronized和lock的异同","depth":2,"charIndex":2702},{"text":"12.sleep()和wait()的异同？","id":"12sleep和wait的异同","depth":2,"charIndex":2969},{"text":"13.String拼接相关面试题","id":"13string拼接相关面试题","depth":2,"charIndex":3204},{"text":"14.String值传递相关面试题","id":"14string值传递相关面试题","depth":2,"charIndex":3490},{"text":"15.ArrayList、LinkedList、Vector三者的异同","id":"15arraylistlinkedlistvector三者的异同","depth":2,"charIndex":3834},{"text":"16.List中remove()相关面试题","id":"16list中remove相关面试题","depth":2,"charIndex":4117},{"text":"17.Set相关面试题","id":"17set相关面试题","depth":2,"charIndex":4271},{"text":"18.HashMap的底层实现原理？","id":"18hashmap的底层实现原理","depth":2,"charIndex":4934},{"text":"19.HashMap和Hashtable的异同？","id":"19hashmap和hashtable的异同","depth":2,"charIndex":4956},{"text":"20.加载因子值的大小，对HashMap有什么影响？","id":"20加载因子值的大小对hashmap有什么影响","depth":2,"charIndex":5209}],"domain":"","frontmatter":{},"version":""},{"id":135,"title":"5.部署项目","content":"自动部署#\n\n\n1.插件准备#\n\n在jenkins管理界面，点击Manage Jenkins，选择Manage Plugins，点击可选插件，搜索GitLab Plugin、Docker\nPlugin，直接安装。\n\n\n\n\n2.服务器环境配置#\n\n\n2.1安装git#\n\n因是每次git上项目有更新，都会自动制作镜像、升级服务镜像，故装有jenkins的服务器需要安装git用来下载gitlab上的项目。\n\n\n2.2安装docker#\n\n制作镜像的时候，需要用到docker，因此装有jenkins的服务器需要安装docker来实现镜像的制作与推送等操作。\n\n\n3.jenkins全局工具配置#\n\n在jenkins管理界面，点击Manage Jenkins，选择Global Tool Configuration，点击可选插件，搜索GitLab\nPlugin、Docker Plugin，直接安装。\n\n\n3.1配置git#\n\n在jenkins管理界面，点击Manage Jenkins，选择Global Tool Configuration，找到Git，点击Add\nGit，对git进行配置。\n\n\n\n\n3.2配置docker#\n\n\n3.2.1docker基本配置#\n\n\n\n\n3.2.2docker配置失败的解决方法#\n\n如果点击【Test Connection】按钮报如下错误，可按照以下步骤解决。\n\n报错如下：\n\n\n\n解决步骤：\n\nStep1.输入systemctl status docker查看docker端口号\n\n\n\nStep2. 修改docker tcp端口号\n\n\n\n\n\nStep3.重启docker\n\n\n\n\n\nStep4.jenkins测试是否连接成功\n\n\n\n\n4.创建项目#\n\n\n4.1 新建Item#\n\n\n\n\n4.2项目源码设置#\n\n\n\n\n4.3 构建触发器#\n\n\n\n\n4.4编写构建脚本#\n\n\n\n\n\n\n4.5保存项目信息#\n\n项目信息编写完成后，点击【保存】按钮即可。\n\n\n\n\n5.部署项目#\n\n\n5.1 运行#\n\n\n\n\n5.2查看项目构建日志#\n\n","routePath":"/tang/k8s/学习资料/auto","lang":"","toc":[{"text":"2.1安装git","id":"21安装git","depth":2,"charIndex":123},{"text":"2.2安装docker","id":"22安装docker","depth":2,"charIndex":203},{"text":"3.1配置git","id":"31配置git","depth":2,"charIndex":400},{"text":"3.2配置docker","id":"32配置docker","depth":2,"charIndex":499},{"text":"3.2.1docker基本配置","id":"321docker基本配置","depth":3,"charIndex":514},{"text":"3.2.2docker配置失败的解决方法","id":"322docker配置失败的解决方法","depth":3,"charIndex":535},{"text":"4.1 新建Item","id":"41-新建item","depth":2,"charIndex":745},{"text":"4.2项目源码设置","id":"42项目源码设置","depth":2,"charIndex":761},{"text":"4.3 构建触发器","id":"43-构建触发器","depth":2,"charIndex":776},{"text":"4.4编写构建脚本","id":"44编写构建脚本","depth":2,"charIndex":791},{"text":"4.5保存项目信息","id":"45保存项目信息","depth":2,"charIndex":808},{"text":"5.1 运行","id":"51-运行","depth":2,"charIndex":856},{"text":"5.2查看项目构建日志","id":"52查看项目构建日志","depth":2,"charIndex":868}],"domain":"","frontmatter":{},"version":""},{"id":136,"title":"6.SSH连接慢","content":"一些博客#\n\n\n1.安装nfs-util服务端及客户端#\n\nhttps://blog.csdn.net/swanrat_rr/article/details/85200015\n\n\n2.三种常见的文件共享服务--ftp,nfs,samba#\n\nhttps://blog.51cto.com/guoting/1541299\n\n\n3.StatefulSet详解#\n\nStatefulSet详解：https://blog.51cto.com/newfly/2140004\n\n什么是Headless Services： https://www.jianshu.com/p/fe5303b8c1c1\n\n\n4.gpu插件#\n\nhttps://github.com/NVIDIA/k8s-device-plugin/tree/master/docker\n\n\n5.K8S文档#\n\nhttps://kubernetes.io/docs/home/\n\nhttps://kubernetes.io/zh/docs/home/\n\n\n6.SSH连接慢#\n\n[CentOS/Linux 解决 SSH 连接慢_doiido的专栏-CSDN博客](","routePath":"/tang/k8s/学习资料/blog","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":137,"title":"1.node相关","content":"常用命令#\n\n\n1.node相关#\n\n\n1.1 设置node是否可调度#\n\n\n\n\n1.2 删除node#\n\n","routePath":"/tang/k8s/学习资料/command","lang":"","toc":[{"text":"1.1 设置node是否可调度","id":"11-设置node是否可调度","depth":2,"charIndex":19},{"text":"1.2 删除node","id":"12-删除node","depth":2,"charIndex":40}],"domain":"","frontmatter":{},"version":""},{"id":138,"title":"3.登录","content":"docker 安装 ftp 服务端#\n\n\n1.拉取镜像#\n\n\n\nfauria/vsftpd是官方的FTP服务器镜像\n\n\n2.启动docker容器#\n\n\n\n参数说明：\n\n-p 是将容器中的端口映射到宿主机的端口，冒号前边是宿主机的端口；\n\n/home/share/pano_sources/pano-dev-sources-pvc-555f9685-2ff8-4932-bcfd-f2ac309925\ne7:/home/vsftpd/pano是将容器中的/home/vsftpd/pano挂载到宿主机的/home/share/pano_sources/pano-\ndev-sources-pvc-555f9685-2ff8-4932-bcfd-f2ac309925e7路径下；\n\nFTP_USER、FTP_PASS分别是FTP登录的用户名和密码；\n\nPASV_ADDRESS是宿主机IP；\n\nPASV_MIN_PORT、PASV_MAX_PORT分别是给客户端提供下载服务随机的端口号范围，默认是21100-2111。此处要和前面docker端口映射设\n置成一样。\n\nname是容器名称；\n\n--restart=always /fauria/vsftpd指定重启策略以及容器镜像。\n\n\n3.登录#\n\n浏览器输入ftp://pano:bd_21_pano@10.1.93.172即可访问\n\n注意：pano用户的根目录为/home/vsftpd/pano/","routePath":"/tang/k8s/学习资料/ftp","lang":"","toc":[{"text":"2.启动docker容器","id":"2启动docker容器","depth":2,"charIndex":59}],"domain":"","frontmatter":{},"version":""},{"id":139,"title":"下载镜像提示没有磁盘空间","content":"#\n\n1.查看docker根目录\n\n\n\n2.查看目录剩余空间\n\n\n\n磁盘空间只剩803M可用，可以将他放到一个更大的目录中去。\n\n3.创建目标目录\n\n\n\n4.创建配置文件\n\n\n\n5.重启docker\n\n","routePath":"/tang/k8s/错误集锦/1","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":140,"title":"使用容器制作基础镜像","content":"#\n\n以制作pecan项目的基础镜像为例\n\n最近做了个python的web项目，使用的是pecan框架。按照原来制作镜像的方法，每次制作镜像都需要重新pip install相同的动态库","routePath":"/tang/k8s/错误集锦/2","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":141,"title":"解决步骤：","content":"无法推送镜像#\n\nhttps://blog.csdn.net/haodiaoer/article/details/94835649\n\n\n错误信息：#\n\nGet https://10.1.93.164:5000/v2/: net/http: request canceled while waiting for\nconnection (Client.Timeout exceeded while awaiting headers)\n\n\n\n\n错误原因：#\n\ndocker私有仓库服务器，默认是基于https传输的，所以我们需要在客户端做相关设置，不使用https传输\n\n\n解决步骤：#\n\n\nstep1.编辑/etc/docker/daemon.json文件#\n\n\n\n\nstep2.将下面的代码放进去保存并退出#\n\n\n\n结果如下：\n\n\n\n\nstep3.重新启动docker#\n\n","routePath":"/tang/k8s/错误集锦/3","lang":"","toc":[{"text":"step1.编辑/etc/docker/daemon.json文件","id":"step1编辑etcdockerdaemonjson文件","depth":2,"charIndex":292},{"text":"step2.将下面的代码放进去保存并退出","id":"step2将下面的代码放进去保存并退出","depth":2,"charIndex":331},{"text":"step3.重新启动docker","id":"step3重新启动docker","depth":2,"charIndex":366}],"domain":"","frontmatter":{},"version":""},{"id":142,"title":"6.查看flannel状态","content":"节点notReady#\n\n今天查看节点状态，发现master节点状态为NotReady。排查步骤如下：\n\n\n1.查看master kubelet状态#\n\n\n\n如果状态正常，继续按照如下步骤排查。\n\n我这里在该步骤就不正常了，提示找不到节点“master”。我本来设置的master节点的hostname为bdmaster，因此我又查看了下该服务器的hostn\name，发现该服务器的hostname变成了master。修改hostname后重启服务器，发现master节点正常了。\n\n\n\n\n2.查看master kube-proxy状态#\n\n\n\n\n3.查看master kube-apiserver状态#\n\n\n\n\n4.查看master kube-scheduler状态#\n\n\n\n\n5.查看master etcd状态#\n\n\n\n\n6.查看flannel状态#\n\n在kubernetes-dashboard上看到flannel挂掉了，查看日志如下\n\nFailed create pod sandbox: rpc error: code = Unknown desc = failed to start\nsandbox container for pod \"kube-flannel-ds-amd64-sc7sr\": Error response from\ndaemon: OCI runtime create failed: container_linux.go:348: starting container\nprocess caused \"process_linux.go:301: running exec setns process for init caused\n\\\"signal: broken pipe\\\"\": unknown\n\n而这个问题，通过分析应该是flannel在网络比较大的情况下，内存资源不足了，所以修改flannel的配置，将内存扩大即可。\n\n\n\n修改完成之后，需要重启docker，在删除原来的flannel pod，这样问题就解决拉。","routePath":"/tang/k8s/错误集锦/4","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":143,"title":"解决步骤","content":"6443_connect-refused#\n\n\n错误信息#\n\nThe connection to the server 192.168.100.170:6443 was refused\n\n\n\n\n解决步骤#\n\n参考文档：https://www.jianshu.com/p/6edc9f171df1\n\n\nstep1. 查看6443端口是否正常或者是否开启防火墙#\n\n\n\n运行之后什么都没有返回，也就是说 APIServer 完全没有提供服务，那我们就去查看一下 kubelet 的日志，大家都知道使用 kubeadm 搭建的\nk8s集群里，APIServer 都是在 docker 里运行的，这里我们先找到对应的容器，记得加 -a，因为该容器可能已经处于非正常状态了。\n\n\nstep2.查看APIServer#\n\n\n\n这里能看到两个容器，可以看到 容器的状态已经是 Exited 了，注意下面的pause容器，这个只是用来引导 APIServer\n的，并不是服务的实际运行容器，所以看不到日志，所以查看日志时不要输错容器 id 了。接下来查看 APIServer 的日志。\n\n\nStep3.查看APIServer 的日志#\n\n\n\n从最后一行可以看到，是 APIServer 在尝试创建存储时出现了问题，导致无法正确启动服务，由于 k8s 是使用 etcd 作为存储的，所以我们再来查看\netcd 的日志 。\n\n\nStep4.查看etcd日志#\n\n\n\n从最后一行可以看出，no space left on device，表示磁盘空间不够了。解决方法，要么是删掉虚拟机中无用文件，要么是给虚拟机增加内存。","routePath":"/tang/k8s/错误集锦/6443_connect-refused","lang":"","toc":[{"text":"step1. 查看6443端口是否正常或者是否开启防火墙","id":"step1-查看6443端口是否正常或者是否开启防火墙","depth":2,"charIndex":149},{"text":"step2.查看APIServer","id":"step2查看apiserver","depth":2,"charIndex":334},{"text":"Step3.查看APIServer 的日志","id":"step3查看apiserver-的日志","depth":2,"charIndex":486},{"text":"Step4.查看etcd日志","id":"step4查看etcd日志","depth":2,"charIndex":603}],"domain":"","frontmatter":{},"version":""},{"id":144,"title":"2.云平台部署Nacos","content":"Nacos的使用#\n\nNacos官方文档：https://nacos.io/zh-cn/docs/quick-start.html\n\n\n1.windows环境启动Nacos#\n\n * 环境准备： 64 bit JDK 1.8+ 、 Maven 3.2.x+\n * Nacos有两种启动方式。一种是下载源码，进行编译后再启动；另一种是直接下载nacos-server-$version.zip解压后再启动。本文介绍使用下\n   载zip文件的方式进行启动。\n * 目前稳定版本是1.4.1，推荐使用该版本，下载地址：https://github.com/alibaba/nacos/releases/download/\n   1.4.1/nacos-server-1.4.1.zip。我这里使用的是最新版2.0.0。\n\n\n1.1解压#\n\n\n\n\n1.2创建数据库#\n\n在mysql中创建nacos数据库，导入D:\\Nacos\\nacos\\conf\\nacos-mysql.sql:\n\n\n\n\n1.3修改配置文件#\n\n用记事本打开D:\\Nacos\\nacos\\conf\\application.properties文件进行修改。\n\n\n\n\n1.4启动#\n\ncmd进入D:\\Nacos\\nacos\\bin路径，执行startup.cmd -m standalone命令。\n\n\n\n\n1.5访问#\n\n浏览器输入http://localhost:8848/nacos/ 进行访问。登录账号/密码为：nacos/nacos\n\n\n\n\n2.云平台部署Nacos#\n\n一个yaml文件搞定~\n\n\n\n\n\n访问的话，需要去查询service的端口号进行访问：http://IP:端口号/nacos。","routePath":"/tang/mservice/1","lang":"","toc":[{"text":"1.1解压","id":"11解压","depth":2,"charIndex":359},{"text":"1.2创建数据库","id":"12创建数据库","depth":2,"charIndex":370},{"text":"1.3修改配置文件","id":"13修改配置文件","depth":2,"charIndex":442},{"text":"1.4启动","id":"14启动","depth":2,"charIndex":514},{"text":"1.5访问","id":"15访问","depth":2,"charIndex":583}],"domain":"","frontmatter":{},"version":""},{"id":145,"title":"10.  服务异步通讯RabbitMQ","content":"微服务学习#\n\n\n1.认识微服务#\n\n\n1.1 分布式架构#\n\n> 定义\n\n根据业务功能对系统进行拆分，每个业务模块的作为独立项目开发，成为一个服务。\n\n> 优点\n\n * 降低服务耦合\n * 有利于服务扩展\n\n> 分布式架构要考虑的问题\n\n * 服务拆分粒度？\n * 服务集群地址如何维护？\n * 服务之间如何实现远程调用？\n * 服务健康状态如何感知？\n\n\n1.2 微服务#\n\n> 定义\n\n微服务是一种经过良好架构设计的分布式架构方案。\n\n> 特征\n\n * ==单一职责==：微服务拆分粒度更小，每一个服务对应唯一的业务能力，做到单一职责，避免业务重复开发\n * ==面向对象==：微服务对外暴露接口\n * ==自治==：团队独立、技术独立、数据独立、部署独立\n * ==隔离性强==：服务调用做好隔离、容错、降级，避免出现隔离问题\n\n> 微服务技术对比\n\n          DUBBO             SPRINGCLOUD               SPRINGCLOUDALIBABA\n注册中心      zookeeper、Redis   Eureka、Consul             Nacos、Eureka\n服务远程调用    Dobbo协议           Feign（http协议）             Dubbo、Feign\n配置中心      无                 SpringCloudConfig         SpringCloudConfig、Nacos\n服务网关      无                 SpringCloudGateway、Zuul   SpringCloudGateway、Zuul\n服务监控和保护   dubbo-admin，功能弱   Hystrix                   Sentinel\n\n\n1.3 SpringCloud#\n\n目前使用最广泛的微服务架构。\n\n\n2.服务拆分及远程调用#\n\n\n2.1 服务拆分注意事项#\n\n * 不同微服务，不要重复开发相同业务。\n * 微服务数据独立，不要访问其他微服务的数据库。\n * 微服务可以将自己的业务暴露为接口，供其他服务使用。\n\n\n2.2 服务调用关系#\n\n * ==服务提供者==：一次业务中，被其他微服务调用的服务。\n\n * ==服务消费者==：一次业务中，低啊用其他微服务的服务。\n   \n   ==提供者与消费者的角色是相对而言的==：一个服务既可以是消费者，又可以是提供者\n\n\n2.3 Eureka注册中心#\n\nEureka架构中,微服务角色有两类:\n\n * EurekaServer：服务端，注册中心\n   \n   * 作用：记录服务信息，监控客户端心跳\n\n * EurekaClient：客户端\n   \n   * Provider：服务提供者\n     * 启动时，注册自己的信息到EurekaServer\n     * 每隔30s向EurekaServer发送心跳\n   * Consumer：服务消费者\n     * 根据服务名称从EurekaServer拉取服务列表\n     * 基于服务列表做负载均衡，选中一个微服务后发起调用。\n\n\n2.4 Ribbon负载均衡#\n\n> Ribbon负载均衡流程\n\n\n\n> 负载均衡策略\n\n==Ribbon的负载均衡规则是一个叫IRule的接口来定义的，每一个子接口都是一种规则。==\n\n\n\n内置负载均衡规则类                   规则描述\nRoundRobinRule              轮询。Ribbon默认的负载均衡。\nAvailabilityFilteringRule   对以下两种服务器忽略:\n                            1.“短路”的服务器。默认情况下，如果一台服务器3次连接失败，就会被设置为“短路”状态。短路状态将持续30s，如果再次连\n                            接失败，短路状态持续时间几何级增加。\n                            2.并发数过高的服务器。可以由..ActiveConnectionsLimit配置。\nWeightedResponseTimeRule    为每一个服务器赋予一个权重值。服务器响应时间越长，其权重值越小。这个规则会随机选择服务器，权重值会影响服务器的选择。\nZoneAvoidanceRule           以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，Zone可以理解为一个机房、一个机架等。而后再对\n                            Zone内的多个服务做轮询。\nBestAvailableRule           忽略短路服务器，并选择并发数较低的服务器。\nRandomRule                  随机选择一个可用的服务器。\nRetryRule                   重试机制的选择逻辑。\nRandomRule                  随机选择。\n\n> 负载均衡两种配置方式\n\n * 在消费者服务的启动类里注入IRule\n   \n   \n\n * 在消费者服务的yaml文件里添加规则\n   \n   \n\n==以上二者的区别==：\n\n第一种是所有服务的负载均衡策略都是RandomRule；第二种是只有指定服务名（userservice）的服务的负载均衡策略是RandomRule。\n\n> Ribbon 策略--饥饿加载\n\nRibbon默认使用的是懒加载。\n\n==开启饥饿加载==\n\n\n\n\n2.5 Nacos注册中心#\n\n\n7.Feign(HTTP客户端)#\n\n\n7.1 Feign替代RestTemplate#\n\n> Feign定义\n\nFeign是一个声明式的http客户端，作用是帮助我们优雅的实现http请求的发现，帮助实现各个微服务内部之间的调用。\n\n> 使用\n\nStep1. 引入依赖\n\n\n\nStep2. 启动类添加Feign启动注解\n\n\n\nStep3. 编写Feign客户端\n\n\n\nStep4. 测试使用\n\n\n\n\n7.2 自定义配置#\n\n> 概念\n\n\n\n> 使用配置文件配置Feign日志\n\n\n\n> 使用注解配置Feign日志\n\n\n\n\n7.3 Feign使用优化#\n\n> Feign底层客户端实现\n\n * URLConnection：默认实现，不支持连接池，性能较差\n * Apache HttpClient：支持连接池\n * OKHttp：支持连接池\n\n> 优化策略\n\n * 使用连接池代替默认URLConnection\n * 日志级别，最好使用basic或none\n\n> Feign性能优化-连接池配置\n\n\n\n\n7.4 最佳实践#\n\n> 方式一--继承（耦合度比较高）\n\n\n\n> 方式二--抽取（如果FeignAPI功能比较多，包比较大，orderservice只用到一两个方法，就造成了浪费）\n\n\n\n方式2的实现难点\n\n> 当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用，解决方法如下：\n\n\n\n\n8.统一网关Gateway#\n\n\n8.1 为什么需要网关#\n\n> 网关功能\n\n * 对用户请求做身份认证和权限校验\n * 将用户请求路由到微服务，并实现负载均衡\n * 对要不过户请求做限流\n\n> 网关的技术实现\n\n * gateway\n * zuul\n\n==对比==：zuul是基于servlet实现，属于阻塞式变成。gateway是基于SPring5中提供的WebFlux，属于响应式变成，具备更好的性能。\n\n\n8.2 gateway快速入门#\n\n> 搭建步骤\n\n\n\n> 请求流程\n\n\n\n> 总结->路由可以配置的内容包括以下几点：\n\n * 路由id：路由唯一标识\n * 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名称做负载均衡\n * 路由断言（predicates）：判断路由规则\n * 路由过滤器（filters）：对请求或响应做处理\n\n\n8.3 断言工厂#\n\n> 作用\n\n读取用户在配置文件中编写的断言规则，将他们解析出来，并且对请求做出判断\n\n> Spring提供的11中基本的Predicate工厂\n\n\n\n> After断言工厂的使用\n\n\n\n==当前是2022年，不符合路由规则，此时访问会报404==\n\n\n8.4 过滤器工厂#\n\n\n8.4.1 路由过滤器GatewayFilter#\n\nGatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n\n\n\n\n8.4.2 路由过滤器工厂#\n\n> 过滤器的作用\n\n * 对路由的请求或响应做加工处理，比如添加请求头\n * 配置在路由下的过滤器只对当前路由的请求生效（==如果想对所有路由都生效，可以使用defaultFilter==）\n\n一共30多种。使用时可以参考官网。\n\n\n\n> 例子：给所有进入userservice的请求加一个请求头：Truth=Itcast is freeking awesome！\n\n\n\n\n\n> 优化：给所有请求都加上请求头：Truth=Itcast is freeking awesome！\n\n\n\n\n8.5 全局过滤器GlobalFilter#\n\n> 作用\n\n处理一切进入网关的请求和微服务响应，和GatewayFilter的作用一样。==区别==在于GatewayFilter通过配置定义，处理逻辑是固定的；但是Glo\nbalFilter的逻辑需要自己写代码实现。\n\n> 实现方式\n\n实现GlobalFilter接口。\n\n\n\n> 案例：编写一个拦截器，获取请求中的authorization参数。如果用户是admin，放行，否则就拦截。\n\n\n\n\n8.6 过滤器执行顺序#\n\n * order值越小，执行顺序越靠前\n * order值相等时，安装defaultFilter>路由过滤器>GlobalFilter的顺序执行。\n\n\n8.7 跨域问题#\n\n> 定义\n\n浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题。\n\n> 解决方案\n\nCORS\n\n> 实现\n\n\n\n\n9.Docker#\n\n\n9.1 初识Docker#\n\n\n9.1.1 概念#\n\n> Docker如何解决大型项目依赖关系复杂、不同组件依赖兼容性的问题？\n\n * Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像。\n * Docker应用运行在容器中，使用沙箱机制，相互隔离\n\n> Docker如何解决开发、测试、生产环境有差异的问题？\n\nDocker镜像中包含完整的运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行。\n\n\n9.1.2 Docker与虚拟机的区别#\n\n * Docker是一个系统进程；虚拟机是在操作系统中的操作系统\n * Docker体积小，启动速度快，性能好；虚拟机体积大，启动速度慢，性能较差。\n\n\n\n\n9.1.3 Docker架构#\n\n\n\n\n9.2 数据卷#\n\n\n\n\n\n\n9.3 目录挂载#\n\n命令和数据卷挂载一致。\n\n> 目录挂载和数据卷挂载的区别\n\n\n\n\n9.4 镜像#\n\n> 定义\n\n镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。\n\n> 镜像结构\n\n==镜像是分层结构，每一层称为一个Layer==\n\n\n\n\n9.5 DockerCompose#\n\n> 概念\n\n * DockerCompose基于Compose文件实现快速部署分布式应用。\n\n * Compose文件是一个文本文件，通过指令定义急群众的每个容器如何运行。\n   \n   \n\n\n10. 服务异步通讯RabbitMQ#\n\n\n10.1 初始MQ#\n\n\n10.1.1 同步通讯#\n\n==微服务间基于Feign的调用就属于同步方式。==\n\n> 优点\n\n时效性强，能够立即得到结果\n\n> 同步调用的问题\n\n * 耦合度高：每次加入新需求，都要改原来的代码\n * 性能下降：调用者需要等待提供者响应。如果调用链过程则响应时间等于每次调用的时间之和\n * 资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下极度浪费系统资源\n * 级联失败：如果提供者出现问题，所有调用方法都会跟着出问题，如同多米诺骨牌，迅速导致整个微服务群故障\n\n\n10.1.2 异步通讯#\n\n==异步调用常见实现就是事件驱动模式。==\n\n\n\n> 优势\n\n * 服务解耦\n * 性能提升，吞吐量提高\n * 服务没有强依赖，不担心级联失败问题\n * 流量削峰\n\n> 缺点\n\n * 依赖于Broker的可靠性、安全性、吞吐能力\n * 架构复杂了，业务没有明显的流程线，不好追踪管理\n\n\n10.1.3 MQ常见框架#\n\n> MQ定义\n\nMQ（MessageQueue），存放消息的队列，即时间驱动架构中的Broker。\n\n> MQ常见框架对比\n\n\n\n\n10.2 RabbitMQ快速入门#\n\n\n10.2.1 概述#\n\n==RabbitMQ最擅长的是消息的可靠性、稳定性，以及系统的高可用==\n\n官网：Messaging that just works — RabbitMQ\n\n10.2.1.1 单机部署MQ#\n\nStep1. 下载RabbitMQ镜像\n\n\n\nStep2. 运行MQ容器\n\n\n\n\n10.2.2 RabbitMQ概念和结构#\n\n> 概念\n\n * channel：操作MQ的工具\n * exchange：路由消息到队列中\n * queue：缓存消息\n * virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组\n\n> 结构\n\n\n\n\n10.3 常见消息模型#\n\n\n\n> Hello World 实践\n\n\n\n\n10.4 SpringAMQP#\n\n\n10.4.1 概念#\n\n> AMQP\n\nAdvanced Message Queuing Protocol，用于在应用程序之间传递业务消息的开放标准。该协议与平台无关，更符合微服务中独立性要求。\n\n> Spring AMQP\n\nSpring\nAMQP是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的\n默认实现。\n\n==特征==\n\n * 侦听器容器，用于异步处理入栈消息\n * 支持用于发送和接收消息的RabbitTemplate\n * 支持RabbitAdmin自动声明队列、交换、绑定\n\n\n10.4.2 案例#\n\n> 利用SpringAMQP实现HelloWorld中的基础消息队列功能\n\n流程如下：","routePath":"/tang/mservice/2","lang":"","toc":[{"text":"1.1 分布式架构","id":"11-分布式架构","depth":2,"charIndex":19},{"text":"1.2 微服务","id":"12-微服务","depth":2,"charIndex":179},{"text":"1.3 SpringCloud","id":"13-springcloud","depth":2,"charIndex":806},{"text":"2.1 服务拆分注意事项","id":"21-服务拆分注意事项","depth":2,"charIndex":856},{"text":"2.2 服务调用关系","id":"22-服务调用关系","depth":2,"charIndex":949},{"text":"2.3 Eureka注册中心","id":"23-eureka注册中心","depth":2,"charIndex":1077},{"text":"2.4 Ribbon负载均衡","id":"24-ribbon负载均衡","depth":2,"charIndex":1362},{"text":"2.5 Nacos注册中心","id":"25-nacos注册中心","depth":2,"charIndex":2387},{"text":"7.1 Feign替代RestTemplate","id":"71-feign替代resttemplate","depth":2,"charIndex":2424},{"text":"7.2 自定义配置","id":"72-自定义配置","depth":2,"charIndex":2605},{"text":"7.3 Feign使用优化","id":"73-feign使用优化","depth":2,"charIndex":2666},{"text":"7.4 最佳实践","id":"74-最佳实践","depth":2,"charIndex":2856},{"text":"8.1 为什么需要网关","id":"81-为什么需要网关","depth":2,"charIndex":3056},{"text":"8.2 gateway快速入门","id":"82-gateway快速入门","depth":2,"charIndex":3246},{"text":"8.3 断言工厂","id":"83-断言工厂","depth":2,"charIndex":3428},{"text":"8.4 过滤器工厂","id":"84-过滤器工厂","depth":2,"charIndex":3565},{"text":"8.4.1 路由过滤器GatewayFilter","id":"841-路由过滤器gatewayfilter","depth":3,"charIndex":3578},{"text":"8.4.2 路由过滤器工厂","id":"842-路由过滤器工厂","depth":3,"charIndex":3659},{"text":"8.5 全局过滤器GlobalFilter","id":"85-全局过滤器globalfilter","depth":2,"charIndex":3918},{"text":"8.6 过滤器执行顺序","id":"86-过滤器执行顺序","depth":2,"charIndex":4142},{"text":"8.7 跨域问题","id":"87-跨域问题","depth":2,"charIndex":4232},{"text":"9.1 初识Docker","id":"91-初识docker","depth":2,"charIndex":4324},{"text":"9.1.1 概念","id":"911-概念","depth":3,"charIndex":4340},{"text":"9.1.2 Docker与虚拟机的区别","id":"912-docker与虚拟机的区别","depth":3,"charIndex":4556},{"text":"9.1.3 Docker架构","id":"913-docker架构","depth":3,"charIndex":4657},{"text":"9.2 数据卷","id":"92-数据卷","depth":2,"charIndex":4677},{"text":"9.3 目录挂载","id":"93-目录挂载","depth":2,"charIndex":4692},{"text":"9.4 镜像","id":"94-镜像","depth":2,"charIndex":4736},{"text":"9.5 DockerCompose","id":"95-dockercompose","depth":2,"charIndex":4822},{"text":"10.1 初始MQ","id":"101-初始mq","depth":2,"charIndex":4961},{"text":"10.1.1 同步通讯","id":"1011-同步通讯","depth":3,"charIndex":4974},{"text":"10.1.2 异步通讯","id":"1012-异步通讯","depth":3,"charIndex":5226},{"text":"10.1.3 MQ常见框架","id":"1013-mq常见框架","depth":3,"charIndex":5384},{"text":"10.2 RabbitMQ快速入门","id":"102-rabbitmq快速入门","depth":2,"charIndex":5466},{"text":"10.2.1 概述","id":"1021-概述","depth":3,"charIndex":5487},{"text":"10.2.1.1 单机部署MQ","id":"10211-单机部署mq","depth":4,"charIndex":5578},{"text":"10.2.2 RabbitMQ概念和结构","id":"1022-rabbitmq概念和结构","depth":3,"charIndex":5637},{"text":"10.3 常见消息模型","id":"103-常见消息模型","depth":2,"charIndex":5776},{"text":"10.4 SpringAMQP","id":"104-springamqp","depth":2,"charIndex":5813},{"text":"10.4.1 概念","id":"1041-概念","depth":3,"charIndex":5832},{"text":"10.4.2 案例","id":"1042-案例","depth":3,"charIndex":6130}],"domain":"","frontmatter":{},"version":""},{"id":146,"title":"1 MySQL数据库概述","content":"#\n\n\n1.1 为什么要使用数据库#\n\n * 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企\n   业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多 通过各种关系数据库来完成。\n * 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数 据文件中。\n\n\n1.2 数据库相关概念#\n\n * DB：数据库（Database） 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。\n * DBMS：数据库管理系统（Database Management System）\n   是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控 制。用户通过数据库管理系统访问数据库中表内的数据。\n * SQL：结构化查询语言（Structured Query Language） 专门用来与数据库通信的语言。\n\n\n1.3 SQL分类#\n\nSQL语言在功能上主要分为如下3大类：\n\n * DDL：数据定义语言。这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。\n   \n   主要的语句关键字包括 CREATE 、 DROP 、 ALTER、TURNCATE 等。\n\n * DML：数据操作语言。用于添加、删除、更新和查询数据库记 录，并检查数据完整性。\n   \n   主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。 SELECT是SQL语言的基础，最为重要。\n\n * DCL：数据控制语言。用于定义数据库、表、字段、用户的访问权限和 安全级别。\n   \n   主要的语句关键字包括 GRANT （赋予权限）、 REVOKE（回收权限）、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。\n\n\n1.4 MySQL特点#\n\n * 开放源代码，使用成本低。\n * 性能卓越，服务稳定。\n * 软件体积小，使用简单，并且易于维护。\n * 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n * 许多互联网公司在用，经过了时间的验证。\n\n\n1.5 Oracle vs MySQL#\n\n * Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要 求。\n * MySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码\n   这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库","routePath":"/tang/mysql/01_MySQL概述","lang":"","toc":[{"text":"1.1 为什么要使用数据库","id":"11-为什么要使用数据库","depth":2,"charIndex":3},{"text":"1.2 数据库相关概念","id":"12-数据库相关概念","depth":2,"charIndex":191},{"text":"1.3 SQL分类","id":"13-sql分类","depth":2,"charIndex":438},{"text":"1.4 MySQL特点","id":"14-mysql特点","depth":2,"charIndex":837},{"text":"1.5 Oracle vs MySQL","id":"15-oracle-vs-mysql","depth":2,"charIndex":957}],"domain":"","frontmatter":{},"version":""},{"id":147,"title":"2 关系型数据库与非关系型数据库","content":"#\n\n\n2.1 关系型数据库RDBMS#\n\n> 定义\n\n关系型数据库模型是把复杂的数据结构归结为简单的 二元关系 （即二维表格形式）。\n\n * 关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。这一系列的行和列被称为 表(table)\n   ，一组表组成了一个库(database)。\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型\n   来表示。关系型数据库，就是建立在关系模型基础上的数据库\n\n> 优势\n\n * 复杂查询： 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n * 事务支持： 使得对于安全性能很高的数据访问要求得以实现。\n\n\n2.2 非关系型数据库NoSQL#\n\n> 定义\n\n非关系型数据库，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层 的解析， 性能非常高\n。同时，通过减少不常用的功能，进一步提高性能。\n\n> 分类\n\n * 键值型数据库\n   * 定义：键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key\n     作为唯一的标识符\n   * 优点：查找速度快\n   * 缺点：无法 像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键， 这就会消耗大量的计算\n   * 使用场景：内存缓存\n   * 举例：Redis\n * 文档型数据库\n   * 定义：在数据库中文档作为处理信息的基本单位， 一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。\n   * 使用场景：存放并获取文档，可以是XML、JSON等格式\n   * 举例：MongoDB\n * 搜索引擎数据库\n   * 定义：搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检 索的时候才能保证性能最优\n   * 使用场景：搜索引擎领域\n   * 举例：Solr、Elasticsearch、Splunk\n * 列式数据库\n   * 定义：列式数据库是将数据按照列存储到数据库中\n   * 优点：可以大量降低系统的 I/O\n   * 缺点：功能相对行式数据库有限\n   * 使用场景：分布式文件系统\n   * 举例：HBase\n * 图形数据库：\n   * 定义：是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象） 之间的关系\n   * 优点：能高效地解决复杂的关系问题\n   * 使用场景：存储复杂的实体关系，如社交网络中人与人的关系\n   * 举例：Neo4J、InfoGrid","routePath":"/tang/mysql/02_关系型数据库与非关系型数据库","lang":"","toc":[{"text":"2.1 关系型数据库RDBMS","id":"21-关系型数据库rdbms","depth":2,"charIndex":3},{"text":"2.2 非关系型数据库NoSQL","id":"22-非关系型数据库nosql","depth":2,"charIndex":335}],"domain":"","frontmatter":{},"version":""},{"id":148,"title":"3 关系型数据库设计原则","content":"#\n\n> 前言\n\n * 关系型数据库的典型数据结构就是 数据表 ，这些数据表的组成都是结构化的（Structured）。\n * 将数据放到表中，表再放到库中。\n * 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。\n * 表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。\n\n\n3.1 表、记录、字段#\n\n * E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。\n * 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表\n   中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列 （column），也称为一个字段（field）。\n * ORM思想 (Object Relational Mapping)体现：\n   * 数据库中的一个表 <---> Java或Python中的一个类\n   * 表中的一条数据 <---> 类中的一个对象（或实例）\n   * 表中的一个列 <----> 类中的一个字段、属性(field)\n\n\n3.2 表的关联关系#\n\n> 概述\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型来表示。\n * 分类：一对一关联、一对多关联、多对多关联、自我引用\n\n> 一对一关联（one-to-one）\n\n * 在实际的开发中应用不多，因为一对一可以创建成一张表。\n * 举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急 联系人、...\n   * 拆为两个表：两个表的记录是一一对应关系。\n   * 基础信息表 （常用信息）：学号、姓名、手机号码、班级、系别\n   * 档案信息表 （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...\n * 两种建表原则：\n   * 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n   * 外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n> 一对多关系（one-to-many）\n\n * 常见实例场景： 客户表和订单表 ， 分类表和商品表 ， 部门表和员工表 。\n * 举例： 员工表：编号、姓名、...、所属部门 部门表：编号、名称、简介\n * 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n> 多对多（many-to-many）\n\n * 定义：要表示多对多关系，必须创建第三个表，该表通常称为 联接表 ，它将多对多关系划分为两个一对多关 系。将这两个表的主键都插入到第三个表中。\n * 举例：\n   * 学生和课程（一个学生可以选多门课程，一个课程可以被多名学生选择）：学生表、课程表、学生选课信息表\n   * 产品和订单（一个产品可以出现在多个订单中，一个订单可以有多个产品）：产品表、订单表、订单明细表\n\n> 自我引用(Self reference)\n\n * 举例：员工表中属性：员工编号，员工姓名，员工主管编号，...。其中员工主管编号就是员工主管的员工编号。表中字段指向了另一个字段。","routePath":"/tang/mysql/03_关系型数据库设计原则","lang":"","toc":[{"text":"3.1 表、记录、字段","id":"31-表记录字段","depth":2,"charIndex":175},{"text":"3.2 表的关联关系","id":"32-表的关联关系","depth":2,"charIndex":538}],"domain":"","frontmatter":{},"version":""},{"id":149,"title":"4 MySQL的登录","content":"#\n\n\n4.1 服务的启动与停止#\n\n * 方式1：使用图形界面工具\n   \n   * 步骤1：打开windows服务\n   * 步骤2：找到MySQL（点击鼠标右键）→ 启动或停止（点击）\n\n * 方式2：使用命令行工具（需要管理员权限）\n   \n   \n\n\n4.2 使用命令行登录MySQL#\n\n> 登录MySQL\n\n\n\n连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识\n\n> 查看MySQL Server服务版本信息\n\n * 登录前：\n   \n   c:\\> mysql -V或c:\\> mysql --version\n\n * 登录后\n   \n   mysql> select version();\n\n> 退出登录\n\nexit或quit","routePath":"/tang/mysql/04_MySQL的登录","lang":"","toc":[{"text":"4.1 服务的启动与停止","id":"41-服务的启动与停止","depth":2,"charIndex":3},{"text":"4.2 使用命令行登录MySQL","id":"42-使用命令行登录mysql","depth":2,"charIndex":130}],"domain":"","frontmatter":{},"version":""},{"id":150,"title":"5 MySQL一些常用命令","content":"#\n\n\n5.1 查看所有的数据库#\n\n\n\n * “information_schema”是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，\n   比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的 文件夹，等等\n * “performance_schema”是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。\n * “sys”数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据\n   库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。\n * “mysql”数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的 字符集、约束检查信息，等等\n\n\n5.2 查看库、表的创建信息#\n\n\n\n\n5.3 显示表结构#\n\ndescribe 表名或desc 表名\n\n\n\n\n5.4 分页#\n\nlimit\n\n * 语法： limit 位置偏移量, 行数，其中位置偏移量可省（省略时表示从0开始）\n * limit字句必须放在select语句的最后！\n * MySQL8.0新特性：limit 行数 offset 位置偏移量 和 limit 位置偏移量, 行数 效果一致\n * 使用limit的优点：\n   * 减少表的网格传输量，提升查询效率。\n   * 当知道返回结果只有1条时，就可以使用limit 1，这样不需扫描整张表，从而提升效率\n\n\n5.5 多表查询#\n\n\n\n * inner join ... on或join ... on：内连接。A inner join B ... on表示取A和B的交集\n\n * left outer join ... on或left join ... on：左外连接。A left join B ...\n   on表示取所有满足条件的A中元素\n\n * right outer join ... on或right join ... on：左外连接。A right join B ...\n   on表示取所有满足条件的B中元素\n\n * union或union all：合并查询结果。即将多条select的结果集组合成一个结果集。\n   \n   * union：返回两个查询结果集的并集，并去除重复记录。\n   \n   * union all：返回两个查询结果集的并集，不去重，效率高\n     \n     当明知道合并数据后的结果不存在重复数据，或者不需要去重的情况下，尽量使用union all。\n\n * natural join：自然连接。SQL99新特性。会自动查询两张表中所有同名的字段 ，并对它们进行等值连接\n   \n   在SQL92标准中：\n   \n   \n   \n   在 SQL99 中可以写成：\n   \n   \n\n * join ... using(字段名)：SQL99新特性。指定数据表里的同名字段进行**等值连接 **，只能配合join使用。\n   \n   在SQL92标准中：\n   \n   \n   \n   在 SQL99 中可以写成：\n   \n   \n\n> 注意\n\n要控制连接表的数量 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下 降得很严重，因此不要连接不必要的表。\n\n阿里巴巴《Java开发手册》中，超过三个表禁止 join。\n\n\n5.6 编码集设置#\n\n在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3，如果没有修改编码，会出现乱码问题。但是从MySQL 8.0\n开始，数据库的默认编码改为 utf8mb4，从而避免了乱码问题。因此，此处编码集设置是针对MySQL5.7版本。\n\n> 问题再现\n\n\n\n> 问题解决\n\n * 步骤1：查看编码命令\n   \n   \n\n * 步骤2：修改mysql的数据目录下的my.ini配置文件\n   \n   \n\n * 步骤3：重启服务\n\n * 步骤4：查看编码信息\n   \n   ","routePath":"/tang/mysql/05_MySQL一些常用命令","lang":"","toc":[{"text":"5.1 查看所有的数据库","id":"51-查看所有的数据库","depth":2,"charIndex":3},{"text":"5.2 查看库、表的创建信息","id":"52-查看库表的创建信息","depth":2,"charIndex":370},{"text":"5.3 显示表结构","id":"53-显示表结构","depth":2,"charIndex":390},{"text":"5.4 分页","id":"54-分页","depth":2,"charIndex":426},{"text":"5.5 多表查询","id":"55-多表查询","depth":2,"charIndex":661},{"text":"5.6 编码集设置","id":"56-编码集设置","depth":2,"charIndex":1455}],"domain":"","frontmatter":{},"version":""},{"id":151,"title":"6 MySQL图形化管理工具","content":"#\n\n\n6.1 工具分类#\n\n * MySQL Workbench：MySQL 官方提供的图形化管理工具\n   \n   下载地址：https://dev.mysql.com/downloads/workbench/\n\n * Navicat Preminum：\n   \n   下载地址：http://www.navicat.com/\n\n * SQLyog：\n   \n   下载地 址：http://www.webyog.com/\n\n\n6.2 常见问题#\n\n> Authentication plugin 'caching_sha2_password' cannot be loaded\n\n有些图形界面工具，特别是旧版本的图形界面工具，在连接MySQL8时出现“Authentication plugin\n'caching_sha2_password' cannot be loaded”错误。\n\n分析:\n\n出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则\n是caching_sha2_password。\n\n解决:\n\n * 方法1：升级图形界面工具版本\n\n * 方法2：把MySQL8 用户登录密码加密规则还原成mysql_native_password。\n   \n   \n\n> root用户密码忘记--重置用户密码\n\n * 通过任务管理器或者服务管理，关掉mysqld(服务进程)\n\n * 通过命令行+特殊参数开启mysqld mysqld --\n   defaults-file=\"D:\\ProgramFiles\\mysql\\MySQLServer5.7Data\\my.ini\"\n   --skip-grant-tables 。此时，mysqld服务进程已经打开。并且不需要权限检查\n\n * 另启动一 个客户端进行，通过mysql -uroot 无密码登陆服务器。\n\n * 修改密码\n   \n   \n\n * 重启mysql后，即可使用新密码登录root用户","routePath":"/tang/mysql/06_MySQL图形化管理工具","lang":"","toc":[{"text":"6.1 工具分类","id":"61-工具分类","depth":2,"charIndex":3},{"text":"6.2 常见问题","id":"62-常见问题","depth":2,"charIndex":215}],"domain":"","frontmatter":{},"version":""},{"id":152,"title":"7.4 位运算符","content":"7 运算符#\n\n\n7.1 算术运算符#\n\n> 加法与减法\n\n * 整型 +(-) 整型 = 整型\n * 整型 +(-) 浮点型 = 浮点型\n * +只表示数 值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）\n\n> 乘法与除法\n\n * 一个数 *(/) 整数1 = 原数\n * 一个数 *(/)浮点数1 = 浮点数，且数值与原数相等\n * 一个数 / 整数 = 浮点数\n * 一个数 / 另一个数 = 浮点数，且当除不尽时，保留到小数点后4位\n * 一个数 / 0 = null\n\n\n7.2 比较运算符#\n\n比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。\n\n * =：判断等号两边的值、字符串或表达式是否相等\n   \n   * 如果等号两遍都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。\n   * 如果等号两边都是整数，则MySQL会按照整数来比较两个值的大小。\n   * 如果等号两边一个是整数，一个是字符串，则MySQL会将字符串转化为数字进行比较。\n   * 如果等号两边有一个为NULL，则比较结果为NULL\n\n * <=>：安全等于运算符（<=>）与等于运算符（=）的作用是相似的，唯一的区别是<=>可\n   以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1；当一个操作数为NULL 时，其返回值为0。\n\n * <>或!=：不等于运算符。\n   \n   * 不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL， 或两边都为NULL，则结果为NULL\n\n * IS NULL或ISNULL(值)：判断一个值是否为null\n\n * IS NOT NULL：判断一个值是否不为null\n\n * LEAST(值1, 值2, ..., 值n)：返回最小值\n\n * GREATEST(值1, 值2, ..., 值n)：返回最大值\n\n * BETWEEN 值1 AND 值2：判断一个值是否在闭区间[值1, 值2]之间\n\n * IN(值1, 值2, ..., 值n)：判断一个值是否是（值1, 值2, ..., 值n）中的一个值\n\n * NOT IN(值1, 值2, ..., 值n)：判断一个值是否不是（值1, 值2, ..., 值n）中的任意一个值\n\n * LIKE：模糊匹配\n   \n   * 常和如下通配符配合使用：\n     * %：匹配0个或多个字符\n     * _：匹配单个字符\n\n * ESCAPE：指定一个字符去替代转义字符(\"\\\")\n   \n   在mysql中，如果表中某个字段存储了一些特殊符号（如%、_等），在使用LIKE进行模糊查询时，需要对特殊字符进行转义。\n   \n   对特殊字符的转义有两种方法：①使用转义字符\\ ②使用关键字ESCAPE。使用方法如下\n   \n   \n\n * REGEXP：使用正则表达式来匹配字符串，语法格式字符串 regexp 正则表达式\n   \n   常用通配符如下：\n   \n   通配符        说明                                                         例子        匹配值示例\n   ^          匹配以该字符后面的字符开头的字符串                                          ^b        big， banana\n   $          匹配以该字符前面的字符结尾的字符串                                          st$       test， persist\n   .          匹配任何一个单字符                                                  b.t       bit， bat\n   *          匹配零个或多个在它前面的字符。如果前面没有字符，表示匹配任何数量的任何字符串                     f*n       fn， fan，faan，fabcn\n   +          匹配1次或多次在它前面的字符                                             ba+       ba，bay，bare，battle\n   <字符串>      匹配包含指定字符串的文本                                                         fan， afa，aaafabbb\n   [字符串集合]    匹配字符串集合中任意一个字符。可以使用一 个-表明命名字符的范围：[a-z]匹配任何字母,[0-9]匹配任何数字   [xz]      dizzy，x-ray\n   [^字符串集合]   匹配不包含字符串集合中任意字符的文本                                         [^abc]    desk， k8s\n   字符串{n,}    匹配至少n次它前面的字符串                                              b{2}      bb，bbb，bbbb，bbbbbbb\n   字符串{n,m}   匹配**[n, m]次它前面的字符串**。如果n为0，n可省                             b{2, 4}   bb，bbb，bbbb\n\n\n7.3 逻辑运算符#\n\n * NOT或!：逻辑非\n   \n   * 当给定的值为0时返回1；\n   * 当给定的值为非0值时返回0；\n   * 当给定的值为NULL时，返回NULL\n\n * AND或&&：逻辑与。\n   \n   * 当给定的所有值均为非0值，并且都不为NULL时，返回 1；\n   * 当给定的一个值或者多个值为0时则返回0；\n   * 否则返回NULL\n\n * OR或||：逻辑或。\n   \n   * 当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；\n   * 当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；\n   * 当两个值都为 NULL时，返回NULL\n\n * XOR：逻辑异或。\n   \n   * 当给定的值中任意一个是null时，返回null\n   * 当两个非null的值都是0或者都不是0时，返回0\n   * 当一个值为0，另一个不为0时，返回1\n\n\n7.4 位运算符#\n\n * &：按位与。将给定值对应的二进制数进行逻辑与运算（逻辑与：两个二进制位都是1时返回1，其他返回0）。\n * |：按位或。将给定值对应的二进制数进行逻辑或运算（逻辑或：两个二进制位全为0时返回0，其他返回1）。\n * ^：按位异或。将给定值对应的二进制数进行逻辑异或运算（逻辑异或：两个二进制位数值相同时返回1，否则返回0）。\n * ~：按位取反。将给定值对应的二进制数进行取反操作（取反：0变1，1变0）。\n * >>：按位右移，语法数值 >> 位数。\n * <<：按位左移，语法数值 << 位数。","routePath":"/tang/mysql/07_运算符","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":153,"title":"8 MySQL函数","content":"#\n\n\n8.1 单行函数#\n\n\n8.1.1 数值函数#\n\n函数                    用法\nSIGN(X)               返回X的符号。正数返回1，负数返回-1，0返回0\nCEIL(x)，CEILING(x)    对x向上取整\nFLOOR(x)              对x向下取整\nLEAST(e1,e2,e3…)      返回列表中的最小值\nGREATEST(e1,e2,e3…)   返回列表中的最大值\nRAND()                返回0~1的随机数\nRAND(x)               返回0~1的随机数。x是种子，相同的x值会产生相同的随机数\nROUND(x)              对x四舍五入，得到一个整数\nROUND(x,y)            对x进行四舍五入，并保留y位小数\nTRUNCATE(x,y)         对x截断，保留y位小数\nSQRT(x)               返回x的平方根。当X的值为负数时，返回NULL\nPOW(x,y)，POWER(X,Y)   返回x的y次方\nEXP(X)                返回e的x次方\nCONV(x,f1,f2)         将x由f1进制数转为f2进制数。f1指明当前x是什么进制，f2指明想转成什么进制\n...                   ...\n\n\n8.1.2 字符串函数#\n\n函数                                                             用法\nCHAR_LENGTH(s) ,与CHARACTER_LENGTH(s)                           返回字符串s的字符数。\nLENGTH(s)                                                      返回字符串s的字节数，和字符集有关\nCONCAT(s1,s2,......,sn)                                        连接s1,s2,......,sn为一个字符串\nCONCAT_WS(x, s1,s2,......,sn)                                  同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x\nINSERT(str, idx, len, replacestr)                              将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr\nREPLACE(str, a, b)                                             用字符串b替换字符串str中所有出现的字符串a\nUPPER(s) ， UCASE(s)                                            将字符串s的所有字母转成大写字母\nLOWER(s) ，LCASE(s)                                             将字符串s的所有字母转成小写字母\nLEFT(str,n)或RIGHT(str,n)                                       返回字符串str最左边或最右边的n个字符\nLPAD(str, len, pad)或RPAD(str ,len, pad)                        用字符串pad对str最左边或最右边进行填充，直到str的长度为len个字符\nLTRIM(s)或RTRIM(s)                                              去掉字符串s左侧或右的空格\nTRIM(s)                                                        去掉字符串s开始与结尾的空格\nTRIM(s1 FROM s)                                                去掉字符串s开始与结尾的s1\nTRIM(LEADING s1 FROM s)                                        去掉字符串s开始处的s1\nTRIM(TRAILING s1 FROM s)                                       去掉字符串s结尾处的s1\nREPEAT(str, n)                                                 返回str重复n次的结果\nSPACE(n)                                                       返回n个空格\nSTRCMP(s1,s2)                                                  比较字符串s1,s2的ASCII码值的大小\nSUBSTR(s,index,len),SUBSTRING(s,n,len),MID(s,n,len)            返回从字符串s的index位置其len个字符\nLOCATE(substr,str),POSITION(substr IN str),INSTR(str,substr)   返回字符串substr在字符串str中首次出现的位置。未找到，返回0\nELT(m,s1,s2,…,sn)                                              返回指定位置的字符串。如 果m=n，则返回sn\nFIELD(s,s1,s2,…,sn)                                            返回字符串s在字符串列表中第一次出现的位置\nFIND_IN_SET(s1,s2)                                             返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分 隔的字符串。完全匹配不是模糊匹配\nREVERSE(s)                                                     反转s\nNULLIF(value1,value2)                                          比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1\n\n\n8.1.3 日期和时间#\n\n> 获取日期、时间\n\n函数                                                  用法\nCURDATE() ，CURRENT_DATE()                           返回当前日期，只包含年、 月、日\nCURTIME() ， CURRENT_TIME()                          返回当前时间，只包含时、 分、秒\nNOW(),SYSDATE(),CURRENT_TIMESTAMP(), LOCALTIME(),   返回当前系统日期和时间\nLOCALTIMESTAMP()\n\n> 日期与时间戳的转换\n\n函数                         用法\nUNIX_TIMESTAMP()           将当前时间以UNIX时间戳的形式返回\nUNIX_TIMESTAMP(date)       将时间date以UNIX时间戳的形式返回\nFROM_UNIXTIME(timestamp)   将UNIX时间戳转换为普通格式的时间\n\n> 日期的操作函数\n\n函数                        用法\nEXTRACT(type FROM date)   返回指定日期中特定的部分，type指定返回的值，其取值与含义见下图\n\n\n\n\n\n> 计算日期和时间的函数--第1组\n\n函数                                       用法\nDATE_ADD(datetime, INTERVAL expr type)   在当前日期或时间上增加expr对应的时间（时间格式由type指定）\nDATE_SUB(datetime,INTERVAL expr type)    在当前日期或时间上减去expr对应的时间（时间格式由type指定）\n\n\n\n\n\n> 计算日期和时间的函数--第2组\n\n函数                                          用法\nADDTIME(time1,time2)或SUBTIME(time1,time2)   返回time1加上或减掉time2后的时间。当time2为一个数字时，代表的是 秒 ，可以为负数\nDATEDIFF(date1,date2)                       返回date1 - date2的日期间隔天数\nTIMEDIFF(time1, time2)                      返回time1 - time2的时间间隔\nFROM_DAYS(N)                                返回从0000年1月1日起，N天以后的日期\nTO_DAYS(date)                               返回日期date距离0000年1月1日的天数\nLAST_DAY(date)                              返回date所在月份的最后一天的日期\nMAKEDATE(year,n)                            针对给定年份与所在年份中的天数返回一个日期\nMAKETIME(hour,minute,second)                将给定的小时、分钟和秒组合成时间并返回\nPERIOD_ADD(time,n)                          返回time加上n个月后的时间。其中time为YYMM或者YYYYMM\n\n\n\n\n\n\n\n> 日期的格式化与解析\n\n函数                                  用法\nDATE_FORMAT(date,fmt)               按照字符串fmt格式化日期date\nTIME_FORMAT(time,fmt)               按照字符串fmt格式化时间time\nGET_FORMAT(date_type,format_type)   返回日期字符串的显示格式\nSTR_TO_DATE(str, fmt)               按照字符串fmt对str进行解析，解析为一个日期\n\n\n\n\n8.1.4 流程控制函数#\n\n函数                                                             用法\nIF(value,value1,value2)                                        如果value的值为TRUE，返回value1， 否则返回value2\nIFNULL(value1, value2)                                         如果value1不为NULL，返回value1，否 则返回value2\nCASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn]   相当于Java的if...else if...else...\nEND\nCASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n]   相当于Java的switch...case...\nEND\n\n\n8.1.5 加密与解密函数#\n\n函数                            用法\nPASSWORD(str)                 用户密码加密。加密结果不可逆 ，常用于用户的密码加密 。MySQL8.0中已移除该方法\nMD5(str)                      MD5加密。若参数为 NULL，则会返回NULL\nSHA(str)                      SHA加密。当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。\nENCODE(value,password_seed)   返回使用password_seed作为加密密码加密value MySQL8.0中已移除该方法\nDECODE(value,password_seed)   返回使用password_seed作为加密密码解密valueMySQL8.0中已移除该方法\n\n\n8.1.6 MySQL信息函数#\n\n函数                                                    用法\nVERSION()                                             返回当前MySQL的版本号\nCONNECTION_ID()                                       返回当前MySQL服务器的连接数\nDATABASE()，SCHEMA()                                   返回MySQL命令行当前所在的数据库\nUSER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER()   返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名”\nCHARSET(value)                                        返回字符串value自变量的字符集\nCOLLATION(value)                                      返回字符串value的比较规则\n\n\n\n\n8.1.7 其他函数#\n\n函数                               用法\nFORMAT(value,n)                  返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留 到小数位数\nINET_ATON(ipvalue)               将以点分隔的IP地址转化为一个数字\nINET_NTOA(value)                 将数字形式的IP地址转化为以点分隔的IP地址\nBENCHMARK(n,expr)                将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间\nCONVERT(value USING char_code)   将value所使用的字符编码修改为char_code\n\n\n\n\n8.2 聚合函数#\n\n> 聚合函数类型\n\n * AVG()：AVG(column)求column列的平均值。只能对数值型数据使用\n\n * SUM()：SUM(column)求column列的和。只能对数值型数据使用\n\n * MAX()：MAX(column)求column列的最大值。可以对任意数据类型的数据使用\n\n * MIN()：MIN(column)求column列的最小值。可以对任意数据类型的数据使用\n\n * COUNT()：返回表中记录总数。可以对任意数据类型的数据使用\n   \n   * 用count(*)，count(1)，count(列名)谁好呢?\n     \n     答：对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb引擎的表用count(*),count(1)\n     直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。\n   \n   * 能不能使用count(列名)替换count(*)?\n     \n     答：不要使用 count(列名)来替代 count(*) 。**count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为\n     NULL 值的行 **。\n\n> 语法\n\n\n\n> 注意\n\n * 聚合函数不能嵌套使用\n * 不能在where语句中使用聚合函数\n\n\n8.3 GROUP BY#\n\n> 语法\n\n\n\n> 注意事项\n\n> GROUP BY中使用WITH ROLLUP\n\n * 使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录用来求全部数据的sum、avg、count等\n * 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥 的\n\n\n\n\n8.4 HAVING#\n\n> 作用\n\n过滤分组\n\n> 语法\n\n * 使用时，确保行已被分组\n * 使用了聚合函数\n * 和GROUP BY搭配使用，用在GROUP BY后order by前\n\n\n\n> 例子\n\n\n\n\n8.5 SELECT执行过程#\n\n> SELECT语句的结构\n\n\n\n> SELECT语句的执行顺序\n\nFROM （---> ON ---> JOIN ）---> WHERE ---> GROUP BY ---> HAVING ---> SELECT --->\nDISTINCT ---> ORDER BY ---> LIMIT\n\n> SELECT执行原理\n\n * 执行FROM子句，生成虚拟表vt1。如果是多表联查，还会经历如下几个步骤：\n   * 先求两个表的笛卡尔积，生成虚拟表vt1.1\n   * 执行ON语句，对表vt1的数据进行筛选，生成表vt1.2\n   * 如果是外连接（左连接/右连接/全连接），则对表vt1.2添加外部行，生成虚拟表vt1.3\n * 执行WHERE语句，对FROM语句中生成的虚拟表进行筛选，生成虚拟表vt2\n * 执行GROUP BY语句，对表vt2中的数据进行分组，生成虚拟表vt3\n * 执行HAVING语句，对表vt3中的数据再次进行筛选，生成虚拟表vt4。 HAVING语句中可以使用SELECT语句中的列以及列的别名\n * 执行SELECT语句，在表vt4中选取需要的列，生成虚拟表vt5。\n * 执行DISTINCT语句，对表vt5中的数据去重，生成虚拟表vt6。\n * 执行ORDER BY语句，对表vt6中的数据进行排序，生成虚拟表vt7。ORDER BY语句中可以使用SELECT语句中的列以及列的别名\n * 执行LIMIT语句，在表vt7中取出指定的行记录，生成虚拟表vt8。","routePath":"/tang/mysql/08_MySQL函数","lang":"","toc":[{"text":"8.1 单行函数","id":"81-单行函数","depth":2,"charIndex":3},{"text":"8.1.1 数值函数","id":"811-数值函数","depth":3,"charIndex":15},{"text":"8.1.2 字符串函数","id":"812-字符串函数","depth":3,"charIndex":612},{"text":"8.1.3 日期和时间","id":"813-日期和时间","depth":3,"charIndex":2839},{"text":"8.1.4 流程控制函数","id":"814-流程控制函数","depth":3,"charIndex":4624},{"text":"8.1.5 加密与解密函数","id":"815-加密与解密函数","depth":3,"charIndex":5095},{"text":"8.1.6 MySQL信息函数","id":"816-mysql信息函数","depth":3,"charIndex":5501},{"text":"8.1.7 其他函数","id":"817-其他函数","depth":3,"charIndex":6022},{"text":"8.2 聚合函数","id":"82-聚合函数","depth":2,"charIndex":6389},{"text":"8.3 GROUP BY","id":"83-group-by","depth":2,"charIndex":6995},{"text":"8.4 HAVING","id":"84-having","depth":2,"charIndex":7187},{"text":"8.5 SELECT执行过程","id":"85-select执行过程","depth":2,"charIndex":7294}],"domain":"","frontmatter":{},"version":""},{"id":154,"title":"9 子查询","content":"#\n\n\n9.1 概述#\n\n\n9.1.1 定义与语法#\n\n> 定义\n\n子查询是指一个查询语句嵌套在另外一个查询语句内部\n\n> 语法\n\n子查询可以在SELECT、WHERE、HAVING、CASE 语句中使用。基本语法如下\n\n\n\n * 子查询的结果被主查询使用\n\n * 子查询要包含在一对小括号内\n * 将子查询放在比较条件的右侧 ===> 美观\n * 单行操作符对应单行子查询，多行操作符对应多行子查询，此外，多行子查询中也可以单行操作符和多行操作符一起使用。\n\n\n9.1.2 子查询分类#\n\n> 分类方式1：按照子查询的返回结果是一条和多条记录分\n\n * 单行子查询：子查询的返回结果是一条记录\n * 多行子查询：子查询的返回结果是多条记录\n\n> 分类方式2：按照子查询的执行是否依赖主查询分\n\n * 相关子查询：子查询的执行依赖外部情况，通常是指子查询使用了外部的表，并进行了条件关联。每执行一次外部查询，子查询都要重新计算一次。\n * 不相关子查询\n\n\n9.2 单行子查询#\n\n\n9.2.1 单行比较操作符#\n\n操作符   含义\n=     等于\n>     大于\n>=    大于等于\n<     小于\n<=    小于等于\n<>    不等于\n\n\n9.2.2 示例#\n\n\n\n\n9.2.3 其他说明#\n\n * 如果子查询的结果为空，主查询也不会报错\n * 当子查询返回多行记录时，如果只使用单行比较操作符，会报错\n\n\n9.2 多行子查询#\n\n\n9.2.1 多行比较操作符#\n\n操作符    含义\nIN     等于列表中的任意一个\nANY    需要和单行比较操作符一起使用，和子查询返回的某一个值比较\nALL    需要和单行比较操作符一起使用，和子查询返回的所有值比较\nSOME   实际上是ANY的别名，作用相同，一般常使用ANY\n\n\n9.2.2 示例#\n\n\n\n\n9.2.3 其他说明#\n\n无\n\n\n9.3 相关子查询#\n\n\n9.3.1 概述#\n\n> 相关子查询与不相关子查询\n\n相关子查询和不相关子查询的区别是，相关子查询中的子查询使用了外部的表，并进行了条件关联。\n\n比如：查询员工工资高于部门平均工资的员工信息，是相关子查询；查询员工工资高于公司平均工资的员工信息，是不相关查询。\n\n\n9.3.2 示例#\n\n\n\n\n9.3.3 EXISTS 与 NOT EXISTS关键字#\n\n> 概述\n\n相关子查询通常会和EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行：\n\n * 如果当前查询不满足条件，此时返回false，并继续在子查询中查找；\n * 如果找到了满足条件的行，此时返回true，结束查找\n\n> 示例\n\n\n\n如上子查询的 SELECT e.department_id ，也可以写成 SELECT * 、 SELECT 'x'\n等。只要满足子查询条件就会返回true，不会返回SELECT中的列。\n\n\n9.4 相关更新#\n\n\n9.4.1 基本语法#\n\n\n\n\n9.4.2 示例#\n\n\n\n\n9.5 相关删除#\n\n\n9.5.1 基本语法#\n\n\n\n\n9.5.2 示例#\n\n","routePath":"/tang/mysql/09_子查询","lang":"","toc":[{"text":"9.1 概述","id":"91-概述","depth":2,"charIndex":3},{"text":"9.1.1 定义与语法","id":"911-定义与语法","depth":3,"charIndex":13},{"text":"9.1.2 子查询分类","id":"912-子查询分类","depth":3,"charIndex":231},{"text":"9.2 单行子查询","id":"92-单行子查询","depth":2,"charIndex":428},{"text":"9.2.1 单行比较操作符","id":"921-单行比较操作符","depth":3,"charIndex":441},{"text":"9.2.2 示例","id":"922-示例","depth":3,"charIndex":527},{"text":"9.2.3 其他说明","id":"923-其他说明","depth":3,"charIndex":541},{"text":"9.2 多行子查询","id":"92-多行子查询","depth":2,"charIndex":611},{"text":"9.2.1 多行比较操作符","id":"921-多行比较操作符","depth":3,"charIndex":624},{"text":"9.2.2 示例","id":"922-示例-1","depth":3,"charIndex":773},{"text":"9.2.3 其他说明","id":"923-其他说明-1","depth":3,"charIndex":787},{"text":"9.3 相关子查询","id":"93-相关子查询","depth":2,"charIndex":804},{"text":"9.3.1 概述","id":"931-概述","depth":3,"charIndex":817},{"text":"9.3.2 示例","id":"932-示例","depth":3,"charIndex":950},{"text":"9.3.3 EXISTS 与 NOT EXISTS关键字","id":"933-exists-与-not-exists关键字","depth":3,"charIndex":964},{"text":"9.4 相关更新","id":"94-相关更新","depth":2,"charIndex":1218},{"text":"9.4.1 基本语法","id":"941-基本语法","depth":3,"charIndex":1230},{"text":"9.4.2 示例","id":"942-示例","depth":3,"charIndex":1246},{"text":"9.5 相关删除","id":"95-相关删除","depth":2,"charIndex":1260},{"text":"9.5.1 基本语法","id":"951-基本语法","depth":3,"charIndex":1272},{"text":"9.5.2 示例","id":"952-示例","depth":3,"charIndex":1288}],"domain":"","frontmatter":{},"version":""},{"id":155,"title":"10 数据库和数据库表的管理","content":"#\n\n\n10.1 创建和管理数据库#\n\n\n10.1.1 创建数据库#\n\n\n\n * IF NOT EXISTS，表示如果要创建的数据库不存在，才会创建成功。如果存在，不会创建，也不会报错。\n * 如果不指明字符编码集CHARACTER，会使用数据库管理系统默认字符编码集\n\n\n10.1.2 修改数据库#\n\n企业开发中一般不会修改。改的话，也是只能改字符集，数据库名无法修改。\n\n\n\n\n10.1.3 删除数据库#\n\n\n\n\n10.1.4 数据库其他操作#\n\n\n\n\n10.2 创建和管理数据库表#\n\n\n10.2.1 创建表#\n\n * 方式1：“白手起家”式\n   \n   \n   \n   * IF NOT EXISTS，表示如果要创建的表不存在，才会创建成功。如果存在，不会创建，也不会报错。\n   * 如果不指明字符编码集CHARACTER，会使用当前数据库默认的字符编码集\n\n * 方式2：基于已有的表创建\n   \n   \n   \n   * 这种方式是基于已有的表创建，或者是基于已有的表经过一系列的查询出来的数据来创建。AS后边加上一个SELECT查询语句即可。查询语句中的列名或者列的别名\n     就作为新表的列名。\n   * 这种方式在创建表时，还会在新表中导入符合条件的数据。\n   * 除了非空约束，其他约束不能被赋值过来\n\n\n10.2.2 修改表#\n\n修改表指的是修改数据库中已经存在的数据表的结构，分为如下4中情况：\n\n * 添加新的列\n * 修改已有的列\n * 删除已有的列\n * 重命名已有的列\n\n实现以上功能的关键字，ALTER TABLE。\n\n> 添加新的列\n\n\n\n * 关键字：ALTER TABLE 和 ADD\n * 约束条件是可选的，用来对添加的字段进行约束。\n * 字段位置，也是可选的。不同的值代表的意义如下：\n   * 不写：表示在表的末尾追加新的列\n   * FIRST：在表的开头添加新的列\n   * AFTER 字段名：在“字段名”之后插入新的列\n\n> 修改已有的列\n\n修改列指的是修改列的字段类型、默认值、在表中的位置。\n\n\n\n * 关键字：ALTER TABLE 和 MODIFY\n * 默认值是可选的。\n * 字段位置，也是可选的。不同的值代表的意义如下：\n   * 不写：表示还在原来位置不变\n   * FIRST：表示将该列移到表的开头\n   * AFTER 字段名：表示将该列移动到“字段名2”之后\n\n> 重命名已有的列\n\n\n\n * 关键字：ALTER TABLE 和 CHANGE\n\n> 删除已有的列\n\n\n\n * 关键字：ALTER TABLE 和 DROP\n\n\n10.2.3 重命名表#\n\n * 方式1：RENAME\n   \n   \n\n * 方式2：ALTER\n   \n   \n\n\n10.2.4 删除表#\n\n> 说明\n\n * 当一张表没有与其他任何数据表形成关联关系时，才可删除\n * 删除表时，所有正在运行的相关事务被提交\n * 删除表时，所有相关索引被删除\n\n> 语法\n\n\n\n * DROP TABLE 语句不能回滚！！！ 删表前，做好备份工作。\n * DROP之后，删除表数据、表结构，释放表空间\n\n\n10.2.5 清空表#\n\n> 语法\n\n * 方式1：使用TRUNCATE\n   \n   \n\n * 方式2：使用不带WHERE的DELETE\n   \n   \n\n> DROP、DELETE和TRUNCATE的区别\n\n * DROP会删掉表结构，DELETE和TRUNCATE是删除表数据，保留表结构\n * DELETE是DML（数据库操作语言），TRUNCATE是DDL（数据库定义语言）。因此DELETE可以回滚，TRUNCATE不可以回滚\n * 使用DELETE，删除数据后表空间还在（在系统重启前，还可以恢复），TRUNCATE是将数据和表空间都删除了\n * DELETE可以操作table、view，TRUNCATE只能操作table\n * 如果表中id是自增型且步长为1，使用delete后，新插入的数据的id会原数数据的id上继续累加。使用TRUNCATE后，新插入的数据的id会从1开始\n\n\n10.2.7 DCL中的COMMIT和ROLLBACK#\n\n * COMMIT：提交数据。一旦执行COMMIT，则数据就被永久的保存在了数据库中，意为着数据不可以回滚\n * ROLLBACK：回滚数据。一旦ROLLBACK，则可以实现数据的回滚。回滚到最近的一次COMMIT之后。\n\n\n10.2.8 DDL和DML的说明#\n\n * ① DDL的操作一旦执行，就不可以回滚。DDL操作执行完成后，会自动执行COMMIT操作，因此指令SET autocommit= FALSE对DML无效。\n * ② DML的操作默认情况下，一旦执行，也是不可回滚。但是如果在执行DML之前，执行了SET autocommit=\n   FALSE，则执行的DML操作就可以实现回滚\n\n\n10.2.9 表的其他操作#\n\n\n\n\n10.2.10 MySQL8.0新特性：DDL的原子化#\n\n> 概述\n\n * 在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即 DDL操作要么成功要么回滚 。\n * DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show\n   tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。\n * 原子DDL操作这一特性，支持表相关操作，也支持非表相关操作。\n   * 表相关操作： drop、create、alter(操作对象是databases, tablespaces, tables, and\n     indexes)语法、truncate语法\n   * 非表相关操作： create、drop、alter(操作对象是trigger、event、views)\n\n> 例子1：DROP表\n\n在数据库中创建表book1，同时保证当前数据库中没有book2表。执行DROP TABLE book1,\nbook2;，观察在MySQL5.7和MySQL8.0中的结果。\n\n结果：MySQL5.7中book1被删除，MySQL8.0中book1仍然存在。\n\n\n\n> 例子2：使用子查询创建表CREATE TABLE ... SELECT ...\n\n从MySQL8.0.21开始，在支持原子DDL的存储引擎上，当使用基于row的复制模式时，CREATE\nTABLE...SELECT...，该语句作为一个事务记录在二进制日志中。之前的版本中，它被记录为两个事务，一个用于create表，另一个用于insert数据。\n两个事务之间或插入数据时发生服务器故障可能导致复制了一张空表。通过引入原子DDL支持，CREATE TABLE\n...SELECT语句现在对于基于行的复制是安全的，并且允许与基于GTID的复制一起使用。","routePath":"/tang/mysql/10_管理数据库和数据库表","lang":"","toc":[{"text":"10.1 创建和管理数据库","id":"101-创建和管理数据库","depth":2,"charIndex":3},{"text":"10.1.1 创建数据库","id":"1011-创建数据库","depth":3,"charIndex":20},{"text":"10.1.2 修改数据库","id":"1012-修改数据库","depth":3,"charIndex":136},{"text":"10.1.3 删除数据库","id":"1013-删除数据库","depth":3,"charIndex":190},{"text":"10.1.4 数据库其他操作","id":"1014-数据库其他操作","depth":3,"charIndex":208},{"text":"10.2 创建和管理数据库表","id":"102-创建和管理数据库表","depth":2,"charIndex":228},{"text":"10.2.1 创建表","id":"1021-创建表","depth":3,"charIndex":246},{"text":"10.2.2 修改表","id":"1022-修改表","depth":3,"charIndex":567},{"text":"10.2.3 重命名表","id":"1023-重命名表","depth":3,"charIndex":1107},{"text":"10.2.4 删除表","id":"1024-删除表","depth":3,"charIndex":1167},{"text":"10.2.5 清空表","id":"1025-清空表","depth":3,"charIndex":1330},{"text":"10.2.7 DCL中的COMMIT和ROLLBACK","id":"1027-dcl中的commit和rollback","depth":3,"charIndex":1731},{"text":"10.2.8 DDL和DML的说明","id":"1028-ddl和dml的说明","depth":3,"charIndex":1874},{"text":"10.2.9 表的其他操作","id":"1029-表的其他操作","depth":3,"charIndex":2064},{"text":"10.2.10 MySQL8.0新特性：DDL的原子化","id":"10210-mysql80新特性ddl的原子化","depth":3,"charIndex":2083}],"domain":"","frontmatter":{},"version":""},{"id":156,"title":"11 数据处理之增删改","content":"#\n\n\n11.1 插入数据#\n\n> 为表的所有字段插入数据\n\n\n\n值列表中值的顺序必须和表中字段定义的顺序保持一致\n\n> 为表中指定的字段插入数据\n\n\n\nINSERT字句中的列名顺序可以随意，但值列表中值的顺序必须和其保持一致\n\n> 同时插入多条数据\n\n\n\n或\n\n\n\n> 将查询结果插入到表中\n\n不必写VALUES字句\n\n\n\n说明：表1中要添加数据的字段的长度不能低于表2中查询的字段的长度。否则，就有添加不成功的风险。\n\n> 小结：插入多条数据 VS 多个单行插入\n\n同时插入多条数据比多个单行插入效率更高。因为MySQL在执行单条插入语句时比使用多条插入语句快，所以在插入多条记录时，最好选择使用一个INSERT语句同时插入多\n条数据。\n\n\n11.2 更新数据#\n\n如果需要回滚数据，需要保证在DML之前，进行设置：SET AUTOCOMMIT = FALSE;\n\n\n\n修改数据时，是可能存在不成功的情况的。（可能是由于约束的影响造成的）\n\n\n11.3 删除数据#\n\n如果需要回滚数据，需要保证在DML之前，进行设置：SET AUTOCOMMIT = FALSE;\n\n\n\n如果省略查询条件，表示将表中的数据全部删除。\n\n在删除数据时，也有可能因为约束的影响，导致删除失败。\n\n\n11.4 MySQL8新特性：计算列#\n\n> 定义\n\n计算列，就是指某一列的值是通过别的列计算得来的。是在创建表的时候来定义计算列\n\n> 举例\n\n","routePath":"/tang/mysql/11_数据的增删改","lang":"","toc":[{"text":"11.1 插入数据","id":"111-插入数据","depth":2,"charIndex":3},{"text":"11.2 更新数据","id":"112-更新数据","depth":2,"charIndex":322},{"text":"11.3 删除数据","id":"113-删除数据","depth":2,"charIndex":423},{"text":"11.4 MySQL8新特性：计算列","id":"114-mysql8新特性计算列","depth":2,"charIndex":540}],"domain":"","frontmatter":{},"version":""},{"id":157,"title":"12.6 日期与时间","content":"12 MySQL中的数据类型#\n\n\n12.1 概述#\n\n> MySQL中的数据类型分类\n\n类型         类型举例\n整数类型       TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT\n浮点类型       FLOAT、DOUBLE\n定点类型       DECIMAL\n位类型        BIT\n日期时间类型     YEAR、TIME、DATE、DATETIME、TIMESTAMP\n文本字符串类型    CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT\n枚举类型       ENUM\n集合类型       SET\n二进制字符串类型   BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB\nJSON类型     JSON对象、JSON数组\n空间数据类型     单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；\n           集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、\n           GEOMETRYCOLLECTION\n\n> 常见数据类型的属性\n\nMYSQL关键字              含义\nNULL                  数据列可以包含NULL值\nNOT NULL              数据列不允许有NULL值\nDEFAULT               默认值\nPRIMARY KEY           主键\nAUTO_INCREMENT        自动递增，适用于整数类型\nUNSIGNED              无符号\nCHARACTER SET '字符集'   指定一个字符集\n\n\n12.2 整型#\n\n\n12.2.1 类型介绍#\n\n类型            字节   有符号数取值范围                                   无符号数取值范围\nTINYINT       1    -128~127                                   0~255\nSMALLINT      2    -32768~32767                               0~65535\nMEDIUMINT     3    -8388608~8388607                           0~16777215\nINT、INTEGER   4    -2147483648~2147483647                     0~4294967295\nBIGINT        8    -9223372036854775808~9223372036854775807   0~18446744073709551615\n\n\n12.2.2 可选属性#\n\n * M：表示显示宽度，需要配合ZEROFILL使用，表示当存储的数值不足M位时，用0进行填充\n   \n   * 如果设置了显示宽度，插入的数据超过了宽度范围，但是仍在当前类型的取值范围内，该数值不会被截断或插入失败，而是能够正常插入。如：\n     \n     \n   \n   * 从MySQL8.0.17开始，整数数据类型不推荐使用显示宽度属性。\n\n * UNSIGNED：无符号类型（表示非负数）。\n   \n   使用举例\n   \n   \n\n * ZEROFILL：0填充，需要配合M属性使用，表示当不够M位时，用0在左侧填充。\n   \n   如果指定了某列是ZEROFILL，MySQL会自动为当前列添加UNSIGNED属性\n   \n   \n\n\n12.2.3 使用场景#\n\n * TINYINT：一般用于枚举数据，比如系统设定取值范围很小且固定的场景\n * SMALLINT：可以用于较小范围的统计数据\n * MEDIUMINT：用于较大整数的计算\n * INT、INTEGER：取值范围足够大，一般情况下不用考虑朝鲜问题，用的最多。比如商品的编号\n * BIGINT：处理特别巨大的整数时用到。如双十一的交易量，大型门户网站的点击量，证券公司衍生产品持仓等\n\n小结：在评估使用哪种整数类型的时候，需要考虑存储空间和可靠性的平衡问题。首先在确保数据不会超过取值范围的前提下，再去考虑如何节省内存空间。\n\n\n12.3 浮点型#\n\n\n12.3.1 类型介绍#\n\n类型       字节数   有符号取值范围                                                        无符号取值范围\nFLOAT    4     -3.402823466E+38～-1.175494351E-38，0，1.175494351E-38～3.402823   0，1.175494351E-38～3.402823466E+38\n               466E+38\nDOUBLE   8     -1.7976931348623157E+308～-2.2250738585072014E-308，0，2.225073   0，2.2250738585072014E-308~1.7976931348623157E+308\n               8585072014E-308~1.7976931348623157E+308\n\n * 除了FLOAT和DOUBLE之外，还有一种浮点类型--REAL。REAL默认为DOUBLE。如果把SQL模式设定位启用REAL_AS_FLOAT模式，RE\n   AL的默认值就变成了FLOAT。\n   \n   \n\n * 浮点数无符号数取值范围相当于有符号数取值范围的一半，即相当于有符号数取值范围中大于等于0的部分。这是因为在MySQL中存储浮点数的格式为：符号（S）、尾数\n   （M）、阶码（E），无论有没有符号，MySQL的浮点数在存储时都会保留出符号位。\n\n * FLOAT和DOUBLE不用特意的声明为UNSIGNED，因为浮点数无符号数取值范围相当于有符号数取值范围的一半。\n\n\n12.3.2 数据精度说明#\n\n * MySQL允许使用非标准语法（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）： FLOAT(M,D) 或 DOUBLE(M,D)\n   。这里，M称为精度 ，D称为标度 。(M,D)中 M=整数位+小数位，D=小数位。 D<=M<=255，0<=D<=30。\n\n * FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示\n\n * 不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：\n   \n   * 如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值\n   \n   * 如果存储时，小数点部分若超出范围，就分以下情况：\n     \n     * 若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。\n       \n       例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。\n     \n     * 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。\n       \n       如FLOAT(5,2)列内插入 999.995和-999.995都会报错。\n\n * 从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可能被移除。\n\n * 从MySQL 8.0.17开始，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。\n\n\n12.3.3 精度误差说明#\n\n浮点数类型有个缺陷，就是不精准，详情见如下例子：\n\n\n\n例子中，对0.47、 0.44、 0.19三个数进行SUM()操作，结果返回1.0999999999999999，但是实际0.47 + 0.44 + 0.19\n= 1.1，此时就产生了误差。\n\n**为什么会存在这样的误差呢？**问题还是出在 MySQL 对浮点类型数据的存储方式上。 MySQL 用 4 个字节存储 FLOAT 类型数据，用 8\n个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625，用二进制来表达，就是\n1001.101，或者表达成1.001101×2^3。如 果尾数不是 0 或 5（比如\n9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。\n\n因此，在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来\n判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL\n有没有精准的数据类型呢？当然有，这就是定点数 类型： DECIMAL 。\n\n\n12.4 定点数#\n\n\n12.4.1 类型介绍#\n\n类型             字节数     说明\nDECIMAL(M,D)   M+2字节   有效范围由M和D决定。未指定M和D时，默认M=10，D=0\n\n * DECIMAL(M,D)，M=整数位数+小数位数，D=小数位数。M取值范围是[0,65]，D取值范围是[0,30]，且D DECIMAL\n   的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。 定点数在MySQL内部是以字符串的形式进行存储，这就决定了它一定是精准的。\n   存储数值时：\n   * 小数位不足会自动补0\n   * 首位数字为0自动忽略\n   * 整数超出存储范围会报错\n   * 小数超出会截断，发出警告，并按四舍五入处理\n\n\n12.4.2 使用场景#\n\n在涉及对小数求和，特别是涉及到金额的时候，推荐使用DECIMAL。\n\n\n12.5 位类型#\n\n\n12.5.1 类型介绍#\n\n类型       字节数           说明\nBIT(M)   约(M+7)/8个字节   M表示二进制的位数，取值范围是[1,64]。未指定M时，默认M=1\n\n * BIT类型中存储的是二进制值\n\n\n12.5.2 使用#\n\n\n\n\n12.6 日期与时间#\n\n\n12.6.1 类型介绍#\n\n类型          字节   描述           格式                    最小值                       最大值\nYEAR        1    年            YYYY或YY               1901                      2155\nTIME        3    时分秒          HH:MM:SS              -838:59:59                838:59:59\nDATE        3    年月日          YYYY-MM-DD            1000-01-01                9999-12-03\nDATETIME    8    年月日时分秒       YYYY-MM-DD HH:MM:SS   1000-01-01 00:00:00       9999-12-31 23:59:59\nTIMESTAMP   4    带时区的年月日时分秒   YYYY-MM-DD HH:MM:SS   1970-01-01 00:00:00 UTC   2038-01-19 03:14:07UTC\n\n\n12.6.2 YEAR#\n\n * 以4位字符串或数字格式表示，格式为YYYY，最小值为1901，最大值为2155\n * 以2位字符串或数字格式表示，最小值为00，最大值为99\n   * 当取值为01~69，表示2001~2069\n   * 当取值为70~99，表示1970~1999\n   * 当取值为整数的0或者00，表示是0000\n   * 当取值是字符串0或者00，表示是2000\n\n\n12.6.3 TIME#\n\n * 使用带有冒号的字符串，如D HH:MM:SS、HH:MM:SS、HH:MM、D HH:MM、D\n   HH、SS格式。其中D表示天，取值范围是[0,34]，插入时，D会被转化为小时\n * 使用不带冒号的字符串或者数字，如HHMMSS。\n   * 如果插入的字符串或者数字不合法，会将其转化为00:00:00存储\n   * 假如插入的是1210，存储后的时间是00:12:10，而不是12:10:00\n * 使用CURRENT_TIME() 、CURTIME()或者 NOW()等，可以插入当前系统时间\n\n\n12.6.4 DATE#\n\n * YYYY-MM-DD或YYYYMMDD格式。最小取值1000-01-01，最大取值9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD\n * YY-MM-DD或YYMMDD格式。\n   * 当年份(YY)取值为[00,69]，会被转化为[2000,2069]\n   * 当年份(YY)取值为[70,99]，会被转化为[1970,1999]\n * 使用CURRENT_DATE() 、CURDATE()或者 NOW()等，可以插入当前系统日期\n\n\n12.6.5 DATETIME#\n\n * YYYY-MM-DD HH:MM:SS或YYYYMMDDHHMMSS格式。最小取值1000-01-01 00:00:00，最大取值9999-12-03\n   23:59:59\n * 使用函数CURRENT_TIMESTAMP()和NOW()等，可以插入系统的当前日期和 时间。\n\n\n12.6.6 TIMESTAMP#\n\n> TIMESTAMP VS DATETIME\n\n * TIMESTAMP只需要4个字节，存储的时间范围比DATETIME小很多。只能存储 “1970-01-01 00:00:01\n   UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫 作世界标准时间。\n * 底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。\n * 两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。\n * **使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。**而DATETIME不同时区显示的是同一时间。\n\n\n12.7 文本字符串类型#\n\n\n12.7.1 类型介绍#\n\n类型           长度范围              长度单位   占用的存储空间\nCHAR(M)      [0, 255]          字符     M个字符\nVARCHAR(M)   [0, 65535]        字节     MySQL4.0之前，M的单位是字节；MySQL5.0之后，M的单位是字符。最大的字符数需要通过编码来算，按照不超过行6\n                                      5535个字节\nTINYTEXT     [0, 255]          字节     L+2个字节，最多能存255/3=85个UTF8编码的字符\nTEXT         [0, 65535]        字节     L+2个字节，最多能存65535/3个UTF8编码的字符\nMEDIUMTEXT   [0, 16777215]     字节     L+3个字节，最多能存16777215/3个UTF8编码的字符\nLONGTEXT     [0, 4294967295]   字节     L+4个字节，最多能存4294967295/3个UTF8编码的字符\n\n\n12.7.2 CHAR与VARCHAR#\n\nCHAR和VARCHAR类型都可以存储比较短的字符串。\n\n> CHAR类型\n\n * CHAR(M)是固定长度，一般需要先指定字符串的长度。如果不指定，默认长度是1个字符\n * 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在右侧填充空格已达到指定的长度。\n * 当检索时，CHAR类型的字段会去除尾部的空格。\n * 定义CHAR类型的字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字符数。\n\n> VARCHAR类型\n\n * VARCHAR(M) 定义时，必须指定长度M，否则报错。\n\n * MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节）\n   ；MySQL5.0版本以上，varchar(20)：指的是20字符。\n\n * 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。\n\n * VARCHAR类型的字段所占用的存储空间为字符串实际长度加1或2个字节。\n\n * VARCHAR最大存储长度的计算理论：\n   \n   虽然VARCHAR类型最大长度是65535个字节，但是真实存储的时候，并不能存这么多数据。VARCHAR的真实存储长度，需要按照如下规则计算：\n   \n   * ①一行记录的最大字节数不得超过65535字节；\n   \n   * ②VARCHAR本身需要1到2个字节来存储数据长度（如果列声明的长度超过255，则使用2个字节来存储长度，否则1个）；\n   \n   * ③VARCHAR字段允许为空时，NULL值标识需要1个字节。\n\n * VARCHAR最大存储长度的计算例子：\n   \n   以MySQL8.0为例，以下表都使用 utf8mb4 编码，一个字符最大能占用 4 个字节。\n   \n   * 例子1：CREATE TABLE t1 (name varchar(M) NULL) CHARSET=utf8mb4;，其中M最大是多少？\n     \n     M = (行最大字节数 - 数据的长度 - NULL标识) / utf8mb4 编码最大字节数\n     \n     = (65535 - 2 - 1) / 4 = 16383\n     \n     **结论：**M最大为16383\n   \n   * 例子2：CREATE TABLE t2 (name varchar(M) NOT NULL) CHARSET=utf8mb4;，其中M最大是多少？\n     \n     M = (行最大字节数 - 数据的长度) / utf8mb4 编码最大字节数\n     \n     = (65535 - 2) / 4 = 16383.25\n     \n     对16383.25向下取整，得M=16383\n     \n     **结论：**M最大为16383\n   \n   * 例子3：CREATE TABLE t3 (name varchar(M) NULL, age int)\n     CHARSET=utf8mb4;，其中M最大是多少？\n     \n     M = (行最大字节数 - 数据的长度 - NULL标识 - int字段所占字节) / utf8mb4 编码最大字节数\n     \n     = (65535 - 2 - 1 - 4) / 4 = 16382\n     \n     **结论：**M最大为16382\n\n> CHAR 和 VARCHAR 的对比（MySQL5.0以上）\n\n       CHAR(M)           VARCHAR(M)\n最大长度   M最大是255个字符        M最大值需要按照一定规则计算（见上）\n是否定长   定长，不足的部分尾部用空格补齐   不定长，保留实际字符\n空间使用   可能浪费              更加节省\n查找效率   高                 低\n尾部空格   插入时会被忽略           可以正常插入\n\n> CHAR 和 VARCHAR 的适用场景：\n\n * 存储很短的信息，建议使用char。如门牌号\n   \n   假如使用varchar，还需要使用1个字节存储信息长度，得不偿失\n\n * 存储固定长度的信息，建议使用char。如uuid\n\n * 存储需要频繁改变的信息，建议使用char。\n   \n   varchar每次存储都需要额外的计算长度等信息，如果频繁改变，需要很多的精力用于计算\n\n * 考虑具体存储引擎中的情况：\n   \n   * MyISAM：最好使用char。这样使得整个表静态化，从而使数据检索更快，用空间换时间\n   * MEMORY：无论使用char和varchar，底层都是作为char类型处理的\n   * InnoDB：建议使用varchar。InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列，所有数据行都是用指向数据列值的头指针，而且主\n     要影响性能的因素是数据行使用的存储总量。由于char平均占用的空间多于varchar，所以处理简短并且固定长度的使用char，其他考虑varchar。\n     这样节省空间，对磁盘I/O和数据存储总量比较好\n\n> 附：字符、字节、位之间的关系\n\n * **位：**数据存储的最小单位。每个二进制数字0或者1就是1个位；\n\n * **字节：**8个位构成一个字节；\n   \n   即：1 byte (字节)= 8 bit(位)；\n   \n   1 KB = 1024 B(字节)；\n   \n   1 MB = 1024 KB; (2^10 B) 1 GB = 1024 MB; (2^20 B) 1 TB = 1024 GB; (2^30 B)\n\n * 字符：\n   \n   * a、A、中、+、*、の......均表示1个字符\n   * 一般 utf-8 编码下，一个汉字字符占用 3 个 字节；数字属于汉字，和汉字占用一样字节\n   * 一般 utf8mb4 ** 编码下，一个汉字字符**占用 4 个 字节\n   * 一般 gbk 编码下，一个汉字字符占用 2 个 字节\n\n\n12.7.3 TEXT类型#\n\n * TEXT类型分为4种，分别为TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT\n * 在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。与VARCHAR类型相同\n * 由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键\n * 开发中的经验：\n   * TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替\n   * TEXT类型不用加默认值，加了也没用\n   * text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用 一个表\n\n\n12.8 ENUM类型#\n\n\n12.8.1 类型介绍#\n\n类型     长度   长度范围          占用的存储空间\nENUM   L    1<=L<=65535   1或2个字节\n\n * ENUM类型的取值范围需要在定义字段时进行指定。\n * 设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。\n * 当ENUM类型包含1～255个成员时，需要1个字节的存储空间\n * 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。\n * ENUM类型的成员个数的上限为65535个。\n\n\n12.8.2 使用#\n\n\n\n\n12.9 SET类型#\n\n\n12.9.1 类型介绍#\n\n当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：\n\n成员个数范围（L表示实际成员个数）   占用的存储空间\n1 <= L <= 8         1个字节\n9 <= L <= 16        2个字节\n17 <= L <= 24       3个字节\n25 <= L <= 32       4个字节\n33 <= L <= 64       8个字节\n\n * SET表示一个字符串对象，可以包含0个或多个成员，成员上线为64\n * SET存储多个成员时，成员之间用英文逗号隔开\n * SET类型在存储数据时成员个数越多，其占用的存储空间越大。\n\n\n12.9.2 使用#\n\n\n\n\n12.10 二进制字符串类型#\n\n\n12.10.1 类型介绍#\n\n * MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数 据。\n * MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。\n\n\n12.10.2 BINARY与VARBINARY#\n\n> 类型介绍\n\n类型             特点     值的长度                 占用空间\nBINARY(M)      固定长度   M （0 <= M <= 255）    M个字节\nVARBINARY(M)   可变长度   M（0 <= M <= 65535）   M+1个字节\n\n * BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串\n * BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数。如果未 指定(M)，表示只能存储 1个字节\n * BINARY(M)如果字段值不足(M)个字 节，将在右边填充'\\0'以补齐指定长度\n * VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长\n   度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数\n * VARBINARY类型必须指定(M)\n\n> 使用\n\n\n\n\n12.10.3 BLOB#\n\n> 类型介绍\n\n类型           长度范围                           占用空间\nTINYBLOB     0 <= L <= 255                  L + 1 个字节\nBLOB         0 <= L <= 65535（相当于64KB）       L + 2 个字节\nMEDIUMBLOB   0 <= L <= 16777215 （相当于16MB）   L + 3 个字节\nLONGBLOB     0 <= L <= 4294967295（相当于4GB）   L + 4个字节\n\n * BLOB是一个二进制大对象 ，可以容纳可变数量的数据。\n * BLOB类型可以存储一个二进制的大对象，比如图片 、音频和视频等\n * 但是实际工作中，图片等一般都保存在服务器的磁盘上，数据库存储的是图片等的访问路径\n\n> 使用\n\n\n\n> TEXT和BLOB的使用注意事项\n\n在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。\n\n * ①\n   在执行了大量的删除或更新操作的时候，删除text和blob类型的值会在数据表中留下很大的\"空洞\"，以后填入这些\"空洞\"的记录可能长度不同。为了提高性能，建\n   议定期使用OPTIMIZE TABLE功能对这类表进行碎片整理 。\n * ② 尽量避免检索大型的BLOB或TEXT值。如果需要对大文本字段进行模糊查询，MySQL 提供了前缀索引 。\n * ③ 把BLOB或TEXT列分离到单独的表 中。这样做的好处是：减少主表中的碎片 ，并且当主数据表上运行 SELECT * 查询的时候不会通过\n   网络传输大量的BLOB或TEXT值。\n\n\n12.11 JSON类型#\n\n> 使用\n\n\n\n\n12.12 空间类型#\n\n略\n\n\n12.13 小结#\n\n阿里巴巴《Java开发手册》之MySQL数据库：\n\n * 任何字段如果为非负数，必须是 UNSIGNED\n * 【 强制 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。\n   * 说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得 到不正确的结果。\n   * 如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。\n * 【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。\n * 【 强制 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大 于此值，定义字段类型为\n   TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。","routePath":"/tang/mysql/12_MySQL中的数据类型","lang":"","toc":[{"text":"12.1 概述","id":"121-概述","depth":2,"charIndex":17},{"text":"12.2 整型","id":"122-整型","depth":2,"charIndex":789},{"text":"12.2.1 类型介绍","id":"1221-类型介绍","depth":3,"charIndex":800},{"text":"12.2.2 可选属性","id":"1222-可选属性","depth":3,"charIndex":1258},{"text":"12.2.3 使用场景","id":"1223-使用场景","depth":3,"charIndex":1599},{"text":"12.3 浮点型","id":"123-浮点型","depth":2,"charIndex":1879},{"text":"12.3.1 类型介绍","id":"1231-类型介绍","depth":3,"charIndex":1891},{"text":"12.3.2 数据精度说明","id":"1232-数据精度说明","depth":3,"charIndex":2609},{"text":"12.3.3 精度误差说明","id":"1233-精度误差说明","depth":3,"charIndex":3288},{"text":"12.4 定点数","id":"124-定点数","depth":2,"charIndex":3822},{"text":"12.4.1 类型介绍","id":"1241-类型介绍","depth":3,"charIndex":3834},{"text":"12.4.2 使用场景","id":"1242-使用场景","depth":3,"charIndex":4167},{"text":"12.5.1 类型介绍","id":"1251-类型介绍","depth":3,"charIndex":4229},{"text":"12.5.2 使用","id":"1252-使用","depth":3,"charIndex":4347},{"text":"12.6.1 类型介绍","id":"1261-类型介绍","depth":3,"charIndex":4376},{"text":"12.6.2 YEAR","id":"1262-year","depth":3,"charIndex":4933},{"text":"12.6.3 TIME","id":"1263-time","depth":3,"charIndex":5129},{"text":"12.6.4 DATE","id":"1264-date","depth":3,"charIndex":5399},{"text":"12.6.5 DATETIME","id":"1265-datetime","depth":3,"charIndex":5649},{"text":"12.6.6 TIMESTAMP","id":"1266-timestamp","depth":3,"charIndex":5811},{"text":"12.7 文本字符串类型","id":"127-文本字符串类型","depth":2,"charIndex":6150},{"text":"12.7.1 类型介绍","id":"1271-类型介绍","depth":3,"charIndex":6166},{"text":"12.7.2 CHAR与VARCHAR","id":"1272-char与varchar","depth":3,"charIndex":6693},{"text":"12.7.3 TEXT类型","id":"1273-text类型","depth":3,"charIndex":9278},{"text":"12.8 ENUM类型","id":"128-enum类型","depth":2,"charIndex":9627},{"text":"12.8.1 类型介绍","id":"1281-类型介绍","depth":3,"charIndex":9642},{"text":"12.8.2 使用","id":"1282-使用","depth":3,"charIndex":9894},{"text":"12.9 SET类型","id":"129-set类型","depth":2,"charIndex":9909},{"text":"12.9.1 类型介绍","id":"1291-类型介绍","depth":3,"charIndex":9923},{"text":"12.9.2 使用","id":"1292-使用","depth":3,"charIndex":10227},{"text":"12.10 二进制字符串类型","id":"1210-二进制字符串类型","depth":2,"charIndex":10242},{"text":"12.10.1 类型介绍","id":"12101-类型介绍","depth":3,"charIndex":10260},{"text":"12.10.2 BINARY与VARBINARY","id":"12102-binary与varbinary","depth":3,"charIndex":10410},{"text":"12.10.3 BLOB","id":"12103-blob","depth":3,"charIndex":10904},{"text":"12.11 JSON类型","id":"1211-json类型","depth":2,"charIndex":11652},{"text":"12.12 空间类型","id":"1212-空间类型","depth":2,"charIndex":11676},{"text":"12.13 小结","id":"1213-小结","depth":2,"charIndex":11693}],"domain":"","frontmatter":{},"version":""},{"id":158,"title":"13 约束","content":"#\n\n\n13.1 概述#\n\n\n13.1.1 为什么需要约束#\n\n数据完整性（Data\nIntegrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造\n成无效操作或错误信息而提出的。\n\n为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制，从以下4个方面考虑：\n\n * 实体完整性（Entity Integrity）：例如，同一个表中不能存在两条完全相同无法区分的数据\n * 域完整性（Domain Integrity）：例如，年龄范围0~120；再如，性别范围“男/女”\n * 引用完整性（Referential Integrity）：例如，员工所在部门，要在部门表中能找到这个部门\n * 用户自定义完整性（User-defined\n   Integrity）：例如，用户名唯一、密码不能为空等；再如，本部门经历的工资不得高于本部门职工的平均工资的5倍\n\n\n13.1.2 什么是约束#\n\n约束是对表中字段的限制，是表级的强制规定。\n\n可以在创建表时规定约束（通过CREATE TABLE语句），或者在表创建之后通过ALTER TABLE语句规定约束。\n\n\n13.1.3 约束的分类#\n\n * 按照约束数据列的限制分：\n   * 单列约束：每个约束只约束一列\n   * 多列约束：每个约束可约束多列\n * 按照约束的作用范围分：\n   * 列级约束：只能作用在一个列上。在列的定义后面指明约束\n   * 表级约束：可以作用在多个列上。不与列的定义在一起，而是单独定义\n * 按照约束的作用分：\n   * NOT NULL：非空约束。规定字段值不能为空\n   * UNIQUE：唯一约束。规定字段值在整个表中是唯一的\n   * PRIMARY KEY：主键约束。是非空和唯一约束的组合\n   * FOREIGN KEY：外键约束\n   * CHECK：检查约束\n   * DEFAULT：默认值约束\n\n\n13.1.4 查看指定表已有的约束#\n\n\n\n\n13.2非空约束#\n\n\n13.2.1 作用#\n\n限定某个字段的值不允许为空\n\n\n13.2.2 关键字#\n\nNOT NUL\n\n\n13.2.3 特点#\n\n * 默认情况下，所有的类型都是可以为NULL的。包括INT、FLOAT等\n * 非空约束只能是列级约束，不能组合非空\n * 一个表可以有多个字段分别限制非空\n * 空字符、0都不等于NULL\n * 如果某字段原有默认值约束，并且想在添加非空约束后还想保留默认值约束，则需要在MODIFY语句中保留默认值约束\n\n\n13.2.4 添加非空约束#\n\n> 方式一：在创建表时添加非空约束\n\n\n\n> 方式二：在建表后添加非空约束\n\n\n\n\n13.2.5 删除非空约束#\n\n\n\n或\n\n\n\n\n13.2.6 面试题#\n\n> 为什么建表时，加 not null default '' 或 default 0\n\n答：不想让表中出现null值。\n\n> 为什么不想要 null 的值\n\n答：\n\n * ① 不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。\n\n * ② 效率不高。影响提高索引效果。因此，我们往往在建表时 not null default '' 或 default 0\n\n\n13.3 唯一性约束#\n\n\n13.3.1 作用#\n\n用来限制某个字段的值不能重复。\n\n\n13.3.2 关键字#\n\nUNIQUE\n\n\n13.3.3 特点#\n\n * 同一个表可以有多个唯一约束\n * 唯一性约束可以是一个列的值唯一，也可以是多个列组合的值唯一\n * 唯一性约束允许列值为空，且允许多列为空值\n * 在创建唯一约束的时候，如果不给唯一性约束命名，就默认和列名相同\n * MySQL会给唯一性约束的列上默认创建一个唯一索引\n\n\n13.3.4 添加唯一性约束#\n\n> 方式一：在创建表是添加唯一性约束\n\n\n\n> 方式二：建表后添加唯一性约束\n\n * ALTER ... ADD方式\n   \n   \n\n * ALTER ... MODIFY方式\n   \n   \n\n\n13.3.5 删除唯一性约束#\n\n> 说明\n\n * 添加唯一性约束的列也会自动创建唯一索引\n\n * 删除唯一性约束只能通过删除唯一索引的方式删除\n\n * 删除时需要指定唯一索引名，唯一索引名和唯一约束名一样\n\n * 如果创建唯一约束时未指明名称，如果是单列，就默认和列名相同；如果是组合列，默认为第一个列名。此外也可以自定义唯一性约束名\n\n * 查看指定表中都有哪些索引\n   \n   \n\n> 删除唯一性约束\n\n\n\n\n13.4 主键约束#\n\n\n13.4.1 作用#\n\n非空且唯一，用来唯一标识表中的一行记录\n\n\n13.4.2 关键字#\n\nPRIMARY KEY\n\n\n13.4.3 特点#\n\n * 主键约束相当于唯一约束+非空约束的组合。主键约束列不允许重复，也不允许出现空值\n * 一个表最多只能有一个主键约束\n * 建立主键约束，既可以在列级创建，也可以在表级创建\n * 主键约束对应着表中的一列或者多列（复合主键）\n * 如果是多列组合的复合主键约束，那么这些列都不允许为空，且组合的值不允许重复\n * MySQL的主键约束名总是PRIMARY，自己命名的无效\n * 当创建主键约束时，会默认创建主键索引。如果删除主键约束了，那么其对应的主键索引也自动删除了\n * 不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能破坏数据的完整性\n\n\n13.4.4 添加主键约束#\n\n> 方式一：在创建表时添加主键约束\n\n * 列级约束\n   \n   \n\n * 表级约束\n   \n   \n\n> 方式二：在创建表后添加主键约束\n\n * ALTER ... ADD方式\n   \n   \n\n * ALTER ... MODIFY方式\n   \n   \n\n\n13.4.5 删除主键约束#\n\n\n\n主键约束被删除后，该列的非空属性仍保留\n\n\n13.5 自增约束#\n\n\n13.5.1 作用#\n\n使得指定字段的值进行自增\n\n\n13.5.2 关键字#\n\nAUTO_INCREMENT\n\n\n13.5.3 特点和要求#\n\n * 一个表最多只能有一个自增长的列\n * 当需要产生唯一标识或者顺序值时，可以设置自增长\n * 设置为自增长的列必须是主键约束列或者唯一性约束列\n * 自增约束的列的数据类型必须是整数类型\n * 在插入数据时，如果自增长列设置为0或者null，会在当前列最大值的基础上递增；如果手动指定了非0、非null的值，则直接赋值为该值\n\n\n13.5.4 添加自增约束#\n\n> 方式一：在创建表的时候添加自增约束\n\n\n\n> 方式二：在建表后添加自增约束\n\n只能使用ALTER...MODIFY方式\n\n\n\n\n13.5.5 删除自增约束#\n\n去掉auto_increment相当于删除\n\n\n\n\n13.5.6 MySQL8.0新特性#\n\n在MySQL5.7和MySQL8.0中分别执行以下操作：\n\n\n\n执行为步骤⑨后，再次查询，MySQL5.7查询到的id值为1,2,3,4，MySQL8.0查询到的id值为1,2,3,6。\n\n原因：\n\n * 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个计数器来决定的，而该计数器只在内存中维护\n   ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化；\n * MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志\n   中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。\n\n\n13.5.7 面试题#\n\n> 带AUTO_INCREMENT约束的字段值是从1开始的吗？\n\n答：在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。此外，还可以通过如下两种方法设置自增属性的起始值：\n\n * ① 在建表时指定AUTO_INCREMENT的值：\n   \n   \n\n * ② 在使用ALTER TABLE ... 时修改指定表的AUTO_INCREMENT的默认值：\n   \n   \n\n * ② 指定第 一条插入记录的自增字段的值。这样新插入的记录的自增字段值从初始值开始递增。\n   \n   如在表中插入第一 条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加\n\n\n13.6 外键约束#\n\n\n13.6.1 作用#\n\n限定某个表的某个字段的引用完整性。 比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。\n\n\n13.6.2 关键字#\n\nFOREIGN KEY\n\n\n13.6.3 主表和从表#\n\n * 主表（父表）：被引用的表，被参考的表\n * 从表（子表）：引用别人的表，参考别人的表\n\n\n13.6.4 特点#\n\n * 从表的外键列，必须引用/参考主表的主键或唯一约束的列\n   \n   原因：因为被引用/参考的值必须是唯一的\n\n * 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（如student_ibfk_1）\n\n * 如果在创建表时就指定外键，需要先创建主表，再创建子表\n\n * 删除表时，先删子表，再删主表\n\n * 当主表的记录被参考时，主表记录将不允许删除。如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可删除主表数据\n\n * 从表中，一个表可以建立多个外键约束\n\n * 从表的外键列与主表被参照列名字可以不同，但是数据类型必须一样，逻辑意义一致\n\n * 删除外键约束时，必须手动删除对应的索引\n\n * 外键约束不可以跨引擎使用\n\n\n13.6.4 添加外键约束#\n\n> 方式一：建表时添加外键约束\n\n\n\n> 方式二：建表后添加外键约束\n\n只能通过ALTER TABLE ... ADD方式添加\n\n\n\n\n13.6.5 删除外键约束#\n\n * ① 查看表中约束，以确定外键约束名（如果已知外键约束名，此步骤可省）\n   \n   CONSTRAINT_NAME列对应的是约束名\n   \n   \n\n * ② 删除外键约束\n   \n   \n\n * ③ 查看外键约束对应的普通索引名\n   \n   \n\n * ④ 删除索引（外键约束对应的索引，只能手动删除）\n   \n   \n\n\n13.6.6 约束等级#\n\n * Cascade方式：在父表中update或delete记录时，同步update或delete子表的匹配记录\n * Set null方式：在父表中update或delete记录时，将子表上匹配记录的列设为null，此时需要注意子表的外键列不能是not null\n * No action方式：如果子表中有匹配的记录，不允许对父表对应候选键进行update或delete操作\n * Restrict方式：同no action方式，都是立即检查外键约束\n * Set default方式：父表有变更时，子表将外键列设置成一个默认值，但InnoDB不能识别\n\n * 如果没有指定等级，相当于Restrict方式。\n\n * 对于外键约束，最好是采用ON UPDATE CASCADE ON DELETE RESTRICt的方式：\n   \n   \n\n\n13.6.7 开发中的常见问题#\n\n * 问题1：如果两个表之间有关联关系，如员工表和部门表，是否一定要建外键约束？\n   \n   答：不一定\n\n * 问题2：建和不建外键约束有什么区别？\n   \n   答：①创建外键约束，创建表、删除表、添加记录、修改记录、删除记录会在语法方面受到限制。比如，在员工表中添加员工时，该员工所在的部门不允许在部门表中找不到；\n   ②不创建外键约束，创建表、删除表、添加记录、修改记录、删除记录不会受到限制。但是要保证数据的引用完整性，只能依靠程序员的自觉（但自觉一般都没用），或者在J\n   ava程序中进行限定。\n\n * 问题3：建和不建外键约束和查询有没有关系？\n   \n   答：没有\n\n> 小结：\n\n在 MySQL 里，外键约束是有成本的，需要消耗系统资源**。对于大并发的 SQL 操作，有可能会不适 合**。比如大型网站的中央数据库，可能会\n因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许不使用系统自带的外键约束，在 应用层面完成检查数据一致性的逻辑。也就是说，即使你不\n用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。\n\n\n13.6.8 阿里开发规范#\n\n【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n\n说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的\nstudent_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发 ，不适合分布式、\n并发集群；级联更新是强阻塞，存在数据库更新风暴 的风险；外键影响数据库的插入速度 。\n\n\n13.7 检查约束#\n\n\n13.7.1 作用#\n\n检查某个字段的值是否符合指定要求。一般指的是值的范围\n\n检查约束在MySQL8.0中才开始有作用（MySQL5.7中已存在，但是没有起作用）。\n\n\n13.7.2 关键字#\n\nCHECK\n\n\n13.7.3 添加检查约束#\n\n> 方式一：在建表时添加约束\n\n * 列级约束\n   \n   \n\n * 表级约束\n   \n   \n\n> 方式2：建表后添加约束\n\n\n\n例1：salary不得小于2000\n\n\n\n例2：sex只能是男或女\n\n\n\n\n13.7.4 删除检查约束#\n\n\n\n\n13.8 默认值约束#\n\n\n13.8.1 作用#\n\n为给定字段指定默认值。插入数据时，如果该字段没有显示赋值，则赋值为默认值\n\n\n13.8.2 关键字#\n\nDEFAULT\n\n\n13.8.3 特点#\n\n * 在建表后给字段添加默认值约束时，如果该字段原有NOT NULL约束，并且仍旧想保留NOT NULL，那么需要在MODIFY语句中保留非空约束\n * 在建表后将字段的默认值约束删除时，如果该字段原有NOT NULL约束，并且仍旧想保留NOT NULL，那么需要在MODIFY语句中保留非空约束\n\n\n13.8.4 添加默认值约束#\n\n> 方式1：建表时添加默认值约束\n\n\n\n> 方式2：建表后添加默认值约束\n\n\n\n * 如果该字段原来有非空约束，并且在添加默认值约束后还想保留非空约束，则需要在MODIFY语句中保留非空约束\n\n * 同理，如果某字段原有默认值约束，并且想在添加非空约束后还想保留默认值约束，则需要在MODIFY语句中保留默认值约束。\n   \n   这就是以如下代码报错的原因。\n   \n   \n\n\n13.8.5 删除默认值约束#\n\n * 如果该字段原有非空约束，只需删除默认值约束时，需要保留原有非空约束：\n\n\n\n * 删除字段值的默认约束的同时，也删除其非空约束：\n\n","routePath":"/tang/mysql/13_约束","lang":"","toc":[{"text":"13.1 概述","id":"131-概述","depth":2,"charIndex":3},{"text":"13.1.1 为什么需要约束","id":"1311-为什么需要约束","depth":3,"charIndex":14},{"text":"13.1.2 什么是约束","id":"1312-什么是约束","depth":3,"charIndex":436},{"text":"13.1.3 约束的分类","id":"1313-约束的分类","depth":3,"charIndex":535},{"text":"13.1.4 查看指定表已有的约束","id":"1314-查看指定表已有的约束","depth":3,"charIndex":857},{"text":"13.2非空约束","id":"132非空约束","depth":2,"charIndex":880},{"text":"13.2.1 作用","id":"1321-作用","depth":3,"charIndex":892},{"text":"13.2.2 关键字","id":"1322-关键字","depth":3,"charIndex":920},{"text":"13.2.3 特点","id":"1323-特点","depth":3,"charIndex":943},{"text":"13.2.4 添加非空约束","id":"1324-添加非空约束","depth":3,"charIndex":1112},{"text":"13.2.5 删除非空约束","id":"1325-删除非空约束","depth":3,"charIndex":1170},{"text":"13.2.6 面试题","id":"1326-面试题","depth":3,"charIndex":1194},{"text":"13.3 唯一性约束","id":"133-唯一性约束","depth":2,"charIndex":1427},{"text":"13.3.1 作用","id":"1331-作用","depth":3,"charIndex":1441},{"text":"13.3.2 关键字","id":"1332-关键字","depth":3,"charIndex":1471},{"text":"13.3.3 特点","id":"1333-特点","depth":3,"charIndex":1493},{"text":"13.3.4 添加唯一性约束","id":"1334-添加唯一性约束","depth":3,"charIndex":1645},{"text":"13.3.5 删除唯一性约束","id":"1335-删除唯一性约束","depth":3,"charIndex":1762},{"text":"13.4 主键约束","id":"134-主键约束","depth":2,"charIndex":1971},{"text":"13.4.1 作用","id":"1341-作用","depth":3,"charIndex":1984},{"text":"13.4.2 关键字","id":"1342-关键字","depth":3,"charIndex":2018},{"text":"13.4.3 特点","id":"1343-特点","depth":3,"charIndex":2045},{"text":"13.4.4 添加主键约束","id":"1344-添加主键约束","depth":3,"charIndex":2348},{"text":"13.4.5 删除主键约束","id":"1345-删除主键约束","depth":3,"charIndex":2496},{"text":"13.5 自增约束","id":"135-自增约束","depth":2,"charIndex":2536},{"text":"13.5.1 作用","id":"1351-作用","depth":3,"charIndex":2549},{"text":"13.5.2 关键字","id":"1352-关键字","depth":3,"charIndex":2576},{"text":"13.5.3 特点和要求","id":"1353-特点和要求","depth":3,"charIndex":2606},{"text":"13.5.4 添加自增约束","id":"1354-添加自增约束","depth":3,"charIndex":2788},{"text":"13.5.5 删除自增约束","id":"1355-删除自增约束","depth":3,"charIndex":2870},{"text":"13.5.6 MySQL8.0新特性","id":"1356-mysql80新特性","depth":3,"charIndex":2912},{"text":"13.5.7 面试题","id":"1357-面试题","depth":3,"charIndex":3232},{"text":"13.6 外键约束","id":"136-外键约束","depth":2,"charIndex":3554},{"text":"13.6.1 作用","id":"1361-作用","depth":3,"charIndex":3567},{"text":"13.6.2 关键字","id":"1362-关键字","depth":3,"charIndex":3632},{"text":"13.6.3 主表和从表","id":"1363-主表和从表","depth":3,"charIndex":3659},{"text":"13.6.4 特点","id":"1364-特点","depth":3,"charIndex":3722},{"text":"13.6.4 添加外键约束","id":"1364-添加外键约束","depth":3,"charIndex":4071},{"text":"13.6.5 删除外键约束","id":"1365-删除外键约束","depth":3,"charIndex":4155},{"text":"13.6.6 约束等级","id":"1366-约束等级","depth":3,"charIndex":4337},{"text":"13.6.7 开发中的常见问题","id":"1367-开发中的常见问题","depth":3,"charIndex":4724},{"text":"13.6.8 阿里开发规范","id":"1368-阿里开发规范","depth":3,"charIndex":5238},{"text":"13.7 检查约束","id":"137-检查约束","depth":2,"charIndex":5461},{"text":"13.7.1 作用","id":"1371-作用","depth":3,"charIndex":5474},{"text":"13.7.2 关键字","id":"1372-关键字","depth":3,"charIndex":5560},{"text":"13.7.3 添加检查约束","id":"1373-添加检查约束","depth":3,"charIndex":5581},{"text":"13.7.4 删除检查约束","id":"1374-删除检查约束","depth":3,"charIndex":5702},{"text":"13.8 默认值约束","id":"138-默认值约束","depth":2,"charIndex":5721},{"text":"13.8.1 作用","id":"1381-作用","depth":3,"charIndex":5735},{"text":"13.8.2 关键字","id":"1382-关键字","depth":3,"charIndex":5786},{"text":"13.8.3 特点","id":"1383-特点","depth":3,"charIndex":5809},{"text":"13.8.4 添加默认值约束","id":"1384-添加默认值约束","depth":3,"charIndex":5972},{"text":"13.8.5 删除默认值约束","id":"1385-删除默认值约束","depth":3,"charIndex":6180}],"domain":"","frontmatter":{},"version":""},{"id":159,"title":"14 视图","content":"#\n\n\n14.1 常见的数据库对象#\n\n对象                描述\n表（TABLE）          表是存储数据的逻辑单元，以行和列的形式存在。列就是字段，行就是记录\n数据字典              就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员一般不可修改，只能查看\n约束（CONSTRAINT）    执行数据校验的规则，用于保证数据的完整性\n视图（VIEW）          一个或者多个数据表里的数据的逻辑显示，视图本身并不存储数据\n索引（INDEX）         用于提高查询性能，相当于书的目录\n存储过程（PROCEDURE）   用于完成一次完整的业务处理，没有返回值。但可以通过传出参数将多个值传给调用环境\n存储函数（FUNCTION）    用于完成一次特定的计算，具有一个返回值\n触发器（TRIGGER）      相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理\n\n\n14.2 视图概述#\n\n * 视图是一个虚拟表，本身不存储数据，占用很少的内存空间\n * 视图建立在已有表的基础上，视图赖以建立的表被称为基表\n * 视图的创建和删除只影响视图本身，不影响对应的基表\n * 针对视图中的数据做DML操作，会影响到对应的基表中的数据。反之亦然\n * 视图的应用场景：针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图\n * 视图的优点：简化查询; 控制数据的访问\n\n\n14.3 创建视图#\n\n\n14.3.1 完整语法#\n\n\n\n * OR REPLACE：表示如果没有就创建，如果有就修改\n\n * ALGORITHM（了解）：它表示使用何种算法来处理视图。是MySQL对标准SQL进行的功能扩展。\n   \n   ALGORITHM有如下3个值可选：\n   \n   * MERGE：会将引用视图的语句的文本与视图定义合并起来，使得视图定义的部分替换语句的相应部分\n     \n     例子如下：\n     \n     * ① 创建视图\n       \n       \n     \n     * ② 使用视图进行查询\n       \n       \n     \n     * ③ 最终执行的语句实际为：\n       \n       \n   \n   * TEMPTABLE，视图的结果将被置于临时表中，然后使用它执行语句\n   \n   * UNDEFINED，MySQL选择使用哪种算法。如果可能，它倾向于MERGE而不是TEMPTABLE，这是因为MERGE通常更有效，而且如果使用了临时\n     表，视图是不可更新的。\n   \n   * 如果没有ALGORITHM子句，默认算法由系统变量optimizer_switch的derived_merge标志的值确定。\n\n * 查询语句：既可以在表的基础上创建视图，也可以在视图的基础上创建视图\n\n * WITH [CASCADED|LOCAL] CHECK\n   OPTION：确保视图数据的一致性。即当通过视图更新或插入基表的一行记录时，MySQL都会确保插入或更新操作符合视图的定义（即确保该记录符合创建视图时SE\n   LECT字句中的WHERE条件）\n   \n   * CASCADED：默认值。表示MySQL会以递归方式检查视图的规则以及基础视图的规则（）\n   \n   * LOCAL：在MySQL 5.7.6之前，仅检查当前视图的规则，而不检查基础视图的规则；在MySQL 5.7.6之后，将检查带有WITH LOCAL\n     CHECK OPTION和WITH CASCADED CHECK OPTION选项的视图规则（只检查带有这两个选项的视图规则）。\n   \n   * 例子：\n     \n     \n\n\n14.3.2 精简版语法#\n\n\n\n * 查询语句：既可以在表的基础上创建视图，也可以在视图的基础上创建视图\n\n\n14.4 查看视图信息#\n\n> 查看数据库的表对象、视图对象\n\n\n\n> 看视图的结构\n\n\n\n> 查看视图的属性信息（显示数据表的存储引擎、版本、数据行数和数据大小等）\n\n\n\n> 查看视图的详细定义信息\n\n\n\n\n14.5 更新视图中的数据#\n\n一般情况下，MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发\n生变化，反之亦然。\n\n但是，在如下情况下，视图中的数据是不允许更新的：\n\n * 在定义视图时，指定了ALGORITHM = TEMPTABLE，该视图不支持INSERT和 DELETE操作\n * 在定义视图时，指定了WITH [CASCADED|LOCAL] CHECK OPTION，且INSERT和UPDATE的记录不满足视图规则时，不能更新\n * 视图中不包含基表中所有被定义为NOT NULL且又未指定默认值的列，该视图不支持INSERT操作\n * 在定义视图的SELECT中使用了JOIN联合查询，该视图不支持 INSERT和 DELETE操作\n * 在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，该视图不支持INSERT操作，也不支持对使用了数学表达式和子查询的字段使用UPDATE\n   操作\n * 在定义视图的SELECT语句后的字段列表中使用了DISTINCT、聚合函数、GROUP BY、HAVING、UNION等\n * 视图定义基于一个不可更新视图\n * 常量视图\n\n\n14.6 修改视图#\n\n> 使用CREATE OR REPLACE VIEW子句修改视图\n\n\n\n> 使用ALTER VIEW子句修改视图\n\n\n\n\n14.7 删除视图#\n\n\n\n * 删除的是视图本身，而不会删除基表中的数据\n * 假设视图c是基于视图a创建的，如果删除了视图a，会导致视图c查询失败，此时需要手动删除视图c。\n\n\n14.8 视图的优缺点#\n\n\n14.8.1 视图的优点#\n\n * 操作简单\n   \n   将常用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表结构、表与表之间的关联关系，只需要简单的操作视图即可，极大的简化了开发人员对数据库的操\n   作\n\n * 减少数据冗余\n   \n   视图本身就是一条被保存起来的SELECT语句，本身不存储数据，从而减少了数据冗余\n\n * 数据安全\n   \n   用户不需要查询数据表，可以通过视图获取表中的数据。此外还可以限制用户对视图的操作权限，以保证数据的安全\n\n * 适应灵活多变的需求\n   \n   当业务系统的需求发生变化后，如果需要改动表的结构，此时工作量比较大。如果借助视图，则能减少改动的工作量\n\n * 能够分解复杂的查询逻辑\n   \n   数据库中如果存在复杂的逻辑查询，则可以将问题分解，创建多个视图获取数据，在将创建的多个视图结合起来，完成复杂的逻辑查询\n\n\n14.8.2 视图的缺点#\n\n * 维护比较困难，可读性不好\n   \n   如果在实际数据表的基础上创建了视图，一旦基表的结构变更，必须及时对相关视图进行维护，特别是嵌套的视图，维护变得比较复杂，可读性不好，容易变成系统的潜在隐患\n   。且创建视图的SQL查询可能会对字段重命名，也可能是包含复杂的逻辑，这些都会增加维护的成本。\n\n\n14.8.3 视图的使用场景#\n\n针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图","routePath":"/tang/mysql/14_视图","lang":"","toc":[{"text":"14.1 常见的数据库对象","id":"141-常见的数据库对象","depth":2,"charIndex":3},{"text":"14.2 视图概述","id":"142-视图概述","depth":2,"charIndex":436},{"text":"14.3 创建视图","id":"143-创建视图","depth":2,"charIndex":642},{"text":"14.3.1 完整语法","id":"1431-完整语法","depth":3,"charIndex":655},{"text":"14.3.2 精简版语法","id":"1432-精简版语法","depth":3,"charIndex":1597},{"text":"14.4 查看视图信息","id":"144-查看视图信息","depth":2,"charIndex":1653},{"text":"14.5 更新视图中的数据","id":"145-更新视图中的数据","depth":2,"charIndex":1758},{"text":"14.6 修改视图","id":"146-修改视图","depth":2,"charIndex":2312},{"text":"14.7 删除视图","id":"147-删除视图","depth":2,"charIndex":2385},{"text":"14.8 视图的优缺点","id":"148-视图的优缺点","depth":2,"charIndex":2476},{"text":"14.8.1 视图的优点","id":"1481-视图的优点","depth":3,"charIndex":2491},{"text":"14.8.2 视图的缺点","id":"1482-视图的缺点","depth":3,"charIndex":2889},{"text":"14.8.3 视图的使用场景","id":"1483-视图的使用场景","depth":3,"charIndex":3057}],"domain":"","frontmatter":{},"version":""},{"id":160,"title":"15 存储过程与存储函数","content":"#\n\n\n15.1 概述#\n\n\n15.1.1 存储过程#\n\n> 理解\n\n存储过程(Stored\nProcedure)，就是一组经过预先编译的SQL语句的封装。它是预先存储在MySQL服务器上的，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，\n服务器端就可以把预先存储好的一系列SQL语句全部执行。\n\n> 优点\n\n * 简化操作，提高了sql语句的重用性，减少了开发程序员的压力\n * 减少操作过程中的失误，提高效率\n * 减少网络传输量（客户端不需要把所有的sql通过网络发送个MySQL服务器）\n * 减少了SQL语句暴露在网上的风险，也提高了数据查询的安全性\n\n> 和视图的对比\n\n * 相同点：存储过程和视图有着同样的优点，清晰、安全，还可以减少网络传输量。\n * 不同点：\n   * 视图是虚拟表，通常用来对基表的查询操作，不用于增删改操作；\n   * 存储过程可以直接操作底层数据，能够实现一些复杂的数据处理。\n\n> 存储过程的参数\n\n存储过程的参数类型可以：\n\n * IN：默认值。表示该参数是传入的参数。存储过程知识读取这个参数的值。\n * OUT：表示该参数是传出的参数。当存储过程执行完毕后，存储过程的客户端或应用程序可以读取该参数的返回值\n * INOUT：表示该参数既是传入的参数，又是传出的参数。\n\n以上参数类型都可以在一个存储过程中带0个、1个或者多个。\n\n> 分类\n\n存储过程可以按照参数类型进行分类：\n\n * 没有参数\n * 仅带IN类型\n * 仅带OUT类型\n * 既带IN类型又带OUT类型\n * 带OUT类型\n\n\n15.1.2 存储函数#\n\nMySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样\n\n\n15.1.3 存储过程 VS 存储函数#\n\n       关键字         调用语法                 返回值    应用场景\n存储过程   PROCEDURE   CALL 存储过程名(参数列表)     无      一般用于更新\n存储函数   FUNCTION    SELECT 存储函数名(参数列表)   只有1个   一般用于查询结果为一个值，并需要返回的场景\n\n此外：\n\n * 存储函数可以在查询语句中使用，存储过程不行。\n * 存储过程的功能比存储函数更强大，能执行对表的操作（如创建表、删除表）和事务操作，这些功能存储函数不具备。\n\n\n15.2 创建存储过程#\n\n> 语法\n\n\n\n * DELIMITER：用来设置新的结束标记。MySQL中默认的语句结束符号是\";\"。为了避免与存储过程中的SQL语句的结束符冲突，需要使用DELIMITER\n   改变存储过程的结束符。\n   \n   * 第一个DELIMITER：用来表明存储的结束标记。\n   * 第二个DELIMITER：将结束标记改为MySQL默认的存储标记。\n   \n   常用的新的结束标记：$、//\n\n * characteristics：表示创建存储过程时指定的对存储过程的约束条件。\n   \n   characteristics取值信息如下：\n   \n   \n   \n   * LANGUAGE SQL：说明存储过程体是由SQL语句组成的，当前系统支持的语言是SQL。\n   * [NOT] DETERMINISTIC：默认是NOT DETERMINISTIC。指明存储过程执行的结果是否是确定的，即同一输入是否能得到相同的输出。\n   * { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA\n     }：指明子程序使用SQL语句的限制。\n     * CONTAINS SQL：默认。表示包含SQL语句，但是并不包含读写数据的SQL语句；\n     * NO SQL：表示不包含任何SQL；\n     * READS SQL DATA：包含读数据的SQL；\n     * MODIFIES SQL DATA：包含写数据的SQL。\n   * SQL SECURITY { DEFINER | INVOKER }：指明哪些用户可以执行当前存储过程。\n     * DEFINER ：表示只有创建者才能执行\n     * INVOKER ：表示有当前存储过程访问权限的用户都可以执行\n   * COMMENT 'string'：string处可以写明该存储过程的一些注释信息\n\n * BEGIN ... END 存储过程体结束符：存储过程的过程体要写在BEGIN ... END 之间。\n   \n   存储过程体编写注意事项：\n   \n   * 存储过程体如果只有一条SQL语句，BEGIN ... END可省。\n   * 存储过程体中的每个语句都要以\";\"作为结束符。\n   * DECLARE用来声明变量，且变量的声明必须在其他语句使用之前进行。\n   * SET 变量名 = 值用来对变量赋值。\n   * SELECT ... INTO 变量名 [FROM ... WHERE ...]也可以对变量进行赋值\n\n> 举例：\n\n\n\n\n15.3 调用存储过程#\n\n> 语法\n\n\n\n> 例子\n\n * 参数为IN类型：\n   \n   \n\n * 调用OUT模式的参数：\n   \n   \n\n * 调用INOUT模式的参数：\n   \n   \n\n\n15.4 创建存储函数#\n\n> 语法\n\n\n\n * 存储函数的参数列表，总是默认为IN类型\n * RETURNS 返回值类型存储函数必须指明返回值类型，函数体中必须包含一个RETURN 返回值;语句。\n * characteristic指明对函数的约定，与创建存储过程的约束一致。\n * BEGIN ... END 新的结束标记：函数体要写在BEGIN ... END之间。如果函数体只有一条语句，BEGIN ... END可省。\n\n> 举例\n\n\n\n对于创建函数时报错This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in\nits declaration and binary logging is enabled (you *might* want to use the less\nsafe log_bin_trust_function_creators variable)的处理办法：\n\n * 方式一：\n   \n   在创建函数时加上必要的函数约束[NOT] DETERMINISTIC和{CONTAINS SQL | NO SQL | READS SQL DATA |\n   MODIFIES SQL DATA}\n\n * 方式二：\n   \n   \n\n\n15.5 调用存储函数#\n\n> 语法\n\n\n\n\n15.6 查看存储过程和存储函数#\n\n * 使用SHOW CREATE语句查看存储过程和函数的创建信息\n   \n   \n\n * 使用SHOW STATUS语句查看存储过程和函数的状态信息\n   \n   \n\n * 从information_schema.Routines表中查看存储过程和函数的信息\n   \n   \n\n\n15.7 修改存储过程和存储函数#\n\n修改存储过程和存储函数，不能修改其存储过程体或者函数体，只能修改相关特性。语法如下：\n\n\n\n\n\n\n15.8 删除存储过程和存储函数#\n\n\n\n\n15.9 存储过程的优缺点#\n\n尽管存储过程有诸多优点，但是对于存储过程的使用，**一直都存在着很多争议，**比如有些公司对于大型\n项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程。\n\n\n15.9.1 存储过程的优点#\n\n * 一次编译多次使用，提高了SQL的执行效率：存储过程只在创建时进行编译，之后的使用都不需要重新编译\n * 减少开发工作量，保证代码结构清晰：将代码封装成模块，模块间可以重复使用\n * 存储过程的安全性强：在创建存储过程时设置用户的使用权限，这样就和视图一样具有较强的安全性\n * 减少网络传输量：存储过程是保存在MySQL服务器端的，每次只需要调用存储过程即可，减少了SQL语句的网络传输\n * 良好的封装性：在进行相对复杂的数据库操作时，原本需要使用一条一条的SQL语句，可能需要多次连接数据库。如果使用存储过程，只需要连接一次\n\n\n15.9.2 存储过程的缺点#\n\n * 可移植性差：存储过程不能跨数据库移植。如在 MySQL、Oracle 和 SQL Server 里编写的存储过 程，在换成其他数据库时都需要重新编写。\n * 调试困难：对于复杂的存储过程，开发和维护都不容易，没有好用、免费的调试工具\n * 存储过程的版本管理很困难：比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发\n   软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦\n * 不适合高并发场景：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方 式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，\n   增加数据库的压力 ，显然就 不适用了","routePath":"/tang/mysql/15_存储过程与存储函数","lang":"","toc":[{"text":"15.1 概述","id":"151-概述","depth":2,"charIndex":3},{"text":"15.1.1 存储过程","id":"1511-存储过程","depth":3,"charIndex":14},{"text":"15.1.2 存储函数","id":"1512-存储函数","depth":3,"charIndex":681},{"text":"15.1.3 存储过程 VS 存储函数","id":"1513-存储过程-vs-存储函数","depth":3,"charIndex":739},{"text":"15.2 创建存储过程","id":"152-创建存储过程","depth":2,"charIndex":1026},{"text":"15.3 调用存储过程","id":"153-调用存储过程","depth":2,"charIndex":2144},{"text":"15.4 创建存储函数","id":"154-创建存储函数","depth":2,"charIndex":2244},{"text":"15.5 调用存储函数","id":"155-调用存储函数","depth":2,"charIndex":2814},{"text":"15.6 查看存储过程和存储函数","id":"156-查看存储过程和存储函数","depth":2,"charIndex":2837},{"text":"15.7 修改存储过程和存储函数","id":"157-修改存储过程和存储函数","depth":2,"charIndex":2996},{"text":"15.8 删除存储过程和存储函数","id":"158-删除存储过程和存储函数","depth":2,"charIndex":3064},{"text":"15.9 存储过程的优缺点","id":"159-存储过程的优缺点","depth":2,"charIndex":3086},{"text":"15.9.1 存储过程的优点","id":"1591-存储过程的优点","depth":3,"charIndex":3186},{"text":"15.9.2 存储过程的缺点","id":"1592-存储过程的缺点","depth":3,"charIndex":3473}],"domain":"","frontmatter":{},"version":""},{"id":161,"title":"16 变量、流程控制与游标","content":"#\n\n\n16.1 变量#\n\n * 系统变量\n   \n   * 全局系统变量\n   * 会话系统变量（默认）\n\n * 用户自定义变量\n   \n   * 会话用户变量\n   * 局部变量\n\n\n16.1.1 系统变量#\n\n> 概述\n\n * 定义：变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，\n   MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特 征。这些系统变量的值要么是\n   编译MySQL时参数的默认值，要么是 配置文件 （例如my.ini等）中的参数值。\n * 系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字）。如果不写，默认会话级别。\n * 有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。\n * 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。\n * 全局系统变量针对于所有会话有效，但是不能跨重启\n * 会话系统变量，只针对当前会话有效。\n * 会话1针对某个全局系统变量值的修改，会导致会话2中同一个全局变量的值的修改。\n * 有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如\n   character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id\n   用于标记当前会话的 MySQL 连接 ID\n\n> 查看系统变量\n\n * 查看所有或部分系统变量\n   \n   \n\n * 查看指定系统变量\n   \n   * @@global开头表示全局系统变量\n   * @@session开头表示会话系统变量\n   * @@开头，首先会查询会话系统变量，如果会话系统不存在，再去查全局系统变量\n   \n   \n\n> 修改系统变量的值\n\n * 方法一：\n   \n   修改MySQL 配置文件my.ini ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）\n\n * 方法二：\n   \n   在MySQL服务运行期间，使用set命令重新设置系统变量的值，语法如下：\n   \n   \n\n> MySQL8.0新特性：全局变量的持久化\n\n\n\n * 数据库重启后，值仍有效\n * MySQL会将该命令的配置保存到数据目录下的mysqld-auto.cnf文件中，下次启动时会读取该文件，用其中的配置来覆盖默认配置\n\n\n16.1.2 用户变量#\n\n> 概述\n\n * 定义：用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 @ 开头。\n * 分类：\n   * 会话用户变量：作用域是当前会话，只对当前连接有效\n   * 局部变量：只在存储过程或者存储函数的BEGIN ... END语句中有效。\n\n> 用户变量的定义\n\n * 会话级用户变量\n   \n   \n\n * 局部变量\n   \n   \n\n> 用户变量的查看\n\n * 会话用户变量\n   \n   \n\n * 局部变量\n   \n   \n\n> 会话用户变量 VS 局部变量\n\n         作用域                    定义位置                     语法\n会话用户变量   当前会话                   会话的任意位置                  使用@符号，不用指定类型\n局部变量     声明的BEGIN ... END 语句中   BEGIN ... END语句中的第一句代码   使用DECLARE，需要指定类型\n\n\n16.2 定义条件与处理程序#\n\n定义条件是事先定义程序执行过程中可能遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能够继续执行。这样可以增强\n存储过程或者存储程序处理问题的能力，增强程序的健壮性，避免程序异常停止运行。类似于Java的异常处理机制。\n\n\n16.2.1 定义条件#\n\n> 定义\n\n定义条件就是给MySQL中的错误命名，有助于存储的程序代码更清晰。它将一个错误名字和错误条件关联起来，随后可以被用在定义处理程序的DECLARE\nHANDLER语句中。\n\n> 语法\n\n\n\n * MySQL_error_code和sqlstate_value都可以表示MySQL的错误。\n   * MySQL_error_code：是数值型的错误代码\n   * sqlstate_value：是长度为5的字符串类型的错误代码\n * 例子：在“ERROR 1418 (HY000)”中，1418是MySQL_error_code，“HY000”是sqlstate_value。\n * 例子：在“ERROR 1142（42000）”中，1142是MySQL_error_code，“42000”是sqlstate_value。\n\n> 定义条件举例\n\n例定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应\n\n\n\n\n16.2.2 定义处理程序#\n\n> 定义\n\n可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。\n\n> 语法\n\n\n\n * 处理方式：取值如下：\n   \n   * CONTINUE：表示遇到指定的错误类型不处理，继续执行\n   * EXIT：表示遇到指定的错误类型马上退出\n   * UNDO：表示遇到指定的错误类型后撤回之前的操作。MySQL中暂时不支持该操作\n\n * 错误类型：取值如下：\n   \n   * SQLSTATE '字符串错误码'：表示长度为5的字符串类型的错误代码\n   * MySQL_error_code错误代码：匹配数值类型的错误码\n   * 错误名称：表示DECLARE ... CONDITION定义的错误条件名称\n   * SQLWARNING：匹配所有以01开头的SQLSTATE错误代码\n   * NOT FOUND：匹配所有以02开头的SQLSTATE错误代码；\n   * SQLEXCEPTION：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码\n\n * 处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。\n   \n   处理语句可以是 SET 变量 = 值 这样的简单语句，也可以是BEGIN ... END编写的复杂语句\n\n> 例子\n\n\n\n\n16.3 流程控制#\n\n> 流程的分类\n\n * 顺序结构：程序从上往下依次执行\n * 分支结构：程序按照条件进行选择执行，从两条或者多条路径中选择一条执行\n * 循环结构：程序满足一定条件下，重复执行一组语句\n\n> 流程控制语句的分类\n\n * 条件判断语句：IF 语句或者 CASE 语句\n * 循环语句：LOOP 语句、WHILE 语句或者 REPEAT语句\n * 跳转语句：ITERATE 语句和 LEAVE 语句\n\n\n16.3.1 分支结构之 IF#\n\n> 语法\n\n\n\n> 举例\n\n例声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨\n薪500元；否则就涨薪100元。\n\n\n\n\n16.3.2 分支结构之 CASE#\n\n> 语法1：类似于Java中的switch语句\n\n\n\n> 语法2：类似于Java中的多重if\n\n\n\n> 举例\n\n例声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；\n薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。\n\n\n\n\n16.3.3 循环结构之 LOOP#\n\n> 语法\n\n\n\n * loop_label：当前LOOP循环语句的标注名称，在使用LEAVE跳出循环时会用到\n\n> 举例\n\n例当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中\n实现循环给大家涨薪，薪资涨为原来的1.1倍，直到全公司的平均薪资达到12000结束，并统计循环次数。\n\n\n\n\n16.3.4 循环结构之 WHILE#\n\nWHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。\n\n> 语法\n\n\n\n * while_label：当前WHILE循环语句的标注名称。\n\n> 例子\n\n例市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储\n过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束，并统计循环次数。\n\n\n\n\n16.3.5 循环结构之 REPEAT#\n\nREPEAT 循环首先会执行一次循 环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会\n就继续执行循环，直到满足退出条件为止。\n\n> 语法\n\n\n\n * repeat_label：当前REPEAT循环语句的标注名称。\n\n> 例子\n\n例当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过\n程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束，并统计循环次数。\n\n\n\n\n16.3.6 LOOP、WHILE、REPEAT的对比#\n\n * 相同点：\n   \n   三者都可以省略标注名称，但是如果在循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加标注名称。\n\n * 不同点：\n   \n   * LOOP：一般用于实现简单的“死”循环\n   * WHILE：先判断，后执行\n   * REPEAT：先执行，后判断。无条件至少执行一次\n\n\n16.3.7 跳转语句之 LEAVE#\n\n> 作用\n\n * 可以用在BEGIN ... END语句中，表示跳出程序体\n * 可以用在循环体内，表示跳出循环\n\n相当于break。\n\n> 语法\n\n\n\n> 举例\n\n例跳出 BEGIN ... END 语句。\n\n\n\n例跳出while循环\n\n当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHI\nLE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。\n\n\n\n\n16.3.8 跳转语句之 ITERATE#\n\n> 作用\n\n只能用在循环语句内，表示重新开始循环，将执行顺序转到语句段的开头。\n\n相当于continue。\n\n> 语法\n\n\n\n> 举例\n\n例定义局部变量num，初始值为0。循环结构中执行num + 1操作。如果num < 10，则继续执行循环；如果num > 15，则退出循环结构。\n\n\n\n\n16.4 游标#\n\n\n16.4.1 概述#\n\n * 作用：游标，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过\n   程开发的能力。\n * 游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用。\n * 游标可以在存储过程和存储函数中使用\n\n\n16.4.2 游标的使用#\n\n使用游标，一般需要经历如下4个步骤：\n\n * 声明游标：游标的声明必须在变量声明之后、处理程序之前。\n   \n   \n\n * 开启游标\n   \n   \n\n * 使用游标（从游标中获取数据）：\n   \n   \n   \n   游标的查询结果集中的字段，必须和INTO后的变量保持一致\n\n * 关闭游标\n   \n   \n\n\n16.4.3 举例#\n\n例创建存储过程“get_count_by_limit_total_salary()”，声明IN参数\nlimit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到\n薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。\n\n\n\n\n16.4.4 游标的优缺点#\n\n * 优点：\n   \n   * 允许逐条读取结果集中的数据\n   * 跟在应用层 面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。\n\n * 缺点：\n   \n   在使用游标的过程中，会对数据行进行加锁。这样在业务并发量大 的时候，不仅会影响业务之间的效率，还会消耗系统资源 ，造成内存不足，这是因为游标是在内存中进\n   行的处理\n\n\n16.5 综合例子#\n\n例创建存储过程update_salary()，参数1为 IN 的INT型变量dept_id，表示部门id；参数2为\nIN的INT型变量change_sal_count，表示要调整薪资的员工个数；参数3为OUT的VARCHAR(255)型变量result，记录程序是否正常结束。\n\n查询指定id部门的员工信息，按照salary升序排列，根据hire_date的情况，调整前change_sal_count个员工的薪资。涨薪比例如下：\n\n * 1995(含1995)年之前入职的，涨薪120%；\n * 1995~1998（含1998）年入职的，涨薪115%；\n * 1998~2001（含2001）年入职的涨薪110%；\n * 其他涨薪105%\n\n另外，关于参数3 result的值设计如下：\n\n * 如果程序正常结束，result 值为 \"success\"；\n * 当程序报错 “ERROR 1329 (02000)”时，result 值为 \"The change_sal_count is more than the\n   number of employees of the current department\"\n\n分析：用到的知识点有：\n\n①创建存储过程；②分支结构；③循环结构；④游标；⑤定义条件与处理程序；⑥局部变量等\n\n代码\n\n","routePath":"/tang/mysql/16_变量、流程控制与游标","lang":"","toc":[{"text":"16.1 变量","id":"161-变量","depth":2,"charIndex":3},{"text":"16.1.1 系统变量","id":"1611-系统变量","depth":3,"charIndex":93},{"text":"16.1.2 用户变量","id":"1612-用户变量","depth":3,"charIndex":1118},{"text":"16.2 定义条件与处理程序","id":"162-定义条件与处理程序","depth":2,"charIndex":1591},{"text":"16.2.1 定义条件","id":"1621-定义条件","depth":3,"charIndex":1745},{"text":"16.2.2 定义处理程序","id":"1622-定义处理程序","depth":3,"charIndex":2208},{"text":"16.3 流程控制","id":"163-流程控制","depth":2,"charIndex":2785},{"text":"16.3.1 分支结构之 IF","id":"1631-分支结构之-if","depth":3,"charIndex":2997},{"text":"16.3.2 分支结构之 CASE","id":"1632-分支结构之-case","depth":3,"charIndex":3131},{"text":"16.3.3 循环结构之 LOOP","id":"1633-循环结构之-loop","depth":3,"charIndex":3350},{"text":"16.3.4 循环结构之 WHILE","id":"1634-循环结构之-while","depth":3,"charIndex":3568},{"text":"16.3.5 循环结构之 REPEAT","id":"1635-循环结构之-repeat","depth":3,"charIndex":3826},{"text":"16.3.6 LOOP、WHILE、REPEAT的对比","id":"1636-loopwhilerepeat的对比","depth":3,"charIndex":4132},{"text":"16.3.7 跳转语句之 LEAVE","id":"1637-跳转语句之-leave","depth":3,"charIndex":4321},{"text":"16.3.8 跳转语句之 ITERATE","id":"1638-跳转语句之-iterate","depth":3,"charIndex":4597},{"text":"16.4 游标","id":"164-游标","depth":2,"charIndex":4766},{"text":"16.4.1 概述","id":"1641-概述","depth":3,"charIndex":4777},{"text":"16.4.2 游标的使用","id":"1642-游标的使用","depth":3,"charIndex":4947},{"text":"16.4.3 举例","id":"1643-举例","depth":3,"charIndex":5121},{"text":"16.4.4 游标的优缺点","id":"1644-游标的优缺点","depth":3,"charIndex":5318},{"text":"16.5 综合例子","id":"165-综合例子","depth":2,"charIndex":5514}],"domain":"","frontmatter":{},"version":""},{"id":162,"title":"17 触发器","content":"#\n\n\n17.1 定义触发器#\n\n> 语法\n\n\n\n * BEFORE|AFTER：二选一\n   \n   * BEFORE：表示在事件发生之前执行当前触发器\n   * AFTER：表示在事件发生之后之执行触发器。不允许在触发后更新new行和old行\n\n * INSERT|UPDATE|DELETE：三选一，表名事件类型\n   \n   * INSERT：使用NEW(或new)代表当前要插入的对象\n   * DELETE：使用OLD(或old)代表当前要删除的对象\n   * UPDATE：NEW(或new)和OLD(或old)都可以用。\n\n * FOR EACH ROW：表示每一行都要执行触发器\n\n * 触发器执行的语句块：可以是一行sql语句，也可以是复杂的BEGIN ... END语句\n\n * 同表的更新不能在触发器中使用update，而是直接使用set。相当于给new或old对象进行赋值操作。\n   \n   例子：16.5-->代码--> ②和⑤\n\n\n17.2 查看触发器#\n\n * 查看当前数据库所有的触发器\n   \n   \n\n * 查看当前数据库指定触发器的定义\n   \n   \n\n * 从系统库information_schema的TRIGGERS表中查询触发器的信息\n   \n   \n\n\n17.3 删除触发器#\n\n\n\n\n17.4 中断触发器的执行#\n\n可以使用SIGNAL语句抛出异常，中断触发器的执行，并提供错误信息。\n\n> 语法\n\n\n\n * condition_value可选值如下：\n   * SQLSTATE '长度为5的字符串类型的错误代码'：其中'错误码'不能是00（表示成功）和01（表示警告）开头，因为二者不会中断执行。\n   * 事先用DECLARE自定义的条件名称\n * condition_information_item_name可选值如下：\n   * MESSAGE_TEXT：对应的值为错误描述信息\n   * MYSQL_ERRNO：对应的值为数值型的错误代码\n   * ...\n\n\n\n\n17.5 触发器的优缺点#\n\n\n17.5.1 优点#\n\n * 可以确保数据的完整性\n * 可以帮助我们记录日志操作\n * 可以在操作数据前，对数据进行合法性检查\n\n\n17.5.2 缺点#\n\n * 可读性差。因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制。\n   \n   比如，在给t_user表中插入用户信息时，需要更新t_user_log表。当t_user_log中的remark字段过长，触发器会报错。但是t_user表\n   中并没有remark字段。如果你不了解这个触发器， 很可能会认为是更新语句本身的问题\n\n * **相关数据的变更，可能会导致触发器出错。**特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触\n   发器本身的隐蔽性，影响到应用中错误原因排查的效率\n\n\n17.6 触发器使用例子#\n\n例创建t_user表，t_user_log表。\n\n * ①在插入用户信息后，使用触发器，自动插入create_time、update_time字段，并且在t_user_log表中插入日志\n * ②在更新用户信息前，使用触发器，自动更新update_time字段，并且在t_user_log表中插入日志\n * ③在删除用户信息后，使用触发器，在t_user_log表中插入日志\n\n代码\n\n * ①创建t_user表，t_user_log表\n   \n   \n\n * ②创建触发器t_user_before_insert_trigger，在插入用户信息时，自动填充create_time和update_time\n   \n   \n\n * ③创建触发器t_user_after_insert_trigger，在插入用户信息时，使用日志表t_user_log记录操作日志\n   \n   \n\n * ④插入数据验证\n   \n   \n\n * ⑤创建触发器t_user_before_update_trigger，在更新用户信息时，自动更新update_time\n   \n   \n\n * ⑥创建触发器t_user_after_update_trigger，使用日志表t_user_log记录操作日志\n   \n   \n\n * ⑦更新数据验证\n   \n   \n\n * ⑧创建触发器t_user_after_delete_trigger，在删除数据后，使用日志表t_user_log记录操作日志\n   \n   \n\n * ⑨删除数据验证\n   \n   \n\n\n17.7 触发器使用注意事项#\n\n如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET\nNULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被\n激活","routePath":"/tang/mysql/17_触发器","lang":"","toc":[{"text":"17.1 定义触发器","id":"171-定义触发器","depth":2,"charIndex":3},{"text":"17.2 查看触发器","id":"172-查看触发器","depth":2,"charIndex":431},{"text":"17.3 删除触发器","id":"173-删除触发器","depth":2,"charIndex":553},{"text":"17.4 中断触发器的执行","id":"174-中断触发器的执行","depth":2,"charIndex":569},{"text":"17.5 触发器的优缺点","id":"175-触发器的优缺点","depth":2,"charIndex":867},{"text":"17.5.1 优点","id":"1751-优点","depth":3,"charIndex":883},{"text":"17.5.2 缺点","id":"1752-缺点","depth":3,"charIndex":950},{"text":"17.6 触发器使用例子","id":"176-触发器使用例子","depth":2,"charIndex":1246},{"text":"17.7 触发器使用注意事项","id":"177-触发器使用注意事项","depth":2,"charIndex":1926}],"domain":"","frontmatter":{},"version":""},{"id":163,"title":"18 MySQL8.0新特性","content":"#\n\n\n18.1 MySQL80.0新特性概述#\n\n\n18.1.1 MySQL8.0新增特性#\n\n * 更简便的NoSQL支持。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL8.0对这一功能做了优化，以更灵活的方式实现NoSQL，\n   不再依赖模式。\n\n * 更好的索引。新增隐藏索引和降序索引。隐藏索引可以用来测试去掉索引对查询性能的影响；在查询中混合存在多列索引时，使用降序索引可以提高查询性能。\n\n * 更完善的JSON支持。从5.7版本开始支持原生json数据的存储，8.0进行了优化。\n   \n   * 增加了聚合函数JSON_ARRAYGG和JSON_OBJECTAGG，将参数聚合为JSON数组或对象；\n   * 新增行内操作符->>，是列路径运算符->的增强，对JSON排序做了提升；\n   * 优化了JSON的更新操作\n\n * 安全和账户管理。新增caching_sha2_password授权插件、角色、密码历史记录和FIPS模式支持。提高了数据库的安全性和性能，使数据库管理员能\n   更灵活的进行账户管理工作。\n\n * InnoDB的变化。InnoDB是MySQL默认的存储引擎，8.0在其自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言（\n   DDL），提高了数据安全性，对事务提供更好的支持。\n\n * 数据字典。新增事务数据字典，用来存储数据库对象信息。数据字典存储在内部事务表中。\n\n * 原子数据定义语言，即原子DDL。目前只有InnoDB引擎支持。\n   \n   * 定义：原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中。\n   * 好处：即使服务器崩溃，事务也会提交或回滚。\n   * 具体表现：使用支持原子DDL的引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、RENAME\n     TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP\n     TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。\n\n * 资源管理。MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行.\n\n * 字符集支持。MySQL 8默认字符集改为utf8mb4 ，并首次增加了日语所特定使用的集 合，utf8mb4_ja_0900_as_cs。\n\n * 优化器增强。MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必\n   要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许 优化器对多个列进行排序，并且允许排序顺序不一致。\n\n * 公用表表达式。公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。\n\n * 窗口函数。在之前的版本中已存在的大部分 聚合函数 在MySQL 8中也可以 作为窗口函数来使用。\n\n * 正则表达式支持。增加了REGEXP_LIKE()、 EGEXP_INSTR()、REGEXP_REPLACE()和\n   REGEXP_SUBSTR()等函数来提升性能，另外，regexp_stack_limit和\n   regexp_time_limit系统变量能够通过匹配引擎来控制资源消耗。\n\n * 内部临时表。TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎 。TempTable存储\n   引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部\n   临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。\n   temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。\n\n * 日志记录。在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量\n   log_error_services来配置，能够实现日志事件的过滤和写入。\n\n * \n\n * 增强的MySQL复制。MySQL 8复制支持对JSON文档进行部分更新的二进制日志记录 ，该记录使用紧凑的二进制格式\n   ，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_opt\n   ions系统变量值设置为PARTIAL_JSON来启用。\n\n\n18.1.2 MySQL8.0移除的就特性#\n\n * 查询缓存。查询缓存已被移除 ，删除的项有：\n   * 语句：FLUSH QUERY CACHE和RESET QUERY CACHE。\n   * 系统变量：query_cache_limit、query_cache_min_res_unit、query_cache_size、\n     query_cache_type、query_cache_wlock_invalidate。\n   * 状态变量：Qcache_free_blocks、\n     Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_n\n     ot_cached、 Qcache_queries_in_cache、Qcache_total_blocks。\n   * 线程状态：checking privileges on cached query、checking query cache for\n     query、invalidating query cache entries、sending cached result to\n     client、storing result in query cache、waiting for query cache lock。\n * 加密相关。\n   * 删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和\n     DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，\n     HAVE_CRYPT CMake选项。\n   * 对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使 用AES_ENCRYPT()和AES_DECRYPT()替代。\n * 空间函数相关。在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被 移除，只保留了对应的ST_和MBR函数。\n * \\N和NULL。在SQL语句中，解析器不再将\\N视为NULL，所以在SQL语句中应使用NULL代替\\N。这项变化 不会影响使用LOAD DATA\n   INFILE或者SELECT...INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL 仍等同于\\N。\n * mysql_install_db。在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着--\n   initialize或者--initialize-insecure选项的mysqld来代替实现。另外，--bootstrap和INSTALL_SCRIPT\n   DIR CMake也已被删除。\n * 通用分区处理程序。通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存 储引擎需要自有的分区处理程序。\n   提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在 MySQL 8中只支持InnoDB。\n * 系统和状态变量信息。在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。\n   GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系\n   统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、\n   Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Sla\n   ve_running。以上被删除 的内容都可使用性能模式中对应的内容进行替代。\n * mysql_plugin工具。mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用--plugin-load或-\n   -plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该 工具\n\n\n18.2 新特性1-窗口函数#\n\n\n18.2.1 概述#\n\n * 作用：类似于在查询中使用GROUP BY对数据进行分组，不同的是，分组操作会把分组的结果汇聚成一条记录，窗口函数是将结果置于每一条数据记录中。\n\n * 分类：\n   \n   * 静态窗口函数：函数的窗口大小是固定的，不会因为记录的不同而不同\n   * 动态窗口函数：函数的窗口大小会随着记录的不同而变化\n\n * 概览：窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下：\n   \n   函数分类   函数                   描述\n   序号函数   ROW_NUMBER()         顺序排序\n   序号函数   RANK()               并列排序，会跳过重复的序号，如1、1、3\n   序号函数   DENSE_RANK()         并列排序，不会跳过重复的序号，如1、1、2\n   分布函数   PERCENT_RANK         等级值百分比\n   分布函数   CUME_DIST()          累积分布值\n   前后函数   LAG(expr, n)         返回当前行的往前数第n行的expr的值。expr是表中字段名\n   前后函数   LEAD(expr, n)        返回当前行的往后数第n行的expr的值。expr是表中字段名\n   首尾函数   FIRST_VALUE(expr)    返回第一个expr的值。expr是表中字段名\n   首尾函数   LAST_VALUE(expr)     返回最后一个expr的值。expr是表中字段名\n   其他函数   NTH_VALUE(expr, n)   返回第n个expr的值。expr是表中字段名\n   其他函数   NTILE(n)             将分区中的有序数据分成n个桶，记录桶编号\n\n\n18.2.2 语法#\n\n\n\n或\n\n\n\n * OVER：指定窗口函数的范围。\n   \n   * 如果省略括号中的内容（即函数 OVER()），则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录并进行计算。\n   \n   * 如果OVER()中使用了ORDER BY，FROM后边建议不要使用ORDER BY了，否则结果出人意料：\n     \n     当sql语句中的order by子句里的内容和窗口函数over()中的order\n     by子句里的内容一样，那么sql语句中的排序将先执行,窗口函数在分析时就不必再排序；order by\n     字段两者不一致时，那么sql语句中的排序将最后在窗口函数分析结束后执行排序。所以如果在over中已经添加了order\n     by…，就不建议在from后面再添加相同的order by。二者一致的话还好(效果一样，没有差别)，但不一致时结果有时就可能令人费解了。\n   \n   * OVER ([PARTITION BY 字段名1 ORDER BY 字段名2 ASC|DESC])表示根据字段名1进行分组，在分组内按照字段名2排序\n\n * PARTITION BY：指定窗口函数按照哪些字段进行分组。\n   \n   分组后，窗口函数可以在每个分组中分别执行。\n\n * ORDER BY：指定窗口函数按照哪些字段进行排序。\n   \n   执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号\n\n * WINDOW 子句：可以只用WINDOW子句为窗口函数命名，在窗口函数的OVER关键字后边直接使用窗口名即可\n\n\n18.2.3 序号函数#\n\n① ROW_NUMBER()#\n\n * 语法：ROW_NUMBER() OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n\n * 含义：\n   \n   * 按照字段1分组，分组内按照字段2排序，然后按照排好的顺序给每个分组内的记录按照顺序编号。\n   * 每个分组内的编号是连续且唯一的。\n   * 如果PARTITION BY 字段1省略，表示整个表是一个分组\n   * 如果ORDER BY 字段名2省略，按照默认排序方式进行排序\n\n * 举例：查询goods中商品信息，并给不用类型的服装以价格由高到低进行编号，且保持编号的唯一性。\n   \n   \n\n② RANK()函数#\n\n * 语法：RANK() OVER ([PARTITION BY 字段1 ]ORDER BY 字段名2 ASC|DESC)\n\n * 含义：\n   \n   * 按照字段1分组，分组内按照字段2排序，然后按照排好的顺序给每个分组内的记录按照顺序编号。\n   * 序号是可以重复的。\n   * 会跳过重复序号，如1、2、2、4\n\n * 说明：OVER()中必须使用ORDER BY 语句，否则排序序号全都为1\n\n * 举例：查询goods中商品信息，并给不用类型的服装以价格由高到低进行编号，且跳过重复序号\n   \n   \n\n③ DENSE_RANK()函数#\n\n * 语法：DENSE_RANK() OVER ([PARTITION BY 字段1 ]ORDER BY 字段名2 ASC|DESC)\n\n * 含义：\n   \n   * 按照字段1分组，分组内按照字段2排序，然后按照排好的顺序给每个分组内的记录按照顺序编号。\n   * 序号是可以重复的。\n   * 不会跳过重复序号，如1、2、2、3\n\n * 说明：OVER()中必须使用ORDER BY 语句，否则排序序号全都为1\n\n * 举例：查询goods中商品信息，并给不用类型的服装以价格由高到低进行编号，且不要跳过重复序号。\n   \n   \n\n\n18.2.4 分布函数#\n\n① PERCENT_RANK()函数#\n\n * 语法：PERCENT_RANK() OVER ([PARTITION BY 字段1 ]ORDER BY 字段名2 ASC|DESC)\n\n * 含义：\n   \n   * 按照RANK()函数计算出来的编号，计算当前分组中每条记录的等级值百分比\n   * 公式为(rank-1)/(rows-1)，其中rank为使用RANK()产生的序号，rows为当前分组中的总记录条数\n\n * 说明：OVER()中必须使用ORDER BY语句，否则计算出来的值为0（因为rank=1）\n\n * 举例：查询goods中商品信息，并计算不同类别的商品价格的等级百分比\n   \n   \n\n② CUME_DIST()函数#\n\n * 语法：CUME_DIST() OVER ([PARTITION BY 字段1 ]ORDER BY 字段名2 ASC|DESC)\n\n * 含义：计算每条记录在当前分组中所占百分比，公式如下：\n   \n   * 使用ASC升序排序：根据公式当前分组中小于等于当前值的数据行数 / 该分组总行数totalrows计算每条记录的百分比\n   * 使用DESC降序排序：根据公式当前分组中大于等于当前值的数据行数 / 该分组总行数totalrows计算每条记录的百分比\n\n * 说明：OVER()中必须使用ORDER BY语句，否则计算出来的值都为1\n\n * 举例：查询goods中商品信息，并计算不同类别的商品价格小于等于当前商品价格的比例\n   \n   \n\n\n18.2.5 前后函数#\n\n也称偏移量函数\n\n① LAG(expr)函数#\n\n * 语法：LAG(expr[,n, [default]]) OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n\n * 含义：查询当前记录的往前数第n个expr的值。参数说明如下：\n   \n   * expr：必填。表示当前记录的哪个字段\n   * n：选填。默认为1\n   * default：选填。默认为null。表示当前行如果是当前分区内第一条则显示default值。\n\n * 举例：查询商品id为1的商品销售额，并计算当天销售额与前1天销售额的差值\n   \n   \n\n② LEAD(expr)函数#\n\n * 语法：LEAD(expr[,n, [default]]) OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n * 含义：查询当前记录的往后数第n个expr的值。参数说明如下：\n   * expr：必填。表示当前记录的哪个字段\n   * n：选填。默认为1\n   * default：选填。默认为null。表示当前行如果是当前分区内最后一条则显示default值。\n\n\n18.2.6 首尾函数#\n\n① FIRST_VALUE(expr)函数#\n\n * 语法：FIRST_VALUE(expr) OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n\n * 含义：返回当前分组（排序后）的第一个值\n\n * 举例：查询商品id为1的商品销售额，并计算当天销售额与最大销售额的差值\n   \n   \n\n② LAST_VALUE(expr)函数#\n\n * 语法：LAST_VALUE(expr) OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n * 含义：返回当前分组（排序后）的最后一个值\n\n\n18.2.7 聚合函数#\n\n聚合函数：SUM()、AVG()、COUNT()、MIN()、MAX()\n\n举例：以SUM()为例，查询商品每天销售额\n\n\n\n\n18.2.8 其他函数#\n\n① NTH_VALUE(expr,n)函数#\n\n * 语法：NTH_VALUE(expr,n) OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n\n * 含义：返回第n条记录的expr值\n\n * 举例：查询goods中商品信息，并计算不同商品类型中排名第2高的价格信息\n   \n   \n\n② NTILE(n)函数#\n\n * 语法：NTILE(n) OVER ([PARTITION BY 字段1 ORDER BY 字段名2 ASC|DESC])\n\n * 含义：在每个分组中，将数据分为n个桶（组），并记录桶编号\n\n * 举例：查询goods中商品信息，并将不同商品类型中的商品按照价格降序分为3个桶（组）\n   \n   \n\n\n18.2.9 WINDOW语法的使用#\n\n * 18.2.8-②例子可改写为：\n   \n   \n\n * 18.2.4-①例子可改写为：\n   \n   \n\n\n18.2.10 小结-窗口函数的特点#\n\n * 窗口函数可以对数据进行分组，并且可以在组内排序\n * 窗口函数不会因分组而减少原表中的行数\n\n\n18.2.9 测试中用到的表及数据#\n\n\n\n\n18.3 新特性2-公用表表达式#\n\n> 概念\n\n> 分类\n\n按照语法结构和执行方式的不同，可以分为两类：\n\n * 普通公用表表达式\n * 递归公用表表达式\n\n\n18.3.1 普通公用表表达式#\n\n * 语法：\n   \n   \n\n * 举例：查询员工所在部门的详细信息。\n   \n   因为有的部门没有员工，这些部门是不能显示的，所以不能直接返回部门表信息。\n   \n   \n\n\n18.3.2 递归公用表表达式#\n\n * 语法：\n   \n   \n   \n   * 查询语句①由两部分组成：\n     \n     * 种子查询：用来获取递归的初始值。这个查询只运行一次，以创建初始数据集\n     \n     * 递归查询：递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。\n       \n       递归查询中，不用或慎用外连接，最好使用内连接（[inner] join ... on）\n     \n     * 二者通过关键字UNION [ALL]进行连接\n\n * 举例：针对于我们常用的emps表，包含employee_id，last_name和manager_id三个字段。如果a是b\n   的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下 属。\n   要求：使用递归公用表表达式查询出所有具有下下属身份的人员信息。\n   \n   * ① 通过种子查询，获取公司最大领导，即第一层员工。使用n记录员工层级，第一层员工记n=1\n   * ② 开始进行递归查询。查询出以公用表表达式中员工为领导的员工，并记录该层员工的n值为公用表表达式中的n值+1，递归返回\n   * ③ 最后的查询，筛选出公用表表达式中属于下下属身份的员工，即n>=3的员工\n   \n   \n\n\n18.3.3 小结#\n\n公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根 节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。","routePath":"/tang/mysql/18_MySQL8.0新特性","lang":"","toc":[{"text":"18.1 MySQL80.0新特性概述","id":"181-mysql800新特性概述","depth":2,"charIndex":3},{"text":"18.1.1 MySQL8.0新增特性","id":"1811-mysql80新增特性","depth":3,"charIndex":26},{"text":"18.1.2 MySQL8.0移除的就特性","id":"1812-mysql80移除的就特性","depth":3,"charIndex":2022},{"text":"18.2 新特性1-窗口函数","id":"182-新特性1-窗口函数","depth":2,"charIndex":3849},{"text":"18.2.1 概述","id":"1821-概述","depth":3,"charIndex":3867},{"text":"18.2.2 语法","id":"1822-语法","depth":3,"charIndex":4676},{"text":"18.2.3 序号函数","id":"1823-序号函数","depth":3,"charIndex":5379},{"text":"18.2.4 分布函数","id":"1824-分布函数","depth":3,"charIndex":6259},{"text":"18.2.5 前后函数","id":"1825-前后函数","depth":3,"charIndex":6928},{"text":"18.2.6 首尾函数","id":"1826-首尾函数","depth":3,"charIndex":7457},{"text":"18.2.7 聚合函数","id":"1827-聚合函数","depth":3,"charIndex":7762},{"text":"18.2.8 其他函数","id":"1828-其他函数","depth":3,"charIndex":7840},{"text":"18.2.9  WINDOW语法的使用","id":"1829--window语法的使用","depth":3,"charIndex":-1},{"text":"18.2.10 小结-窗口函数的特点","id":"18210-小结-窗口函数的特点","depth":3,"charIndex":8269},{"text":"18.2.9 测试中用到的表及数据","id":"1829-测试中用到的表及数据","depth":3,"charIndex":8341},{"text":"18.3 新特性2-公用表表达式","id":"183-新特性2-公用表表达式","depth":2,"charIndex":8364},{"text":"18.3.1 普通公用表表达式","id":"1831-普通公用表表达式","depth":3,"charIndex":8445},{"text":"18.3.2 递归公用表表达式","id":"1832-递归公用表表达式","depth":3,"charIndex":8554},{"text":"18.3.3 小结","id":"1833-小结","depth":3,"charIndex":9130}],"domain":"","frontmatter":{},"version":""},{"id":164,"title":"19 附：表及其数据","content":"#\n\n以上笔记中用到的表及其数据：\n\n","routePath":"/tang/mysql/19_表及其数据","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":165,"title":"99 MySQL常见问题的解决","content":"#\n\n\n1.MySQL8.0时间与系统时间相差8小时#\n\n","routePath":"/tang/mysql/99_MySQL常见问题的解决","lang":"","toc":[{"text":"1.MySQL8.0时间与系统时间相差8小时","id":"1mysql80时间与系统时间相差8小时","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":166,"title":"4.在服务器A上实现免密登录服务器B","content":"CentOS7root#\n\n本笔记实现的是在服务器A上使用ssh免密登录到服务器B。\n\n\n1.在服务器A上生成密钥文件#\n\n\n\n执行过程中一路回车即可。\n\n\n\n执行完成后，会在/root下生成.ssh文件夹，该文件夹下会生成id_rsa和id_rsa.pub文件。\n\n\n2.在服务器A上将密钥发送到服务器B上#\n\n\n\n\n\n\n3.修改服务器B上的文件权限#\n\n修改服务器B上的/root/.ssh文件夹和/root/.ssh/authorized_keys文件权限分别为700、600\n\n\n4.在服务器A上实现免密登录服务器B#\n\n","routePath":"/tang/server/CentOS7root账号免密登录","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":167,"title":"CentOS7安装GitLab","content":"#\n\n本教程中，防火墙是关闭的。\n\n\n1 安装ssh#\n\n\n\n\n2 安装 Postfix#\n\nPostfix 是用来发送通知邮件的。\n\n\n\n\n3 安装 policycoreutils-python#\n\npolicycoreutils-python 是gitlab的一个依赖。\n\n\n\n\n4 安装GitLab#\n\n\n\n安装过程需要些时间，如果出现下图，则说明安装成功。\n\n\n\n\n5 配置GitLab#\n\nGitLab相关参数配置都在 /etc/gitlab/gitlab.rb 文件里，每次配置完成之后需要执行gitlab-ctl\nreconfigure，重新配置才能生效。\n\n\n5.1 配置 external_url#\n\n修改 external_url ‘[http://ip:address]‘为真实的服务器IP和端口。\n\n\n\n\n5.2 配置邮件服务#\n\n以qq邮箱向外发送gitlab的相关邮件为例。\n\n5.2.1 开启qq邮箱的STMP服务#\n\n\n\n5.2.2 修改gitlab配置#\n\n\n\n\n5.3 重启gitlab#\n\n\n\ngitlab-ctl reconfigure（等待时间较长） 若安装过程遇到“ ruby_block[wait for redis service\nsocket] action run”处卡住，可通过ctrl+c退出，并执行systemctl restart\ngitlab-runsvdir，再继续执行gitlab-ctl reconfigure，如安装过程遇到报错信息，可重复执行gitlab-ctl\nreconfigure。\n\n\n5.4 测试邮件是否生效#\n\n\n\n\n\n\n5.5 设置root账号密码#\n\n打开浏览器，输入gitlab的ip+端口号，如果未设置root账号的密码，会自动跳转到如下界面，在该界面里便可设置root账号密码。\n\n\n\n\n6 gitlab的迁移#\n\n\n6.1 gitlab版本的升级#\n\ngitlab迁移，需要保证两台服务器gitlab版本一致。\n\n\n\n如果版本号不一致，则需要对gitlab进行升级。\n\n\n\n\n6.2 开始迁移#\n\n\n\n\n7 卸载gitlab#\n\n如不需要，可不操作\n\n","routePath":"/tang/server/CentOS7安装GitLab","lang":"","toc":[{"text":"1 安装ssh","id":"1-安装ssh","depth":2,"charIndex":18},{"text":"2 安装 Postfix","id":"2-安装-postfix","depth":2,"charIndex":31},{"text":"3 安装 policycoreutils-python","id":"3-安装-policycoreutils-python","depth":2,"charIndex":70},{"text":"4 安装GitLab","id":"4-安装gitlab","depth":2,"charIndex":141},{"text":"5 配置GitLab","id":"5-配置gitlab","depth":2,"charIndex":186},{"text":"5.1 配置 external_url","id":"51-配置-external_url","depth":3,"charIndex":287},{"text":"5.2 配置邮件服务","id":"52-配置邮件服务","depth":3,"charIndex":364},{"text":"5.2.1 开启qq邮箱的STMP服务","id":"521-开启qq邮箱的stmp服务","depth":4,"charIndex":402},{"text":"5.2.2 修改gitlab配置","id":"522-修改gitlab配置","depth":4,"charIndex":426},{"text":"5.3 重启gitlab","id":"53-重启gitlab","depth":3,"charIndex":448},{"text":"5.4 测试邮件是否生效","id":"54-测试邮件是否生效","depth":3,"charIndex":682},{"text":"5.5 设置root账号密码","id":"55-设置root账号密码","depth":3,"charIndex":702},{"text":"6 gitlab的迁移","id":"6-gitlab的迁移","depth":2,"charIndex":790},{"text":"6.1 gitlab版本的升级","id":"61-gitlab版本的升级","depth":3,"charIndex":805},{"text":"6.2 开始迁移","id":"62-开始迁移","depth":3,"charIndex":885},{"text":"7 卸载gitlab","id":"7-卸载gitlab","depth":2,"charIndex":899}],"domain":"","frontmatter":{},"version":""},{"id":168,"title":"CentOS7安装jdk1.8","content":"#\n\n\n1 官网下载jdk#\n\nhttps://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html\n\n\n\n\n2 安装#\n\n创建/usr/java8文件夹，将压缩包上传至该文件夹内，进行解压。\n\n\n\n\n3 配置JDK#\n\n编辑 /etc/profile文件，进行全局变量的设置，在文件末尾添加如下内容即可：\n\n\n\n\n\n\n4 让环境变量生效#\n\n\n\n\n5 检查是否安装成功#\n\n\n\n","routePath":"/tang/server/CentOS7安装jdk1.8","lang":"","toc":[{"text":"1 官网下载jdk","id":"1-官网下载jdk","depth":2,"charIndex":3},{"text":"2 安装","id":"2-安装","depth":2,"charIndex":94},{"text":"3 配置JDK","id":"3-配置jdk","depth":2,"charIndex":140},{"text":"4 让环境变量生效","id":"4-让环境变量生效","depth":2,"charIndex":199},{"text":"5 检查是否安装成功","id":"5-检查是否安装成功","depth":2,"charIndex":214}],"domain":"","frontmatter":{},"version":""},{"id":169,"title":"使用yum源安装MySQL5.7 CentOS7安装mysql5.7","content":"#\n\n\n1.配置yum源#\n\n\n1.1下载yum源#\n\n\n\n\n1.2安装yum源#\n\n\n\n\n1.3查看mysql版本#\n\n\n\n\n\n\n2.安装#\n\n如果安装5.7.x版本，直接安装即可；如果安装5.6.x版本，需要先修改mysql的repo文件。\n\n\n2.1 安装5.7.x版本#\n\n\n\n\n2.2安装5.6.x版本#\n\n修改文件 /etc/yum.repos.d/mysql-community.repo ，如下图所示\n\n\n\n\n3.启动mysql#\n\n\n\n\n4.登录mysql#\n\n\n4.1查看mysql初始密码#\n\n\n\n\n\n\n4.2登录#\n\n\n\n\n4.3 修改密码#\n\n\n\n\n4.4设置mysql允许远程访问#\n\n","routePath":"/tang/server/CentOS7安装mysql5.7(使用yum源安装)","lang":"","toc":[{"text":"1.配置yum源","id":"1配置yum源","depth":2,"charIndex":3},{"text":"1.1下载yum源","id":"11下载yum源","depth":3,"charIndex":15},{"text":"1.2安装yum源","id":"12安装yum源","depth":3,"charIndex":30},{"text":"1.3查看mysql版本","id":"13查看mysql版本","depth":3,"charIndex":45},{"text":"2.安装","id":"2安装","depth":2,"charIndex":65},{"text":"2.1 安装5.7.x版本","id":"21-安装57x版本","depth":3,"charIndex":124},{"text":"2.2安装5.6.x版本","id":"22安装56x版本","depth":3,"charIndex":143},{"text":"3.启动mysql","id":"3启动mysql","depth":2,"charIndex":212},{"text":"4.登录mysql","id":"4登录mysql","depth":2,"charIndex":227},{"text":"4.1查看mysql初始密码","id":"41查看mysql初始密码","depth":3,"charIndex":240},{"text":"4.2登录","id":"42登录","depth":3,"charIndex":262},{"text":"4.3 修改密码","id":"43-修改密码","depth":3,"charIndex":273},{"text":"4.4设置mysql允许远程访问","id":"44设置mysql允许远程访问","depth":3,"charIndex":287}],"domain":"","frontmatter":{},"version":""},{"id":170,"title":"8.将redis添加为服务","content":"CentOS7安装redis#\n\n\n1.安装gcc#\n\n\n\n\n2.创建/usr/local/redis文件夹#\n\n\n\n\n3.下载redis安装包并解压#\n\n\n\n\n\n\n4.开始安装#\n\n\n\n如果执行make的时候报错： redis编译报致命错误：jemalloc/jemalloc.h：没有那个文件或目录 ，将make命令改为make\nMALLOC=libc\n\n\n5.设置后台启动redis#\n\n\n\n将redis-4.0.6/redis.conf文件中的daemonize改为yes，如下图\n\n\n\n启动命令为：\n\n\n\n\n6.设置密码#\n\n\n\n将redis-4.0.6/redis.conf文件中的requirepass的注释取消，并设置密码，如下图：\n\n\n\n启动命令为：\n\n\n\n\n7.设置远程访问#\n\n将redis-4.0.6/redis.conf文件中的bind 127.0.0.1的注释掉，并将protected-mode值改为no，如下图：\n\n\n\n\n8.将redis添加为服务#\n\n\n8.1复制redis脚本#\n\n将脚本文件 redis_init_script 复制到/etc/rc.d/init.d/，并改名为redis:\n\n\n\n\n\n\n8.2更改redis脚本#\n\n\n\n\n\n\n8.3复制redis配置文件#\n\n\n\n\n8.4注册服务#\n\n\n\n\n8.5启动服务#\n\n\n\n\n8.6可能遇到的问题#\n\n使用systemctl start redis启动redis时，可能遇到如下问题:\n\n\n\n解决方法：直接删掉/var/run/redis_6379.pid即可。\n\n","routePath":"/tang/server/CentOS7安装redis","lang":"","toc":[{"text":"8.1复制redis脚本","id":"81复制redis脚本","depth":2,"charIndex":443},{"text":"8.2更改redis脚本","id":"82更改redis脚本","depth":2,"charIndex":520},{"text":"8.3复制redis配置文件","id":"83复制redis配置文件","depth":2,"charIndex":540},{"text":"8.4注册服务","id":"84注册服务","depth":2,"charIndex":560},{"text":"8.5启动服务","id":"85启动服务","depth":2,"charIndex":573},{"text":"8.6可能遇到的问题","id":"86可能遇到的问题","depth":2,"charIndex":586}],"domain":"","frontmatter":{},"version":""},{"id":171,"title":"CentOS7平滑升级nginx","content":"Welcome to nginx!\n\nIf you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.\n\nFor online documentation and support please refer to nginx.org.\nCommercial support is available at nginx.com.\n\nThank you for using nginx.\n\n\nWelcome to nginx!\n\nIf you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.\n\nFor online documentation and support please refer to nginx.org.\nCommercial support is available at nginx.com.\n\nThank you for using nginx.\n\n\nWelcome to nginx!\n\nIf you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.\n\nFor online documentation and support please refer to nginx.org.\nCommercial support is available at nginx.com.\n\nThank you for using nginx.","routePath":"/tang/server/CentOS7平滑升级nginx","lang":"","toc":[{"text":"1 安装旧版本nginx","id":"1-安装旧版本nginx","depth":2,"charIndex":-1},{"text":"1.1 解压 nginx-1.14.2.tar.gz","id":"11-解压-nginx-1142targz","depth":3,"charIndex":-1},{"text":"1.2 准备nginx安装路径","id":"12-准备nginx安装路径","depth":3,"charIndex":-1},{"text":"1.3 编译安装","id":"13-编译安装","depth":3,"charIndex":-1},{"text":"1.4 修改nginx端口","id":"14-修改nginx端口","depth":3,"charIndex":-1},{"text":"1.5 运行","id":"15-运行","depth":3,"charIndex":-1},{"text":"1.6 查看nginx版本号","id":"16-查看nginx版本号","depth":3,"charIndex":-1},{"text":"2 安装新版本nginx","id":"2-安装新版本nginx","depth":2,"charIndex":-1},{"text":"2.1 解压nginx-1.22.0","id":"21-解压nginx-1220","depth":3,"charIndex":-1},{"text":"2.2 查看旧版本配置","id":"22-查看旧版本配置","depth":3,"charIndex":-1},{"text":"2.3 编译","id":"23-编译","depth":3,"charIndex":-1},{"text":"3 升级","id":"3-升级","depth":2,"charIndex":-1},{"text":"3.1 备份旧版本，用新版本替换","id":"31-备份旧版本用新版本替换","depth":3,"charIndex":-1},{"text":"3.2 测试配置文件是否正确","id":"32-测试配置文件是否正确","depth":3,"charIndex":-1},{"text":"3.3 查看nginx进程","id":"33-查看nginx进程","depth":3,"charIndex":-1},{"text":"3.4 发送USR2信号","id":"34-发送usr2信号","depth":3,"charIndex":-1},{"text":"3.5 查看nginx进程","id":"35-查看nginx进程","depth":3,"charIndex":-1},{"text":"3.6 发送WINCH信号","id":"36-发送winch信号","depth":3,"charIndex":-1},{"text":"3.7 访问验证","id":"37-访问验证","depth":3,"charIndex":-1},{"text":"3.8 发送HUP信号（如果需要回滚的话）","id":"38-发送hup信号如果需要回滚的话","depth":3,"charIndex":-1},{"text":"3.9 发送QUIT信号","id":"39-发送quit信号","depth":3,"charIndex":-1},{"text":"3.10 验证nginx版本号，并进行访问测试","id":"310-验证nginx版本号并进行访问测试","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":172,"title":"CentOS7InstallJenkins","content":"#\n\n\n1 检查jdk是否安装#\n\n\n\n\n\n未安装的话，需要安装jdk。\n\n\n2 下载安装包#\n\n安装jenkins时，需要匹配jdk的版本，可在Jenkins官网中查看。\n因为我的jdk版本是1.8，所以我选择jenkins-2.346-1.1.noarch.rpm版本。\n\n\n\n\n3 安装#\n\n\n\n\n\n\n4 修改jenkins配置文件#\n\njenkins相关配置都在文件/etc/sysconfig/jenkins中\n\n\n4.1 修改jenkins端口#\n\n进入/etc/sysconfig/jenkins文件中，将JENKINS_PORT改为自己想要的即可。\n\n\n\n\n\n\n4.2修改jenkins默认的操作用户#\n\nlinux下jenkins默认使用jenkins用户进行脚本和文件的操作。如果不修改，在部署项目时需要调整涉及到的文件和目录的操作权限。\n\n为避免操作权限不足问题，可以调整jenkins配置文件，将用户修改为root用户。即将JENKINS_USER=\"jenkins\"调整为JENKINS_USER\n=“root”。当然也可以忽略此步骤\n\n\n\n\n5 配置jdk#\n\n\n\n\n\n\n6 运行#\n\n\n\n\n7 打开#\n\n在浏览器中输入ip+端口号，即可打开jenkins界面。首次登录需要按照页面提示获取登录密码。\n\n\n8 jenkin设置#\n\n\n8.1 选择安装插件#\n\n第一个为默认安装，第二个为手动安装。选择第一个即可。\n\n\n8.2设置管理员账号#","routePath":"/tang/server/CentOs7安装jenkins","lang":"","toc":[{"text":"1 检查jdk是否安装","id":"1-检查jdk是否安装","depth":2,"charIndex":3},{"text":"2 下载安装包","id":"2-下载安装包","depth":2,"charIndex":38},{"text":"3 安装","id":"3-安装","depth":2,"charIndex":141},{"text":"4 修改jenkins配置文件","id":"4-修改jenkins配置文件","depth":2,"charIndex":153},{"text":"4.1 修改jenkins端口","id":"41-修改jenkins端口","depth":3,"charIndex":212},{"text":"4.2修改jenkins默认的操作用户","id":"42修改jenkins默认的操作用户","depth":3,"charIndex":288},{"text":"5 配置jdk","id":"5-配置jdk","depth":2,"charIndex":484},{"text":"6 运行","id":"6-运行","depth":2,"charIndex":499},{"text":"7 打开","id":"7-打开","depth":2,"charIndex":509},{"text":"8 jenkin设置","id":"8-jenkin设置","depth":2,"charIndex":566},{"text":"8.1 选择安装插件","id":"81-选择安装插件","depth":3,"charIndex":580},{"text":"8.2设置管理员账号","id":"82设置管理员账号","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":173,"title":"4.附","content":"借助阿里云服务器使用frp做内网穿透#\n\n\n1.安装包准备#\n\nfrp git地址：https://github.com/fatedier/frp/releases\n\n也可以使用wget命令直接下载：\n\n\n\n\n2.服务端配置frp#\n\n\n2.1解压#\n\n\n\n\n2.2编辑frps.ini文件#\n\n注：此处的vhost_http_port、dashboard_port、bind_port需要设置对外开放。\n\nStep1.在阿里云后台添加安全组。\n\nStep2.在防火墙放开以上单个端口\n\n\n\n\n2.3启动frp服务端#\n\n\n\n\n2.4查看启动日志#\n\n若输出以下信息，说明启动成功。\n\n\n2.5登录frp管理后台#\n\nhttp://120.27.54.55:7500/\n\n\n3.客户端配置frp#\n\n\n3.1解压#\n\n\n\n\n3.2配置frpc.ini#\n\n可以先将无用文件frps、frps.ini、frps_full.ini文件删掉。\n\n\n3.3启动frp客户端#\n\n\n\n\n3.4查看启动日志#\n\n若输出以下信息，说明启动成功。\n\n至此，内网穿透设置成功。\n\n\n4.附#\n\n如果想使用frp映射多个项目，需要有域名。具体操作可参考：https://blog.csdn.net/Aria_Miazzy/article/details/1\n00055828","routePath":"/tang/server/借助阿里云服务器使用frp做内网穿透","lang":"","toc":[{"text":"2.1解压","id":"21解压","depth":2,"charIndex":118},{"text":"2.2编辑frps.ini文件","id":"22编辑frpsini文件","depth":2,"charIndex":129},{"text":"2.3启动frp服务端","id":"23启动frp服务端","depth":2,"charIndex":246},{"text":"2.4查看启动日志","id":"24查看启动日志","depth":2,"charIndex":263},{"text":"2.5登录frp管理后台","id":"25登录frp管理后台","depth":2,"charIndex":293},{"text":"3.1解压","id":"31解压","depth":2,"charIndex":350},{"text":"3.2配置frpc.ini","id":"32配置frpcini","depth":2,"charIndex":361},{"text":"3.3启动frp客户端","id":"33启动frp客户端","depth":2,"charIndex":420},{"text":"3.4查看启动日志","id":"34查看启动日志","depth":2,"charIndex":437}],"domain":"","frontmatter":{},"version":""},{"id":174,"title":"1.自定义主题","content":"#\n\n直接导入pixyll.css即可。\n\n\n2.设置字体颜色#\n\n打开文件->偏好设置->Markdown，勾选内联公式，然后重启Typora后，才可以用内联公式修改文字颜色。\n\n> 使用方法\n\n\n\neg：$\\textcolor{red}{输入红色字体的例子}$\n\n> 颜色公式代码\n\n","routePath":"/tang/typora配置/1","lang":"","toc":[{"text":"2.设置字体颜色","id":"2设置字体颜色","depth":2,"charIndex":22}],"domain":"","frontmatter":{},"version":""},{"id":175,"title":"记一次小程序接口的发布","content":"#\n\n\n0 前言#\n\n本文是记录某个小程序后台接口的部署全过程。\n\n因为小程序需要使用https的域名，所以，本文内容包括域名的申请、域名的解析、免费https证书的申请与配置。\n\n\n1 申请域名#\n\n本文是在阿里云申请的域名，具体操作如下：\n\n> Step1. 进入域名注册页面\n\n在阿里云官网搜索“域名”，在弹出框的下拉列表中点击“域名注册”，跳转到域名注册页面。\n\n或者，直接通过网址进入域名注册页面。\n\n\n\n> Step2. 选择域名，进行购买\n\n\n\n> Step3. 查看已购买的域名\n\n\n\n\n2 域名备案#\n\n因为我的域名和服务器都是阿里云的，所以在阿里云上备案，备案地址为：阿里云网站备案\n\n具体操作按照按照网页上的表单填写即可。\n\n\n3 域名解析#\n\n> Step1. 在域名列表页面，点击“解析”，进入域名解析页面\n\n\n\n> Step2. 解析域名\n\n\n\n\n4 申请免费https证书#\n\n说明： 免费证书一般仅用于个人网站或测试使用，不建议业务成熟的企业类型网站使用。\n\n每个经过实名认证的阿里云账号（主账号），在每一个自然年内，可以通过数字证书管理服务的免费证书购买页，免费获取20个DV单域名证书【免费试用】（参考文档）。\n\n因此，申请免费https证书，需要先申请20个DV单域名证书，然后在“数字证书管理服务”中创建证书、申请证书、下载证书等。\n\n> Step1. 申请DV单域名证书\n\n申请DV单域名证书链接\n\n\n\n> Step2. 创建证书\n\n在【数字证书管理服务】-【SSL证书】-【免费证书】标签中，创建证书。\n\n\n\n> Step3. 证书申请\n\n\n\n> Step4. 证书审核\n\n官方说，证书审核需要1~2个工作日，但是我申请的两个10分钟之内就通过了，所以可以稍微耐心等待下。审核通过之后会有短信和邮件通知。\n\n\n5 配置https证书#\n\n\n5.1 配置Tomcat类型服务器的证书#\n\n说明： 因为小程序接口是SpringBoot项目，所以尝试配置一次Tomcat类型服务器的证书。\n\n> Step1. 下载Tomcat服务器对应的证书\n\n\n\n> Step2. 将证书放到项目的resources文件夹下\n\n\n\n> Step3. 在项目的application.yaml配置文件中，添加如下配置\n\n\n\n证书别名查看命令\n\n\n\n> Step4. 项目启动与测试\n\n将项目打包，上传至服务器并运行。项目运行成功后，浏览器访问 【 https://域名 】 。如果能有应答，表示https设置完成。\n\n\n5.2 配置nginx类型服务器的证书#\n\n> Step1. 下载Nginx服务器对应的证书\n\n\n\n> Step2. 上传nginx证书到服务器\n\n在nginx安装路径下，新建cert文件夹，将nginx证书上传至该文件夹\n\n\n\n> Step3. 配置nginx\n\n我的nginx版本号是1.22.0。低于1.15.0版本号的，需要将listen 443 ssl;替换成listen 443; ssl on;。\n\n\n\n> Step4. 测试\n\n启动nginx，浏览器访问 【 https://域名 】 。如果能有应答，表示https设置完成\n\n\n附：nginx的安装#\n\n> Step1. 下载nginx安装包\n\nnginx下载地址\n\n> Step2. 上传nginx安装包到服务器并解压\n\n\n\n\n\n> Step3. 创建文件夹，作为nginx的安装路径\n\n\n\n\n\n> Step4. 安装\n\n\n\n> Step5. 查看nginx安装结果\n\n\n\n\n\n> Step6. 启动nginx，并访问\n\n\n\n\n\n> Step7. nginx常用命令\n\n","routePath":"/tang/项目上线/xiaochengxu","lang":"","toc":[{"text":"0 前言","id":"0-前言","depth":2,"charIndex":3},{"text":"1 申请域名","id":"1-申请域名","depth":2,"charIndex":91},{"text":"2 域名备案","id":"2-域名备案","depth":2,"charIndex":251},{"text":"3 域名解析","id":"3-域名解析","depth":2,"charIndex":324},{"text":"4 申请免费https证书","id":"4-申请免费https证书","depth":2,"charIndex":387},{"text":"5 配置https证书","id":"5-配置https证书","depth":2,"charIndex":776},{"text":"5.1 配置Tomcat类型服务器的证书","id":"51-配置tomcat类型服务器的证书","depth":3,"charIndex":791},{"text":"5.2 配置nginx类型服务器的证书","id":"52-配置nginx类型服务器的证书","depth":3,"charIndex":1070},{"text":"附：nginx的安装","id":"附nginx的安装","depth":2,"charIndex":1343}],"domain":"","frontmatter":{},"version":""}]