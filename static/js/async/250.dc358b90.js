"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["250"],{32523:function(n,r,e){e.r(r),e.d(r,{default:function(){return l}});var a=e(85893),i=e(50065);function s(n){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",h3:"h3",div:"div",ul:"ul",li:"li",h4:"h4",h5:"h5"},(0,i.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.h1,{id:"函数的扩展",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的扩展",children:"#"}),"函数的扩展"]}),"\n",(0,a.jsxs)(r.h2,{id:"函数参数的默认值",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#函数参数的默认值",children:"#"}),"函数参数的默认值"]}),"\n",(0,a.jsx)(r.p,{children:"ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function log(x, y) {\r\n    y = y || 'World';\r\n    console.log(x, y);\r\n}\r\n\r\nlog('Hello') // Hello World\r\nlog('Hello', 'China') // Hello China\r\nlog('Hello', '') // Hello World\n"})}),"\n",(0,a.jsx)(r.p,{children:"ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。参数变量是默认声明的，所以不能用let或const再次声明。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function Point(x = 0, y = 0) {\r\n    this.x = x;\r\n    this.y = y;\r\n}\r\n\r\nconst p = new Point();\r\np // { x: 0, y: 0 }\r\n\r\n//使用参数默认值时，函数不能有同名参数。\r\n\n"})}),"\n",(0,a.jsxs)(r.h3,{id:"与解构赋值默认值结合使用",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#与解构赋值默认值结合使用",children:"#"}),"与解构赋值默认值结合使用"]}),"\n",(0,a.jsx)(r.p,{children:"参数默认值可以与解构赋值的默认值，结合起来使用。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function foo({x, y = 5}) {\r\n    console.log(x, y);\r\n}\r\n\r\nfoo({}) // undefined 5\r\nfoo({x: 1}) // 1 5\r\nfoo({x: 1, y: 2}) // 1 2\r\nfoo() // TypeError: Cannot read property 'x' of undefined\n"})}),"\n",(0,a.jsx)(r.p,{children:"上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function foo({x, y = 5} = {}) {\r\n    console.log(x, y);\r\n}\r\n\r\nfoo() // undefined 5\n"})}),"\n",(0,a.jsxs)(r.h3,{id:"参数默认值的位置",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#参数默认值的位置",children:"#"}),"参数默认值的位置"]}),"\n",(0,a.jsx)(r.p,{children:"通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"// 例一\r\nfunction f(x = 1, y) {\r\n    return [x, y];\r\n}\r\n\r\nf() // [1, undefined]\r\nf(2) // [2, undefined]\r\n// f(, 1) // 报错\r\nf(undefined, 1) // [1, 1]\r\n// 例二\r\nfunction f(x, y = 5, z) {\r\n    return [x, y, z];\r\n}\r\n\r\nf() // [undefined, 5, undefined]\r\nf(1) // [1, 5, undefined]\r\n// f(1, ,2) // 报错\r\nf(1, undefined, 2) // [1, 5, 2]\n"})}),"\n",(0,a.jsx)(r.p,{children:"上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。如果传入undefined，将触发该参数等于默认值，null则没有这个效果。"}),"\n",(0,a.jsxs)(r.h3,{id:"函数的-length-属性",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的-length-属性",children:"#"}),"函数的 length 属性"]}),"\n",(0,a.jsx)(r.p,{children:"指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"(function (a) {\r\n}).length // 1\r\n    (function (a = 5) {\r\n    }).length // 0\r\n    (function (a, b, c = 5) {\r\n    }).length // 2\n"})}),"\n",(0,a.jsxs)(r.h3,{id:"作用域",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#作用域",children:"#"}),"作用域"]}),"\n",(0,a.jsx)(r.p,{children:"一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"var x = 1;\r\n\r\nfunction f(x, y = x) {\r\n    console.log(y);\r\n}\r\n\r\nf(2) // 2\n"})}),"\n",(0,a.jsx)(r.p,{children:"上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"let x = 1;\r\n\r\nfunction f(y = x) {\r\n    let x = 2;\r\n    console.log(y);\r\n}\r\n\r\nf() // 1\n"})}),"\n",(0,a.jsx)(r.p,{children:"上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。"}),"\n",(0,a.jsx)(r.p,{children:"如果此时，全局变量x不存在，就会报错。"}),"\n",(0,a.jsxs)(r.h2,{id:"rest-参数",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#rest-参数",children:"#"}),"rest 参数"]}),"\n",(0,a.jsx)(r.p,{children:"ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function add(...values) {\r\n    let sum = 0;\r\n    for (var val of values) {\r\n        sum += val;\r\n    }\r\n    return sum;\r\n}\r\n\r\nadd(2, 5, 3) // 10\r\n\r\n// arguments变量的写法\r\nfunction sortNumbers() {\r\n    return Array.prototype.slice.call(arguments).sort();\r\n}\r\n\r\n// rest参数的写法\r\nconst sortNumbers = (...numbers) => numbers.sort();\n"})}),"\n",(0,a.jsx)(r.p,{children:"arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest\r\n参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function push(array, ...items) {\r\n    items.forEach(function (item) {\r\n        array.push(item);\r\n        console.log(item);\r\n    });\r\n}\r\n\r\nvar a = [];\r\npush(a, 1, 2, 3)\n"})}),"\n",(0,a.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,a.jsx)(r.div,{className:"rspress-directive-title",children:"注意"}),(0,a.jsxs)(r.div,{className:"rspress-directive-content",children:[(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。"}),"\n",(0,a.jsx)(r.li,{children:"函数的length属性，不包括 rest 参数。\r\n:::"}),"\n"]}),(0,a.jsxs)(r.h2,{id:"严格模式",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#严格模式",children:"#"}),"严格模式"]}),(0,a.jsx)(r.p,{children:"从 ES5 开始，函数内部可以设定为严格模式。ES2016\r\n做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。"}),(0,a.jsxs)(r.h2,{id:"name-属性",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#name-属性",children:"#"}),"name 属性"]}),(0,a.jsx)(r.p,{children:"函数的name属性，返回该函数的函数名。这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。"}),(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:'function foo() {\r\n}\r\n\r\nfoo.name // "foo"\r\n\r\n    //Function构造函数返回的函数实例，name属性的值为anonymous。\r\n    (new Function).name // "anonymous"\r\n\r\n//bind返回的函数，name属性值会加上bound前缀。\r\nfunction foo() {\r\n};\r\nfoo.bind({}).name // "bound foo"\r\n    (function () {\r\n    }).bind({}).name // "bound "\n'})}),(0,a.jsx)(r.p,{children:":::tip 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。"}),(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:'var f = function () {\r\n};\r\n// ES5\r\nf.name // ""\r\n// ES6\r\nf.name // "f"\n'})})]})]}),"\n",(0,a.jsxs)(r.h2,{id:"箭头函数",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#箭头函数",children:"#"}),"箭头函数"]}),"\n",(0,a.jsx)(r.p,{children:"ES6 允许使用“箭头”（=>）定义函数。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"var f = v => v;\r\n// 等同于\r\nvar f = function (v) {\r\n    return v;\r\n};\r\n\r\n/**\r\n * 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\r\n */\r\nvar f = () => 5;\r\n// 等同于\r\nvar f = function () {\r\n    return 5\r\n};\r\nvar sum = (num1, num2) => num1 + num2;\r\n// 等同于\r\nvar sum = function (num1, num2) {\r\n    return num1 + num2;\r\n};\r\n\r\n\r\n/**\r\n * 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\r\n */\r\n// 报错\r\n// let getTempItem = id => { id: id, name: \"Temp\" };\r\n// 不报错\r\nlet getTempItem = id => ({id: id, name: \"Temp\"});\r\n\r\n//如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。\r\nlet fn = () => void doesNotReturn();\r\n\r\n//箭头函数可以与变量解构结合使用。\r\n\r\nconst full = ({first, last}) => first + ' ' + last;\r\n\r\n// 等同于\r\nfunction full(person) {\r\n    return person.first + ' ' + person.last;\r\n}\r\n\r\n//箭头函数的一个用处是简化回调函数。\r\n\r\n// 正常函数写法\r\n[1, 2, 3].map(function (x) {\r\n    return x * x;\r\n});\r\n// 箭头函数写法\r\n[1, 2, 3].map(x => x * x);\n"})}),"\n",(0,a.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,a.jsx)(r.div,{className:"rspress-directive-title",children:"使用注意点"}),(0,a.jsxs)(r.div,{className:"rspress-directive-content",children:[(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。"}),"\n",(0,a.jsx)(r.li,{children:"不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。"}),"\n",(0,a.jsx)(r.li,{children:"不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。"}),"\n",(0,a.jsx)(r.li,{children:"不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\r\n:::"}),"\n"]}),(0,a.jsxs)(r.h2,{id:"尾调用优化",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#尾调用优化",children:"#"}),"尾调用优化"]}),(0,a.jsx)(r.p,{children:"尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要是最后一步操作即可。"}),(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function f(x) {\r\n    return g(x);\r\n}\r\n\r\n// 函数f的最后一步是调用函数g，这就叫尾调用。\r\n// 以下三种情况，都不属于尾调用。\r\n// 情况一\r\nfunction f(x) {\r\n    let y = g(x);\r\n    return y;\r\n}\r\n\r\n// 情况二\r\nfunction f(x) {\r\n    return g(x) + 1;\r\n}\r\n\r\n// 情况三\r\nfunction f(x) {\r\n    g(x);\r\n}\n"})}),(0,a.jsx)(r.p,{children:"尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call\r\nframe），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call\r\nstack）。"}),(0,a.jsx)(r.p,{children:"尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。"}),(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function f() {\r\n    let m = 1;\r\n    let n = 2;\r\n    return g(m + n);\r\n}\r\n\r\nf();\r\n\r\n// 等同于\r\nfunction f() {\r\n    return g(3);\r\n}\r\n\r\nf();\r\n// 等同于\r\ng(3);\n"})}),(0,a.jsx)(r.p,{children:"上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。"}),(0,a.jsx)(r.p,{children:"这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。"}),(0,a.jsx)(r.p,{children:"注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\r\n:::warning 注意 目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。"})]})]}),"\n",(0,a.jsxs)(r.h3,{id:"尾递归",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#尾递归",children:"#"}),"尾递归"]}),"\n",(0,a.jsx)(r.p,{children:"函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"// 以一个阶乘函数为例，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n) 。\r\nfunction factorial(n) {\r\n    if (n === 1) return 1;\r\n    return n * factorial(n - 1);\r\n}\r\n\r\nfactorial(5) // 120\r\n//改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\r\nfunction factorial(n, total) {\r\n    if (n === 1) return total;\r\n    return factorial(n - 1, n * total);\r\n}\r\n\r\nfactorial(5, 1) // 120\n"})}),"\n",(0,a.jsxs)(r.h4,{id:"递归函数的改写",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#递归函数的改写",children:"#"}),"递归函数的改写"]}),"\n",(0,a.jsx)(r.p,{children:"尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total\r\n，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算 5 的阶乘，需要传入两个参数 5 和 1 ？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function factorial(n) {\r\n    return tailFactorial(n, 1);\r\n\r\n    function tailFactorial(n, total) {\r\n        if (n === 1) return total;\r\n        return tailFactorial(n - 1, n * total);\r\n    }\r\n}\r\n\r\nfactorial(5) // 120\n"})}),"\n",(0,a.jsxs)(r.h5,{id:"柯里化",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#柯里化",children:"#"}),"柯里化"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function currying(fn, n) {\r\n  return function (m) {\r\n    return fn.call(this, m, n);\r\n  };\r\n}\r\nfunction tailFactorial(n, total) {\r\n  if (n === 1) return total;\r\n  return tailFactorial(n - 1, n * total);\r\n}\r\nconst factorial = currying(tailFactorial, 1);\r\nfactorial(5) // 120\n"})}),"\n",(0,a.jsxs)(r.h5,{id:"es6-的函数默认值",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#es6-的函数默认值",children:"#"}),"ES6 的函数默认值"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function factorial(n, total = 1) {\r\n  if (n === 1) return total;\r\n  return factorial(n - 1, n * total);\r\n}\r\nfactorial(5) // 120\n"})}),"\n",(0,a.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,a.jsx)(r.div,{className:"rspress-directive-title",children:"TIP"}),(0,a.jsx)(r.div,{className:"rspress-directive-content",children:(0,a.jsx)(r.p,{children:"\nES6 的尾调用优化只在严格模式下开启，正常模式是无效的。"})})]}),"\n",(0,a.jsxs)(r.h3,{id:"尾递归优化的实现",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#尾递归优化的实现",children:"#"}),"尾递归优化的实现"]}),"\n",(0,a.jsx)(r.p,{children:"它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\r\n下面是一个正常的递归函数。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:"function sum(x, y) {\r\n  if (y > 0) {\r\n    return sum(x + 1, y - 1);\r\n  } else {\r\n    return x;\r\n  }\r\n}\r\nsum(1, 100000)\r\n// 上面代码中， sum 是一个递归函数，参数 x 是需要累加的值，参数 y 控制递归次数。一旦指定 sum 递归 100000 次，就会报错，提示超出调用栈的最大次数。\r\n// 蹦床函数（trampoline）可以将递归执行转为循环执行。\r\n/**\r\n * 它接受一个函数 f 作为参数。只要 f 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。\r\n * 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。\r\n * @param f\r\n * @returns {*}\r\n */\r\nfunction trampoline(f) {\r\n  while (f && f instanceof Function) {\r\n    f = f();\r\n  }\r\n  return f;\r\n}\r\n\r\ntrampoline(sum(1, 100000))\n"})}),"\n",(0,a.jsxs)(r.h2,{id:"函数参数的尾逗号",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#函数参数的尾逗号",children:"#"}),"函数参数的尾逗号"]}),"\n",(0,a.jsx)(r.p,{children:"ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。"}),"\n",(0,a.jsxs)(r.h2,{id:"functionprototypetostring",children:[(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#functionprototypetostring",children:"#"}),"Function.prototype.toString()"]}),"\n",(0,a.jsx)(r.p,{children:"ES2019 对函数实例的 toString()方法做出了修改。toString() 方法返回函数代码本身，以前会省略注释和空格。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",meta:"",children:'function /* foo comment */ foo () {}\r\n// 之前\r\nfoo.toString()// function foo() {}\r\n// 之后\r\nfoo.toString()// "function /* foo comment */ foo () {}"\n'})})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),n.components);return r?(0,a.jsx)(r,Object.assign({},n,{children:(0,a.jsx)(s,n)})):s(n)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%2Fes6%2Fes6-7.md"]={toc:[{id:"函数参数的默认值",text:"函数参数的默认值",depth:2},{id:"与解构赋值默认值结合使用",text:"与解构赋值默认值结合使用",depth:3},{id:"参数默认值的位置",text:"参数默认值的位置",depth:3},{id:"函数的-length-属性",text:"函数的 length 属性",depth:3},{id:"作用域",text:"作用域",depth:3},{id:"rest-参数",text:"rest 参数",depth:2},{id:"严格模式",text:"严格模式",depth:2},{id:"name-属性",text:"name 属性",depth:2},{id:"箭头函数",text:"箭头函数",depth:2},{id:"尾调用优化",text:"尾调用优化",depth:2},{id:"尾递归",text:"尾递归",depth:3},{id:"递归函数的改写",text:"递归函数的改写",depth:4},{id:"尾递归优化的实现",text:"尾递归优化的实现",depth:3},{id:"函数参数的尾逗号",text:"函数参数的尾逗号",depth:2},{id:"functionprototypetostring",text:"Function.prototype.toString()",depth:2}],title:"函数的扩展",headingTitle:"函数的扩展",frontmatter:{}}}}]);