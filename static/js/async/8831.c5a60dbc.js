"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["8831"],{4217:function(n,e,r){r.r(e),r.d(e,{default:function(){return c}});var i=r(85893),l=r(50065);function s(n){let e=Object.assign({h1:"h1",a:"a",h3:"h3",blockquote:"blockquote",p:"p",ul:"ul",li:"li",code:"code",pre:"pre",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,l.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"13-io流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13-io流",children:"#"}),"13 IO流"]}),"\n",(0,i.jsxs)(e.h3,{id:"131-file类的使用",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#131-file类的使用",children:"#"}),"13.1 File类的使用"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"创建File实例"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"new File(String filePath)"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"new File(String parentPath, String childPath)"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"new File(File filePath, String childPath)"})}),"\n"]}),"\n","\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"File常用方法"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"String getAgetAbsolutePath()"}),"：获取绝对路径"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"String getPath()"}),"：获取路径"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'File file = new File("hello.txt");\r\nFile file1 = new File("D:\\\\project\\\\JavaSenior\\\\hi.txt");\r\n\r\nSystem.out.println(file.getPath()); // hello.txt\r\nSystem.out.println(file1.getPath()); // D:\\project\\JavaSenior\\hi.txt\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"String getName()"}),"：获取文件名"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"String getParent()"}),"：获取上层文件目录路径。若无，返回null"]}),"\n",(0,i.jsx)(e.p,{children:"如果创建文件的时候，使用的是相对路径，返回的是null；如果使用的是绝对路径，则返回该文件的上级路径"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'File file = new File("hello.txt");\r\nFile file1 = new File("D:\\\\project\\\\JavaSenior\\\\hi.txt");\r\n\r\nSystem.out.println(file.getParent()); // null\r\nSystem.out.println(file1.getParent()); // D:\\project\\JavaSenior\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"long length()"}),"：获取文件长度（单位：字节）"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"long lastModified()"}),"：获取最后一次的修改时间（单位：毫秒）"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"String[] list()"}),"：获取",(0,i.jsx)(e.strong,{children:"指定目录"}),"下的所有文件或者文件夹的名称数组"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"File[] listFiles()"}),"：获取",(0,i.jsx)(e.strong,{children:"指定目录"}),"下的所有文件或者文件夹的File数组"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean renameTo(File dest)"}),"：把文件重命名为指定的文件路径"]}),"\n",(0,i.jsxs)(e.p,{children:["以",(0,i.jsx)(e.code,{children:"file1.renameTo(file2)"}),"为例，若想返回true，要保证："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"file1在硬盘中真实存在"}),"\n",(0,i.jsx)(e.li,{children:"file2在硬盘中不存在"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isDirectory()"}),"：是否是个路径"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isFile()"}),"：是否是个文件"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean exists()"}),"：是否存在"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean canRead()"}),"：是否可读"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean canWrite()"}),"：是否可写"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isHidden()"}),"：是否隐藏"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean createNewFile()"}),"：创建文件。如果文件存在，则不创建，返回false"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean mkdir()"}),"：创建文件目录。如果此目录存在，或者此文件目录的上层目录不存在，就不创建"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean mkdirs()"}),"：创建文件目录。如果上层文件目录不存在，一并创建"]}),"\n",(0,i.jsx)(e.p,{children:"如果创建文件或者文件目录没有写盘符，默认在项目路径下"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean delete()"}),"：删除文件或文件夹"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"java中的删除不走回收站"}),"\n",(0,i.jsx)(e.li,{children:"要删除一个文件目录，请注意该文件目录下不能包含文件或者文件目录"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"132-io流原理及流的分类",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#132-io流原理及流的分类",children:"#"}),"13.2 IO流原理及流的分类"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"流的分类"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"按操作的数据单位分：字节流、字符流"}),"\n",(0,i.jsx)(e.li,{children:"按流的流向分：输入流、输出流"}),"\n",(0,i.jsx)(e.li,{children:"按流的角色分：节点流、处理流"}),"\n"]}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"（抽象基类）"}),(0,i.jsx)(e.th,{children:"节点流（文件流）"}),(0,i.jsx)(e.th,{children:"处理流"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"InputStream"}),(0,i.jsx)(e.td,{children:"FileInputStream"}),(0,i.jsx)(e.td,{children:"BufferedInputStream"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"OutputStream"}),(0,i.jsx)(e.td,{children:"FileOutputStream"}),(0,i.jsx)(e.td,{children:"BufferedOutputStream"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Reader"}),(0,i.jsx)(e.td,{children:"FileReader"}),(0,i.jsx)(e.td,{children:"BufferedReader"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Writer"}),(0,i.jsx)(e.td,{children:"FileWriter"}),(0,i.jsx)(e.td,{children:"BufferedWriter"})]})]})]}),"\n",(0,i.jsxs)(e.h3,{id:"133-filereader与filewriter的使用",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#133-filereader与filewriter的使用",children:"#"}),"13.3 FileReader与FileWriter的使用"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"使用场景"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["适用于处理","文本文件（.txt，.java，.c，.cpp）","的场景。不能用来处理图片等字节数据"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"步骤"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"创建File对象，指明写入、写出的文件"}),"\n",(0,i.jsx)(e.li,{children:"创建输入流FileReader、输出流FileWriter对象"}),"\n",(0,i.jsx)(e.li,{children:"执行写入、写出操作"}),"\n",(0,i.jsx)(e.li,{children:"关闭流(关闭时，先判断流是否为空。不为空的流才执行关闭操作)"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"重点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"FileReader.reader()：每次读取一个字符，返回值为当前字符的ASCII码。如果读到文件末尾，返回-1"}),"\n",(0,i.jsx)(e.li,{children:"FileReader.reader.read(char [] cbuf)：每次最多读取cbuf.length个字符放到cbuf[]中，返回值是本次读取到的字符的个数。如果读到文件末尾，返回-1"}),"\n",(0,i.jsx)(e.li,{children:"new FileWriter(file, false) / new FileWriter(file)：写出时会对原有文件进行覆盖"}),"\n",(0,i.jsx)(e.li,{children:"new FileWriter(file, true)：在原有文件基础上追加内容"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void testFileReader1() {\r\n    FileReader reader = null;\r\n    try {\r\n        // 1.File实例化\r\n        File file = new File("hello.txt");\r\n\r\n        // 2.FileReader实例化\r\n        reader = new FileReader(file);\r\n\r\n        // 3.读取数据\r\n        // reader.read()：每次读取一个字符，返回值为当前字符的ASCII码。如果读到文件末尾，返回-1\r\n        int data;\r\n        while ((data = reader.read()) != -1) {\r\n            System.out.println((char)data);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        try {\r\n            if (null != reader) {\r\n                reader.close();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n     * 对read()操作升级：使用read()的重载方法 read(char cbuf[])\r\n     */\r\n@Test\r\npublic void testFileReader2() {\r\n    FileReader reader = null;\r\n    try {\r\n        // 1.File实例化\r\n        File file = new File("hello.txt");\r\n\r\n        // 2.FileReader实例化\r\n        reader = new FileReader(file);\r\n\r\n        // 3.读入\r\n        // reader.read(cbuf)：每次最多读取cbuf.length个字符放到cbuf[]中，该方法的返回值是本次读取到的字符的个数。\r\n        // 	如果达到文件末尾，返回-1\r\n        char cbuf[] = new char[5];\r\n        int len;\r\n        while ((len = reader.read(cbuf)) != -1) {\r\n            // 方式一：注意循环次数是len次，不是cbuf.length次\r\n            //                for (int i = 0; i < len; i++) {\r\n            //                    System.out.print(cbuf[i]);\r\n            //                }\r\n\r\n            // 方式二\r\n            String str = new String(cbuf, 0, len);\r\n            System.out.print(str);\r\n\r\n\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != reader) {\r\n            // 4.关闭流\r\n            try {\r\n                reader.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* 从内存中写出数据到硬盘文件\r\n*\r\n* 说明：\r\n*  1. 输出操作，对应的File可以不存在。\r\n*  2. File中对应的文件如果不存在，在输出的过程中会自动创建此文件\r\n*  3. File中对应的文件如果存在：\r\n*      加入使用的是new FileWriter(file, false) / new FileWriter(file)构造器，写出时会对原有文件进行覆盖\r\n*      如果使用的是new FileWriter(file, true)构造器，不会对原有文件覆盖，而是在原有文件基础上追加内容\r\n*/\r\n@Test\r\npublic void testFileWriter() {\r\n    FileWriter fw = null;\r\n    try {\r\n        // 1.File实例化，指明写出到的文件\r\n        File file = new File("hello1.txt");\r\n\r\n        // 2.FileWriter实例化，用于数据的写出\r\n        fw = new FileWriter(file);\r\n\r\n        // 3.写出\r\n        fw.write("I have a dream!\\n");\r\n        fw.write("I want to eat all the food of the world!");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != fw){\r\n            // 4.关闭流\r\n            try {\r\n                fw.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"134-fileinputstream与fileoutputstream的使用",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#134-fileinputstream与fileoutputstream的使用",children:"#"}),"13.4 FileInputStream与FileOutputStream的使用"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"使用场景"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["适用于处理","非文本文件（.jpg，.png，.mp3，.mp4，.avi，.doc，.ppt）","。如果执行复制操作，也可以处理文本文件。"]}),"\n",(0,i.jsx)(e.p,{children:"如果用来输出文本文件，有可能出现乱码"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"步骤"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"创建File对象，指明写入、写出的文件"}),"\n",(0,i.jsx)(e.li,{children:"创建输入流FileInputStream、输出流FileOutputStream对象"}),"\n",(0,i.jsx)(e.li,{children:"执行写入、写出操作"}),"\n",(0,i.jsx)(e.li,{children:"关闭流(关闭时，先判断流是否为空。不为空的流才执行关闭操作)"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 实现图片的复制\r\n */\r\n@Test\r\npublic void test() {\r\n    FileInputStream fis = null;\r\n    FileOutputStream fos = null;\r\n    try {\r\n        // 1.File实例化，指明写出到的文件\r\n        File srcFile = new File("image.png");\r\n        File destFile = new File("image1.png");\r\n\r\n        // 2.FileInputStream、FileOutputStream实例化，用于数据的读取与写出\r\n        fis = new FileInputStream(srcFile);\r\n        fos = new FileOutputStream(destFile);\r\n\r\n        // 3.复制\r\n        byte[] buff = new byte[5];\r\n        int len;\r\n        while ((len = fis.read(buff)) != -1) {\r\n            fos.write(buff, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 4.关闭流\r\n        if (null != fos) {\r\n            try {\r\n                fos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != fis) {\r\n            try {\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"135-处理流之缓冲流的使用",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#135-处理流之缓冲流的使用",children:"#"}),"13.5 处理流之缓冲流的使用"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"缓冲流"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"BufferedInputStream和BufferedOutputStream"}),"\n",(0,i.jsx)(e.li,{children:"BufferedReader和BufferedWriter"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"作用：提高流的读取、写入速度"}),"\n",(0,i.jsx)(e.li,{children:"原理：内部提供了一个缓冲区"}),"\n",(0,i.jsx)(e.li,{children:"实现：处理流，就是“套接”在已有的流的基础上"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"步骤"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"实例化File，指明读取、写出的文件"}),"\n",(0,i.jsxs)(e.li,{children:["造流","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"造节点流"}),"\n",(0,i.jsx)(e.li,{children:"造处理流"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{children:"读取文件、写入文件"}),"\n",(0,i.jsx)(e.li,{children:"关闭流"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"重点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"BufferedReader"}),"中多了个",(0,i.jsx)(e.code,{children:"readLine()"}),"，该方法一次返回一行数据，不包括换行符。读取到文件末尾，返回null"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"BufferedWriter"}),"中可以使用",(0,i.jsx)(e.code,{children:"newLine()"}),"实现换行"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"FileInputStream"}),"、",(0,i.jsx)(e.code,{children:"FileOutputStream"}),"实例化时参数也可以传文件路径",(0,i.jsx)(e.code,{children:"new FileInputStream(String filePath)"}),"、",(0,i.jsx)(e.code,{children:"new FileOutputStream(String filePath)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"BufferedReader"}),"、",(0,i.jsx)(e.code,{children:"BufferedWriter"}),"实例化时参数也可以传文件路径",(0,i.jsx)(e.code,{children:"new BufferedReader(String filePath)"}),"、",(0,i.jsx)(e.code,{children:"new BufferedWriter(String filePath)"})]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n* 使用BufferedInputStream和BufferedOutputStream实现图片的复制\r\n*/\r\n@Test\r\npublic void bufferedStreamTest() {\r\n    BufferedInputStream bis = null;\r\n    BufferedOutputStream bos = null;\r\n    try {\r\n        // 1.实例化File，指明读取、写出的文件\r\n        File srcFile = new File("image.png");\r\n        File destFile = new File("image3.png");\r\n\r\n        // 2.造流\r\n        // 2.1 造节点流\r\n        FileInputStream fis = new FileInputStream(srcFile); // new FileInputStream("image.png");\r\n        FileOutputStream fos = new FileOutputStream(destFile);\r\n        // 2.2 造缓冲流\r\n        bis = new BufferedInputStream(fis);\r\n        bos = new BufferedOutputStream(fos);\r\n\r\n        // 3.复制\r\n        byte[] buff = new byte[10];\r\n        int len;\r\n        while ((len = bis.read(buff)) != -1) {\r\n            bos.write(buff, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 4.资源关闭\r\n        // 关闭原则：先关外层的流，再关内层的流。\r\n        // 说明：在关闭外层流的同时，内层的流也会自动关闭。因此内层流的关闭操作，可以省略\r\n        if (null != bos) {\r\n            try {\r\n                bos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != bis) {\r\n            try {\r\n                bis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        //            fos.close();\r\n        //            fis.close();\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* 使用BufferedReader和BufferedWriter实现文本文件的复制\r\n*/\r\n@Test\r\npublic void bufferedReaderWriterTest() {\r\n    BufferedReader br = null;\r\n    BufferedWriter bw = null;\r\n\r\n    try {\r\n        // 1.造流\r\n        br = new BufferedReader(new FileReader(new File("error.log")));\r\n        bw = new BufferedWriter(new FileWriter(new File("error1.log")));\r\n\r\n        // 2.复制\r\n        //            方法一：使用read\r\n        //            char[] cbuff = new char[1024];\r\n        //            int len;\r\n        //            while ((len = br.read(cbuff)) != -1) {\r\n        //                bw.write(cbuff, 0, len);\r\n        //            }\r\n\r\n        // 方法二：使用readLine()：一次读取一行，不包括换行符。读到文件末尾，返回null\r\n        String data;\r\n        while (null != (data = br.readLine())) {\r\n            bw.write(data);\r\n            bw.newLine();//换行\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != bw) {\r\n            try {\r\n                bw.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != br) {\r\n            try {\r\n                br.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"136-处理流之转换流的使用",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#136-处理流之转换流的使用",children:"#"}),"13.6 处理流之转换流的使用"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"转换流"}),"\n"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"InputStreamReader：将一个字节的输入流转换为字符的输入流。体现为解码"}),"\n",(0,i.jsx)(e.li,{children:"OutputStreamReader：将一个字符的输出流转换为字节的输出流。体现为编码"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"作用：提供字节流与字符流之间的转换"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n* 借助InputStreamReader和OutputStreamWriter，将utf-8格式的文本文件复制为gbk格式的文件\r\n*/\r\n@Test\r\npublic void test() {\r\n    InputStreamReader isr = null;\r\n    OutputStreamWriter osw = null;\r\n    try {\r\n        // 1.造流\r\n        FileInputStream fis = new FileInputStream("hello.txt");\r\n        FileOutputStream fos = new FileOutputStream("hello_gbk.txt");\r\n\r\n        isr = new InputStreamReader(fis, "utf-8");\r\n        osw = new OutputStreamWriter(fos, "gbk");\r\n\r\n        // 2.复制\r\n        char[] cbuf = new char[10];\r\n        int len;\r\n        while ((len = isr.read(cbuf)) != -1) {\r\n            osw.write(cbuf);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != isr) {\r\n            try {\r\n                isr.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != osw) {\r\n            try {\r\n                osw.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"137-字符集",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#137-字符集",children:"#"}),"13.7 字符集"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"ASCII：美国标准信息交换码。用一个字节的7位可以表示"}),"\n",(0,i.jsx)(e.li,{children:"ISO8895-1：拉丁码表，欧洲码表。用一个字节的8位表示"}),"\n",(0,i.jsx)(e.li,{children:"GB2312：中国的中文编码表。最多两个字节编码所有字符"}),"\n",(0,i.jsx)(e.li,{children:"GBK：中国的中文编码表升级，融合了更多的中文文字符号（如繁体字）。最多两个字节编码所有字符"}),"\n",(0,i.jsx)(e.li,{children:"Unicode：国际标准码，融合了目前人类使用的所有字符，为每一个字符分配唯一的字符。所有文字都用两个字节来表示"}),"\n",(0,i.jsx)(e.li,{children:"UTF-8：变长的编码方式。可用1-4的字节来表示一个字符"}),"\n"]}),"\n","\n",(0,i.jsx)(e.p,{children:"Unicode字符集只是定义了字符的集合和唯一编号。Unicode编码，是对UTF-8、UTF-16、UTF-32等具体编码的统称，并不是具体的编码方案"}),"\n",(0,i.jsxs)(e.h3,{id:"138-处理流之标准的输入输出流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#138-处理流之标准的输入输出流",children:"#"}),"13.8 处理流之标准的输入、输出流"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"System.in: 标准的输入流，默认从键盘输入。类型是InputStream"}),"\n",(0,i.jsx)(e.li,{children:"System.out: 标准的输出流，默认从显示器输出。类型是PrintStream"}),"\n",(0,i.jsxs)(e.li,{children:["可以通过",(0,i.jsx)(e.code,{children:"System.setIn(InputStream in)"}),"和",(0,i.jsx)(e.code,{children:"System.setOut(PrintStream out)"}),"对默认设备进行修改"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"实例"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"要求：从键盘输入字符串。要求将读取到的整行字符串转成大写并输出，然后继续进行输入操作。直到当输入“e”或者“exit”时，退出程序。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test1() {\r\n    BufferedReader br = null;\r\n    try {\r\n        // 1.造流。\r\n        // 因为需要用到读取整行的功能，而只有BufferedReader有读取整行的函数，因此需要BufferedReader流。\r\n        // 又因System.in的类型是InputStream，所以需要用到转换流InputStreamReader将InputStream转为BufferedReader\r\n        // 1.1 先创建了转换流InputStreamReader流，将字节输入流转换为字符输入流\r\n        InputStreamReader isr = new InputStreamReader(System.in);\r\n        // 1.2 再创建了BufferedReader字符读取流。\r\n        br = new BufferedReader(isr);\r\n\r\n        // 2.读取整行字符串，将其转为大写\r\n        while (true) {\r\n            System.out.println("请输入字符串");\r\n            String data = br.readLine();\r\n            if (null == data || "e".equalsIgnoreCase(data) || "exit".equalsIgnoreCase(data)) {\r\n                System.out.println("程序结束");\r\n                break;\r\n            }\r\n\r\n            String dataUpperCase = data.toUpperCase();\r\n            System.out.println(dataUpperCase);\r\n\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != br) {\r\n            try {\r\n                br.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"139-处理流之打印流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#139-处理流之打印流",children:"#"}),"13.9 处理流之打印流"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["实现将","基本数据类型","的数据格式转化为","字符串","输出"]}),"\n",(0,i.jsxs)(e.li,{children:["提供了一系列重载的",(0,i.jsx)(e.code,{children:"print()"}),"和",(0,i.jsx)(e.code,{children:"println()"})]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"打印流"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"PrintStream：字节输出流"}),"\n",(0,i.jsx)(e.li,{children:"PrintWriter：字符输出流"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"要求：使用System.out将内容输出到文件中，而非控制台中"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test2() {\r\n    PrintStream ps = null;\r\n    try {\r\n        // 1.创建流\r\n        FileOutputStream fos = new FileOutputStream("info.txt");\r\n        ps = new PrintStream(fos);\r\n\r\n        // 2.把标准输出流（控制台输出）改成文件\r\n        if (null != ps) {\r\n            System.setOut(ps);\r\n        }\r\n\r\n        // 3.输出\r\n        for (int i = 0; i < 255; i++) {\r\n            System.out.print((char) i);\r\n            // 每50个字符一行\r\n            if (i % 50 == 0) {\r\n                System.out.println();\r\n            }\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 4.关闭流\r\n        if (null != ps) {\r\n            ps.close();\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1310-处理流之数据流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1310-处理流之数据流",children:"#"}),"13.10 处理流之数据流"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"数据流"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"DataInputStream"}),"\n",(0,i.jsx)(e.li,{children:"DataOutputStream"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"用于读取或者写出基本数据类型的变量或字符串。（如将内存中的数据持久化到文件中（写出），在文件中读取数据到内存中（读取））"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"重点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"文件的读取和写入顺序要一致，否则会报EOFException异常"}),"\n",(0,i.jsxs)(e.li,{children:["每当执行",(0,i.jsx)(e.code,{children:"DataOutputStream"}),"的",(0,i.jsx)(e.code,{children:"flush()"}),"就会将内存中的数据写入到文件中"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"要求：将内存中的变量写入到文件中，并将文件中的内容读取到变量中，并输出"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test3() {\r\n    // 将内存中的字符串、基本数据类型的变量写出到文件中\r\n    DataOutputStream dos = null;\r\n    try {\r\n        dos = new DataOutputStream(new FileOutputStream("data.txt"));\r\n        dos.writeUTF("唐天华");\r\n        dos.flush();\r\n        dos.writeInt(18);\r\n        dos.flush();\r\n        dos.writeBoolean(false);\r\n        dos.flush();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != dos) {\r\n            try {\r\n                dos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 读取文件中的存储的基本类型变量和字符串到内存，保存在变量中\r\n    DataInputStream dis = null;\r\n    try {\r\n        dis = new DataInputStream(new FileInputStream("data.txt"));\r\n\r\n        // 注意：数据的读取顺序要和写入顺序保持一致，否则会报EOFException\r\n        String name = dis.readUTF();\r\n        int age = dis.readInt();\r\n        boolean isMale = dis.readBoolean();\r\n        System.out.println("name = " + name);\r\n        System.out.println("age = " + age);\r\n        System.out.println("isMale = " + isMale);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 关闭流\r\n        if (null != dis) {\r\n            try {\r\n                dis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1311-处理流之对象流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1311-处理流之对象流",children:"#"}),"13.11 处理流之对象流"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"对象流"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"ObjectInputStream"}),"\n",(0,i.jsx)(e.li,{children:"ObjectOutputStream"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["用于存储和读取","基本数据类型","数据或","对象","的处理流"]}),"\n",(0,i.jsxs)(e.p,{children:["用到了","序列化","和","反序列化","技术"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"要求："}),"\n",(0,i.jsx)(e.p,{children:"① 序列化过程：将内存中的java对象以二进制流的方式保存到磁盘中或通过网络传输出去"}),"\n",(0,i.jsx)(e.p,{children:"② 反序列化过程：将磁盘或者网络中的二进制流转化为内存中的Java对象"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n* 序列化过程：将内存中的java对象以二进制流的方式保存到磁盘中或通过网络传输出去\r\n* 使用ObjectOutputStream实现\r\n*/\r\n@Test\r\npublic void testObjectOutputStream() {\r\n    ObjectOutputStream oos = null;\r\n    try {\r\n        // 1.造流\r\n        oos = new ObjectOutputStream(new FileOutputStream("object.dat"));\r\n        // 2.将对象持久化到文件\r\n        oos.writeObject("我爱北京天安门");\r\n        oos.flush();//刷新写入\r\n        oos.writeObject(new Person("张小凡", 18));\r\n        oos.flush();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != oos) {\r\n            try {\r\n                oos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* 反序列化过程：将磁盘或者网络中的二进制流转化为内存中的Java对象\r\n* 使用ObjectInputStream实现\r\n*/\r\n@Test\r\npublic void testObjectInputStream() {\r\n    ObjectInputStream ois = null;\r\n    try {\r\n        // 1.造流\r\n        ois = new ObjectInputStream(new FileInputStream("object.dat"));\r\n\r\n        // 2.反序列化并打印\r\n        Object object = ois.readObject();\r\n        String str = (String) object;\r\n        System.out.println(str);\r\n        Object object1 = ois.readObject();\r\n        Person person = (Person) object1;\r\n        System.out.println(person);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } catch (ClassNotFoundException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != ois) {\r\n            try {\r\n                ois.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1312-序列化与反序列化",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1312-序列化与反序列化",children:"#"}),"13.12 序列化与反序列化"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["序列化：用ObjectOutputStream类","保存","基本类型数据或对象的机制"]}),"\n",(0,i.jsxs)(e.li,{children:["反序列化：用ObjectInputStream类","读取","基本类型数据或对象的机制"]}),"\n"]}),"\n","\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"对象的序列化机制"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"对象序列化机制允许把内存中的Java对象转换为平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另外一个网络节点。当其它程序获取了这种二进制流，就可以回复称原来的Java对象。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Java对象序列化的要求"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"需要实现接口：Serializable"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"当前类需要提供一个全局常量serialVersionUID"}),"\n",(0,i.jsx)(e.p,{children:"serialVersionUID用来表明类的不同版本之间的兼容性。如果类没有显示定义该静态常量，它的值是Java运行时环境根据类的内部细节自动生成。如果类的属性进行了修改（添加属性或者删除属性），serialVersionUID有可能发生变化。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"除了当前类需要实现Serializable接口外，还必须保证该类的所有属性也必须是可序列化的"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"注意"}),"\n"]}),"\n","\n",(0,i.jsxs)(e.h3,{id:"1313-随机存取文件流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1313-随机存取文件流",children:"#"}),"13.13 随机存取文件流"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"随机存取文件流-RandomAccessFile"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"RandomAccessFile类直接继承Object类，实现了DataInput和DataOutput接口，因此该类既可以读也可以写"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"RandomAccessFile支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"支持只访问文件的部分内容"}),"\n",(0,i.jsx)(e.li,{children:"可以向已存在的文件后追加内容"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"RandomAccessFile对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"long getFilePointer()"}),"：获取文件记录指针的当前位置"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"void seek(long pos)"}),"：将文件记录指针定位到pos位置"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"RandomAccessFile类写文件时："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"如果文件不存在，会自动创建文件；"}),"\n",(0,i.jsx)(e.li,{children:"如果文件存在，会在文件开头进行覆盖写入"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"RandomAccessFile构造器："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"public RandomAccessFile(String name, String mode)"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"public RandomAccessFile(File file, String mode)"})}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["在创建RandomAccessFile实例时，需要指定",(0,i.jsx)(e.code,{children:"mode"}),"参数，该参数指定RandomAccessFile的访问模式："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"r：以只读的方式打开。不会创建文件，如果读取不存在的文件，会抛出异常"}),"\n",(0,i.jsx)(e.li,{children:"rw：打开以便读取和写入。文件不存在时，会创建文件"}),"\n",(0,i.jsx)(e.li,{children:"rwd：打开以便读取和写入；同步文件内容的更新"}),"\n",(0,i.jsx)(e.li,{children:"rws：打开以便读取和写入；同步文件内容和元数据的更新"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"应用举例"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["可以使用RandomAccessFile实现","多线程断点下载","任务。"]}),"\n",(0,i.jsx)(e.p,{children:"下载前，先创建两个临时文件。一个是与被下载文件大小相同的空文件，一个是记录文件指针的位置文件。每次暂停时，都会保存上一次的指针，再次下载时，会继续从上一次的地方下载。以此实现断点下载或者上传的功能。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例：使用RandomAccessFile实现图片的复制"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test1() {\r\n    RandomAccessFile raf1 = null;\r\n    RandomAccessFile raf2 = null;\r\n    try {\r\n        // 1.造流\r\n        raf1 = new RandomAccessFile(new File("img.png"), "r");\r\n        raf2 = new RandomAccessFile(new File("image1.png"), "rw");\r\n\r\n        // 2.复制\r\n        byte[] buffer = new byte[1024];\r\n        int len;\r\n        while ((len = raf1.read(buffer)) != -1) {\r\n            raf2.write(buffer, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != raf2) {\r\n            try {\r\n                raf2.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != raf1) {\r\n            try {\r\n                raf1.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例：使用RandomAccessFile实现在文件中间插入"}),"\n"]}),"\n","\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test2() {\r\n    RandomAccessFile raf = null;\r\n    try {\r\n        // 1.造流\r\n        raf = new RandomAccessFile("hello.txt", "rw");\r\n\r\n        // 2.插入\r\n        // 2.1保存指针3后边的数据到StringBuilder中\r\n        raf.seek(3);\r\n        StringBuilder sb = new StringBuilder((int)new File("hello.txt").length());\r\n        byte[] buff = new byte[10];\r\n        int len;\r\n        while ((len = raf.read(buff)) != -1) {\r\n            sb.append(new String(buff, 0, len));\r\n        }\r\n        // 2.2调回指针，在3的位置后进行插入\r\n        raf.seek(3);\r\n        raf.write("xyz".getBytes());\r\n        // 2.3将StringBuilder中的数据写入到文件\r\n        raf.write(sb.toString().getBytes());\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 3.关闭流\r\n        if (null != raf) {\r\n            try {\r\n                raf.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1314-nio2中pathpathsfiles类的使用",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1314-nio2中pathpathsfiles类的使用",children:"#"}),"13.14 NIO.2中Path、Paths、Files类的使用"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["NIO：New IO，Non-Blocking IO。是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。\r\nNIO与原来的IO有着同样的作用和目的，但是使用的方式完全不同。",(0,i.jsx)(e.strong,{children:"NIO支持面向缓冲区的（IO是面向流的）、基于通道的IO操作"}),"。\r\n","NIO将以更加高效的方式进行文件的读写操作"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Java API中提供了两套NIO，一套是",(0,i.jsx)(e.strong,{children:"针对标准输入输出的NIO"}),"， 一套是",(0,i.jsx)(e.strong,{children:"网络编程NIO"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["java.nio.channels.Channel","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"FileChannel：处理本地文件"}),"\n",(0,i.jsx)(e.li,{children:"SocketChannel：TCP网络编程的客户端的Channel"}),"\n",(0,i.jsx)(e.li,{children:"ServerSocketChannel：TCP网络编程的服务端的Channel"}),"\n",(0,i.jsx)(e.li,{children:"DatagramChannel：UDP网络编程中发送端和接收端的Channel"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"NIO.2：JDK7中，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，因此被称为NIO.2"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"JDK7中引入了如下类："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Path接口：代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以视为File的升级版（如File中的大多数方法在失败的时候只能返回false，并不能提供异常。Path接口弥补了这种不足）"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Paths类：Path的工具类"}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"static Path get(String first, String ...more)"}),"：用于将多个字符串串连成路径"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"static Path get(URI uri)"}),"：返回指定uri队形的Path路径"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Files类：工具类"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Path常用方法"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"String toString()"}),"：返回调用Path对象的字符串表示形式"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"boolean startsWith(String path)"}),"：判断是否以path路径开始"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"boolean endsWith(String path)"}),"：判断是否以path路径结束"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"boolean isAbsolute()"}),"：判断是否是绝对路径"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Path getParent()"}),"：返回path的父级文件（夹）"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Path getRoot()"}),"：获取path的根路径"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Path getFileName()"}),"：返回与调用Path对象关联的文件名"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"int getNameCount()"}),"：返回path根路径后元素的数量"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Path getName(int index)"}),"：返回指定索引index出的路径名"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Path toAbsolutePath()"}),"：返回以当前path的绝对路径的Path对象"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Path resolve(Path other)"}),"：合并两个路径，并返回合并后的Path对象"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"File toFile()"}),"：将Path类对象转为File类对象"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Files常用方法"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean exists(Path path, LinkOption... options)"}),"：判断文件是否存在"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'Path path = Paths.get("D:\\\\project\\\\JavaSenior\\\\day10\\\\image.png");\r\nSystem.out.println("exists: " + Files.exists(path, LinkOption.NOFOLLOW_LINKS));\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean notExists(Path path, LinkOption... options)"}),"：判断文件是否不存在"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isDirectory(Path path, LinkOption... options)"}),"：判断是否是目录"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isRegularFile(Path path, LinkOption... options)"}),"：判断是否是文件"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isHidden(Path path)"}),"：判断是否是隐藏文件"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isReadable(Path path)"}),"：判断文件是否可读"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"boolean isWritable(Path path)"}),"：判断文件是否可写"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"SeekableByteChannel newByteChannel(Path path, OpenOption... options)"}),"：获取与指定文件的连接，options指定打开方式"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"DirectoryStream<Path> newDirectoryStream(Path dir)"}),"：打开dir指定的路径"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"InputStream newInputStream(Path path, OpenOption... options)"}),"：获取InputStream对象"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"OutputStream newOutputStream(Path path, OpenOption... options)"}),"：获取Output对象"]}),"\n"]}),"\n"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"LinkOption.NOFOLLOW_LINKS"}),"：不遵循符号链接"]}),"\n"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.READ"}),"：以读的方式连接文件"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.WRITE"}),"：以写的方式连接文件"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.APPEND"}),"：以追加的方式连接文件，不会覆盖文件原本内容，在后面追加"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.TRUNCATE_EXISTING"}),"：","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"如果文件存在并且以WRITE的方式连接时就会把文件内容清空，文件设置为0字节大小"}),"\n",(0,i.jsx)(e.li,{children:"如果文件只以READ连接 时，该选项会被忽略"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.CREATE"}),"：创建一个文件，如果文件已存在，就打开文件连接。与CREATE_NEW同时存在时该选项会被忽略"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.CREATE_NEW"}),"：创建一个文件，如果文件已存在，如果已经存在会抛异常"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.DELETE_ON_CLOSE"}),"：通道关闭时删除文件"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.SPARSE"}),"：创建稀疏文件，与CREATE_NEW选项配合使用"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.SYNC"}),"：要求每次写入要把内容和元数据刷到存储设备上"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"StandardOpenOption.DSYNC"}),"：要求每次写入要把内容刷到存储设备上"]}),"\n"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(s,n)})):s(n)}let c=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["tang%2Fjava2%2F13_IO%E6%B5%81.md"]={toc:[{id:"131-file类的使用",text:"13.1 File类的使用",depth:3},{id:"132-io流原理及流的分类",text:"13.2 IO流原理及流的分类",depth:3},{id:"133-filereader与filewriter的使用",text:"13.3 FileReader与FileWriter的使用",depth:3},{id:"134-fileinputstream与fileoutputstream的使用",text:"13.4 FileInputStream与FileOutputStream的使用",depth:3},{id:"135-处理流之缓冲流的使用",text:"13.5 处理流之缓冲流的使用",depth:3},{id:"136-处理流之转换流的使用",text:"13.6 处理流之转换流的使用",depth:3},{id:"137-字符集",text:"13.7 字符集",depth:3},{id:"138-处理流之标准的输入输出流",text:"13.8 处理流之标准的输入、输出流",depth:3},{id:"139-处理流之打印流",text:"13.9 处理流之打印流",depth:3},{id:"1310-处理流之数据流",text:"13.10 处理流之数据流",depth:3},{id:"1311-处理流之对象流",text:"13.11 处理流之对象流",depth:3},{id:"1312-序列化与反序列化",text:"13.12 序列化与反序列化",depth:3},{id:"1313-随机存取文件流",text:"13.13 随机存取文件流",depth:3},{id:"1314-nio2中pathpathsfiles类的使用",text:"13.14 NIO.2中Path、Paths、Files类的使用",depth:3}],title:"13 IO流",headingTitle:"13 IO流",frontmatter:{}}}}]);