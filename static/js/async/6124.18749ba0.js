"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["6124"],{64220:function(n,r,e){e.r(r),e.d(r,{default:function(){return c}});var s=e(85893),i=e(50065);function d(n){let r=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",code:"code",pre:"pre",div:"div",ul:"ul",li:"li",ol:"ol"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"commonjscmdesm和amd",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjscmdesm和amd",children:"#"}),"Commonjs、CMD、ESM和AMD"]}),"\n",(0,s.jsxs)(r.p,{children:["模块化的开发方式可以提供代码复用率，方便进行代码的管理。通常来说，",(0,s.jsx)(r.strong,{children:"一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数"}),"。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。"]}),"\n",(0,s.jsxs)(r.h2,{id:"commonjs",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs",children:"#"}),"CommonJS"]}),"\n",(0,s.jsxs)(r.p,{children:["NodeJS是CommonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：",(0,s.jsx)(r.code,{children:"module"}),"、",(0,s.jsx)(r.code,{children:"exports"}),"、",(0,s.jsx)(r.code,{children:"require"}),"、",(0,s.jsx)(r.code,{children:"global"}),"。实际使用时，用",(0,s.jsx)(r.code,{children:"module.exports"}),"\r\n定义当前模块对外输出的接口（不推荐直接用",(0,s.jsx)(r.code,{children:"exports"}),"），用",(0,s.jsx)(r.code,{children:"require"}),"加载模块。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"// 定义模块math.js\r\nvar basicNum = 0;\r\n\r\nfunction add(a, b) {\r\n    return a + b;\r\n}\r\n\r\nmodule.exports = { //在这里写上需要向外暴露的函数、变量\r\n    add: add,\r\n    basicNum: basicNum\r\n}\r\n\r\n/** 必须加./路径，不加的话只会去node_modules文件找 **/\r\n// 引用自定义的模块时，参数包含路径，可省略.js\r\nvar math = require('./math');\r\nmath.add(2, 5);\n"})}),"\n",(0,s.jsxs)(r.p,{children:["CommonJS用同步的方式加载模块。",(0,s.jsx)(r.strong,{children:"在服务端，模块文件都存放在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。"})]}),"\n",(0,s.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,s.jsx)(r.div,{className:"rspress-directive-title",children:"exports和module.export区别："}),(0,s.jsx)(r.div,{className:"rspress-directive-content",children:(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["exports：对于本身来讲是一个变量（对象），它不是module的引用，它是",(0,s.jsx)(r.code,{children:"{}"}),"的引用，它指向",(0,s.jsx)(r.code,{children:"module.exports"}),"的{}模块。只能使用",(0,s.jsx)(r.code,{children:"."}),"语法 向外暴露变量。"]}),"\n",(0,s.jsxs)(r.li,{children:["module.exports：",(0,s.jsx)(r.code,{children:"module"}),"是一个变量，指向一块内存，",(0,s.jsx)(r.code,{children:"exports"}),"是",(0,s.jsx)(r.code,{children:"module"}),"中的一个属性，存储在内存中，然后",(0,s.jsx)(r.code,{children:"exports"}),"属性指向",(0,s.jsx)(r.code,{children:"{}"}),"模块。既可以使用",(0,s.jsx)(r.code,{children:"."}),"语法，也可以使用",(0,s.jsx)(r.code,{children:"="}),"直接赋值。"]}),"\n"]})})]}),"\n",(0,s.jsxs)(r.h2,{id:"amd和requirejs",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#amd和requirejs",children:"#"}),"AMD和require.js"]}),"\n",(0,s.jsx)(r.p,{children:"AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()\r\n指定引用路径等，用definde()定义模块，用require()加载模块。"}),"\n",(0,s.jsx)(r.p,{children:"首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:'/** 网页中引入require.js及main.js **/\r\n<script src="js/require.js" data-main="js/main"><\/script>\r\n\r\n/** main.js 入口文件/主模块 **/\r\n// 首先用config()指定各模块路径和引用名\r\nrequire.config({\r\n    baseUrl: "js/lib",\r\n    paths: {\r\n        "jquery": "jquery.min",  //实际路径为js/lib/jquery.min.js\r\n        "underscore": "underscore.min",\r\n    }\r\n});\r\n// 执行基本操作\r\nrequire(["jquery", "underscore"], function ($, _) {\r\n    // some code here\r\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:"引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"// 定义math.js模块\r\ndefine(function () {\r\n    var basicNum = 0;\r\n    var add = function (x, y) {\r\n        return x + y;\r\n    };\r\n    return {\r\n        add: add,\r\n        basicNum: basicNum\r\n    };\r\n});\r\n\r\n// 定义一个依赖underscore.js的模块\r\ndefine(['underscore'], function (_) {\r\n    var classify = function (list) {\r\n        _.countBy(list, function (num) {\r\n            return num > 30 ? 'old' : 'young';\r\n        })\r\n    };\r\n    return {\r\n        classify: classify\r\n    };\r\n})\r\n\r\n// 引用模块，将模块放在[]内\r\nrequire(['jquery', 'math'], function ($, math) {\r\n    var sum = math.add(10, 20);\r\n    $(\"#sum\").html(sum);\r\n});\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"cmd和seajs",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#cmd和seajs",children:"#"}),"CMD和sea.js"]}),"\n",(0,s.jsx)(r.p,{children:"CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:'/** AMD写法 **/\r\ndefine(["a", "b", "c", "d", "e", "f"], function (a, b, c, d, e, f) {\r\n    // 等于在最前面声明并初始化了要用到的所有模块\r\n    a.doSomething();\r\n    if (false) {\r\n        // 即便没用到某个模块 b，但 b 还是提前执行了\r\n        b.doSomething()\r\n    }\r\n});\r\n\r\n/** CMD写法 **/\r\ndefine(function (require, exports, module) {\r\n    var a = require(\'./a\'); //在需要时申明\r\n    a.doSomething();\r\n    if (false) {\r\n        var b = require(\'./b\');\r\n        b.doSomething();\r\n    }\r\n});\r\n\r\n/** sea.js **/\r\n// 定义模块 math.js\r\ndefine(function (require, exports, module) {\r\n    var $ = require(\'jquery.js\');\r\n    var add = function (a, b) {\r\n        return a + b;\r\n    }\r\n    exports.add = add;\r\n});\r\n\r\n// 加载模块\r\nseajs.use([\'math.js\'], function (math) {\r\n    var sum = math.add(1 + 2);\r\n});\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"es6-module",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#es6-module",children:"#"}),"ES6 Module"]}),"\n",(0,s.jsx)(r.p,{children:"ES6\r\n在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"/** 定义模块 math.js **/\r\nvar basicNum = 0;\r\nvar add = function (a, b) {\r\n    return a + b;\r\n};\r\nexport {basicNum, add};\r\n\r\n/** 引用模块 **/\r\nimport {basicNum, add} from './math';\r\n\r\nfunction test(ele) {\r\n    ele.textContent = add(99 + basicNum);\r\n}\n"})}),"\n",(0,s.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,s.jsx)(r.div,{className:"rspress-directive-title",children:"ES6 模块的特征："}),(0,s.jsx)(r.div,{className:"rspress-directive-content",children:(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"严格模式：ES6 的模块自动采用严格模式"}),"\n",(0,s.jsx)(r.li,{children:"import read-only特性： import的属性是只读的，不能赋值，类似于const的特性"}),"\n",(0,s.jsx)(r.li,{children:"export/import提升： import/export必须位于模块顶级，不能位于作用域内；其次对于模块内的import/export会提升到模块顶部，这是在编译阶段完成的"}),"\n"]})})]}),"\n",(0,s.jsxs)(r.h2,{id:"es6-模块与-commonjs-模块的差异",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#es6-模块与-commonjs-模块的差异",children:"#"}),"ES6 模块与 CommonJS 模块的差异"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"}),"。"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。"}),"\n",(0,s.jsx)(r.li,{children:"ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6\r\n的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"运行时加载: CommonJS模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。"}),"\n",(0,s.jsx)(r.li,{children:"编译时加载: ES6模块不是对象，而是通过export命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"首先看个CommonJS输出拷贝的例子："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"// a.js\r\nlet a = 1;\r\nlet b = { num: 1 }\r\nsetTimeout(() => {\r\n    a = 2;\r\n    b = { num: 2 };\r\n}, 200);\r\nmodule.exports = {\r\n    a,\r\n    b,\r\n};\r\n\r\n// main.js\r\n// node main.js\r\nlet {a, b} = require('./a');\r\nconsole.log(a);  // 1\r\nconsole.log(b);  // { num: 1 }\r\nsetTimeout(() => {\r\n    console.log(a);  // 1\r\n    console.log(b);  // { num: 1 }\r\n}, 500);\n"})}),"\n",(0,s.jsx)(r.p,{children:"所谓输出拷贝，如果了解过 NodeJS 或者 webpack 对 CommonJS 的实现（不了解可以看这篇文章），就会知道：exports对象是模块内外的唯一关联， CommonJS 输出的内容，就是exports对象的属性，模块运行结束，属性就确定了。\r\n再看ES6 Module输出的例子："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"// a.mjs\r\nlet a = 1;\r\nlet b = { num: 1 }\r\nsetTimeout(() => {\r\n    a = 2;\r\n    b = { num: 2 };\r\n}, 200);\r\nexport {\r\n    a,\r\n    b,\r\n};\r\n\r\n// main.mjs\r\n// node --experimental-modules main.mjs\r\nimport {a, b} from './a';\r\nconsole.log(a);  // 1\r\nconsole.log(b);  // { num: 1 }\r\nsetTimeout(() => {\r\n    console.log(a);  // 2\r\n    console.log(b);  // { num: 2 }\r\n}, 500);\n"})}),"\n",(0,s.jsx)(r.p,{children:"以上就是 ES6 Module 输出引用和 CommonJS 输出值的区别，模块内部引用的变化，会反应在外部，这是 ES6 Module 的规范。"}),"\n",(0,s.jsxs)(r.h2,{id:"总结",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"AMD/CMD/CommonJs 是js模块化开发的规范，对应的实现是require.js/sea.js/Node.js"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"CommonJs 主要针对服务端，AMD/CMD/ES Module主要针对浏览器端，容易混淆的是AMD/CMD。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。\r\nAMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。\r\nAMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。\r\nCMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。\r\nCMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。（PS：重新看这篇文章，发现这里写的不是很准确。确切来说，JS是单线程，所有JS文件执行时间叠加在AMD和CMD中是一样的。但是CMD是使用时执行，没法利用空闲时间，而AMD是文件加载好就执行，往往可以利用一些空闲时间。这么来看，CMD比AMD的优点还是很明显的，毕竟AMD加载好的时候也未必就是JS引擎的空闲时间！）"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"CommonJS 和 ES Module 区别：CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"如何使用？CommonJs的话，因为NodeJS就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过script标签引入require.js，CMD则是引入sea.js"}),"\n"]}),"\n"]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),n.components);return r?(0,s.jsx)(r,Object.assign({},n,{children:(0,s.jsx)(d,n)})):d(n)}let c=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["notes%2FJS%2Fmodules.md"]={toc:[{id:"commonjs",text:"CommonJS",depth:2},{id:"amd和requirejs",text:"AMD和require.js",depth:2},{id:"cmd和seajs",text:"CMD和sea.js",depth:2},{id:"es6-module",text:"ES6 Module",depth:2},{id:"es6-模块与-commonjs-模块的差异",text:"ES6 模块与 CommonJS 模块的差异",depth:2},{id:"总结",text:"总结",depth:2}],title:"Commonjs、CMD、ESM和AMD",headingTitle:"Commonjs、CMD、ESM和AMD",frontmatter:{}}}}]);