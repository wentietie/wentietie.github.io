"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["2695"],{83773:function(e,n,i){i.r(n),i.d(n,{default:()=>Z});var r=i("85893"),s=i("50065");let d=i.p+"static/image/image-20220127171558841.3511cc81.png",l=i.p+"static/image/image-20220127171820634.2808147c.png",c=i.p+"static/image/image-20220209154437564.91be419a.png",h=i.p+"static/image/image-20220209154452236.fbfa2b11.png",a=i.p+"static/image/image-20220209151658578.a2db9c4a.png",t=i.p+"static/image/image-20220209151739496.c5bc20a7.png",x=i.p+"static/image/image-20220209164321092.0fd6b2cc.png",j=i.p+"static/image/image-20220209164434848.199ffb4a.png",o=i.p+"static/image/image-20220209164849881.9696bfb2.png",p=i.p+"static/image/image-20220209165620070.409ff6ed.png",g=i.p+"static/image/image-20220209170014814.658911c4.png",m=i.p+"static/image/image-20220209170120507.0416eb0f.png",u=i.p+"static/image/image-20220209171005236.96cf43bb.png",b=i.p+"static/image/12.e1119f75.png",k=i.p+"static/image/image-20220209174439226.7414f710.png",f=i.p+"static/image/image-20220209175005801.a11452d9.png",q=i.p+"static/image/image-20220209175858695.a433313c.png",N=i.p+"static/image/image-20220209180256860.63c574bf.png",R=i.p+"static/image/image-20220209180441253.3b83321b.png",F=i.p+"static/image/image-20220209180558252.a2d6d255.png",S=i.p+"static/image/image-20220209180819755.6932485c.png",y=i.p+"static/image/image-20220209180923497.54c2f40a.png",M=i.p+"static/image/image-20220210093916467.2f9a1d6b.png",w=i.p+"static/image/8-5-1-16444579203281.aec9dcac.png",Q=i.p+"static/image/image-20220210103110838.f4a71eef.png",C=i.p+"static/image/image-20220210104913398.591eacfb.png",A=i.p+"static/image/image-20220210131410083.2678a70b.png",v=i.p+"static/image/image-20220210140826301.5f0123b4.png",D=i.p+"static/image/image-20220210141144238.1f4647f1.png",E=i.p+"static/image/image-20220210143457921.520554d2.png",P=i.p+"static/image/image-20220210143938080.32583e34.png",G=i.p+"static/image/image-20220210145521763.0952ca1b.png",T=i.p+"static/image/image-20220210164846034.b942216f.png",_=i.p+"static/image/image-20220210171202166.0f3f66e6.png",B=i.p+"static/image/image-20220210173943912.3cfbaba5.png",I=i.p+"static/image/image-20220210174208165.6990013c.png",L=i.p+"static/image/image-20220210175441671.f8029633.png";function H(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",img:"img",code:"code",pre:"pre",h3:"h3",h4:"h4"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"微服务学习",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微服务学习",children:"#"}),"微服务学习"]}),"\n",(0,r.jsxs)(n.h1,{id:"1认识微服务",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1认识微服务",children:"#"}),"1.认识微服务"]}),"\n",(0,r.jsxs)(n.h2,{id:"11-分布式架构",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-分布式架构",children:"#"}),"1.1 分布式架构"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"定义"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"根据业务功能对系统进行拆分，每个业务模块的作为独立项目开发，成为一个服务。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"优点"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"降低服务耦合"}),"\n",(0,r.jsx)(n.li,{children:"有利于服务扩展"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"分布式架构要考虑的问题"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"服务拆分粒度？"}),"\n",(0,r.jsx)(n.li,{children:"服务集群地址如何维护？"}),"\n",(0,r.jsx)(n.li,{children:"服务之间如何实现远程调用？"}),"\n",(0,r.jsx)(n.li,{children:"服务健康状态如何感知？"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"12-微服务",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-微服务",children:"#"}),"1.2 微服务"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"定义"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["微服务是一种经过良好架构设计的",(0,r.jsx)(n.strong,{children:"分布式"}),"架构方案。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"特征"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"==单一职责==：微服务拆分粒度更小，每一个服务对应唯一的业务能力，做到单一职责，避免业务重复开发"}),"\n",(0,r.jsx)(n.li,{children:"==面向对象==：微服务对外暴露接口"}),"\n",(0,r.jsx)(n.li,{children:"==自治==：团队独立、技术独立、数据独立、部署独立"}),"\n",(0,r.jsx)(n.li,{children:"==隔离性强==：服务调用做好隔离、容错、降级，避免出现隔离问题"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"微服务技术对比"}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{children:"Dubbo"}),(0,r.jsx)(n.th,{children:"SpringCloud"}),(0,r.jsx)(n.th,{children:"SpringCloudAlibaba"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"注册中心"}),(0,r.jsx)(n.td,{children:"zookeeper、Redis"}),(0,r.jsx)(n.td,{children:"Eureka、Consul"}),(0,r.jsx)(n.td,{children:"Nacos、Eureka"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"服务远程调用"}),(0,r.jsx)(n.td,{children:"Dobbo协议"}),(0,r.jsx)(n.td,{children:"Feign（http协议）"}),(0,r.jsx)(n.td,{children:"Dubbo、Feign"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"配置中心"}),(0,r.jsx)(n.td,{children:"无"}),(0,r.jsx)(n.td,{children:"SpringCloudConfig"}),(0,r.jsx)(n.td,{children:"SpringCloudConfig、Nacos"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"服务网关"}),(0,r.jsx)(n.td,{children:"无"}),(0,r.jsx)(n.td,{children:"SpringCloudGateway、Zuul"}),(0,r.jsx)(n.td,{children:"SpringCloudGateway、Zuul"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"服务监控和保护"}),(0,r.jsx)(n.td,{children:"dubbo-admin，功能弱"}),(0,r.jsx)(n.td,{children:"Hystrix"}),(0,r.jsx)(n.td,{children:"Sentinel"})]})]})]}),"\n",(0,r.jsxs)(n.h2,{id:"13-springcloud",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-springcloud",children:"#"}),"1.3 SpringCloud"]}),"\n",(0,r.jsx)(n.p,{children:"目前使用最广泛的微服务架构。"}),"\n",(0,r.jsxs)(n.h1,{id:"2服务拆分及远程调用",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2服务拆分及远程调用",children:"#"}),"2.服务拆分及远程调用"]}),"\n",(0,r.jsxs)(n.h2,{id:"21-服务拆分注意事项",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-服务拆分注意事项",children:"#"}),"2.1 服务拆分注意事项"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"不同微服务，不要重复开发相同业务。"}),"\n",(0,r.jsx)(n.li,{children:"微服务数据独立，不要访问其他微服务的数据库。"}),"\n",(0,r.jsx)(n.li,{children:"微服务可以将自己的业务暴露为接口，供其他服务使用。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"22-服务调用关系",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-服务调用关系",children:"#"}),"2.2 服务调用关系"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"==服务提供者==：一次业务中，被其他微服务调用的服务。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"==服务消费者==：一次业务中，低啊用其他微服务的服务。"}),"\n",(0,r.jsxs)(n.p,{children:["==",(0,r.jsx)(n.strong,{children:"提供者与消费者的角色是相对而言的"}),"==：一个服务既可以是消费者，又可以是提供者"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"23-eureka注册中心",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-eureka注册中心",children:"#"}),"2.3 Eureka注册中心"]}),"\n",(0,r.jsx)(n.p,{children:"Eureka架构中,微服务角色有两类:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"EurekaServer：服务端，注册中心"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"作用：记录服务信息，监控客户端心跳"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"EurekaClient：客户端"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Provider：服务提供者","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"启动时，注册自己的信息到EurekaServer"}),"\n",(0,r.jsx)(n.li,{children:"每隔30s向EurekaServer发送心跳"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Consumer：服务消费者","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"根据服务名称从EurekaServer拉取服务列表"}),"\n",(0,r.jsx)(n.li,{children:"基于服务列表做负载均衡，选中一个微服务后发起调用。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"24-ribbon负载均衡",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-ribbon负载均衡",children:"#"}),"2.4 Ribbon负载均衡"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Ribbon负载均衡流程"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220127171558841",src:d})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"负载均衡策略"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"==Ribbon的负载均衡规则是一个叫IRule的接口来定义的，每一个子接口都是一种规则。=="}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220127171820634",src:l})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"内置负载均衡规则类"}),(0,r.jsx)(n.th,{children:"规则描述"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"RoundRobinRule"}),(0,r.jsx)(n.td,{children:"轮询。Ribbon默认的负载均衡。"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"AvailabilityFilteringRule"}),(0,r.jsxs)(n.td,{children:["对以下两种服务器忽略: ","1.“短路”的服务器。默认情况下，如果一台服务器3次连接失败，就会被设置为“短路”状态。短路状态将持续30s，如果再次连接失败，短路状态持续时间几何级增加。"," 2.并发数过高的服务器。可以由",(0,r.jsx)(n.code,{children:"<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit"}),"配置。"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"WeightedResponseTimeRule"}),(0,r.jsx)(n.td,{children:"为每一个服务器赋予一个权重值。服务器响应时间越长，其权重值越小。这个规则会随机选择服务器，权重值会影响服务器的选择。"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ZoneAvoidanceRule"}),(0,r.jsx)(n.td,{children:"以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"BestAvailableRule"}),(0,r.jsx)(n.td,{children:"忽略短路服务器，并选择并发数较低的服务器。"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"RandomRule"}),(0,r.jsx)(n.td,{children:"随机选择一个可用的服务器。"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"RetryRule"}),(0,r.jsx)(n.td,{children:"重试机制的选择逻辑。"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"RandomRule"}),(0,r.jsx)(n.td,{children:"随机选择。"})]})]})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"负载均衡两种配置方式"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"在消费者服务的启动类里注入IRule"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",meta:"",children:"@Bean\r\npublic IRule randomRule() {\r\n    return new RendomRule();\r\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"在消费者服务的yaml文件里添加规则"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",meta:"",children:"userservice: # 服务提供者的服务名\r\n    ribbon:\r\n       NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"==以上二者的区别==："}),"\n",(0,r.jsx)(n.p,{children:"​	第一种是所有服务的负载均衡策略都是RandomRule；第二种是只有指定服务名（userservice）的服务的负载均衡策略是RandomRule。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Ribbon 策略--饥饿加载"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Ribbon默认使用的是",(0,r.jsx)(n.strong,{children:"懒加载"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"==开启饥饿加载=="}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",meta:"",children:"ribbon:\r\n  eager-load:\r\n      enable: true # 开启饥饿加载\r\n      clients: userservice # 只对单个服务开启饥饿加载\r\n#--------------------------------------------------------------------------------------------      \r\nribbon:\r\n  eager-load:\r\n      enable: true # 开启饥饿加载\r\n      clients: \r\n        - userservice # 对多个服务开启饥饿加载\r\n           goodservice\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"25-nacos注册中心",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-nacos注册中心",children:"#"}),"2.5 Nacos注册中心"]}),"\n",(0,r.jsxs)(n.h1,{id:"7feignhttp客户端",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7feignhttp客户端",children:"#"}),"7.Feign(HTTP客户端)"]}),"\n",(0,r.jsxs)(n.h2,{id:"71-feign替代resttemplate",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-feign替代resttemplate",children:"#"}),"7.1 Feign替代RestTemplate"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Feign定义"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Feign是一个声明式的http客户端，作用是帮助我们优雅的实现http请求的发现，帮助实现各个微服务内部之间的调用。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"使用"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Step1. 引入依赖"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209154437564",src:c})}),"\n",(0,r.jsx)(n.p,{children:"Step2. 启动类添加Feign启动注解"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209154452236",src:h})}),"\n",(0,r.jsx)(n.p,{children:"Step3. 编写Feign客户端"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209151658578",src:a})}),"\n",(0,r.jsx)(n.p,{children:"Step4. 测试使用"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209151739496",src:t})}),"\n",(0,r.jsxs)(n.h2,{id:"72-自定义配置",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-自定义配置",children:"#"}),"7.2 自定义配置"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"概念"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209164321092",src:x})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"使用配置文件配置Feign日志"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209164434848",src:j})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"使用注解配置Feign日志"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209164849881",src:o})}),"\n",(0,r.jsxs)(n.h2,{id:"73-feign使用优化",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#73-feign使用优化",children:"#"}),"7.3 Feign使用优化"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Feign底层客户端实现"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"URLConnection：默认实现，不支持连接池，性能较差"}),"\n",(0,r.jsx)(n.li,{children:"Apache HttpClient：支持连接池"}),"\n",(0,r.jsx)(n.li,{children:"OKHttp：支持连接池"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"优化策略"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"使用连接池代替默认URLConnection"}),"\n",(0,r.jsx)(n.li,{children:"日志级别，最好使用basic或none"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Feign性能优化-连接池配置"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209165620070",src:p})}),"\n",(0,r.jsxs)(n.h2,{id:"74-最佳实践",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#74-最佳实践",children:"#"}),"7.4 最佳实践"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"方式一--继承（耦合度比较高）"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209170014814",src:g})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"方式二--抽取（如果FeignAPI功能比较多，包比较大，orderservice只用到一两个方法，就造成了浪费）"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209170120507",src:m})}),"\n",(0,r.jsx)(n.p,{children:"方式2的实现难点"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用，解决方法如下："}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209171005236",src:u})}),"\n",(0,r.jsxs)(n.h1,{id:"8统一网关gateway",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8统一网关gateway",children:"#"}),"8.统一网关Gateway"]}),"\n",(0,r.jsxs)(n.h2,{id:"81-为什么需要网关",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#81-为什么需要网关",children:"#"}),"8.1 为什么需要网关"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"网关功能"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"对用户请求做身份认证和权限校验"}),"\n",(0,r.jsx)(n.li,{children:"将用户请求路由到微服务，并实现负载均衡"}),"\n",(0,r.jsx)(n.li,{children:"对要不过户请求做限流"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"网关的技术实现"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"gateway"}),"\n",(0,r.jsx)(n.li,{children:"zuul"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"==对比==：zuul是基于servlet实现，属于阻塞式变成。gateway是基于SPring5中提供的WebFlux，属于响应式变成，具备更好的性能。"}),"\n",(0,r.jsxs)(n.h2,{id:"82-gateway快速入门",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#82-gateway快速入门",children:"#"}),"8.2 gateway快速入门"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"搭建步骤"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"12",src:b})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"请求流程"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209174439226",src:k})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"总结->路由可以配置的内容包括以下几点："}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"路由id：路由唯一标识"}),"\n",(0,r.jsx)(n.li,{children:"路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名称做负载均衡"}),"\n",(0,r.jsx)(n.li,{children:"路由断言（predicates）：判断路由规则"}),"\n",(0,r.jsx)(n.li,{children:"路由过滤器（filters）：对请求或响应做处理"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"83-断言工厂",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#83-断言工厂",children:"#"}),"8.3 断言工厂"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"作用"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"读取用户在配置文件中编写的断言规则，将他们解析出来，并且对请求做出判断"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Spring提供的11中基本的Predicate工厂"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209175005801",src:f})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"After断言工厂的使用"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209175858695",src:q})}),"\n",(0,r.jsx)(n.p,{children:"==当前是2022年，不符合路由规则，此时访问会报404=="}),"\n",(0,r.jsxs)(n.h2,{id:"84-过滤器工厂",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#84-过滤器工厂",children:"#"}),"8.4 过滤器工厂"]}),"\n",(0,r.jsxs)(n.h3,{id:"841-路由过滤器gatewayfilter",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#841-路由过滤器gatewayfilter",children:"#"}),"8.4.1 路由过滤器GatewayFilter"]}),"\n",(0,r.jsx)(n.p,{children:"GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209180256860",src:N})}),"\n",(0,r.jsxs)(n.h3,{id:"842-路由过滤器工厂",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#842-路由过滤器工厂",children:"#"}),"8.4.2 路由过滤器工厂"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"过滤器的作用"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"对路由的请求或响应做加工处理，比如添加请求头"}),"\n",(0,r.jsx)(n.li,{children:"配置在路由下的过滤器只对当前路由的请求生效（==如果想对所有路由都生效，可以使用defaultFilter==）"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"一共30多种。使用时可以参考官网。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209180441253",src:R})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"例子：给所有进入userservice的请求加一个请求头：Truth=Itcast is freeking awesome！"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209180558252",src:F})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209180819755",src:S})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"优化：给所有请求都加上请求头：Truth=Itcast is freeking awesome！"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220209180923497",src:y})}),"\n",(0,r.jsxs)(n.h2,{id:"85-全局过滤器globalfilter",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#85-全局过滤器globalfilter",children:"#"}),"8.5 全局过滤器GlobalFilter"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"作用"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"处理一切进入网关的请求和微服务响应，和GatewayFilter的作用一样。==区别==在于GatewayFilter通过配置定义，处理逻辑是固定的；但是GlobalFilter的逻辑需要自己写代码实现。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"实现方式"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"实现GlobalFilter接口。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210093916467",src:M})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"案例：编写一个拦截器，获取请求中的authorization参数。如果用户是admin，放行，否则就拦截。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"8-5-1",src:w})}),"\n",(0,r.jsxs)(n.h2,{id:"86-过滤器执行顺序",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#86-过滤器执行顺序",children:"#"}),"8.6 过滤器执行顺序"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"order值越小，执行顺序越靠前"}),"\n",(0,r.jsx)(n.li,{children:"order值相等时，安装defaultFilter>路由过滤器>GlobalFilter的顺序执行。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"87-跨域问题",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#87-跨域问题",children:"#"}),"8.7 跨域问题"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"定义"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"解决方案"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"CORS"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"实现"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210103110838",src:Q})}),"\n",(0,r.jsxs)(n.h1,{id:"9docker",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9docker",children:"#"}),"9.Docker"]}),"\n",(0,r.jsxs)(n.h2,{id:"91-初识docker",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#91-初识docker",children:"#"}),"9.1 初识Docker"]}),"\n",(0,r.jsxs)(n.h3,{id:"911-概念",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#911-概念",children:"#"}),"9.1.1 概念"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Docker如何解决大型项目依赖关系复杂、不同组件依赖兼容性的问题？"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Docker允许开发中将应用、依赖、函数库、配置一起",(0,r.jsx)(n.strong,{children:"打包"}),"，形成可移植镜像。"]}),"\n",(0,r.jsxs)(n.li,{children:["Docker应用运行在容器中，使用沙箱机制，相互",(0,r.jsx)(n.strong,{children:"隔离"})]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Docker如何解决开发、测试、生产环境有差异的问题？"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Docker镜像中包含完整的运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行。"}),"\n",(0,r.jsxs)(n.h3,{id:"912-docker与虚拟机的区别",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#912-docker与虚拟机的区别",children:"#"}),"9.1.2 Docker与虚拟机的区别"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Docker是一个系统进程；虚拟机是在操作系统中的操作系统"}),"\n",(0,r.jsx)(n.li,{children:"Docker体积小，启动速度快，性能好；虚拟机体积大，启动速度慢，性能较差。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210104913398",src:C})}),"\n",(0,r.jsxs)(n.h3,{id:"913-docker架构",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#913-docker架构",children:"#"}),"9.1.3 Docker架构"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210131410083",src:A})}),"\n",(0,r.jsxs)(n.h2,{id:"92-数据卷",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#92-数据卷",children:"#"}),"9.2 数据卷"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210140826301",src:v})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210141144238",src:D})}),"\n",(0,r.jsxs)(n.h2,{id:"93-目录挂载",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#93-目录挂载",children:"#"}),"9.3 目录挂载"]}),"\n",(0,r.jsx)(n.p,{children:"命令和数据卷挂载一致。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"目录挂载和数据卷挂载的区别"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210143457921",src:E})}),"\n",(0,r.jsxs)(n.h2,{id:"94-镜像",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#94-镜像",children:"#"}),"9.4 镜像"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"定义"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["镜像是将",(0,r.jsx)(n.strong,{children:"应用程序"}),"及其需要的",(0,r.jsx)(n.strong,{children:"系统函数库"}),"、",(0,r.jsx)(n.strong,{children:"环境"}),"、",(0,r.jsx)(n.strong,{children:"配置"}),"、依赖打包而成。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"镜像结构"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"==镜像是分层结构，每一层称为一个Layer=="}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210143938080",src:P})}),"\n",(0,r.jsxs)(n.h2,{id:"95-dockercompose",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#95-dockercompose",children:"#"}),"9.5 DockerCompose"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"概念"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"DockerCompose基于Compose文件实现快速部署分布式应用。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Compose文件是一个文本文件，通过指令定义急群众的每个容器如何运行。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210145521763",src:G})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"10--服务异步通讯rabbitmq",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10--服务异步通讯rabbitmq",children:"#"}),"10.  服务异步通讯RabbitMQ"]}),"\n",(0,r.jsxs)(n.h2,{id:"101-初始mq",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#101-初始mq",children:"#"}),"10.1 初始MQ"]}),"\n",(0,r.jsxs)(n.h3,{id:"1011-同步通讯",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1011-同步通讯",children:"#"}),"10.1.1 同步通讯"]}),"\n",(0,r.jsx)(n.p,{children:"==微服务间基于Feign的调用就属于同步方式。=="}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"优点"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"时效性强，能够立即得到结果"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"同步调用的问题"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"耦合度高"}),"：每次加入新需求，都要改原来的代码"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"性能下降"}),"：调用者需要等待提供者响应。如果调用链过程则响应时间等于每次调用的时间之和"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"资源浪费"}),"：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下极度浪费系统资源"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"级联失败"}),"：如果提供者出现问题，所有调用方法都会跟着出问题，如同多米诺骨牌，迅速导致整个微服务群故障"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"1012-异步通讯",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1012-异步通讯",children:"#"}),"10.1.2 异步通讯"]}),"\n",(0,r.jsx)(n.p,{children:"==异步调用常见实现就是事件驱动模式。=="}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210164846034",src:T})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"优势"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"服务解耦"}),"\n",(0,r.jsx)(n.li,{children:"性能提升，吞吐量提高"}),"\n",(0,r.jsx)(n.li,{children:"服务没有强依赖，不担心级联失败问题"}),"\n",(0,r.jsx)(n.li,{children:"流量削峰"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"缺点"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"依赖于Broker的可靠性、安全性、吞吐能力"}),"\n",(0,r.jsx)(n.li,{children:"架构复杂了，业务没有明显的流程线，不好追踪管理"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"1013-mq常见框架",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1013-mq常见框架",children:"#"}),"10.1.3 MQ常见框架"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"MQ定义"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"MQ（MessageQueue），存放消息的队列，即时间驱动架构中的Broker。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"MQ常见框架对比"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210171202166",src:_})}),"\n",(0,r.jsxs)(n.h2,{id:"102-rabbitmq快速入门",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#102-rabbitmq快速入门",children:"#"}),"10.2 RabbitMQ快速入门"]}),"\n",(0,r.jsxs)(n.h3,{id:"1021-概述",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1021-概述",children:"#"}),"10.2.1 概述"]}),"\n",(0,r.jsx)(n.p,{children:"==RabbitMQ最擅长的是消息的可靠性、稳定性，以及系统的高可用=="}),"\n",(0,r.jsxs)(n.p,{children:["官网：",(0,r.jsx)(n.a,{href:"https://www.rabbitmq.com/",rel:"noopener noreferrer",target:"_blank",children:"Messaging that just works — RabbitMQ"})]}),"\n",(0,r.jsxs)(n.h4,{id:"10211-单机部署mq",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10211-单机部署mq",children:"#"}),"10.2.1.1 单机部署MQ"]}),"\n",(0,r.jsx)(n.p,{children:"Step1. 下载RabbitMQ镜像"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",meta:"",children:"docker pull rabbitmq:3-management\n"})}),"\n",(0,r.jsx)(n.p,{children:"Step2. 运行MQ容器"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",meta:"",children:"docker run \\\r\n  -e RABBITMQ_DEFAULT_USER=itcast \\\r\n  -e RABBITMQ_DEFAULT_PASS=123456 \\\r\n  --name mq \\\r\n  --hostname mq1 \\ # 配置主机名，单机的话可以不设置，但是集群部署必须设置\r\n  -p 15672:15672 \\   # mq管理平台的端口，提供一个UI界面\r\n  -p 5672:5672 \\   # 消息接收与发送端口\r\n  -d \\\r\n  rabbitmq:3-management\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"1022-rabbitmq概念和结构",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1022-rabbitmq概念和结构",children:"#"}),"10.2.2 RabbitMQ概念和结构"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"概念"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"channel：操作MQ的工具"}),"\n",(0,r.jsx)(n.li,{children:"exchange：路由消息到队列中"}),"\n",(0,r.jsx)(n.li,{children:"queue：缓存消息"}),"\n",(0,r.jsx)(n.li,{children:"virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"结构"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210173943912",src:B})}),"\n",(0,r.jsxs)(n.h2,{id:"103-常见消息模型",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#103-常见消息模型",children:"#"}),"10.3 常见消息模型"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210174208165",src:I})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Hello World 实践"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20220210175441671",src:L})}),"\n",(0,r.jsxs)(n.h2,{id:"104-springamqp",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#104-springamqp",children:"#"}),"10.4 SpringAMQP"]}),"\n",(0,r.jsxs)(n.h3,{id:"1041-概念",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1041-概念",children:"#"}),"10.4.1 概念"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"AMQP"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),"dvanced ",(0,r.jsx)(n.strong,{children:"M"}),"essage ",(0,r.jsx)(n.strong,{children:"Q"}),"ueuing ",(0,r.jsx)(n.strong,{children:"P"}),"rotocol，用于在应用程序之间传递业务消息的开放标准。该协议与平台无关，更符合微服务中独立性要求。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Spring AMQP"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Spring AMQP是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。"}),"\n",(0,r.jsx)(n.p,{children:"==特征=="}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"侦听器容器，用于异步处理入栈消息"}),"\n",(0,r.jsx)(n.li,{children:"支持用于发送和接收消息的RabbitTemplate"}),"\n",(0,r.jsx)(n.li,{children:"支持RabbitAdmin自动声明队列、交换、绑定"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"1042-案例",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1042-案例",children:"#"}),"10.4.2 案例"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"利用SpringAMQP实现HelloWorld中的基础消息队列功能"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"流程如下："})]})}function U(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(H,e)})):H(e)}let Z=U;U.__RSPRESS_PAGE_META={},U.__RSPRESS_PAGE_META["tang%2Fmservice%2F2.md"]={toc:[{id:"11-分布式架构",text:"1.1 分布式架构",depth:2},{id:"12-微服务",text:"1.2 微服务",depth:2},{id:"13-springcloud",text:"1.3 SpringCloud",depth:2},{id:"21-服务拆分注意事项",text:"2.1 服务拆分注意事项",depth:2},{id:"22-服务调用关系",text:"2.2 服务调用关系",depth:2},{id:"23-eureka注册中心",text:"2.3 Eureka注册中心",depth:2},{id:"24-ribbon负载均衡",text:"2.4 Ribbon负载均衡",depth:2},{id:"25-nacos注册中心",text:"2.5 Nacos注册中心",depth:2},{id:"71-feign替代resttemplate",text:"7.1 Feign替代RestTemplate",depth:2},{id:"72-自定义配置",text:"7.2 自定义配置",depth:2},{id:"73-feign使用优化",text:"7.3 Feign使用优化",depth:2},{id:"74-最佳实践",text:"7.4 最佳实践",depth:2},{id:"81-为什么需要网关",text:"8.1 为什么需要网关",depth:2},{id:"82-gateway快速入门",text:"8.2 gateway快速入门",depth:2},{id:"83-断言工厂",text:"8.3 断言工厂",depth:2},{id:"84-过滤器工厂",text:"8.4 过滤器工厂",depth:2},{id:"841-路由过滤器gatewayfilter",text:"8.4.1 路由过滤器GatewayFilter",depth:3},{id:"842-路由过滤器工厂",text:"8.4.2 路由过滤器工厂",depth:3},{id:"85-全局过滤器globalfilter",text:"8.5 全局过滤器GlobalFilter",depth:2},{id:"86-过滤器执行顺序",text:"8.6 过滤器执行顺序",depth:2},{id:"87-跨域问题",text:"8.7 跨域问题",depth:2},{id:"91-初识docker",text:"9.1 初识Docker",depth:2},{id:"911-概念",text:"9.1.1 概念",depth:3},{id:"912-docker与虚拟机的区别",text:"9.1.2 Docker与虚拟机的区别",depth:3},{id:"913-docker架构",text:"9.1.3 Docker架构",depth:3},{id:"92-数据卷",text:"9.2 数据卷",depth:2},{id:"93-目录挂载",text:"9.3 目录挂载",depth:2},{id:"94-镜像",text:"9.4 镜像",depth:2},{id:"95-dockercompose",text:"9.5 DockerCompose",depth:2},{id:"101-初始mq",text:"10.1 初始MQ",depth:2},{id:"1011-同步通讯",text:"10.1.1 同步通讯",depth:3},{id:"1012-异步通讯",text:"10.1.2 异步通讯",depth:3},{id:"1013-mq常见框架",text:"10.1.3 MQ常见框架",depth:3},{id:"102-rabbitmq快速入门",text:"10.2 RabbitMQ快速入门",depth:2},{id:"1021-概述",text:"10.2.1 概述",depth:3},{id:"10211-单机部署mq",text:"10.2.1.1 单机部署MQ",depth:4},{id:"1022-rabbitmq概念和结构",text:"10.2.2 RabbitMQ概念和结构",depth:3},{id:"103-常见消息模型",text:"10.3 常见消息模型",depth:2},{id:"104-springamqp",text:"10.4 SpringAMQP",depth:2},{id:"1041-概念",text:"10.4.1 概念",depth:3},{id:"1042-案例",text:"10.4.2 案例",depth:3}],title:"微服务学习",headingTitle:"微服务学习",frontmatter:{}}}}]);