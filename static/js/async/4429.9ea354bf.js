"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["4429"],{93632:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var s=r("85893"),a=r("50065");let i=r.p+"static/image/17_REPL1.01a0d17c.png",l=r.p+"static/image/17_REPL2.aeb99208.png",t=r.p+"static/image/17_img.2982eef8.png";function d(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",ul:"ul",li:"li",h2:"h2",h3:"h3",strong:"strong",pre:"pre",code:"code",img:"img",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,a.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"17-java91011新特性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17-java91011新特性",children:"#"}),"17 Java9&10&11新特性"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["从java9开始，java的从","以特性驱动","的发布周期转变为","以时间驱动","的发布周期。\r\nJava的计划发布周期是","6个月","，Oracle（在Java11之后）将以","三年为周期","发布长期支持版本。"]}),"\n",(0,s.jsx)(e.li,{children:"java9、java10不是长期支持的版本，java11是长期支持的版本。因此可以不用安装java9、java10，直接安装java11就行"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"171-java9新特性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#171-java9新特性",children:"#"}),"17.1 Java9新特性"]}),"\n",(0,s.jsxs)(e.p,{children:["Java9中最重要的两大改变：","模块化系统","、","jshell命令"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Java9提供了","超过150项新功能","特性，包括备受期待的模块化系统、可交互的REPL工具（jshell、JDK编译工具）、Java公共API和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说","Java9是一个庞大的系统工程，完全做了一个整体改变","。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Java9中不得不说的新特性"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["最主要之一：","模块化系统"]}),"\n",(0,s.jsxs)(e.li,{children:["最主要之二：","jshell命令"]}),"\n",(0,s.jsx)(e.li,{children:"多版本兼容jar包"}),"\n",(0,s.jsx)(e.li,{children:"语法改进之一：接口的私有方法"}),"\n",(0,s.jsx)(e.li,{children:"语法改进之二：钻石操作符(<>)的使用升级"}),"\n",(0,s.jsx)(e.li,{children:"语法改进之三：语法改进：try"}),"\n",(0,s.jsx)(e.li,{children:"API改进之一：String存储结构变更"}),"\n",(0,s.jsx)(e.li,{children:"API改进之二：便利的集合特性--of()创建只读集合"}),"\n",(0,s.jsx)(e.li,{children:"API改进之三：增强的Stream API"}),"\n",(0,s.jsx)(e.li,{children:"API改进之四：全新的HTTP客户端API"}),"\n",(0,s.jsx)(e.li,{children:"API改进之五：Deprecated的相关API"}),"\n",(0,s.jsx)(e.li,{children:"javadoc的HTML5支持"}),"\n",(0,s.jsx)(e.li,{children:"JavaScript引擎升级--Nashorn（Java11中被干掉了）"}),"\n",(0,s.jsx)(e.li,{children:"java的动态编译器"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"1711-模块化系统",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1711-模块化系统",children:"#"}),"17.1.1 模块化系统"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"模块化系统提出的背景"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["谈到Java9大家往往第一个想到的就是Jigsaw项目。","Java自出生以来，Java和相关生态在不断丰富的同时，也暴露出一些问题："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Java运行环境的膨胀和臃肿"}),"。每次启动JVM，至少会有30~60MB的内存加载，主要原因是",(0,s.jsx)(e.strong,{children:"JVM需要加载rt.jar"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长"}),"。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了Java开发和运行效率的提升"]}),"\n",(0,s.jsxs)(e.li,{children:["很难真正的对代码进行封装，而系统并没有对不同部分（也就是JAR文件）之间的依赖有个明确的概念。",(0,s.jsx)(e.strong,{children:"每个公共类都可以被类路径下任何其他公共类访问到，这样就导致无意中使用了并不想公开访问的API"})]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["本质上讲，","模块（module）的概念，其实就是package外再裹一层","。也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，模块化使得代码组织上","更安全","，\r\n因为它可以","指定哪些部分可以暴露，哪些部分需要隐藏","。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"优点"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"减少内存的开销"}),"\n",(0,s.jsx)(e.li,{children:"只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护"}),"\n",(0,s.jsx)(e.li,{children:"改进Java SE平台，使其可以适应不同大小的计算设备"}),"\n",(0,s.jsx)(e.li,{children:"改进其安全性、可维护性，提高性能"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"例子：在day13模块中使用java9test模块中定义的Person类"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"注意事项："}),"\n",(0,s.jsx)(e.p,{children:"day13模块中使用Person类的类，所在的包不能和Person类所在包名字相同"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"步骤"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["①在java9test模块中的","src","目录下创建","module-info.java文件","，写明要暴露出去的包(注意是包，不能详细到类)"]}),"\n",(0,s.jsxs)(e.li,{children:["②在day13模块的","src","目录下中创建","module-info.java文件","，写明要导入的包(注意是包，不能详细到类)"]}),"\n",(0,s.jsx)(e.li,{children:"③在day13模块中使用java9test模块中的类"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"代码"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"java9test模块中Person类"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"package com.tth.learn.java.bean;\r\n\r\n/**\r\n * @Author tth\r\n * @Date 2023/1/4 17:22\r\n */\r\npublic class Person {\r\n    private String name;\r\n    private int age;\r\n\r\n    // 以下省略构造器、getter、setter、toString等方法\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"java9test模块中module-info.java文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"module java9test {\r\n    exports com.tth.learn.java.bean;\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"day13模块中module-info.java文件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"module day13 {\r\n    requires java9test;\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"day13模块中使用Person类"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'package com.tth.learn.java;\r\n\r\nimport com.tth.learn.java.bean.Person;\r\n\r\n/**\r\n * 模块化测试\r\n *  在day13模块中调用java9test模块中的Person类\r\n *\r\n *  步骤：\r\n *  ①在java9test模块中的src目录下创建module-info.java文件，写明要暴露出去的包(注意是包，不能详细到类)\r\n *  ②在day13模块的src目录下中创建module-info.java文件，写明要导入的包(注意是包，不能详细到类)\r\n *  ③在day13模块中使用java9test模块中的类\r\n * @Author tth\r\n * @Date 2023/1/4 17:11\r\n */\r\npublic class ModuleTest {\r\n\r\n    public static void main(String[] args) {\r\n        Person person = new Person("Tom", 11);\r\n        System.out.println(person);\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"1712-java的repl工具jshell命令",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1712-java的repl工具jshell命令",children:"#"}),"17.1.2 Java的REPL工具：jshell命令"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"REPL概念"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"定义："}),"\n",(0,s.jsx)(e.p,{children:"REPL（read-evaluate-print-loop），以交互的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"之前的java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"设计理念："}),"\n",(0,s.jsx)(e.p,{children:"即写即得，快速运行"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"实现目标："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"java9中开始由了REPL工具--jshell。在控制台启动jshell，在没有创建类的情况下，可以直接声明变量、计算表达式、执行语句。"}),"\n",(0,s.jsx)(e.li,{children:"jshell可以从文件中加载语句或者将语句保存到文件中"}),"\n",(0,s.jsx)(e.li,{children:"jshell中可以使用Tab键自动补全"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"jshell工具的使用"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用控制台打开jshell工具，并尝试打印“hello world”："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:'C:\\Users\\tangtianhua>D:\\soft\\jdk-11.0.16.1\\bin\\jshell.exe\r\n|  欢迎使用 JShell -- 版本 11.0.16.1\r\n|  要大致了解该版本, 请键入: /help intro\r\n\r\njshell> System.out.println("hello world")\r\nhello world\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["声明变量：","如果变量名被重复定义，后边定义的会覆盖之前的"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> int n = 10;\r\nn ==> 10\r\n\r\njshell> int m = 20;\r\nm ==> 20\r\n\r\njshell> System.out.println(m+n);\r\n30\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["声明方法：","如果方法名被重复定义，后边定义的会覆盖之前的"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> public int add(int i1, int i2) {\r\n   ...> return i1 + i2;\r\n   ...> }\r\n|  已创建 方法 add(int,int)\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法调用："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> System.out.println(add(m,n))\r\n30\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"声明类："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> class Person {\r\n   ...> private String name;\r\n   ...> private int age;\r\n   ...> }\r\n|  已创建 类 Person\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"引入包："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> import java.net.URL;\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"编译时异常的处理："}),"\n",(0,s.jsx)(e.p,{children:"对于编译时异常，jshell在后台会将其隐藏，不会强制程序员捕获"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:'jshell> URL url = new URL("http://www.baidu.com");\r\nurl ==> http://www.baidu.com\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/help"}),"：获取jshell帮助"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/edit"}),"：打开编辑窗口。对之前输入的内容编辑完成后，点击",(0,s.jsx)(e.code,{children:"Accept"}),"按钮编辑内容方可生效"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:i})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/vars"}),"：列出当前session下定义过的变量"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> /vars\r\n|    int n = 10\r\n|    int m = 20\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/methods"}),"：列出当前session下定义过的方法"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> /methods\r\n|    int add(int,int)\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/list"}),"：列出当前session里所有有效的代码片段"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:'jshell> /list\r\n\r\n   1 : System.out.println("hello world")\r\n   2 : int n = 10;\r\n   3 : int m = 20;\r\n   4 : System.out.println(m+n);\r\n   5 : public int add(int i1, int i2) {\r\n       return i1 + i2;\r\n       }\r\n   6 : System.out.println(add(m,n))\r\n   7 : class Person {\r\n       private String name;\r\n       private int age;\r\n       }\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/open"}),"：调用外部文件中的java代码"]}),"\n",(0,s.jsx)(e.p,{children:"java文件中不需要定义类，只需按照jshell工具中的语法编写即可。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:l})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"/exit"}),"：退出"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",meta:"",children:"jshell> /exit\r\n|  再见\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"1713-接口的私有方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1713-接口的私有方法",children:"#"}),"17.1.3 接口的私有方法"]}),"\n",(0,s.jsx)(e.p,{children:"Java8中接口除了抽象方法之外，还可以定义静态方法（静态方法只能接口自己调用，实现类不能调用）、默认方法（实现类可以选择是否重写接口中的默认方法）。"}),"\n",(0,s.jsxs)(e.p,{children:["Java9中接口的方法可以定义为private的。","私有方法只能在接口内部使用，外部不允许调用。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * @author tth\r\n * @description 接口新特性\r\n * @date 2023/1/5 11:19\r\n */\r\npublic interface InterfaceTest {\r\n    // 定义抽象方法，访问权限是public\r\n    void methodAbstract();\r\n\r\n    // 定义静态方法，访问权限是public\r\n    static void methodStatic() {\r\n        System.out.println("我是接口中的静态方法");\r\n    }\r\n\r\n    // 定义方法，访问权限是public\r\n    default void methodDefault() {\r\n        System.out.println("我是接口中的默认方法");\r\n    }\r\n\r\n    // 定义私有方法。JDK9新特性\r\n    private void methodPrivate() {\r\n        System.out.println("我是接口中的私有方法");\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"1714-钻石操作符使用升级",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1714-钻石操作符使用升级",children:"#"}),"17.1.4 钻石操作符使用升级"]}),"\n","\n",(0,s.jsxs)(e.p,{children:["此外，","该特性要与jdk7中新特性--类型推断区分开","。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"public void test1() {\r\n    // Java9新特性：钻石操作符与匿名实现类可以共同使用\r\n    Comparator<Object> com = new Comparator<>() {\r\n        @Override\r\n        public int compare(Object o1, Object o2) {\r\n            return 0;\r\n        }\r\n    };\r\n\r\n    // JDK7新特性：类型推断\r\n    List<String> list = new ArrayList<>();\r\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"1715-try语句的改进",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1715-try语句的改进",children:"#"}),"17.1.5 try语句的改进"]}),"\n",(0,s.jsxs)(e.p,{children:["在java8和java9中可以实现","资源的自动关闭","。"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["在java8中，需要关闭的资源的实例化需要在","try后边的()","中进行。此时"]}),"\n",(0,s.jsxs)(e.li,{children:["在java9中，需要关闭的资源的实例化可以在","try外边","实现，","try对应的()中写明要关闭的资源","。","多个资源用 ; 隔开"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"@Test\r\npublic void test2() {\r\n    // java8之前的写法\r\n    //        InputStreamReader reader = null;\r\n    //        try {\r\n    //            reader = new InputStreamReader(System.in);\r\n    //            char[] buff = new char[1024];\r\n    //            int len;\r\n    //            while ((len = reader.read(buff)) != -1) {\r\n    //                String str = new String(buff, 0, len);\r\n    //                System.out.println(str);\r\n    //            }\r\n    //        } catch (IOException e) {\r\n    //            e.printStackTrace();\r\n    //        } finally {\r\n    //            if (null != reader) {\r\n    //                try {\r\n    //                    reader.close();\r\n    //                } catch (IOException e) {\r\n    //                    e.printStackTrace();\r\n    //                }\r\n    //            }\r\n    //        }\r\n\r\n    // java8写法：需要自动关闭的资源的实例化必须写在try的()中\r\n    //        try(InputStreamReader reader = new InputStreamReader(System.in)) {\r\n    //            char[] buff = new char[1024];\r\n    //            int len;\r\n    //            while ((len = reader.read(buff)) != -1) {\r\n    //                String str = new String(buff, 0, len);\r\n    //                System.out.println(str);\r\n    //            }\r\n    //        } catch (IOException e) {\r\n    //            e.printStackTrace();\r\n    //        }\r\n\r\n    // java9写法：需要自动关闭的资源的实例化可以放在try()外边，但是此时的资源对象是一个常量，无法更改。\r\n    // 如果有多个资源需要自动关闭，在try()中用;隔开\r\n    InputStreamReader reader = new InputStreamReader(System.in);\r\n    OutputStreamWriter writer = new OutputStreamWriter(System.out);\r\n    try(reader; writer) {\r\n        char[] buff = new char[1024];\r\n        int len;\r\n        while ((len = reader.read(buff)) != -1) {\r\n            String str = new String(buff, 0, len);\r\n            System.out.println(str);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"1716-string存储结构的变更",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1716-string存储结构的变更",children:"#"}),"17.1.6 String存储结构的变更"]}),"\n",(0,s.jsx)(e.p,{children:"String、StringBuilder、StringBuffer(线程安全)底层改用byte[]存储，不在使用char[]"}),"\n",(0,s.jsxs)(e.h3,{id:"1717-新增创建只读集合的方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1717-新增创建只读集合的方法",children:"#"}),"17.1.7 新增创建只读集合的方法"]}),"\n","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["java9之前创建只读集合--使用",(0,s.jsx)(e.code,{children:"Collections.unmodifiableXxx()"})]}),"\n",(0,s.jsxs)(e.p,{children:["以List为例。List还可以使用",(0,s.jsx)(e.code,{children:"Arrays.asList()"}),"创建只读集合"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n     * java9之前创建只读集合。以List为例\r\n     */\r\n@Test\r\npublic void test3() {\r\n    // java9之前的写法1\r\n    List<String> nameList = new ArrayList<>();\r\n    nameList.add("Bob");\r\n    nameList.add("Jerry");\r\n    // 将list变为只读\r\n    nameList = Collections.unmodifiableList(nameList);\r\n    //        nameList.add("张三"); // 抛异常 UnsupportedOperationException\r\n    System.out.println(nameList);\r\n\r\n    // java9之前的写法2\r\n    List<String> nameList2 = Arrays.asList("Tom", "Steven");\r\n    //        nameList2.add("张三"); // 抛异常 UnsupportedOperationException\r\n    System.out.println(nameList2);\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["java9创建只读集合--使用",(0,s.jsx)(e.code,{children:"of()"}),"方法"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'**\r\n    * java9新特性：集合工厂方法，创建只读集合\r\n    */\r\n    @Test\r\n    public void test4() {\r\n    // 创建只读List\r\n    List<Integer> list = List.of(1, 2, 3, 4, 5);\r\n    //        list.add(6); // 抛异常 UnsupportedOperationException\r\n    System.out.println(list);\r\n\r\n    // 创建只读Set\r\n    Set<String> set = Set.of("纳兰性德", "李清照", "辛弃疾");\r\n    //        set.add("李白"); // 抛异常 UnsupportedOperationException\r\n    System.out.println(set);\r\n\r\n    // 创建只读Set，方法一\r\n    Map<String, Object> map = Map.of("name", "李煜", "poem", "浪淘沙令\xb7帘外雨潺潺");\r\n    //        map.put("age", 41); // 抛异常 UnsupportedOperationExceptio\r\n    System.out.println(map);\r\n\r\n    // 创建只读Set，方法二\r\n    Map<String, Object> map2 = Map.ofEntries(Map.entry("name", "李煜"), Map.entry("poem", "浪淘沙令\xb7帘外雨潺潺"));\r\n    //        map2.put("age", 41); // 抛异常 UnsupportedOperationExceptio\r\n    System.out.println(map2);\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"1718-inputstream加强",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1718-inputstream加强",children:"#"}),"17.1.8 InputStream加强"]}),"\n","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * java9新特性：InputStream的新方法--transferTo()\r\n */\r\n@Test\r\npublic void test5() {\r\n    try (InputStream is = new FileInputStream("hello.txt");\r\n         OutputStream os = new FileOutputStream("src\\\\hello.txt")) {\r\n        // 将输入流中的所有数据直接自动的复制到输出流\r\n        is.transferTo(os);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"1719-增强的stream-api",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1719-增强的stream-api",children:"#"}),"17.1.9 增强的Stream API"]}),"\n",(0,s.jsx)(e.p,{children:"Java9中新增了4个新方法："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"takeWhile()"}),"：从开头开始查找满足指定规则的数据，直到找到不满足规则的第一个数据为止，并将这些数据返回"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test6() {\r\n    List<Integer> list = Arrays.asList(11, 22, 34, 54, 90, 88, 67, 7, 102);\r\n    //takeWhile()：从开头开始查找满足指定规则的数据，直到找到不满足规则的第一个数据为止，并将这些数据返回\r\n    list.stream().takeWhile(i -> i < 50).forEach(i -> System.out.print(i+" ")); // 11 22 34\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"dropWhile()"}),"：与takeWhile()相反。从开头开始查找不满足指定规则的数据，直到找到满足规则的第一个数据为止，并将这些数据返回"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test6() {\r\n    List<Integer> list = Arrays.asList(11, 22, 34, 54, 90, 88, 67, 7, 102);\r\n    //dropWhile()：与takeWhile()相反。从开头开始查找不满足指定规则的数据，直到找到满足规则的第一个数据为止，并将这些数据返回\r\n    list.stream().dropWhile(i -> i < 50).forEach(i -> System.out.print(i+" ")); // 54 90 88 67 7 102\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"ofNullable()"}),"：参数只有一个，且形参变量可以是单个的null"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"@Test\r\npublic void test7() {\r\n    // Stream.of()参数中的多个元素，可以包含null值\r\n    Stream<Integer> stream1 = Stream.of(1, 2, 3, null);\r\n    System.out.println(stream1.count());\r\n\r\n    // Stream.of()参数不能存储单个null。否则报NullPointerException\r\n    //        Stream<Object> stream2 = Stream.of(null);\r\n    //        System.out.println(stream2.count());\r\n\r\n    // Stream.of()可以存储多个null值\r\n    Stream<Object> stream3 = Stream.of(null, null);\r\n    System.out.println(stream3.count());\r\n\r\n    // Stream.ofNullable()：形参变量可以是单个的null\r\n    Stream<Integer> stream4 = Stream.ofNullable(1);\r\n    System.out.println(stream4.count());\r\n\r\n    Stream<Integer> stream5 = Stream.ofNullable(null);\r\n    System.out.println(stream5.count());\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"iterate()"}),"：是一个重载方法。重载后的第二个参数可以表示终止条件"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test8() {\r\n    // java8中使用Stream.terate(final T seed, final UnaryOperator<T> f) 创建无限流\r\n    Stream.iterate(0, x -> x + 1).limit(10).forEach(System.out :: println);\r\n\r\n    System.out.println("\\n**************************************************");\r\n\r\n    // java9中重载了Stream.iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)，其中第二个参数用来表示终止条件\r\n    Stream.iterate(0, x -> x < 8, x -> x + 1).forEach(System.out :: println);\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"17110-optional获取stream的方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17110-optional获取stream的方法",children:"#"}),"17.1.10 Optional获取Stream的方法"]}),"\n","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test9() {\r\n    List<String> nameList = new ArrayList<>();\r\n    nameList.add("Bob");\r\n    nameList.add("Jerry");\r\n\r\n    Optional<List<String>> optional = Optional.ofNullable(nameList);\r\n    // 将Optional实例转换为Stream实例\r\n    Stream<List<String>> stream = optional.stream();\r\n    stream.flatMap(x -> x.stream()).forEach(System.out :: println);\r\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"17111-javascript引擎升级nashorn",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17111-javascript引擎升级nashorn",children:"#"}),"17.1.11 JavaScript引擎升级：Nashorn"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Java8之前使用Rhino解析JavaScript，Java8开始使用Nashorn，","在Java9中对Nashorn进行改进--Nashorn为java提供了轻量级的JavaScript运行时"]}),"\n",(0,s.jsxs)(e.li,{children:["Java9包含一个用来解析Nashorn的ECMAScript语法树的API","。这个API使得IED和服务端框架不需要依赖Nashorn项目的内部实现类，就能分析ECMAScript代码"]}),"\n",(0,s.jsx)(e.li,{children:"在Java11中，Nashorn被一个新的引擎所取代"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"附：完整的JavaScript实现包含3部分："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"ECMAScript：描述该语言的语法和基本对象"}),"\n",(0,s.jsx)(e.li,{children:"DOM：文档对象模型。描述处理网页内容的方法和接口"}),"\n",(0,s.jsx)(e.li,{children:"BOM：浏览器对象模型。描述与浏览器进行交互的方法和接口"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"172-java10新特性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#172-java10新特性",children:"#"}),"17.2 Java10新特性"]}),"\n",(0,s.jsxs)(e.p,{children:["Java10中最重要的改变：","局部变量类型推断"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Java10提供了","超过109项新特性","，其中包含12个JEP(JDK特性加强协议)，","对于程序员来讲，真正的新特性就一个","。"]}),"\n",(0,s.jsxs)(e.h3,{id:"1721-局部变量类型推断",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1721-局部变量类型推断",children:"#"}),"17.2.1 局部变量类型推断"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["局部变量类型推断是指，在声明局部变量时，可以根据",(0,s.jsx)(e.code,{children:"="}),"右侧的内容推断出变量的类型，此时",(0,s.jsx)(e.code,{children:"="}),"左侧不需要再注明变量的类型，直接使用",(0,s.jsx)(e.code,{children:"var"}),"即可。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"例子"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"// num的类型为int\r\nvar num = 10;\r\n// list的类型为ArrayList<String>\r\nvar list = new ArrayList<String>();\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"适用场景"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"声明局部变量"}),"\n",(0,s.jsx)(e.li,{children:"增强for循环的遍历操作"}),"\n",(0,s.jsx)(e.li,{children:"普通for循环的遍历操作"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 局部变量的类型推断--适用场景\r\n */\r\n@Test\r\npublic void test1() {\r\n    // 1.声明操作：声明变量时，根据所附的值，推断变量的类型\r\n    // 类型为int\r\n    var num = 10;\r\n    // 类型为ArrayList<String>\r\n    var list = new ArrayList<String>();\r\n    list.add("hello");\r\n\r\n    // 2.遍历操作\r\n    for(var i : list) {\r\n        System.out.println(i);\r\n    }\r\n\r\n    // 3.普通的遍历操作\r\n    for (var i = 0; i < 10; i++) {\r\n        System.out.println(i);\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"不适用场景"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"没有初始化的局部变量"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"var num;//编译报错\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Lambda表达式中，左边的函数式接口不能声明为var"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"// Lambda表达式中，左边的函数式接口不能声明为var\r\nSupplier<Double> sup = () -> Math.random(); // 正确\r\n// var sup1 = () -> Math.random(); // 编译报错\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法引用中，左边函数式接口不能声明为var"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"// 3.方法引用中，左边函数式接口不能声明为var\r\nConsumer<String> con = System.out :: println; // 正确\r\n// var con1 = System.out :: println; // 编译报错\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"数组的静态初始化中，当省略右侧数组元素类型时，左侧变量类型不能生命为var"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"// 4.数组的静态初始化中，当省略右侧数组元素类型时，左侧变量类型不能生命为var\r\nint[] arr = {1,2,3,4}; // 正确\r\n// var arr1 = {1,2,3,4}; // 编译报错\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"catch块中，异常类型不能声明为var"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"// 6.catch块中，异常类型不能声明为var\r\n//        try {\r\n//\r\n//        } catch (var e) { // 编译报错\r\n//\r\n//        }\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法的返回值类型，不能声明为var"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * 方法的返回值类型，不能声明为var\r\n * @return\r\n */\r\npublic var method1() { // 编译报错\r\n    return 0; // 编译报错\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法的形参，不能声明为var"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"构造器的形参，不能声明为var"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"类的属性，不能声明为var"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"工作原理"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["在处理var时，编译器先是看表达式右边部分","，并根据右边变量值的类型进行推断，作为左边的类型，然后","将该类型写入字节码文件中","。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["var不是关键字","。var是一个类型名，也是一个普通的标识符。作为类型名，在编译器需要知道类型的地方才会用到它。作为一个普通的标识符，除了不能用它作为类名外，声明的变量、方法等都可以使用var来命名"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["这不是JavaScript","。JavaScript是一门边解释边运行的语言，是一门动态语言。虽然Java10中引入了var，但是","var 并不会改变Java是一门静态语言的事实","。在遇到var声明的变量时，编译器负责推断出类型，并将其写入字节码文件。var的出现只是简化了程序的编写，对字节码文件没有任何作用。也就是说源文件中用var声明的变量，在字节码中会将var转换为对应的类型，如下图："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:t})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"1722-再次新增创建只读集合的方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1722-再次新增创建只读集合的方法",children:"#"}),"17.2.2 再次新增创建只读集合的方法"]}),"\n","\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用方法"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test3() {\r\n    ArrayList<String> list = new ArrayList<>();\r\n    list.add("木兰花令");\r\n    List<String> list1 = List.copyOf(list); // list1为只读集合\r\n}\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["List  copyOf(Collection coll)在返回只读集合时，会","先判断coll是不是AbstractImmutableList类型的","。如果coll是AbstractImmutableList类型的，会将coll直接返回。否则会调用List.of()方法创建一个新的AbstractImmutableList集合并返回。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'@Test\r\npublic void test4() {\r\n    var list1 = List.of("浪淘沙令", "木兰花令");\r\n    var copy1 = List.copyOf(list1);\r\n    System.out.println(list1 == copy1); // true\r\n\r\n    var list2 = new ArrayList<>();\r\n    list2.add("浪淘沙令");\r\n    list2.add("木兰花令");\r\n    var copy2 = List.copyOf(list2);\r\n    System.out.println(list2 == copy2); // false\r\n}\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"173-java11新特性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#173-java11新特性",children:"#"}),"17.3 Java11新特性"]}),"\n","\n",(0,s.jsxs)(e.p,{children:["Java11中最重要的两个改变：","引入了两种新的GC，包括Epsilon和ZGC（也许具有跨时代的意义）"]}),"\n",(0,s.jsxs)(e.h3,{id:"1731-string新增的方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1731-string新增的方法",children:"#"}),"17.3.1 String新增的方法"]}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"方法"}),(0,s.jsx)(e.th,{children:"描述"}),(0,s.jsx)(e.th,{children:"举例"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"boolean isBlank()"}),(0,s.jsx)(e.td,{children:"判断字符串是否是空白"}),(0,s.jsx)(e.td,{children:'" ".isBlank(); // true'})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"String strip()"}),(0,s.jsx)(e.td,{children:"去掉首尾空格"}),(0,s.jsx)(e.td,{children:'"    JavaStack    ".strip(); // "JavaStack"'})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"String stripTrailing()"}),(0,s.jsx)(e.td,{children:"去掉尾部空格"}),(0,s.jsx)(e.td,{children:'"    JavaStack    ".stripTrailing(); // "    JavaStack"'})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"String stripLeading()"}),(0,s.jsx)(e.td,{children:"去掉首部空格"}),(0,s.jsx)(e.td,{children:'"    JavaStack     ".stripLeading(); // "JavaStack     "'})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"String repeat(int count)"}),(0,s.jsx)(e.td,{children:"复制count次字符串"}),(0,s.jsx)(e.td,{children:'"Java".repeat(3); // "JavaJavaJava"'})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Stream<String> lines()"}),(0,s.jsx)(e.td,{children:"行数统计"}),(0,s.jsx)(e.td,{children:'"A\\nB\\nC".lines().count(); // 3'})]})]})]}),"\n",(0,s.jsxs)(e.h3,{id:"1732-optional加强",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1732-optional加强",children:"#"}),"17.3.2 Optional加强"]}),"\n",(0,s.jsx)(e.p,{children:"Optional也新增了几个方法，可以方便的将一个Optional转换成一个Stream，或者当一个空Optional时给它一个替代的。"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"方法"}),(0,s.jsx)(e.th,{children:"描述"}),(0,s.jsx)(e.th,{children:"新增的版本"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"boolean isEmpty()"}),(0,s.jsx)(e.td,{children:"判断value是否为空（与JDK8中的isPresent()正好相反）"}),(0,s.jsx)(e.td,{children:"JDK11"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"void ifPresentOrElse(Consumer action, Runnable emptyAction)"}),(0,s.jsx)(e.td,{children:"若value非空，执行参数1；否则，执行参数2"}),(0,s.jsx)(e.td,{children:"JDK9"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Optional<T> or(Supplier  supplier)"}),(0,s.jsx)(e.td,{children:"若value非空，返回对应的Optional；否则，返回形参包装的Optional"}),(0,s.jsx)(e.td,{children:"JDK9"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Stream<T> stream()"}),(0,s.jsx)(e.td,{children:"若value非空，返回包含此value的Stream；否则，返回空的Stream"}),(0,s.jsx)(e.td,{children:"JDK9"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"T orElseThrow()"}),(0,s.jsx)(e.td,{children:"若value非空，返回value；否则，抛异常NoSuchElementException"}),(0,s.jsx)(e.td,{children:"JDK10"})]})]})]}),"\n",(0,s.jsxs)(e.h3,{id:"1733-局部变量类型推断升级",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1733-局部变量类型推断升级",children:"#"}),"17.3.3 局部变量类型推断升级"]}),"\n",(0,s.jsxs)(e.p,{children:["可以在","在var上添加注解"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"// 用注解去修饰Lambda表达中的参数\r\n@Test\r\npublic void test3() {\r\n    // 注：当注解去修饰变量的时候，变量的类型一定要有\r\n    Consumer<String> con1 = (@Deprecated var t) -> System.out.println(t.toUpperCase());\r\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"174-全新的http客户端api",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#174-全新的http客户端api",children:"#"}),"17.4 全新的HTTP客户端API"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"HTTP/1.1和HTTP/2（2015年成为标准）两个协议的主要区别"}),"\n",(0,s.jsxs)(e.p,{children:["二者的主要区别是","如何在客户端和服务器之间构建和传输数据","。"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"HTTP/1.1依赖于相应周期"})}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"HTTP/2允许服务器“push”数据：它可以发送比客户端请求更多的数据"}),"。这使得它可以优先处理并发送对于首先加载网页至关重要的数据"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"在JDK9中引入Http Client API，该API支持同步和异步，而且在JDK11中对其进行了修改，此时成为正式可用状态。可以在java.net包中找到该API"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["它将","替代仅适用于blocking模式的HttpURLConnection","(HttpURLConnection是在HTTP1.0的时代创建的)，","并提供对 WebSocket 和 HTTP/2 的支持","。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用举例"}),"\n"]}),"\n","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'// 同步方式\r\n@Test\r\npublic void test4() {\r\n    try {\r\n        HttpClient client = HttpClient.newHttpClient();\r\n        HttpRequest request = HttpRequest.newBuilder(URI.create("http://www.baidu.com")).build();\r\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\r\n        // send是同步发送\r\n        HttpResponse<String> response = client.send(request, responseHandler);\r\n        String body = response.body();\r\n        System.out.println(body);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n\r\n// 异步方式\r\n@Test\r\npublic void test4_2() {\r\n    try {\r\n        HttpClient client = HttpClient.newHttpClient();\r\n        HttpRequest request = HttpRequest.newBuilder(URI.create("http://www.baidu.com")).build();\r\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\r\n        // sendAsync是异步发送\r\n        CompletableFuture<HttpResponse<String>> sendAsync = client.sendAsync(request, responseHandler);\r\n        HttpResponse<String> response = sendAsync.get();\r\n        String body = response.body();\r\n        System.out.println(body);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    } catch (ExecutionException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"175-更简化的编译运行程序",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#175-更简化的编译运行程序",children:"#"}),"17.5 更简化的编译运行程序"]}),"\n",(0,s.jsxs)(e.p,{children:["在JDK11之前，运行一个Java源码，需要先编译，再运行。","在JDK11中只用一个java命令就可以直接编译运行程序","。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"只用一个java命令就运行程序的要求"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"该方法运行java文件，是去执行源文件中的第一个类，且第一个类必须包含main方法"}),"\n",(0,s.jsx)(e.li,{children:"不可以使用其它源文件中的类"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"176-废弃nashorn引擎",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#176-废弃nashorn引擎",children:"#"}),"17.6 废弃Nashorn引擎"]}),"\n",(0,s.jsx)(e.p,{children:"废除Nashorn JavaScript引擎，有需要可以考虑使用G让AIVM。"}),"\n",(0,s.jsxs)(e.h2,{id:"177-zgc垃圾回收",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#177-zgc垃圾回收",children:"#"}),"17.7 ZGC垃圾回收"]}),"\n","\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"背景"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"现代系统中可用的内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存，并且无需长时间的GC暂停时间"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概念"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"ZGC是一个并发、基于region、压缩型的垃圾回收器，只有root扫描阶段会STW（stop the world），因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。"}),"\n",(0,s.jsx)(e.p,{children:"但是目前还是处于试验阶段，开发环境不建议使用"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"优势"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"GC暂停时间不会超过10ms"}),"\n",(0,s.jsx)(e.li,{children:"既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)"}),"\n",(0,s.jsx)(e.li,{children:"和G1相比, 应用吞吐能力不会下降超过15%"}),"\n",(0,s.jsx)(e.li,{children:"为未来的GC功能和利用colord指针以及Load barriers优化奠定基础"}),"\n",(0,s.jsx)(e.li,{children:"初始只支持64位系统"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"178-其他新特性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#178-其他新特性",children:"#"}),"17.8 其他新特性"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Unicode 10"}),"\n",(0,s.jsx)(e.li,{children:"Deprecate the Pack200 Tools and API"}),"\n",(0,s.jsx)(e.li,{children:"新的Epsilon垃圾收集器"}),"\n",(0,s.jsx)(e.li,{children:"完全支持Linux容器（包括Docker）"}),"\n",(0,s.jsx)(e.li,{children:"支持G1上的并行完全垃圾收集"}),"\n",(0,s.jsx)(e.li,{children:"最新的HTTPS安全协议TLS 1.3"}),"\n",(0,s.jsx)(e.li,{children:"Java Flight Recorder"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"179-jdk展望",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#179-jdk展望",children:"#"}),"17.9 JDK展望"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"缺乏一个标准化和轻量级的JSON API"}),"\n",(0,s.jsx)(e.li,{children:"缺乏新的货币API"}),"\n"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(d,n)})):d(n)}let h=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["tang%2Fjava2%2F17_Java9%2610%2611%E6%96%B0%E7%89%B9%E6%80%A7.md"]={toc:[{id:"171-java9新特性",text:"17.1 Java9新特性",depth:2},{id:"1711-模块化系统",text:"17.1.1 模块化系统",depth:3},{id:"1712-java的repl工具jshell命令",text:"17.1.2 Java的REPL工具：jshell命令",depth:3},{id:"1713-接口的私有方法",text:"17.1.3 接口的私有方法",depth:3},{id:"1714-钻石操作符使用升级",text:"17.1.4 钻石操作符使用升级",depth:3},{id:"1715-try语句的改进",text:"17.1.5 try语句的改进",depth:3},{id:"1716-string存储结构的变更",text:"17.1.6 String存储结构的变更",depth:3},{id:"1717-新增创建只读集合的方法",text:"17.1.7 新增创建只读集合的方法",depth:3},{id:"1718-inputstream加强",text:"17.1.8 InputStream加强",depth:3},{id:"1719-增强的stream-api",text:"17.1.9 增强的Stream API",depth:3},{id:"17110-optional获取stream的方法",text:"17.1.10 Optional获取Stream的方法",depth:3},{id:"17111-javascript引擎升级nashorn",text:"17.1.11 JavaScript引擎升级：Nashorn",depth:3},{id:"172-java10新特性",text:"17.2 Java10新特性",depth:2},{id:"1721-局部变量类型推断",text:"17.2.1 局部变量类型推断",depth:3},{id:"1722-再次新增创建只读集合的方法",text:"17.2.2 再次新增创建只读集合的方法",depth:3},{id:"173-java11新特性",text:"17.3 Java11新特性",depth:2},{id:"1731-string新增的方法",text:"17.3.1 String新增的方法",depth:3},{id:"1732-optional加强",text:"17.3.2 Optional加强",depth:3},{id:"1733-局部变量类型推断升级",text:"17.3.3 局部变量类型推断升级",depth:3},{id:"174-全新的http客户端api",text:"17.4 全新的HTTP客户端API",depth:2},{id:"175-更简化的编译运行程序",text:"17.5 更简化的编译运行程序",depth:2},{id:"176-废弃nashorn引擎",text:"17.6 废弃Nashorn引擎",depth:2},{id:"177-zgc垃圾回收",text:"17.7 ZGC垃圾回收",depth:2},{id:"178-其他新特性",text:"17.8 其他新特性",depth:2},{id:"179-jdk展望",text:"17.9 JDK展望",depth:2}],title:"17 Java9&10&11新特性",headingTitle:"17 Java9&10&11新特性",frontmatter:{}}}}]);