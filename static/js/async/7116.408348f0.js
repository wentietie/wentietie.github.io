"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["7116"],{92975:function(e,n,r){r.r(n),r.d(n,{default:function(){return i}});var s=r(85893),a=r(50065);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",pre:"pre",code:"code",div:"div",p:"p",h3:"h3",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"对象的扩展",children:["对象的扩展",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象的扩展",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"属性的简洁表示",children:["属性的简洁表示",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#属性的简洁表示",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// es5中对象使用变量\r\nconst x = '1'\r\nconst y = '2'\r\nconst obj = {\r\n    x: x,\r\n    y: y\r\n}\r\n\r\n// es6写法\r\nconst obj = {\r\n    x,  \r\n    y\r\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"属性名表达式",children:["属性名表达式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#属性名表达式",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const name = 'foo'\r\nconst foo = '123'\r\nconst obj = {}\r\n// 以下几种表示方式是等价的\r\nobj.foo = foo\r\nobj['foo'] = foo\r\nobj['f' + 'oo'] = foo\r\nobj[name] = foo\n"})}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"注意"}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsx)(n.p,{children:"属性名表达式和简洁写法不能同时使用。"})})]}),"\n",(0,s.jsxs)(n.h2,{id:"方法的-name-属性",children:["方法的 name 属性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法的-name-属性",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"函数的name属性，返回函数名。对象方法也是函数，因此也有 name 属性。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const person = {\r\n  sayName() {\r\n    console.log('hello!');\r\n  },\r\n};\r\nperson.sayName.name   // \"sayName\"\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果对象的方法使用了取值函数（ getter ）和存值函数（ setter ），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面，返回值是方法名前加上 get 和 set 。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const obj = {\r\n  get foo() {},\r\n  set foo(x) {}\r\n};\r\nobj.foo.name\r\n// TypeError: Cannot read property 'name' of undefined\r\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');\r\ndescriptor.get.name // \"get foo\"\r\ndescriptor.set.name // \"set foo\"\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"属性的可枚举性和遍历",children:["属性的可枚举性和遍历",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#属性的可枚举性和遍历",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"可枚举性",children:["可枚举性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可枚举性",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"引入“可枚举”（ enumerable ）这个概念的最初目的，就是让某些属性可以规避掉 for...in 操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的 toString 方法，以及数组的 length 属性，就通过“可枚举性”，从而避免被 for...in 遍历到。"}),"\n",(0,s.jsx)(n.p,{children:"对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。 Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let obj = { foo: 123 };\r\nObject.getOwnPropertyDescriptor(obj, 'foo')\r\n//  {\r\n//    value: 123,\r\n//    writable: true,\r\n//    enumerable: true,\r\n//    configurable: true\r\n//  }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"属性的遍历",children:["属性的遍历",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#属性的遍历",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"一共有5 种方法可以遍历对象的属性。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"for...in：循环遍历对象自身的和继承的可枚举属性"}),"\n",(0,s.jsx)(n.li,{children:"Object.keys(obj)： 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。"}),"\n",(0,s.jsx)(n.li,{children:"Object.getOwnPropertyNames(obj)： 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。"}),"\n",(0,s.jsx)(n.li,{children:"Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有 Symbol 属性的键名。"}),"\n",(0,s.jsx)(n.li,{children:"Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"super-关键字",children:["super 关键字",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#super-关键字",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们知道， this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super ，指向当前对象的原型对象。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const proto = {\r\n  foo: 'hello'\r\n};\r\nconst obj = {\r\n  foo: 'world',\r\n  find() {\r\n    return super.foo;\r\n  }\r\n};\r\nObject.setPrototypeOf(obj, proto);\r\nobj.find() // \"hello\"\n"})}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"注意"}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsx)(n.p,{children:"super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。"})})]}),"\n",(0,s.jsxs)(n.h2,{id:"对象的扩展运算符",children:["对象的扩展运算符",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象的扩展运算符",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"解构赋值",children:["解构赋值",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解构赋值",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4}\r\nx // 1\r\ny //2\r\nz // {a:3, b:4}\n"})}),"\n",(0,s.jsx)(n.p,{children:"由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null ，就会报错，因为它们无法转为对象。\r\n解构赋值必须是最后一个参数，否则会报错。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let { ...z } = null; // 运行时错误\r\nlet { ...z } = undefined; // 运行时错误\r\nlet { ...x, y, z } = someObject; // 句法错误\r\nlet { x, ...y, ...z } = someObject; // 句法错误\n"})}),"\n",(0,s.jsx)(n.p,{children:"注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\r\n另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。"}),"\n",(0,s.jsxs)(n.h3,{id:"扩展运算符",children:["扩展运算符",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展运算符",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对象的扩展运算符（ ... ）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'let z = { a: 3, b: 4 };\r\nlet n = { ...z };\r\nn // { a: 3, b: 4 }\r\n\r\n//由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\r\n\r\nlet foo = { ...[\'a\', \'b\', \'c\'] };\r\nfoo\r\n// {0: "a", 1: "b", 2: "c"}\r\n\r\n//如果扩展运算符后面是一个空对象，则没有任何效果。\r\n\r\n// {...{}, a: 1}\r\n// { a: 1 }\r\n如果扩展运算符后面不是对象，则会自动将其转为对象。\r\n\r\n// 等同于 {...Object(1)}\r\n//{...1} // {}\r\n\r\n// 但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\r\n\r\n{...\'hello\'}\r\n// {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}\r\n\r\n//上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。\r\n// 写法一\r\nconst clone1 = {\r\n    __proto__: Object.getPrototypeOf(obj),\r\n    ...obj\r\n};\r\n// 写法二\r\nconst clone2 = Object.assign(\r\n    Object.create(Object.getPrototypeOf(obj)),\r\n    obj\r\n);\r\n// 写法三\r\nconst clone3 = Object.create(\r\n    Object.getPrototypeOf(obj),\r\n    Object.getOwnPropertyDescriptors(obj)\r\n)\r\n\r\n//扩展运算符可以用于合并两个对象。\r\n\r\nlet ab = { ...a, ...b };\r\n// 等同于\r\nlet ab = Object.assign({}, a, b);\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"链判断运算符",children:["链判断运算符",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#链判断运算符",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在实际编程中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取 message.body.user.firstName ，安全的写法是写成下面这样。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const firstName = (message\r\n  && message.body\r\n  && message.body.user\r\n  && message.body.user.firstName) || 'default';\r\n\r\n//或者使用三元运算符 ?: ，判断一个对象是否存在。\r\nconst fooInput = myForm.querySelector('input[name=foo]')\r\nconst fooValue = fooInput ? fooInput.value : undefined\r\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator） ?. ，简化上面的写法。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const firstName = message?.body?.user?.firstName || 'default';\r\nconst fooValue = myForm.querySelector('input[name=foo]')?.value\n"})}),"\n",(0,s.jsx)(n.p,{children:"链判断运算符有三种用法。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"obj?.prop // 对象属性"}),"\n",(0,s.jsx)(n.li,{children:"obj?.[expr] // 同上"}),"\n",(0,s.jsx)(n.li,{children:"func?.(...args) // 函数或对象方法的调用"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"对象的新增方法",children:["对象的新增方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象的新增方法",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"objectis",children:["Object.is()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectis",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Object.is用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。"}),"\n",(0,s.jsxs)(n.h3,{id:"objectassign",children:["Object.assign()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectassign",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const target = { a: 1 };\r\nconst source1 = { b: 2 };\r\nconst source2 = { c: 3 };\r\nObject.assign(target, source1, source2);\r\ntarget // {a:1, b:2, c:3}\n"})})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let i=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%2Fes6%2Fes6-9.md"]={toc:[{text:"属性的简洁表示",id:"属性的简洁表示",depth:2},{text:"属性名表达式",id:"属性名表达式",depth:2},{text:"方法的 name 属性",id:"方法的-name-属性",depth:2},{text:"属性的可枚举性和遍历",id:"属性的可枚举性和遍历",depth:2},{text:"可枚举性",id:"可枚举性",depth:3},{text:"属性的遍历",id:"属性的遍历",depth:3},{text:"super 关键字",id:"super-关键字",depth:2},{text:"对象的扩展运算符",id:"对象的扩展运算符",depth:2},{text:"解构赋值",id:"解构赋值",depth:3},{text:"扩展运算符",id:"扩展运算符",depth:3},{text:"链判断运算符",id:"链判断运算符",depth:2},{text:"对象的新增方法",id:"对象的新增方法",depth:2},{text:"Object.is()",id:"objectis",depth:3},{text:"Object.assign()",id:"objectassign",depth:3}],title:"对象的扩展",frontmatter:{}}}}]);