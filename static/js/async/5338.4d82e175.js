"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["5338"],{90497:function(n,e,r){r.r(e),r.d(e,{default:function(){return d}});var l=r(85893),s=r(50065);function i(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code"},(0,s.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"5-面向对象编程中",children:["5 面向对象编程（中）",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-面向对象编程中",children:"#"})]}),"\n",(0,l.jsxs)(e.h2,{id:"51-oop特征二继承",children:["5.1 OOP特征二：继承",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#51-oop特征二继承",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"使用继承的好处"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"减少了代码的冗余，提高了代码的复用性"}),"\n",(0,l.jsx)(e.li,{children:"便于功能的扩展"}),"\n",(0,l.jsx)(e.li,{children:"为之后多态的使用，提供了前提"}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"说明"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"一旦子类继承了父类，子类就获取到了父类所有的属性和方法。"}),"\n",(0,l.jsx)(e.p,{children:"特别的，父类中声明为private的属性或方法，子类继承父类之后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"java.lang.Object类"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"所有的java类都直接或间接的继承于java.lang.Object类"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"52-方法的重写",children:["5.2 方法的重写",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#52-方法的重写",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["在子类中可以根据需要，对从父类继承来的方法进行改造，也称为方法的","覆盖、重置","。在程序执行时，子类的方法将覆盖父类的方法。"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"规则"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["子类重写的方法必须和父类被重写的方法具有","相同的方法名、参数列表"]}),"\n",(0,l.jsxs)(e.li,{children:["子类重写的方法的",(0,l.jsx)(e.strong,{children:"返回值类型"}),"不能大于","父类被重写方法的返回值类型","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["父类被重写的方法的返回值是","void","，则子类重写时返回值也只能是","void"]}),"\n",(0,l.jsxs)(e.li,{children:["父类被重写的方法的返回值是","A类","，则子类重写时返回值可以是","A类或者A类的子类"]}),"\n",(0,l.jsxs)(e.li,{children:["父类被重写的方法的返回值是","基本数据类型","，则子类重写时返回值必须是","相同的基本数据类型"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["子类重写的方法使用的",(0,l.jsx)(e.strong,{children:"访问权限"}),"不能小于","父类被重写的访问权限","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"子类不能重写父类的private方法"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["子类方法抛出的",(0,l.jsx)(e.strong,{children:"异常"}),"不能大于","父类被重写方法的异常"]}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"注意"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["方法的重写针对的是","非static方法","。因为","static方法是属于类的","，子类无法覆盖父类方法。"]}),"\n",(0,l.jsxs)(e.h2,{id:"53-子类对象实例化过程",children:["5.3 子类对象实例化过程",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#53-子类对象实例化过程",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"从结果来看（继承性）"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"子类继承父类以后，就获取了父类中声明的属性和方法。"}),"\n",(0,l.jsx)(e.p,{children:"创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"从过程看"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类的结构，子类对象才可调用。"}),"\n",(0,l.jsx)(e.p,{children:"说明：虽然创建子类对象时，调用了父类构造器，但是自始至终就创建一个对象，即为new的子类对象。"}),"\n",(0,l.jsxs)(e.h2,{id:"54-oop特征三-多态",children:["5.4 OOP特征三： 多态",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#54-oop特征三-多态",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"理解多态性"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"多态性可以理解为一个事物的多种形态"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"什么是多态性"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:'class Person {\r\n    private String name;\r\n    \r\n    public void eat() {\r\n        System.out.print("Person Eat")\r\n    }\r\n}\r\n\r\nclass Man extends Person {\r\n    private boolean isSmoking;\r\n    \r\n    @Override\r\n     public void eat() {\r\n        System.out.print("Man Eat")\r\n    }\r\n    \r\n    public void earn() {\r\n        System.out.print("Man Earn");\r\n    }\r\n}\r\n\r\nclass Test {\r\n    public static void main(String[] args) {\r\n        Person p = new Man();// 此为多态\r\n    }\r\n}\n'})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"多态的使用（即虚拟方法的使用）"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["有了对象的多态性后，我们在",(0,l.jsx)(e.strong,{children:"编译期"}),"，只能调用父类中声明的方法。在",(0,l.jsx)(e.strong,{children:"运行时"}),"，实际执行的是子类重写的方法。"]}),"\n",(0,l.jsx)(e.p,{children:"总结：编译，看左边；运行，看右边"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:"class Test {\r\n    public static void main(String[] args) {\r\n        Person p = new Man();// 此为多态\r\n        p.eat(); // 此为多态的使用（控制台输出的是【Man Eat】）\r\n        // p.earn(); // 编译报错，找不到方法（p只能调用Person中声明的方法）\r\n    }\r\n}\n"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"多态使用的前提"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"有类的继承关系"}),"\n",(0,l.jsx)(e.li,{children:"有方法的重写"}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"说明"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"对象的多态性，只适用于方法，不适用于属性"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"55-object类的使用",children:["5.5 Object类的使用",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#55-object类的使用",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"属性"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"无"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"方法"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["equals()：对象比较","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["重写原则","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["对称性","：如果x.equlas(y)返回true，那么y.equlas(x)返回的也应该是true"]}),"\n",(0,l.jsxs)(e.li,{children:["自反性","：x.equlas(x)必须是true"]}),"\n",(0,l.jsxs)(e.li,{children:["传递性","：x.equlas(y)返回true，y.equlas(z)返回是true，那么x.equlas(x)也应该是true"]}),"\n",(0,l.jsxs)(e.li,{children:["一致性","：如果x.equlas(y)返回true，只要x，y值不变，不管重复比较多少次，结果永远是true"]}),"\n",(0,l.jsx)(e.li,{children:"x.equlas(null)永远返回false"}),"\n",(0,l.jsx)(e.li,{children:"x.equlas(和x不同类型的对象)永远返回false"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["toString()：将对象转为字符串","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"当输出一个对象的引用时，实际就是调用当前对象的toString()"}),"\n",(0,l.jsxs)(e.li,{children:["Object类中toString()返回的是",(0,l.jsx)(e.code,{children:'实体类名（getClass().getName()) + "@" + 对象的hashCode(Integer.toHexString(hashCode()))'})]}),"\n",(0,l.jsx)(e.li,{children:"String、Date、File、包装类都重写了Object的toString()方法，返回的是各自的“实体内容”"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.li,{children:"getClass()"}),"\n",(0,l.jsx)(e.li,{children:"hashCode()：获取Hash码"}),"\n",(0,l.jsx)(e.li,{children:"clone()"}),"\n",(0,l.jsx)(e.li,{children:"finalize()"}),"\n",(0,l.jsx)(e.li,{children:"wait()"}),"\n",(0,l.jsx)(e.li,{children:"notify()"}),"\n",(0,l.jsx)(e.li,{children:"notifyAll()"}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"构造器"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"只有一个空参构造器"}),"\n",(0,l.jsxs)(e.h2,{id:"56-包装类的使用",children:["5.6 包装类的使用",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#56-包装类的使用",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"包装类有哪些"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"Byte"}),"、",(0,l.jsx)(e.code,{children:"Short"}),"、",(0,l.jsx)(e.code,{children:"Integer"}),"、",(0,l.jsx)(e.code,{children:"Long"}),"、",(0,l.jsx)(e.code,{children:"Float"}),"、",(0,l.jsx)(e.code,{children:"Double"}),"、",(0,l.jsx)(e.code,{children:"Boolean"}),"、",(0,l.jsx)(e.code,{children:"Character"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"装箱"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"基本数据类型 ---\x3e 包装类"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"数值型的（Byte、Short、Integer、Long、Float、Double）举例："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:'int num = 10;\r\nInteger iNum = new Integer(num);\r\nFloat fNum = new Float(12.3);\r\nDouble dNum = new Double("12.3");\r\n// 以下代码运行会报错\r\nInteger iNum2 = new Integer("123abc");\n'})}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"Boolean额外说明："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:'Boolean b1 = new Boolean(true);//b1为true\r\nBoolean b2 = new Boolean("true");//b2为true\r\nBoolean b3 = new Boolean("TruE");//b3为true。转换时忽略大小写了\r\nBoolean b4 = new Boolean("true123");//不会抛异常，b4为false\r\nBoolean b5;\r\nSystem.out.println(b5);//输出null\n'})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"拆箱"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"包装类 ---\x3e 基本数据类型"}),"\n",(0,l.jsx)(e.p,{children:"调用包装类Xxx的xxxValue()方法，如："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:"Float fNum = new Float(12.3);\r\nfloat f = fNum.floatValue();\n"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"自动装箱与自动拆箱"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"JDK 5.0新特性"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:"// 自动装箱\r\nint num = 2;\r\nInteger iNum = num;\r\n\r\n// 自动拆箱\r\nint num2 = iNum;\n"})}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"基本数据类型、包装类 ---\x3e String"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"因基本数据类型可以自动装箱，包装类可以自动拆箱，所以二者在转为String时，所用到的方法都是一样的。"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"连接运算"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:'int num = 1;\r\nString str = num + "";\n'})}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["调用String重载的",(0,l.jsx)(e.code,{children:"valueOf(Xxx xxx)"})]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:"float f = 12.3f;\r\nString str = String.valueOf(f1);\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"String ---\x3e 基本数据类型、包装类"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["调用",(0,l.jsx)(e.code,{children:"parserXxx(String s)"}),"方法"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:'String str = "123";\r\n// 可能会报NumberFormatException\r\nint i = Integer.parseInteger(str);\r\n\r\nString str2 = "true1";\r\n// 不会报NumberFormatException\r\nBoolean b = Boolean.parseBoolean(str2);// b值为false\n'})}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["特别的，包装类可以调用自己的",(0,l.jsx)(e.code,{children:"toString()"}),"方法"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-java",children:"Integer i = 10;\r\nString str = i.toString();\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"57-单元测试",children:["5.7 单元测试",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#57-单元测试",children:"#"})]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"使用步骤"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"引入JUnit 4"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"创建Java类，进行单元测试"}),"\n",(0,l.jsx)(e.p,{children:"Java类的要求：此类是public的；此类须提供公共的无参构造器"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"在上述类中声明单元测试方法"}),"\n",(0,l.jsx)(e.p,{children:"此单元测试方法的要求：方法的权限是public；没有返回值；没有形参"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"单元测试方法上需要使用注解@Test，并导入org.junit.Test"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"运行：双击方法名->右键，选择Run...或者Debug..."}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"执行结果："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"绿条：执行结果没有异常"}),"\n",(0,l.jsx)(e.li,{children:"红条：执行结果出现异常"}),"\n"]}),"\n"]}),"\n"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(i,{...n})}):i(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["tang%2Fjava2%2F05_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89.md"]={toc:[{text:"5.1 OOP特征二：继承",id:"51-oop特征二继承",depth:2},{text:"5.2 方法的重写",id:"52-方法的重写",depth:2},{text:"5.3 子类对象实例化过程",id:"53-子类对象实例化过程",depth:2},{text:"5.4 OOP特征三： 多态",id:"54-oop特征三-多态",depth:2},{text:"5.5 Object类的使用",id:"55-object类的使用",depth:2},{text:"5.6 包装类的使用",id:"56-包装类的使用",depth:2},{text:"5.7 单元测试",id:"57-单元测试",depth:2}],title:"5 面向对象编程（中）",frontmatter:{}}}}]);