"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["1811"],{45882:function(e,n,r){r.r(n),r.d(n,{default:function(){return a}});var h=r(85893),d=r(50065);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",h3:"h3",ol:"ol",li:"li",ul:"ul"},(0,d.ah)(),e.components);return(0,h.jsxs)(h.Fragment,{children:[(0,h.jsxs)(n.h1,{id:"工厂模式",children:["工厂模式",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工厂模式",children:"#"})]}),"\n",(0,h.jsxs)(n.p,{children:[(0,h.jsx)(n.strong,{children:"核心思想"}),"：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。"]}),"\n",(0,h.jsxs)(n.p,{children:[(0,h.jsx)(n.strong,{children:"例子"}),"： js 中的 document.createElement() 方法；Vue 和 React中的createElement() 方法"]}),"\n",(0,h.jsxs)(n.h2,{id:"介绍",children:["介绍",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#介绍",children:"#"})]}),"\n",(0,h.jsxs)(n.h3,{id:"意图",children:["意图：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#意图",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。"}),"\n",(0,h.jsxs)(n.h3,{id:"主要解决",children:["主要解决：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主要解决",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"主要解决接口选择的问题。"}),"\n",(0,h.jsxs)(n.h3,{id:"何时使用",children:["何时使用：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#何时使用",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"我们明确地计划不同条件下创建不同实例时。"}),"\n",(0,h.jsxs)(n.h3,{id:"如何解决",children:["如何解决：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何解决",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"让其子类实现工厂接口，返回的也是一个抽象的产品。"}),"\n",(0,h.jsxs)(n.h3,{id:"关键代码",children:["关键代码：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关键代码",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"创建过程在其子类执行。"}),"\n",(0,h.jsxs)(n.h3,{id:"应用实例",children:["应用实例：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#应用实例",children:"#"})]}),"\n",(0,h.jsxs)(n.ol,{children:["\n",(0,h.jsx)(n.li,{children:"您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。"}),"\n",(0,h.jsx)(n.li,{children:"Hibernate 换数据库只需换方言和驱动就可以。"}),"\n"]}),"\n",(0,h.jsxs)(n.h3,{id:"优点",children:["优点：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优点",children:"#"})]}),"\n",(0,h.jsxs)(n.ol,{children:["\n",(0,h.jsx)(n.li,{children:"一个调用者想创建一个对象，只要知道其名称就可以了。"}),"\n",(0,h.jsx)(n.li,{children:"扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。"}),"\n",(0,h.jsx)(n.li,{children:"屏蔽产品的具体实现，调用者只关心产品的接口。"}),"\n"]}),"\n",(0,h.jsxs)(n.h3,{id:"缺点",children:["缺点：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缺点",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。"}),"\n",(0,h.jsxs)(n.h3,{id:"使用场景",children:["使用场景：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用场景",children:"#"})]}),"\n",(0,h.jsxs)(n.ol,{children:["\n",(0,h.jsx)(n.li,{children:"日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。"}),"\n",(0,h.jsx)(n.li,{children:"数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。"}),"\n",(0,h.jsx)(n.li,{children:'设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。'}),"\n"]}),"\n",(0,h.jsxs)(n.h3,{id:"注意事项",children:["注意事项：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#注意事项",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。"}),"\n",(0,h.jsxs)(n.h3,{id:"核心角色",children:["核心角色：",(0,h.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心角色",children:"#"})]}),"\n",(0,h.jsx)(n.p,{children:"工厂模式包含以下几个核心角色："}),"\n",(0,h.jsxs)(n.ul,{children:["\n",(0,h.jsx)(n.li,{children:"抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。"}),"\n",(0,h.jsx)(n.li,{children:"具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。"}),"\n",(0,h.jsx)(n.li,{children:"抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。"}),"\n",(0,h.jsx)(n.li,{children:"具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。"}),"\n"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,h.jsx)(n,{...e,children:(0,h.jsx)(i,{...e})}):i(e)}let a=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["JavaScript%2Fdesign%2Fpart2.md"]={toc:[{text:"介绍",id:"介绍",depth:2},{text:"意图：",id:"意图",depth:3},{text:"主要解决：",id:"主要解决",depth:3},{text:"何时使用：",id:"何时使用",depth:3},{text:"如何解决：",id:"如何解决",depth:3},{text:"关键代码：",id:"关键代码",depth:3},{text:"应用实例：",id:"应用实例",depth:3},{text:"优点：",id:"优点",depth:3},{text:"缺点：",id:"缺点",depth:3},{text:"使用场景：",id:"使用场景",depth:3},{text:"注意事项：",id:"注意事项",depth:3},{text:"核心角色：",id:"核心角色",depth:3}],title:"工厂模式",frontmatter:{}}}}]);