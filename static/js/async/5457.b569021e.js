"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["5457"],{46314:function(n,e,r){r.r(e),r.d(e,{default:()=>p});var s=r("85893"),l=r("50065");let i=r.p+"static/image/image-20220627112343471.2a6b87dd.png",c=r.p+"static/image/image-20220627162411301.2ed0b7ee.png",d=r.p+"static/image/image-20220627161318590.d19fe5e9.png",t=r.p+"static/image/image-20220629163503964.d5e2e348.png",h=r.p+"static/image/image-20220629163610845.b1cea530.png",a=r.p+"static/image/image-20220701135706927.4be5f288.png",o=r.p+"static/image/image-20220701135720579.135bf153.png",x=r.p+"static/image/image-20220722152810676.c089f89c.png";function j(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",pre:"pre",blockquote:"blockquote",img:"img",h2:"h2",hr:"hr"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"vue基础知识",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#vue基础知识",children:"#"}),"Vue基础知识"]}),"\n",(0,s.jsxs)(e.h1,{id:"1单向绑定与双向绑定",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1单向绑定与双向绑定",children:"#"}),"1.单向绑定与双向绑定"]}),"\n",(0,s.jsx)(e.p,{children:"==单项绑定与双向绑定的区别==：例如在input标签中，修改输入内容。如果输入内容改变时，Vue实例中对应的属性随之改变，则为双向绑定；否则是单向绑定。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["v-bind：单项绑定。",(0,s.jsx)(e.code,{children:"v-bind:"}),"简写为",(0,s.jsx)(e.code,{children:":"})]}),"\n",(0,s.jsxs)(e.li,{children:["v-model：双向绑定。",(0,s.jsx)(e.code,{children:"v-model:value"}),"简写为",(0,s.jsx)(e.code,{children:"v-model"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"v-model只能应用在表单元素上，如input、radio、checkBox、textarea等具有value属性的标签。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"2vue绑定容器的两种方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2vue绑定容器的两种方法",children:"#"}),"2.Vue绑定容器的两种方法"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法一：在创建Vue实例时，直接指定容器"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 方法一：在创建Vue实例时，直接指定容器\r\nnew Vue ({\r\n    el: '#containerId',\r\n    data: {\r\n        name: 'hello'\r\n    }\r\n});\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法二：使用$mount方法指定容器"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 方法二：使用$mount方法指定容器\r\nconst v = new Vue({\r\n    data: {\r\n        name: 'hello'\r\n    }\r\n});\r\nv.$mount('root')\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"3vue实例中data的两种写法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3vue实例中data的两种写法",children:"#"}),"3.Vue实例中data的两种写法"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法一：对象式"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 方法一：对象式\r\nnew Vue ({\r\n    el: '#containerId',\r\n    data: {\r\n        name: 'hello'\r\n    }\r\n});\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法二：函数式"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 方法二：函数式\r\nnew Vue ({\r\n    el: '#containerId',\r\n    data: function() {// 此处function必须是普通函数，不能是箭头函数(箭头函数没有自己的this，会一直往外找找到全局的Window实例)。\r\n       console.log('=====', this) // 此处this是Vue实例对象\r\n       return {\r\n            name: 'hello'\r\n       }\r\n    }\r\n});\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"在创建Vue实例时，以上两种写法都可以。但是当创建组件时，data必须使用函数式，否则会报错。"}),"\n",(0,s.jsx)(e.li,{children:"Vue管理的函数(比如方法二中的data函数)，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。"}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"4vue的mvvm模型",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4vue的mvvm模型",children:"#"}),"4.Vue的MVVM模型"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"M(模型Model)：对应data中的数据"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"V(视图View)：模板(页面)"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"VM(视图模型ViewModel)：Vue实例"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220627112343471",src:i})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"总结"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"data中所有的属性最后都出现在了vm身上。"}),"\n",(0,s.jsx)(e.li,{children:"vm身上所有的属性及Vue原型上所有的属性，在Vue模板中都可以直接使用。"}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"5数据代理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5数据代理",children:"#"}),"5.数据代理"]}),"\n",(0,s.jsx)(e.p,{children:"==ES6语法=="}),"\n",(0,s.jsxs)(e.h2,{id:"51-objectdefineproperty方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#51-objectdefineproperty方法",children:"#"}),"5.1 Object.defineproperty方法"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"let num = 18;\r\nlet person = {\r\n    name: '张三',\r\n    sex: '男'\r\n}\r\n\r\nObject.defineProperty(person, 'age', {\r\n    // value: 18, // 可以在这里直接给age赋值\r\n    // enumerable: true, // 控制属性是否可以被枚举(Object.keys(person)是否能获取到属性)，默认false\r\n    // writable: true, // 控制属性是否可以被修改，默认false\r\n    // configurable: true, // 控制属性是否可以被删除，默认false\r\n\r\n    // 当有人读取person的age属性时，get函数就会被调用，且返回值就是age的值\r\n    get() {\r\n        console.log('有人读取age属性了');\r\n        return num;\r\n    },\r\n\r\n    // 当有人修改普洱送的age属性时，set函数就会被调用，且会受到修改的具体值\r\n    set(value) {\r\n        console.log('有人修改age属性了');\r\n        num = value;\r\n    }\r\n})\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"52-数据代理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#52-数据代理",children:"#"}),"5.2 数据代理"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220627162411301",src:c})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"通过一个对象，代理对另一个对象中属性的操作（读/写）。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"例子：通过obj2对象对obj的x属性进行修改"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"let obj = {x: 100};\r\nlet obj2 = {y: 200};\r\n\r\n// 当读取obj2.x时，返回obj.x的值；当修改obj2.x时，对obj.x进行修改\r\nObject.defineProperty(obj, 'x', {\r\n   get() {\r\n       return obj.x;\r\n   },\r\n   set(value) {\r\n       obj.x = value;\r\n   }\r\n});\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"53--vue中的数据代理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#53--vue中的数据代理",children:"#"}),"5.3  Vue中的数据代理"]}),"\n",(0,s.jsx)(e.p,{children:"==只有写在data中的对象，才会进行数据代理。=="}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220627161318590",src:d})}),"\n",(0,s.jsxs)(e.h1,{id:"6事件处理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6事件处理",children:"#"}),"6.事件处理"]}),"\n",(0,s.jsxs)(e.h2,{id:"61-事件的基本使用",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#61-事件的基本使用",children:"#"}),"6.1 事件的基本使用"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["使用",(0,s.jsx)(e.code,{children:"v-on"}),"或者",(0,s.jsx)(e.code,{children:"@"}),"绑定事件"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"传参"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"无参调用"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<button @click.stop="showInfo">点我提示信息</button><br>\r\n\r\n<script text="text/javascript">\r\nshowInfo(e) {\r\n    // e是默认参数$event\r\n    console.log(e)\r\n}\r\n<\/script>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"有参调用"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<button @click.stop=\"showInfo($event, 'abc')\">点我提示信息</button><br>\r\n\r\n<script text=\"text/javascript\">\r\nshowInfo(e, str) {\r\n    // e是默认参数$event\r\n    console.log(e)\r\n    // str是第二个参数，'abc'\r\n    console.log(str)\r\n}\r\n<\/script>\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"62-事件修饰符",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#62-事件修饰符",children:"#"}),"6.2 事件修饰符"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==prevent==：阻止默认事件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 阻止默认事件 --\x3e\r\n<h2>阻止默认事件</h2>\r\n<div class="tip">点击a标签，只弹出alert，不跳转</div>\r\n<a href="http://www.biying.com" @click.prevent="showInfo">点我提示信息</a>\r\n\r\n<script text="text/javascript">\r\n	showInfo(e) {\r\n        console.log(e)\r\n        alert(\'同学你好\')\r\n    }\r\n<\/script>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==stop==：阻止事件冒泡"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 阻止冒泡事件 --\x3e\r\n<h2>阻止冒泡事件</h2>\r\n<div class="tip">外层div和内层button都有点击事件showInfo。点击button时，只调用一次showInfo函数</div>\r\n<div class="demo1" @click="showInfo">\r\n    <button @click.stop="showInfo">点我提示信息</button>\r\n</div>\r\n\r\n<script text="text/javascript">\r\n	showInfo(e) {\r\n        console.log(e)\r\n        alert(\'同学你好\')\r\n    }\r\n<\/script>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==once==：事件只触发一次"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 事件只触发一次 --\x3e\r\n<h2>事件只触发一次</h2>\r\n<div class="tip">只有在第一次点击button时，才会调用showInfo函数</div>\r\n<button @click.once="showInfo">点我提示信息</button>\r\n\r\n<script text="text/javascript">\r\n	showInfo(e) {\r\n        console.log(e)\r\n        alert(\'同学你好\')\r\n    }\r\n<\/script>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==capture==：使用事件的捕获模式"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 使用事件捕获模式 --\x3e\r\n<h2>使用事件捕获模式</h2>\r\n<div class="tip">外层div和内层button都有点击事件showMsg。点击button时，先调用外层div的点击事件，再调用内层button的点击事件</div>\r\n<div class="demo1" @click.capture="showMsg(\'div\')">\r\n    <button @click="showMsg(\'button\')">点我提示信息</button>\r\n</div>\r\n\r\n<script text="text/javascript">\r\n    showMsg(msg) {\r\n        console.log(msg)\r\n    },\r\n<\/script>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==self==：只有event.target是当前操作的元素才触发事件"}),"\n",(0,s.jsx)(e.p,{children:"个人感觉该修饰符和stop修饰符的作用相同，但是需要注意的是stop用来修饰内部标签，self用来修饰外部标签。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 只有event.target是当前操作的元素时，才触发事件 --\x3e\r\n<h2>只有event.target是当前操作的元素时，才触发事件</h2>\r\n<div class="tip">外层div和内层button都有点击事件showMsg。点击button时，不会调用外层div的点击事件，只有点击外层div时才会触发</div>\r\n<div class="demo1" @click.self="showMsg(\'div\')">\r\n    <button @click="showMsg(\'button\')">点我提示信息</button>\r\n</div>\r\n<hr>\r\n\r\n<script text="text/javascript">\r\n    showMsg(msg) {\r\n        console.log(msg)\r\n    },\r\n<\/script>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==passive==：事件的默认行为立即执行，无需等待事件回调执行完毕"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:".passive"})," 修饰符尤其能够提升移动端的性能。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 事件的默认行为立即执行，无需等待事件回调执行完毕 --\x3e\r\n<h2>事件的默认行为立即执行，无需等待事件回调执行完毕</h2>\r\n<ul class="demo-rl" @wheel.passive="myWheel">\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n    <li>5</li>\r\n    <li>6</li>\r\n    <li>7</li>\r\n    <li>8</li>\r\n</ul>\r\n\r\n<script text="text/javascript">\r\n   myWheel() {\r\n       for (let index = 0; index < 100000; index++) {\r\n           console.log(\'*\')\r\n       }\r\n       console.log(\'累死个人\')\r\n   }\r\n<\/script>\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"==修饰符可以连续写，且顺序无所谓=="}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 修饰符可以连续写，且顺序无所谓 --\x3e\r\n<h2>阻止冒泡事件</h2>\r\n<div class="tip">外层div和内层button都有点击事件showInfo。点击button时，只调用一次showInfo函数</div>\r\n<div class="demo1" @click="showInfo">\r\n    \x3c!-- 先组织a标签的默认行为，再组织冒泡 --\x3e\r\n    <a href="http://www.biying.com" @click.prevent.stop="showInfo">点我提示信息</a>\r\n</div>\r\n<hr>\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"源码"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<!DOCTYPE html>\r\n<html lang="en">\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <title>事件的修饰符</title>\r\n    <script src="../js/vue.js"><\/script>\r\n    <style>\r\n        *{\r\n            margin-top: 10px;\r\n        }\r\n        .demo1 {\r\n            height: 50px;\r\n            background-color: skyblue;\r\n        }\r\n        .tip {\r\n            color: gray;\r\n            margin-bottom: 5px;\r\n        }\r\n        .demo-rl {\r\n            height: 200px;\r\n            background-color: orange;\r\n            overflow: auto;\r\n        }\r\n        .demo-rl li {\r\n            height: 100px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id="root">\r\n        <h1>事件的修饰符</h1>\r\n        <hr>\r\n\r\n        \x3c!-- 阻止默认事件 --\x3e\r\n        <h2>阻止默认事件</h2>\r\n        <div class="tip">点击a标签，只弹出alert，不跳转</div>\r\n        <a href="http://www.biying.com" @click.prevent="showInfo">点我提示信息</a>\r\n        <hr>\r\n\r\n        \x3c!-- 阻止冒泡事件 --\x3e\r\n        <h2>阻止冒泡事件</h2>\r\n        <div class="tip">外层div和内层button都有点击事件showInfo。点击button时，只调用一次showInfo函数</div>\r\n        <div class="demo1" @click="showInfo">\r\n            <button @click.stop="showInfo">点我提示信息</button>\r\n        </div>\r\n        <hr>\r\n        \r\n        \x3c!-- 事件只触发一次 --\x3e\r\n        <h2>事件只触发一次</h2>\r\n        <div class="tip">只有在第一次点击button时，才会调用showInfo函数</div>\r\n        <button @click.once="showInfo">点我提示信息</button>\r\n        <hr>\r\n\r\n        \x3c!-- 使用事件捕获模式 --\x3e\r\n        <h2>使用事件捕获模式</h2>\r\n        <div class="tip">外层div和内层button都有点击事件showMsg。点击button时，先调用外层div的点击事件，再调用内层button的点击事件</div>\r\n        <div class="demo1" @click.capture="showMsg(\'div\')">\r\n            <button @click="showMsg(\'button\')">点我提示信息</button>\r\n        </div>\r\n        <hr>\r\n\r\n        \x3c!-- 只有event.target是当前操作的元素时，才触发事件 --\x3e\r\n        <h2>只有event.target是当前操作的元素时，才触发事件</h2>\r\n        <div class="tip">外层div和内层button都有点击事件showMsg。点击button时，不会调用外层div的点击事件，只有点击外层div时才会触发</div>\r\n        <div class="demo1" @click.self="showMsg(\'div\')">\r\n            <button @click="showMsg(\'button\')">点我提示信息</button>\r\n        </div>\r\n        <hr>\r\n\r\n        \x3c!-- 事件的默认行为立即执行，无需等待事件回调执行完毕 --\x3e\r\n        <h2>事件的默认行为立即执行，无需等待事件回调执行完毕</h2>\r\n        <ul class="demo-rl" @scroll="myWheel">\r\n            <li>1</li>\r\n            <li>2</li>\r\n            <li>3</li>\r\n            <li>4</li>\r\n            <li>5</li>\r\n            <li>6</li>\r\n            <li>7</li>\r\n            <li>8</li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n<script text="text/javascript>">\r\n    new Vue({\r\n        el: \'#root\',\r\n        data: {\r\n            name: "name",\r\n        },\r\n        methods: {\r\n            showInfo(e) {\r\n                console.log(e)\r\n                alert(\'同学你好\')\r\n            },\r\n            showMsg(msg) {\r\n                console.log(msg)\r\n            },\r\n            myWheel() {\r\n                for (let index = 0; index < 100000; index++) {\r\n                    console.log(\'*\')\r\n                }\r\n                console.log(\'累死个人\')\r\n            }\r\n        }\r\n    })\r\n<\/script>\r\n</html>\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"63-按键修饰符",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#63-按键修饰符",children:"#"}),"6.3 按键修饰符"]}),"\n",(0,s.jsxs)(e.p,{children:["Vue允许使用",(0,s.jsx)(e.code,{children:"v-on:keyon"}),"或者",(0,s.jsx)(e.code,{children:"v-on:keydown"}),"对键盘按键添加修饰符，从而起到对按键监听的作用。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用方法"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 只有在按下 `Enter` 键时调用 `vm.submit()` --\x3e\r\n<input v-on:keyup.enter="submit">\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vue中常用的按键别名"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"回车: enter"}),"\n",(0,s.jsx)(e.li,{children:"删除（包括delete键和backspace键）：delete"}),"\n",(0,s.jsx)(e.li,{children:"退出：esc"}),"\n",(0,s.jsx)(e.li,{children:"空格：space"}),"\n",(0,s.jsx)(e.li,{children:"制表符：tab(该键只能配合keydown事件使用，对keyup无效)"}),"\n",(0,s.jsx)(e.li,{children:"上：up"}),"\n",(0,s.jsx)(e.li,{children:"下：down"}),"\n",(0,s.jsx)(e.li,{children:"左：left"}),"\n",(0,s.jsx)(e.li,{children:"右：right"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vue中未提供别名的按键的使用"}),"\n",(0,s.jsx)(e.p,{children:"可以使用按键原始的key值去绑定（大驼峰命名需要转为短横线命名），也可以使用按键的编码值keyCode去绑定。但是使用keyCode不推荐，因为不同电脑按键的keyCode值有可能不一样，并且该特性已经在web标准中移除，将来随时可能移除。"}),"\n",(0,s.jsx)(e.p,{children:"==获取按键的key值和keyCode值：=="}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<div id="root">\r\n    <input type="text" @keyup="showInfo">\r\n</div>\r\n\r\n<script text="text/javascript">\r\n    showInfo(e) {\r\n        console.log(\'按键key值\',e.key);\r\n        console.log(\'按键keyCode值\',e.keyCode);\r\n    }\r\n<\/script>\r\n\r\n\x3c!-- 运行结果 --\x3e\r\n\x3c!-- \r\n    按下shift键时输出：\r\n        按键key值 Shift\r\n        按键keyCode值 16\r\n    按下caps lock键（大小写转换键）时输出：\r\n        按键key值 CapsLock\r\n        按键keyCode值 20\r\n--\x3e\r\n\n'})}),"\n",(0,s.jsx)(e.p,{children:"==大驼峰命名的键的使用：==大驼峰命名改为短横线命名"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- caps lock键的key值是CapsLock，在使用时需要转为短横线命名 --\x3e\r\n<input v-on:keyup.caps-lock="submit">\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"系统修饰键的使用"}),"\n",(0,s.jsx)(e.p,{children:"==系统修饰键：==ctrl、alt 、shift、meta（windows键）"}),"\n",(0,s.jsx)(e.p,{children:"==用法：=="}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"配合keyup使用：按下修饰键的同事，再按下其他键，随后释放其他键，事件才会触发"}),"\n",(0,s.jsx)(e.li,{children:"配合keydown使用：正常触发事件"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"==配合keyup使用时，按下指定按键时才会触发事件：=="}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 只有在按下ctrl+y时，才会触发事件 --\x3e\r\n<input type="text" @keyup.ctrl.y="showInfo">\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"自定义键名(不推荐)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<div id="root">\r\n    <input type="text" @keyup.huiche="showInfo">\r\n</div>\r\n\r\n<script text="text/javascript">\r\n    Vue.config.keyCodes.huiche = 13\r\n<\/script>\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"7计算属性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7计算属性",children:"#"}),"7.计算属性"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"计算属性定义"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"要用的属性在Vue的data中不存在，需要通过已有的属性计算出来。使用计算属性时，必须定义计算属性的get函数。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"原理"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["底层借助了",(0,s.jsx)(e.code,{children:"Object.defineProperty"}),"方法提供的",(0,s.jsx)(e.code,{children:"getter"}),"和",(0,s.jsx)(e.code,{children:"setter"}),"。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"getter执行时机"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"初次读取时会执行一次"}),"\n",(0,s.jsx)(e.li,{children:"当依赖的数据发生变化时会被再次调用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"==计算属性被读取后，会存到缓存中，后续的读取都是在缓存中读取数据=="}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"setter注意事项"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"如果不修改计算属性，可以不写set函数。但是如果修改计算属性，set函数中必须引起其所依赖的属性发生变化。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"与methods相比的优势"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"计算属性内部有缓存机制，效率更高，调试方便。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"计算属性的简写"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"==当确定计算属性只读不改的时候，才可以用简写形式。=="}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<div id="root">\r\n    姓：<input type = "text" v-model="familyName"> <br><br>\r\n    名：<input type = "text" v-model="firstName"> <br><br>\r\n    全名2：<span>{{fullName2}}</span>\r\n</div>\r\n\r\n<script text="text/javascript">\r\n    const vm = new Vue({\r\n        el: \'#root\',\r\n        data: {\r\n            familyName: \'张\',\r\n            firstName: \'三\'\r\n        },\r\n        computed: {\r\n             // 简写\r\n            fullName2() {\r\n                return this.familyName + \'-\' + this.firstName\r\n            }\r\n        }\r\n    })\r\n<\/script>\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"其他"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"计算属性最终会出现在Vue实例中，直接读取即可。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220629163503964",src:t})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"计算属性不会出现在Vue._data属性中。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220629163610845",src:h})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"如果计算属性要被修改，必须写set函数去响应修改，且set函数中要引起计算式依赖的属性发生变化。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"本小节完整代码"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<body>\r\n    <div id=\"root\">\r\n        姓：<input type = \"text\" v-model=\"familyName\"> <br><br>\r\n        名：<input type = \"text\" v-model=\"firstName\"> <br><br>\r\n        全名1：<span>{{fullName1}}</span> <br><br>\r\n        全名2：<span>{{fullName2}}</span>\r\n    </div>\r\n</body>\r\n<script text=\"text/javascript\">\r\n    const vm = new Vue({\r\n        el: '#root',\r\n        data: {\r\n            familyName: '张',\r\n            firstName: '三'\r\n        },\r\n        computed: {\r\n            // 完整写法\r\n            fullName1: {\r\n                get() {\r\n                    return this.familyName + '-' + this.firstName\r\n                },\r\n                set(value) {\r\n                    const arr = value.split('-');\r\n                    this.familyName = arr[0];\r\n                    this.firstName = arr[1]\r\n                }\r\n            },\r\n            // 简写\r\n            fullName2() {\r\n                return this.familyName + '-' + this.firstName\r\n            }\r\n        }\r\n    })\r\n<\/script>\n"})}),"\n",(0,s.jsxs)(e.h1,{id:"8监视属性",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#8监视属性",children:"#"}),"8.监视属性"]}),"\n",(0,s.jsxs)(e.h2,{id:"81-基础监视",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#81-基础监视",children:"#"}),"8.1 基础监视"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"基本知识"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"当被监视的属性变化时，回调函数(handler)自动调用，进行相关操作"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["监视的属性必须存在，才能进行监视。","被监视的属性不存在，控制台不会报错。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"监视有两种写法"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"通过new Vue()时传入watch配置"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const vm = new Vue({\r\n    el: '#root',\r\n    data: {\r\n        isHot: true\r\n    },\r\n    methods: {\r\n        changeWeather() {\r\n            this.isHot = !this.isHot\r\n        }\r\n    },\r\n    computed: {\r\n        info() {\r\n            return this.isHot?'炎热':'凉爽'\r\n        }  \r\n    },\r\n    // 方法一\r\n    watch: {\r\n        isHot: {\r\n            immediate: true, //作用：初始化时让handler调用一次，默认为false\r\n            handler(newValue, oldValue) {\r\n                console.log('isHost被修改了', '新值为'+newValue, '原值为'+oldValue)\r\n            }\r\n        }\r\n    }\r\n});\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"通过vm.$watch监视"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 方法二\r\nconst vm = new Vue({\r\n	// 此处省略\r\n});\r\nvm.$watch('isHot', { \r\n    immediate: true, //作用：初始化时让handler调用一次，默认为false\r\n    handler(newValue, oldValue) {\r\n    console.log('isHost被修改了', '新值为'+newValue, '原值为'+oldValue)\r\n    }\r\n})\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"监视属性的简写"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"==在确定被监视的属性只使用handler()函数时，才可以简写。=="}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法一："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const vm = new Vue({\r\n    el: '#root',\r\n    data: {\r\n        isHot: true\r\n    },\r\n    methods: {\r\n        changeWeather() {\r\n            this.isHot = !this.isHot\r\n        }\r\n    },\r\n    computed: {\r\n        info() {\r\n            return this.isHot?'炎热':'凉爽'\r\n        }  \r\n    },\r\n    // 方法一\r\n    watch: {\r\n        isHot(newValue, oldValue) {\r\n            console.log('isHost被修改了', '新值为'+newValue, '原值为'+oldValue)\r\n        }\r\n    }\r\n});\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"方法二："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 方法二\r\nconst vm = new Vue({\r\n	// 此处省略\r\n});\r\n\r\nvm.$watch('isHot', function(newValue, oldValue) {\r\n    console.log('isHost被修改了', '新值为'+newValue, '原值为'+oldValue)\r\n})\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"完整案例"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<body>\r\n    <div id=\"root\">\r\n        <h2>今天天气很{{info}}</h2>\r\n        <button @click=\"changeWeather\">切换天气</button>\r\n    </div>\r\n</body>\r\n<script text=\"text/javascript\">\r\n    const vm = new Vue({\r\n        el: '#root',\r\n        data: {\r\n            isHot: true\r\n        },\r\n        methods: {\r\n            changeWeather() {\r\n                this.isHot = !this.isHot\r\n            }\r\n        },\r\n        computed: {\r\n          info() {\r\n            return this.isHot?'炎热':'凉爽'\r\n          }  \r\n        },\r\n        // 方法一\r\n        // watch: {\r\n        //     isHot: {\r\n        //         immediate: true, //作用：初始化时让handler调用一次，默认为false\r\n        //         handler(newValue, oldValue) {\r\n        //             console.log('isHost被修改了', '新值为'+newValue, '原值为'+oldValue)\r\n        //         }\r\n        //     }\r\n        // }\r\n    });\r\n\r\n    // 方法二\r\n    vm.$watch('isHot', { \r\n        immediate: true, //作用：初始化时让handler调用一次，默认为false\r\n        handler(newValue, oldValue) {\r\n            console.log('isHost被修改了', '新值为'+newValue, '原值为'+oldValue)\r\n        }\r\n     })\r\n<\/script>\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"82-深度监视",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#82-深度监视",children:"#"}),"8.2 深度监视"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"实现"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Vue中的watch默认不检测对象内部值的改变，但是可以通过修改",(0,s.jsx)(e.code,{children:"Vue.watch.deep"}),"为",(0,s.jsx)(e.code,{children:"true"}),"来实现监测对象内部值的改变。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"完整代码"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<body>\r\n    <div id=\"root\">\r\n        <h2>msg.a的值为：{{msg.a}}</h2>\r\n        <button @click=\"msg.a++\">点我执行a+1</button>\r\n    </div>\r\n</body>\r\n<script text=\"text/javascript\">\r\n    const vm = new Vue({\r\n        el: '#root',\r\n        data: {\r\n            msg: {\r\n                a: 1,\r\n                b: 'hello'\r\n            }\r\n        },\r\n        watch: {\r\n            // 监视多级结构中所有属性的变化\r\n            msg: {\r\n                deep: true, //开启深度监视\r\n                handler(newValue, oldValue) {\r\n                    console.log('msg被修改了', newValue, oldValue)\r\n                }\r\n            },\r\n            // 监视多级结构中某个属性的变化\r\n            'msg.a': {\r\n                handler(newValue, oldValue) {\r\n                    console.log('msg.a被修改了', newValue, oldValue)\r\n                }\r\n            }\r\n        }\r\n    });\r\n<\/script>\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"83-监视属性和计算属性的对比",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#83-监视属性和计算属性的对比",children:"#"}),"8.3 监视属性和计算属性的对比"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"区别"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"computed能完成的功能，watch都可以完成。"}),"\n",(0,s.jsx)(e.li,{children:"watch能完成的功能，computed不一定可以完成。例如：watch可以进行异步操作。"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"两个重要小原则"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"所有被Vue管理的函数，最好写成普通函数，这样this的指向才是Vue实例对象或者组件实例对象。"}),"\n",(0,s.jsx)(e.li,{children:"所有不被Vue管理的函数（如定时器的回调函数、ajax回调函数、Promise的回调函数等），最好写成箭头函数，这样this的指向才是Vue实例对象或者组件实例对象。"}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"9绑定样式",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9绑定样式",children:"#"}),"9.绑定样式"]}),"\n",(0,s.jsxs)(e.h2,{id:"91-绑定class样式",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#91-绑定class样式",children:"#"}),"9.1 绑定class样式"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用字符串绑定"}),"\n",(0,s.jsx)(e.p,{children:"适用于==样式的类名不确定，需要动态指定==的场景"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 字符串写法，使用场景：样式的类名不确定，需要动态指定 --\x3e\r\n<div class="basic" :class="mood" @click="changeMood">Hello, Vue</div>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用数组绑定"}),"\n",(0,s.jsx)(e.p,{children:"适用于==要绑定的样式个数不确定、名字也不确定==的场景"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 数组写法，使用场景：要绑定的样式个数不确定、名字也不确定 --\x3e\r\n<div class="basic" :class="classArr">Hello, Vue</div>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用对象绑定"}),"\n",(0,s.jsx)(e.p,{children:"适用于==要绑定的样式确定、名字确定，但是需要动态决定是否使用==的场景"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 对象写法，使用场景：要绑定的样式确定、名字确定，但是需要动态决定是否使用 --\x3e\r\n<div class="basic" :class="classObj">Hello, Vue</div>\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"92-绑定style样式",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#92-绑定style样式",children:"#"}),"9.2 绑定style样式"]}),"\n",(0,s.jsx)(e.p,{children:"绑定style样式时，需要为style绑定对象，==对象中的key值是css中样式名，但是需要把短横线命名改为小驼峰命名==。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"对象写法"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 单个style样式 --\x3e\r\n<div class="basic" :style="{fontSize: fSize + \'px\'}">Hello, Vue</div><br>\r\n\x3c!-- 多个style样式 --\x3e\r\n<div class="basic" :style="myStyle">Hello, Vue</div><br>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"数组写法(不常用)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 绑定class-> 数组写法 --\x3e\r\n<div class="basic" :style="styleArr">Hello, Vue</div><br>\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"本小节完整代码"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<style>\r\n    .basic {\r\n        border: 1px solid gray;\r\n        height: 50px;\r\n        width: 40%;\r\n        line-height: 50px;\r\n    }\r\n\r\n    .happy {\r\n        background-color: rgb(235, 134, 76);\r\n    }\r\n\r\n    .normal {\r\n        background-color: grey;\r\n    }\r\n\r\n    .sad {\r\n        background-color: aquamarine;\r\n    }\r\n\r\n    .class1 {\r\n        font-size: 20px;\r\n    }\r\n\r\n    .class2 {\r\n        background-color: greenyellow;\r\n    }\r\n\r\n    .class3 {\r\n        border-radius: 10px;\r\n    }\r\n\r\n</style>\r\n<body>\r\n    <div id=\"root\" >\r\n        \x3c!-- 绑定class-> 字符串写法，使用场景：样式的类名不确定，需要动态指定 --\x3e\r\n        <div class=\"basic\" :class=\"mood\" @click=\"changeMood\">Hello, Vue</div><br>\r\n        \x3c!-- 绑定class-> 数组写法，使用场景：要绑定的样式个数不确定、名字也不确定 --\x3e\r\n        <div class=\"basic\" :class=\"classArr\">Hello, Vue</div><br>\r\n        \x3c!-- 绑定class-> 对象写法，使用场景：要绑定的样式确定、名字确定，但是需要动态决定是否使用 --\x3e\r\n        <div class=\"basic\" :class=\"classObj\">Hello, Vue</div><br>\r\n\r\n        \x3c!-- 绑定style-> 对象写法1 --\x3e\r\n        <div class=\"basic\" :style=\"{fontSize: fSize + 'px'}\">Hello, Vue</div><br>\r\n        \x3c!-- 绑定class-> 对象写法2 --\x3e\r\n        <div class=\"basic\" :style=\"myStyle\">Hello, Vue</div><br>\r\n        \x3c!-- 绑定class-> 数组写法 --\x3e\r\n        <div class=\"basic\" :style=\"styleArr\">Hello, Vue</div><br>\r\n    </div>\r\n</body>\r\n<script text=\"text/javascript\">\r\n    new Vue({\r\n        el: '#root',\r\n        data() {\r\n            return {\r\n                mood: 'normal',\r\n                classArr: ['class1', 'class2', 'class3'],\r\n                classObj: {\r\n                    class1: false,\r\n                    class2: false\r\n                },\r\n                fSize: 40,\r\n                myStyle: {\r\n                    fontSize: '40px',\r\n                    color: 'orange',\r\n                    backgroundColor: 'gray'\r\n                },\r\n                styleArr: [\r\n                {\r\n                    fontSize: '40px',\r\n                    color: 'orange'\r\n                },{\r\n                    backgroundColor: 'gray'\r\n                },\r\n                ]\r\n            }\r\n        },\r\n        methods: {\r\n            changeMood() {\r\n                const moodArr = ['happy', 'normal', 'sad'];\r\n                this.mood = moodArr[Math.floor(Math.random() * 3)]\r\n            }\r\n        },\r\n    })\r\n<\/script>\n"})}),"\n",(0,s.jsxs)(e.h1,{id:"10条件渲染",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10条件渲染",children:"#"}),"10.条件渲染"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"v-if"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["写法：",(0,s.jsx)(e.code,{children:'v-if="表达式"'}),"、",(0,s.jsx)(e.code,{children:'v-else-if="表达式"'}),"、 ",(0,s.jsx)(e.code,{children:"v-else"})]}),"\n",(0,s.jsx)(e.li,{children:"使用场景：切换频率较低的场景"}),"\n",(0,s.jsx)(e.li,{children:"特点：==不展示的DOM元素直接被移除=="}),"\n",(0,s.jsxs)(e.li,{children:["注意：",(0,s.jsx)(e.code,{children:"v-if"}),"可以和",(0,s.jsx)(e.code,{children:"v-else-if"}),"、 ",(0,s.jsx)(e.code,{children:"v-else"}),"一起使用，但是要求结构不能被“打断”"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"v-show"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["写法：",(0,s.jsx)(e.code,{children:'v-show="表达式"'})]}),"\n",(0,s.jsx)(e.li,{children:"使用场景：切换频率较高的场景"}),"\n",(0,s.jsx)(e.li,{children:"特点：==不展示的DOM元素未被移除，只是将其display设置为none=="}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"v-if与v-show对比"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["使用",(0,s.jsx)(e.code,{children:"v-if"}),"时，元素可能无法获取到，而使用",(0,s.jsx)(e.code,{children:"v-show"}),"一定可以获取到"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"v-if"}),"可以结合",(0,s.jsx)(e.code,{children:"<template>"}),"标签使用，",(0,s.jsx)(e.code,{children:"v-show"}),"不可以"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"11列表渲染",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11列表渲染",children:"#"}),"11.列表渲染"]}),"\n",(0,s.jsxs)(e.h2,{id:"111-v-for基本用法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#111-v-for基本用法",children:"#"}),"11.1 v-for基本用法"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"作用：用于展示列表数据"}),"\n",(0,s.jsxs)(e.li,{children:["语法：",(0,s.jsx)(e.code,{children:'v-for="(item, index) in xxx" :key="yyy"'})]}),"\n",(0,s.jsx)(e.li,{children:"可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"112-key内部原理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#112-key内部原理",children:"#"}),"11.2 key内部原理"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"面试题：react、vue中key有什么作用（key的内部原理）？"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"虚拟DOM中key的作用"}),"\n",(0,s.jsx)(e.p,{children:"key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较。==比较规则==如下："}),"\n",(0,s.jsx)(e.p,{children:"（1）旧虚拟DOM中找到了与新虚拟DOM相同的key："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:"       1) 如果虚拟DOM内容没变，直接使用之前的真实DOM；\r\n       2) 如果虚拟DOM内容发生改变，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\n"})}),"\n",(0,s.jsx)(e.p,{children:"（2）旧虚拟DOM中未找到与新虚拟DOM相同的key："}),"\n",(0,s.jsx)(e.p,{children:"​		直接创建新的真实DOM，随后渲染到页面。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"用index作为key可能会引发的问题"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"对数据进行逆序添加、逆序删除等破坏顺序操作："}),"\n",(0,s.jsx)(e.p,{children:"会产生没必要的真实DOM更新 ===> 界面没有问题，但是效率低"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"如果结构中还包含输入类DOM："}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"会产生错误DOM更新 ===> 界面有问题"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"例子如下："}),"\n",(0,s.jsx)(e.p,{children:"在原有list的第一个对象之前插入一个新的数据，观察页面变化。"}),"\n",(0,s.jsx)(e.p,{children:"$/textcolor{red}{错误示范：遍历时使用index作为key}$"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220701135706927",src:a})}),"\n",(0,s.jsx)(e.p,{children:"$/textcolor{green}{正确例子：遍历时使用list中对象的唯一标识作为key}$"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220701135720579",src:o})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"并发中如何选择key？"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"最好使用每条数据的唯一标识作为key"}),"\n",(0,s.jsx)(e.li,{children:"如果不存在数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用来展示，使用index作为key是没有问题的。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"113-列表过滤",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#113-列表过滤",children:"#"}),"11.3 列表过滤"]}),"\n",(0,s.jsx)(e.p,{children:"需求：按照输入框输入的名字，过滤掉不匹配的对象。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用watch实现"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"	<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <script src=\"../js/vue.js\"><\/script>\r\n    <title>列表过滤</title>\r\n</head>\r\n<body>\r\n    <div id=\"root\">\r\n        <h2>人员列表</h2>\r\n        <input type=\"text\" placeholder=\"请输入名字\" v-model=\"name\">\r\n        <ul>\r\n            <li v-for=\"p in personArr\" :key=\"p.id\">\r\n                {{p.name}} -- {{p.age}} -- {{p.sex}}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n<script text=\"text/javascript\">\r\n    const vm = new Vue({\r\n        el: '#root',\r\n        data() {\r\n            return {\r\n                name: '',\r\n                persons: [\r\n                    {id: '001', name: '马冬梅', age: 18, sex: '女'},\r\n                    {id: '002', name: '周冬雨', age: 19, sex: '女'},\r\n                    {id: '003', name: '周杰伦', age: 20, sex: '男'},\r\n                    {id: '004', name: '温兆伦', age: 21, sex: '男'}\r\n                ],\r\n                personArr: []\r\n            }\r\n        },\r\n        watch: {\r\n            name: {\r\n                immediate: true,\r\n                handler(val) {\r\n                    this.personArr = this.persons.filter(item => {\r\n                        return item.name.indexOf(val) !== -1\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    })\r\n<\/script>\r\n</html>\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用computed实现"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <script src=\"../js/vue.js\"><\/script>\r\n    <title>列表过滤</title>\r\n</head>\r\n<body>\r\n    <div id=\"root\">\r\n        <h2>人员列表</h2>\r\n        <input type=\"text\" placeholder=\"请输入名字\" v-model=\"name\">\r\n        <ul>\r\n            <li v-for=\"p in personArr\" :key=\"p.id\">\r\n                {{p.name}} -- {{p.age}} -- {{p.sex}}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n<script text=\"text/javascript\">\r\n    const vm = new Vue({\r\n        el: '#root',\r\n        data() {\r\n            return {\r\n                name: '',\r\n                persons: [\r\n                    {id: '001', name: '马冬梅', age: 18, sex: '女'},\r\n                    {id: '002', name: '周冬雨', age: 19, sex: '女'},\r\n                    {id: '003', name: '周杰伦', age: 20, sex: '男'},\r\n                    {id: '004', name: '温兆伦', age: 21, sex: '男'}\r\n                ],\r\n            }\r\n        },\r\n        computed: {\r\n            personArr() {\r\n                return this.persons.filter(item => {\r\n                    return item.name.indexOf(this.name) !== -1\r\n                })\r\n            }\r\n        }\r\n    })\r\n<\/script>\r\n</html>\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"小结"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["观察以上代码，使用",(0,s.jsx)(e.code,{children:"computed"}),"实现比",(0,s.jsx)(e.code,{children:"watch"}),"更简单，所以一般来说，",(0,s.jsx)(e.code,{children:"computed"}),"和",(0,s.jsx)(e.code,{children:"watch"}),"都能实现的，优先使用",(0,s.jsx)(e.code,{children:"computed"}),"."]}),"\n",(0,s.jsxs)(e.h2,{id:"114-列表排序",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#114-列表排序",children:"#"}),"11.4 列表排序"]}),"\n",(0,s.jsx)(e.p,{children:"需求：对列表中对象的年龄进行排序。"}),"\n",(0,s.jsxs)(e.p,{children:["主要考察数组的",(0,s.jsx)(e.code,{children:"sort()"}),"方法。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"arr.sort简介："}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"$\\textcolor{Red}{arr.sort之后会改变原数组}$"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"升序：arr.sort((a,b) => {return a-b})"}),"\n",(0,s.jsx)(e.li,{children:"降序：arr.sort((a,b) => {return b-a})"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<!DOCTYPE html>\r\n<html lang="en">\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <script src="../js/vue.js"><\/script>\r\n    <title>列表排序</title>\r\n</head>\r\n<body>\r\n    <div id="root">\r\n        <h2>人员列表</h2>\r\n        <input type="text" placeholder="请输入名字" v-model="name">\r\n        <button @click="sortType=2">年龄升序</button>\r\n        <button @click="sortType=1">年龄降序</button>\r\n        <button @click="sortType=0">原顺序</button>\r\n        <ul>\r\n            <li v-for="p in personArr" :key="p.id">\r\n                {{p.name}} -- {{p.age}} -- {{p.sex}}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n<script text="text/javascript">\r\n    const vm = new Vue({\r\n        el: \'#root\',\r\n        data() {\r\n            return {\r\n                name: \'\',\r\n                persons: [\r\n                    {id: \'001\', name: \'马冬梅\', age: 18, sex: \'女\'},\r\n                    {id: \'002\', name: \'周冬雨\', age: 17, sex: \'女\'},\r\n                    {id: \'003\', name: \'周杰伦\', age: 40, sex: \'男\'},\r\n                    {id: \'004\', name: \'温兆伦\', age: 21, sex: \'男\'}\r\n                ],\r\n                sortType: 0\r\n            }\r\n        },\r\n        computed: {\r\n            personArr() {\r\n                const arr = this.persons.filter(item => {\r\n                    return item.name.indexOf(this.name) !== -1\r\n                })\r\n                \r\n                /**\r\n                 * arr.sort简介：\r\n                 * 升序：arr.sort((a,b) => {return a-b})\r\n                 * 降序：arr.sort((a,b) => {return b-a})\r\n                 * arr.sort之后会改变原数组\r\n                 * */\r\n                if(this.sortType) {\r\n                    arr.sort((p1,p2) => {\r\n                        return this.sortType == 1?p2.age-p1.age:p1.age-p2.age;\r\n                    });\r\n                }\r\n\r\n                return arr;\r\n            }\r\n        }\r\n    })\r\n<\/script>\r\n</html>\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"115-vue数据监测原理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#115-vue数据监测原理",children:"#"}),"11.5 Vue数据监测原理"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Vue监测数据的原理"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vue会监测data所有层次的数据"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vue监测对象中的数据"}),"\n",(0,s.jsx)(e.p,{children:"$\\textcolor{Red}{通过setter实现监视，需要在创建Vue实例时就传入要监测的数据。}$"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"对象中后追加的属性，Vue默认不做响应式处理"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"如需为后添加的属性做响应式，可以使用Vue.set() API，如："}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"Vue.set(target, propertyName/index, value)"}),"或",(0,s.jsx)(e.code,{children:"vm.$set(target, propertyName/index, value)"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vue监测数组中的数据"}),"\n",(0,s.jsx)(e.p,{children:"$\\textcolor{Red}{通过包裹数组更新元素的方法实现，本质就是做了两件事：}$"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"调用原生对应的方法对数组进行更新"}),"\n",(0,s.jsx)(e.li,{children:"重新解析模板，进而更新页面"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"在Vue中修改数组中的某个元素，一定要使用如下方法："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["使用Vue封装的API：",(0,s.jsx)(e.code,{children:"push()"}),", ",(0,s.jsx)(e.code,{children:"pop()"}),", ",(0,s.jsx)(e.code,{children:"shift()"}),", ",(0,s.jsx)(e.code,{children:"unshift()"}),", ",(0,s.jsx)(e.code,{children:"splice()"}),", ",(0,s.jsx)(e.code,{children:"sort()"}),", ",(0,s.jsx)(e.code,{children:"reverse()"})]}),"\n",(0,s.jsxs)(e.li,{children:["或者使用",(0,s.jsx)(e.code,{children:"Vue.set()"}),"或",(0,s.jsx)(e.code,{children:"vm.$set()"})]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["$\\textcolor{Red}{特别注意：}$",(0,s.jsx)(e.code,{children:"Vue.set()"}),"或",(0,s.jsx)(e.code,{children:"vm.$set()"}),"不能给vm或者vm的根数据对象添加属性"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"12收集表单数据",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12收集表单数据",children:"#"}),"12.收集表单数据"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:'<input type="text"/>'}),"： v-model收集的是",(0,s.jsx)(e.code,{children:"value"}),"值，用户输入的就是",(0,s.jsx)(e.code,{children:"value"}),"值"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:'<input type="radio"/>'}),"：v-model收集的就是",(0,s.jsx)(e.code,{children:"value"}),"值，且要给标签配置",(0,s.jsx)(e.code,{children:"value"}),"值"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:'<input type="checkbox"/>:'}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["没有配置",(0,s.jsx)(e.code,{children:"value"}),"属性，收集的就是checked状态，选中则为",(0,s.jsx)(e.code,{children:"true"}),", 未选中则是",(0,s.jsx)(e.code,{children:"false"})]}),"\n",(0,s.jsxs)(e.li,{children:["配置了",(0,s.jsx)(e.code,{children:"value"}),"属性：","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["==v-model的初始值不是数组==，收集的就是checked状态，选中则为",(0,s.jsx)(e.code,{children:"true"}),", 未选中则是",(0,s.jsx)(e.code,{children:"false"})]}),"\n",(0,s.jsx)(e.li,{children:"==v-model的初始值是数组==，收集的就是value值组成的数组"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"v-model三个修饰符"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"lazy"}),"：失去焦点再收集数据"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"number"}),"：输入字符串转为有效的数字"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"trim"}),"：去掉首尾空格"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"13过滤器",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13过滤器",children:"#"}),"13.过滤器"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"对要显示的数据进行特定的格式化后再显示（适用于一些简单逻辑的处理，复杂的可以使用计算属性或者方法）"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"注册过滤器：Vue.filter(name, callback) （全局注册）或 new Vue{filters:{}}（局部注册）"}),"\n",(0,s.jsx)(e.li,{children:'使用过滤器：{{xxx | 过滤器名}} 或 v-bind:属性="xxx | 过滤器名"， $\\textcolor{Red}{v-model不能使用过滤器。}$'}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"备注"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"过滤器也可以接收额外参数，第一个参数默认为要过滤的数据，可以不用写"}),"\n",(0,s.jsx)(e.li,{children:"多个过滤器可以串联。第一个过滤器默认参数为要过滤的数据，第二个过滤器默认参数为第一个过滤器的返回值"}),"\n",(0,s.jsx)(e.li,{children:"过滤器并没有改变原本的数据，而是产生了新的数据"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"例子"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<!DOCTYPE html>\r\n<html lang="en">\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <script src="../js/vue.js"><\/script>\r\n    <script src="../js/dayjs.min.js"><\/script>\r\n    <title>过滤器</title>\r\n</head>\r\n<body>\r\n    <div id="root">\r\n        \x3c!-- 无参过滤器 --\x3e\r\n        <h2>当前时间为：{{time | timeFormatter}}</h2>\r\n        \x3c!-- 有参过滤器 + 过滤器串联 --\x3e\r\n        <h2>当前日期为：{{time | timeFormatter(\'YYYY年MM月DD日\') | mySlice}}</h2>\r\n    </div>\r\n</body>\r\n<script type="text/javascript">\r\n    const vm = new Vue({\r\n        el: \'#root\',\r\n        data: {\r\n            time: 1658385392873\r\n        },\r\n        filters: {\r\n            timeFormatter(value, str=\'YYYY-MM-DD HH:mm:ss\') {\r\n                return dayjs(value).format(str)\r\n            },\r\n            mySlice(value) {\r\n                return value.slice(0, 11)\r\n            }\r\n        }\r\n    })\r\n<\/script>\r\n</html>\n'})}),"\n",(0,s.jsxs)(e.h1,{id:"14内置指令",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#14内置指令",children:"#"}),"14.内置指令"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-bind"}),"：单项绑定解析表达式，了简写为",(0,s.jsx)(e.code,{children:":xxx"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-model"}),"：双向数据绑定"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-for"}),"：遍历数组、对象、字符串"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-on"}),"：绑定监听时间，可以简写为",(0,s.jsx)(e.code,{children:"@"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-if"}),"： 条件渲染（动态控制节点是否存在）"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-else"}),"：条件渲染（动态控制节点是否存在）"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-show"}),"：条件渲染（动态控制节点是否展示）"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-text"}),"：向其所在的结点中渲染文本内容（$\\textcolor{Red}{若文本中有标签，不会解析标签}$）。与插值语法的区别：",(0,s.jsx)(e.code,{children:"v-text"}),"会替换掉节点中的内容"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-html"}),"：向其所在的结点中渲染$\\textcolor{Red}{包含html结构的}$内容。与插值语法的区别：",(0,s.jsx)(e.code,{children:"v-html"}),"会替换掉节点中的内容，识别html标签。"]}),"\n",(0,s.jsx)(e.p,{children:"$\\textcolor{Red}{！！！v-html有安全问题：}$"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"在网站上动态渲染任意HTML都是非常危险的，容易导致XSS攻击（如利用户cookie，冒充用户登录网站）。"}),"\n",(0,s.jsxs)(e.li,{children:["一定要在可信的内容上使用",(0,s.jsx)(e.code,{children:"v-html"}),"， 永远不要用在用户提交的内容上。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-cloak"}),"：没有值。"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["特殊指令，Vue实例创建完毕并接管容器后，会删掉",(0,s.jsx)(e.code,{children:"v-cloak"}),"属性"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["使用css配合",(0,s.jsx)(e.code,{children:"v-cloak"}),'可以解决网速慢时导致页面展示出"{{xxx}}"的问题']}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用举例："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<h2 v-cloak>{{name}}</h2>\r\n\r\n<style>\r\n    /**属性选择器*/\r\n    [v-cloak] {\r\n        display: none;\r\n    }\r\n</style>\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-once"}),"："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-once"}),"所在节点在初次动态渲染后，就视为静态内容了。以后数据的改变不会引起",(0,s.jsx)(e.code,{children:"v-once"}),"所在结构的更新，可以用于优化性能。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["区分事件的修饰符",(0,s.jsx)(e.code,{children:"once"}),":",(0,s.jsx)(e.code,{children:"<button @click.once>点我提示信息</button>"}),",此处的",(0,s.jsx)(e.code,{children:"button"}),"只能点击一次"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用举例："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<h2 v-once>n的初始值是： {{n}}</h2>\r\n<h2>n的当前值是： {{n}}</h2>\r\n<button @click="n++">点我n+1</button>\r\n\r\n\x3c!-- 结果：点击button时，第一个<h2>中的内容不会改变，第二个会进行+1操作 --\x3e\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"v-pre"}),"："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"作用：跳过其所在节点的编译过程"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"用途：可以用它跳过没有使用指令语法、没有使用插值语法的节点，会加快编译"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用举例："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<h2 v-pre>Vue so easy！</h2>\r\n<h2 v-pre>n的当前值是： {{n}}</h2>\r\n\r\n\x3c!-- 结果：页面不会解析插值语法 --\x3e\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"15自定义指令",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#15自定义指令",children:"#"}),"15.自定义指令"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义语法"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"局部指令"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"定义函数的方式（简写）"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"new Vue ({directives: {指令名: 回调函数}})\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"定义对象的方式（完整写法）"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"new Vue ({directives: {指令名: 配置对象})\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"全局指令："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"定义函数的方式（简写）"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"Vue.directive(指令名, 回调函数)\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"定义对象的方式（完整写法）"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"Vue.directive(指令名, 配置对象)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"配置对象中常用的3个回调"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"bind"}),"：指令与元素绑定成功时调用"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"inserted"}),"：指令所在元素插入页面时调用"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"update"}),"：指令所在模板结构被重新渲染时调用"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"函数式定义的指令被调用时机"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"指令与元素成功绑定时（一上来）就会被调用"}),"\n",(0,s.jsx)(e.li,{children:"指令所在模板被重新解析时会再次被调用"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"备注"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["指令定义时不加",(0,s.jsx)(e.code,{children:"v-"}),"， 但在使用时需要加",(0,s.jsx)(e.code,{children:"v-"})]}),"\n",(0,s.jsx)(e.li,{children:"指令名如果是多个单词，需要使用$\\textcolor{Red}{短横线命名法}$，不要使用驼峰命名"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"例子"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'<!DOCTYPE html>\r\n<html lang="en">\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <title>自定义指令</title>\r\n    <script src="../js/vue.js"><\/script>\r\n</head>\r\n<body>\r\n    <div id="root">\r\n        \x3c!-- 需求1：自定义v-big，将绑定的值放大10倍 --\x3e\r\n        <h2>{{name}}</h2>\r\n        <h2>当前的n值是：<span v-text="n"></span></h2>\r\n        <h2>放大10倍后的n值是：<span v-big="n"></span></h2>\r\n        <button @click="n++">点我n+1</button>\r\n        <hr>\r\n        \x3c!-- 需求2：自定义v-fbind，实现与v-bind相同效果，但可以让其绑定的input元素默认获取焦点 --\x3e\r\n        <input type="text" v-fbind="n">\r\n    </div>\r\n</body>\r\n\r\n<script type="text/javascript">\r\n    // 定义全局指令\r\n    Vue.directive(\'big2\', function(element, binding) {\r\n        console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n        element.innerText = binding.value * 10\r\n    })\r\n\r\n    Vue.directive(\'fbind2\', {\r\n        // 指令与元素成功绑定时（一上来）就会被调用\r\n        bind(element, binding) {\r\n            console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n            element.value = binding.value\r\n        },\r\n        // 指令所在元素被插入页面时被调用\r\n        inserted(element, binding) {\r\n            console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n            // 获取焦点\r\n            element.focus()\r\n        },\r\n        // 指令所在模板被重新解析时被调用\r\n        update(element, binding) {\r\n            console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n            element.value = binding.value\r\n        }\r\n    })\r\n\r\n    new Vue({\r\n        el: \'#root\',\r\n        data: {\r\n            name: \'tth\',\r\n            n: 1\r\n        },\r\n        directives: {\r\n            /**\r\n             * 创建指令有两种写法，一个是定义函数的方式（简写），一个是定义对象的方式（完整写法）\r\n             * 定义函数的写法，其实就是定义对象方式中的bind()和update()方法的结合\r\n            */\r\n            /**\r\n             * big函数调用时间：\r\n             *  1.指令与元素成功绑定时（一上来）就会被调用\r\n             *  2.指令所在模板被重新解析时会再次被调用\r\n            */\r\n            /**\r\n             * 将数值放大10倍\r\n             * @param element 真实的DOM元素 \r\n             *         如： <span>10</span>\r\n             * @param binding 指令对象\r\n             *         如： {\r\n             *              "name": "big",  // 指令名称\r\n             *              "rawName": "v-big", // 使用时的指令名称\r\n             *              "value": 1,  // v-big绑定的值\r\n             *              "expression": "n", // v-big绑定的表达式\r\n             *              "modifiers": {},\r\n             *              "def": {}\r\n             *          }\r\n             * \r\n             */\r\n            big(element, binding) {\r\n                console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n                element.innerText = binding.value * 10\r\n            },\r\n            fbind: {\r\n                // 指令与元素成功绑定时（一上来）就会被调用\r\n                bind(element, binding) {\r\n                    console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n                    element.value = binding.value\r\n                },\r\n                // 指令所在元素被插入页面时被调用\r\n                inserted(element, binding) {\r\n                    console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n                    // 获取焦点\r\n                    element.focus()\r\n                },\r\n                // 指令所在模板被重新解析时被调用\r\n                update(element, binding) {\r\n                    console.log(\'big\', this) // 此处的this不是Vue实例，而是Window\r\n                    element.value = binding.value\r\n                }\r\n            }\r\n        }\r\n    })\r\n<\/script>\r\n</html>\n'})}),"\n",(0,s.jsxs)(e.h1,{id:"16生命周期",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#16生命周期",children:"#"}),"16.生命周期"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"又名：生命周期函数、声明周期回调函数、生命周期钩子"}),"\n",(0,s.jsx)(e.li,{children:"是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数"}),"\n",(0,s.jsx)(e.li,{children:"生命周期函数的名字不可更改，但函数的具体内容由程序员根据需求编写"}),"\n",(0,s.jsx)(e.li,{children:"声明周期函数中的this指向的是Vue实例或组件实例"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"图示"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"备注："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["常用的生命周期钩子","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"mounted"}),"：发送ajax请求、启动定时器、绑定自定义时间、订阅消息等【初始化操作】"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"beforeDestory"}),"：清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["关于销毁Vue实例：","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"销毁后，借助Vue开发者工具看不到任何信息"}),"\n",(0,s.jsx)(e.li,{children:"销毁后自定义事件失效，但原生DOM事件依然有效"}),"\n",(0,s.jsxs)(e.li,{children:["一般不会在",(0,s.jsx)(e.code,{children:"beforeDeatory"}),"中操作数据。因为即使操作数据，也不会再触发更新流程"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["页面中调用了一个定时器，如果在",(0,s.jsx)(e.code,{children:"beforeDestory"}),"或者其他地方没有清除，当执行",(0,s.jsx)(e.code,{children:"vm.$destory()"}),"后，定时器仍然一直在执行"]}),"\n",(0,s.jsx)(e.li,{children:"下图中还有==3个声明周期钩子==未提现，后边学习路由的时候再提出"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220722152810676",src:x})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.h1,{id:"附零零散散小知识",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#附零零散散小知识",children:"#"}),"附：零零散散小知识"]}),"\n",(0,s.jsxs)(e.h2,{id:"1vue模板解析时间",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1vue模板解析时间",children:"#"}),"1)Vue模板解析时间"]}),"\n",(0,s.jsx)(e.p,{children:"每当Vue中data的值发生变化时，Vue的模板都会重新解释一遍。且当使用插值语法插入一个函数时，该函数会被重新执行。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:'\x3c!-- 每当data.familyName或者data.firstName修改时，fullName()方法都会被重新调用--\x3e\r\n<div id="root">\r\n    姓：<input type = "text" v-model="familyName"> <br>\r\n    名：<input type = "text" v-model="firstName"> <br>\r\n    全名：<span>{{fullName}}</span>\r\n</div>\r\n\r\n<script text="text/javascript">\r\n	new Vue({\r\n        el: \'#root\',\r\n        data: {\r\n           familyName: \'张\',\r\n           firstName: \'三\'\r\n        },\r\n        methods: {\r\n            fullName() {\r\n                console.log(\'fullName============\')\r\n                return this.familyName + \'-\' + this.firstName\r\n            }\r\n        }\r\n    })\r\n<\/script>\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"2js第三方库",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2js第三方库",children:"#"}),"2)js第三方库"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.bootcdn.cn/",rel:"noopener noreferrer",target:"_blank",children:"BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务"})})]})}function u(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(j,n)})):j(n)}let p=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["tang%2FVue%2F1.md"]={toc:[{id:"51-objectdefineproperty方法",text:"5.1 Object.defineproperty方法",depth:2},{id:"52-数据代理",text:"5.2 数据代理",depth:2},{id:"53--vue中的数据代理",text:"5.3  Vue中的数据代理",depth:2},{id:"61-事件的基本使用",text:"6.1 事件的基本使用",depth:2},{id:"62-事件修饰符",text:"6.2 事件修饰符",depth:2},{id:"63-按键修饰符",text:"6.3 按键修饰符",depth:2},{id:"81-基础监视",text:"8.1 基础监视",depth:2},{id:"82-深度监视",text:"8.2 深度监视",depth:2},{id:"83-监视属性和计算属性的对比",text:"8.3 监视属性和计算属性的对比",depth:2},{id:"91-绑定class样式",text:"9.1 绑定class样式",depth:2},{id:"92-绑定style样式",text:"9.2 绑定style样式",depth:2},{id:"111-v-for基本用法",text:"11.1 v-for基本用法",depth:2},{id:"112-key内部原理",text:"11.2 key内部原理",depth:2},{id:"113-列表过滤",text:"11.3 列表过滤",depth:2},{id:"114-列表排序",text:"11.4 列表排序",depth:2},{id:"115-vue数据监测原理",text:"11.5 Vue数据监测原理",depth:2},{id:"1vue模板解析时间",text:"1)Vue模板解析时间",depth:2},{id:"2js第三方库",text:"2)js第三方库",depth:2}],title:"Vue基础知识",headingTitle:"Vue基础知识",frontmatter:{}}}}]);