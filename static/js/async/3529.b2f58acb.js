"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["3529"],{98562:function(e,n,r){r.r(n),r.d(n,{default:function(){return i}});var a=r(85893),t=r(50065);function s(e){let n=Object.assign({h1:"h1",a:"a",h3:"h3",p:"p",pre:"pre",code:"code"},(0,t.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"设计模式",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计模式",children:"#"}),"设计模式"]}),"\n",(0,a.jsxs)(n.h3,{id:"单例模式",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单例模式",children:"#"}),"单例模式"]}),"\n",(0,a.jsx)(n.p,{children:"一个类只有一个实例，并提供一个访问他的全局访问接口。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",meta:"",children:"class Singleton {\r\n    constructor(){\r\n        this._instance = null    \r\n    }\r\n    static getInstance(){\r\n        if (this._instance){\r\n            return this._instance\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"工厂模式",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工厂模式",children:"#"}),"工厂模式"]}),"\n",(0,a.jsx)(n.p,{children:"根据不同的参数，返回不同类的实例。\r\n核心思想：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。"}),"\n",(0,a.jsx)(n.p,{children:"例子： js 中的 document.createElement() 方法；Vue 和 React中的createElement() 方法"}),"\n",(0,a.jsxs)(n.h3,{id:"策略模式",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#策略模式",children:"#"}),"策略模式"]}),"\n",(0,a.jsx)(n.p,{children:"利用对象或Map来简化if-else和switch"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",meta:"",children:"function switchFn (type) {\r\n    switch (type){\r\n        case 1: \r\n            // ...\r\n            break;\r\n        case 2:\r\n            //\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n/**\r\n * 改写\r\n */\r\nclass KeyToFn {\r\n    static __keyFn = {}\r\n    static add(key, fn) {\r\n        if(!KeyToFn.__keyFn[key]){\r\n            KeyToFn.__keyFn[key] = fn\r\n        }else {\r\n            throw new Error('已经包含该键名对应的方法，如果想继续更改，请使用update方法')\r\n        }\r\n    }\r\n    static update(key, fn) {\r\n        if(KeyToFn.__keyFn[key]){\r\n            KeyToFn.__keyFn[key] = fn\r\n        }else {\r\n            throw new Error('不包含该键名对应的方法，如果想继续添加，请使用add方法')\r\n        }\r\n    }\r\n    static delete(key){\r\n        if(KeyToFn.__keyFn[key]){\r\n            Reflect.deleteProperty(KeyToFn.__keyFn, key)\r\n        }else {\r\n            throw new Error('对象中不包含该键值对')\r\n        }\r\n    }\r\n    static exeFn (key, ...option){\r\n        KeyToFn.__keyFn[key] && KeyToFn.__keyFn[key](...option)\r\n    }\r\n}\r\nKeyToFn.add('1', (a) => {\r\n    console.log(a)\r\n})\r\nKeyToFn.add('2', (a, b) => {\r\n    console.log(a + b)\r\n})\r\n\r\nKeyToFn.exeFn('1', 'abc')\r\nKeyToFn.exeFn('2', 'abc', 'def')\n"})}),"\n",(0,a.jsx)(n.h3,{id:"",children:(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(s,e)})):s(e)}let i=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["JavaScript%2Fdesign%2Fpart4.md"]={toc:[{id:"单例模式",text:"单例模式",depth:3},{id:"工厂模式",text:"工厂模式",depth:3},{id:"策略模式",text:"策略模式",depth:3},{id:"",text:"",depth:3}],title:"设计模式",headingTitle:"设计模式",frontmatter:{}}}}]);