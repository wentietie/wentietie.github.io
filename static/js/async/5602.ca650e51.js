"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["5602"],{55914:function(n,r,i){i.r(r),i.d(r,{default:()=>a});var s=i("85893"),e=i("50065");let l=i.p+"static/image/06_img3.4a3b4400.png",c=i.p+"static/image/06_img1.9de068fb.png",d=i.p+"static/image/06_img2.126557b7.png";function h(n){let r=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",pre:"pre",img:"img",strong:"strong"},(0,e.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"6-面向对象编程下",children:["6 面向对象编程（下）",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#6-面向对象编程下",children:"#"})]}),"\n",(0,s.jsxs)(r.h2,{id:"61-关键字static",children:["6.1 关键字static",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#61-关键字static",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"static修饰属性：静态变量"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"属性，按是否使用static修饰，又分为："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"静态属性 （类变量）：我们创建了类的多个对象，多个对象共享同一个静态变量。当对某一个对象修改静态变量时，会导致当其他对象调用该属性时，获得的是被修改过之后的值。"}),"\n",(0,s.jsx)(r.li,{children:"非静态属性（实例变量）：我们创建了类的多个对象，每一个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会对其他对象的同一个属性值修改。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"static修饰属性的其他说明："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["静态变量随着类的加载而加载，可以通过",(0,s.jsx)(r.code,{children:"类.静态变量"}),"的方式使用。"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["静态变量的加载","早于","对象的创建。"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["由于类只会加载一次，所以静态变量在内存中野只会存在一份，存在于","方法区的静态域","中。"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"调用方法"}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{}),"\n",(0,s.jsx)(r.th,{children:"类变量（静态属性）"}),"\n",(0,s.jsx)(r.th,{children:"实例变量（非静态属性）"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"类"}),"\n",(0,s.jsx)(r.td,{children:"✔"}),"\n",(0,s.jsx)(r.td,{children:"✘"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"对象"}),"\n",(0,s.jsx)(r.td,{children:"✔"}),"\n",(0,s.jsx)(r.td,{children:"✔"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"static修饰方法（静态方法）"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["随着类的加载而加载，可以通过",(0,s.jsx)(r.code,{children:"类.静态方法(形参列表)"}),"的方式调用"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"调用方法"}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{}),"\n",(0,s.jsx)(r.th,{children:"静态方法"}),"\n",(0,s.jsx)(r.th,{children:"非静态方法"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"类"}),"\n",(0,s.jsx)(r.td,{children:"✔"}),"\n",(0,s.jsx)(r.td,{children:"✘"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"对象"}),"\n",(0,s.jsx)(r.td,{children:"✔"}),"\n",(0,s.jsx)(r.td,{children:"✔"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["静态方法","不可以","调用非静态方法或属性；非静态方法中，既可以调用静态方法或属性又可以调用非静态方法或属性"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"static注意点"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"静态方法中，不能使用this和super关键字"}),"\n",(0,s.jsx)(r.li,{children:"关于静态属性和静态方法的使用，可以从声明周期的角度去理解"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"static使用场景"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"static属性：当属性可以被多个对象所共享，不会随着对象的不同而不同"}),"\n",(0,s.jsxs)(r.li,{children:["static方法：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"操作静态属性的方法，通常被设置为static的"}),"\n",(0,s.jsx)(r.li,{children:"工具类的方法，习惯上声明为static的。如Math、Arrays、Collections等工具类中的方法"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"62-static应用之单例设计模式",children:["6.2 static应用之单例设计模式",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#62-static应用之单例设计模式",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"设计模型"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"定义：在大量的实践中总结和理论化之后优选的代码结构、编程风格，以及解决问题的思考方式。"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"设计模式分类（共23个）"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"创造型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式"}),"\n",(0,s.jsx)(r.li,{children:"结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式"}),"\n",(0,s.jsx)(r.li,{children:"行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"单例模式"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"定义：采取一定的方法，保证在整个软件系统中，某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"实现思路："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"将类的构造器的访问权限设置为private"}),"\n",(0,s.jsxs)(r.li,{children:["在该类中声明一个静态方法，用以返回类内部创建的对象","（原因：构造器私有，外部无法获取对象实例，但类内部可以产生对象实例，所以只能声明一个公有的静态方法以返回类内部创建的对象）"]}),"\n",(0,s.jsxs)(r.li,{children:["该类的变量也必须是静态的","（原因：静态方法只能访问类的静态成员变量）"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"实现方式"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"饿汉式"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"package com.tth.learn.basic.grammer.Singleton;\r\n\r\n/**\r\n * 单例模式的饿汉式实现\r\n * @Author tth\r\n * @Date 2022/10/20 10:25\r\n */\r\npublic class Singleton1 {\r\n\r\n    public static void main(String[] args) {\r\n        Bank bank1 = Bank.getInstance();\r\n        Bank bank2 = Bank.getInstance();\r\n        System.out.println(bank1 == bank2); // 返回true\r\n    }\r\n}\r\n\r\nclass Bank {\r\n    // 1.私有化构造器\r\n    private Bank() {}\r\n\r\n    // 2.内部创建类对象，并声明为静态的\r\n    private static Bank instance = new Bank();\r\n\r\n    // 3.创建静态公共方法，返回对象实例\r\n    public static Bank getInstance() {\r\n        return instance;\r\n    }\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"懒汉式"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"package com.tth.learn.basic.grammer.Singleton;\r\n\r\n/**\r\n * 单例模式的懒汉式实现\r\n * @Author tth\r\n * @Date 2022/10/20 10:30\r\n */\r\npublic class Singleton2 {\r\n    public static void main(String[] args) {\r\n        Order order1 = Order.getInstance();\r\n        Order order2 = Order.getInstance();\r\n        System.out.println(order1 == order2); //返回true\r\n    }\r\n}\r\n\r\nclass Order {\r\n\r\n    // 1.私有化构造器\r\n    private Order() {}\r\n\r\n    // 2.声明静态的当前类的对象，没有初始化\r\n    private static Order instance = null;\r\n\r\n    // 3.创建静态公共方法，返回对象实例\r\n    public static Order getInstance() {\r\n        if (null == instance) {\r\n            instance = new Order();\r\n        }\r\n        return instance;\r\n    }\r\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"区分饿汉式和懒汉式"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["饿汉式：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"好处：天生线程安全"}),"\n",(0,s.jsx)(r.li,{children:"坏处：对象加载时间过长"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["懒汉式：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"好处：延迟对象的创建"}),"\n",(0,s.jsx)(r.li,{children:"坏处：以上写法是线程不安全的（到多线程内容的时候，再修改）"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"单例模式的优点"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"减少内存的开销"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"单例模式举例"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"java.lang.Runtime（饿汉式）"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"单例模式应用场景"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"网站的计数器"}),"\n",(0,s.jsx)(r.li,{children:"应用程序的日志应用"}),"\n",(0,s.jsx)(r.li,{children:"数据库连接池"}),"\n",(0,s.jsx)(r.li,{children:"读取配置文件的类"}),"\n",(0,s.jsx)(r.li,{children:"Application"}),"\n",(0,s.jsx)(r.li,{children:"Windows的Task Manager（任务管理器）"}),"\n",(0,s.jsx)(r.li,{children:"Windows的Recycle Bin（回收站）"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"63-理解main方法的语法",children:["6.3 理解main方法的语法",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#63-理解main方法的语法",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"main()方法是程序的入口"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"main()也是一个普通的静态方法"}),"\n",(0,s.jsxs)(r.p,{children:["可以通过",(0,s.jsx)(r.code,{children:"类名.main(参数)"}),"的方式被调用"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"main()可以作为和控制台交互的方式（之前使用的是Scanner）"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"使用idea给main()方法传参"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"编写代码，打印main()方法接收的参数："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"public class Practise {\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < args.length; i++) {\r\n            System.out.println(args[i]);\r\n        }\r\n    }\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"设置参数："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"右键运行，控制台即可输出参数："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"使用cmd给main()方法传参："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"代码如上"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"运行"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"64-类的成员之四代码块",children:["6.4 类的成员之四：代码块",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#64-类的成员之四代码块",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"用来初始化类、对象"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"修饰符"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"代码块只能使用static来修饰"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"分类"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["静态代码块","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"随着类的加载而执行，且只执行一次"}),"\n",(0,s.jsx)(r.li,{children:"作用：初始化类的信息"}),"\n",(0,s.jsx)(r.li,{children:"静态代码块的执行时间先与非静态代码块的执行时间"}),"\n",(0,s.jsx)(r.li,{children:"静态代码块之间的执行顺序是按照代码编写的先后顺序执行"}),"\n",(0,s.jsx)(r.li,{children:"不可以调用非静态结构（属性和方法）"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["非静态代码块","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"随着对象的创建而执行，且没创建一个对象，就会执行一次"}),"\n",(0,s.jsx)(r.li,{children:"作用：可以在创建对象时，对对象的属性等进行初始化"}),"\n",(0,s.jsx)(r.li,{children:"非静态代码块之间的执行顺序是按照代码编写的先后顺序执行"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"属性赋值的顺序"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"默认初始化 -> 显示初始化/代码块-> 构造器中赋值 -> 通过“对象.方法”或“对象.属性”的方式赋值"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"// 此时创建的Order对象的orderId为2\r\nclass Order {\r\n    int orderId = 1;\r\n    {\r\n        orderId = 2;\r\n    }\r\n}\r\n\r\n// 此时代码不报错，创建的Order2对象的orderId为1\r\nclass Order2 {\r\n    {\r\n        orderId = 2;\r\n    }\r\n    int orderId = 1;\r\n}\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"64-关键字final",children:["6.4 关键字final",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#64-关键字final",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"可以用来修饰："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["类：","final修饰的类不能被其他类所继承。","举例：String类、System类、StringBuffer类"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["方法：","final修饰的方法不能被子类重写。","举例：Object.getClass()"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["变量：","final修饰的变量不能被修改，此时的变量成为“常量”。"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"修饰属性：可以赋值的位置有：显示初始化、代码块中初始化、构造器中初始化"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"修饰局部变量："}),"\n",(0,s.jsx)(r.p,{children:"尤其是修饰形参时，表明此形参时一个常量，只能在方法体内使用，不能修改"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"static final修饰属性"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"被称为全局常量"}),"\n",(0,s.jsxs)(r.h2,{id:"65-抽象类与抽象方法",children:["6.5 抽象类与抽象方法",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#65-抽象类与抽象方法",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"关键字abstract的使用"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["可以用来修饰的结构：","类","、","方法"]}),"\n",(0,s.jsx)(r.p,{children:"不能修饰：属性、构造器、私有方法、静态方法、final方法、final类"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"抽象类"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"被abstract修饰的类叫做抽象类。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"抽象类不能实例化"}),"\n",(0,s.jsx)(r.li,{children:"抽象类中一定有构造器，便于子类实例化的时候调用"}),"\n",(0,s.jsx)(r.li,{children:"开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作"}),"\n",(0,s.jsx)(r.li,{children:"包含抽象方法的类，一定是抽象类；反之，抽象类中可以没有抽象方法"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"抽象方法"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"被abstract修饰的方法叫抽象方法。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"public abstract void fun();\n"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"抽象方法只有方法的声明，没有方法体"}),"\n",(0,s.jsx)(r.li,{children:"若子类重写了父类中的所有抽象方法后，此子类方可实例化；若子类没有重写父类中的所有抽象方法，则子类也必须声明为一个抽象类"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"abstract使用注意事项"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"abstract不能用来修饰属性、构造器等结构"}),"\n",(0,s.jsx)(r.li,{children:"abstract不能用来修饰private方法、static方法、final方法、final类"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"抽象类的匿名子类"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n* 定义抽象类Person\r\n*/\r\npublic abstract Person {\r\n    private String name;\r\n    private int age;\r\n    \r\n    public Person() {}\r\n    \r\n    public abstract void fun1();\r\n    \r\n    public abstract void fun2();\r\n    \r\n    public void fun3() {\r\n        System.out.println("hello, fun3");\r\n    }\r\n}\r\n\r\n/**\r\n* 测试类\r\n*/\r\npublic PersonTest {\r\n    public static void main(String[] args) {\r\n        \r\n        // 定义匿名子类\r\n        Person p = new Person() {\r\n            @Override\r\n            public void fun1(){\r\n                 System.out.println("hello, fun1");\r\n            }\r\n    \r\n            @Override\r\n    		public void fun2() {\r\n                 System.out.println("hello, fun2");\r\n            }\r\n        };\r\n        \r\n        // 创建匿名子类的匿名对象\r\n        method(new Person() {\r\n            @Override\r\n            public void fun1(){\r\n                 System.out.println("hello, fun1");\r\n            }\r\n    \r\n            @Override\r\n    		public void fun2() {\r\n                 System.out.println("hello, fun2");\r\n            }\r\n        })\r\n    }\r\n    \r\n    public static void method(Person p) {\r\n        System.out.println("hello, method")\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"66-abstract应用之模板方法设计模式",children:["6.6 abstract应用之模板方法设计模式",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#66-abstract应用之模板方法设计模式",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"解决的问题"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"当功能内部一部分实现是确定的，一部分实现是不确定的。此时可以吧不确定的部分暴露出去，让子类去实现。"}),"\n",(0,s.jsxs)(r.li,{children:["即","在软件开发中实现一个","算法","时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同的子类实现。这就是一种模板模式。"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"应用举例"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"数据库访问的链接"}),"\n",(0,s.jsx)(r.li,{children:"Junit单元测试"}),"\n",(0,s.jsx)(r.li,{children:"JavaWeb的Servlet中doGet、doPost方法"}),"\n",(0,s.jsx)(r.li,{children:"Hibernate中模板程序"}),"\n",(0,s.jsx)(r.li,{children:"Spring中JDBCTemplate、HibernateTemplate等"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"67-接口",children:["6.7 接口",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#67-接口",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"定义接口中的成员"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["JDK7及以前：只能定义全局常量和抽象方法","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"全局常量：public static final修饰的变量。但是public static final可以省略不写"}),"\n",(0,s.jsx)(r.li,{children:"全局方法：public abstract修饰的方法。但是public static可以省略不写"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.li,{children:"JDK8及以后：可以定义全局常量、抽象方法、静态方法、默认方法"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"接口使用注意事项"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["接口中",(0,s.jsx)(r.strong,{children:"不能"}),"定义构造器。","这意味着接口是不可以实例化的。"]}),"\n",(0,s.jsxs)(r.li,{children:["接口通过让类去实现(implements)的方式来使用。","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"如果实现类实现了接口中所有的抽象方法，则此类可以实例化"}),"\n",(0,s.jsx)(r.li,{children:"否则，实现类需要声明为abstract的"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.li,{children:"Java类可以实现多个接口（多个接口之间用“,”隔开）---\x3e弥补了Java单继承的局限性"}),"\n",(0,s.jsxs)(r.li,{children:["当一个Java类既继承类，又实现接口的时候，应该","先写继承后写实现"]}),"\n",(0,s.jsx)(r.li,{children:"接口与接口之间可以继承（extends），且可以多继承"}),"\n",(0,s.jsx)(r.li,{children:"接口的具体使用，提现了多态性"}),"\n",(0,s.jsx)(r.li,{children:"接口，实际上可以看做是一种规范"}),"\n",(0,s.jsxs)(r.li,{children:["接口的主要用途就是被实现类实现，这称为","面向接口编程"]}),"\n",(0,s.jsx)(r.li,{children:"从本质上讲，接口是一种特殊的抽象类。"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"JDK8中接口新特性"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"JDK8以后，接口既可以定义全局常量、抽象方法，也可以定义静态方法、默认方法。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"定义静态方法（public static）：接口中定义的静态方法，只能通过接口来调用"}),"\n",(0,s.jsxs)(r.li,{children:["定义默认方法（public default）：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"可以通过实现类的对象，调用接口中的默认方法"}),"\n",(0,s.jsx)(r.li,{children:"实现类可以重写接口的默认方法"}),"\n",(0,s.jsxs)(r.li,{children:["如果子类（或实现类）继承的父类和实现的接口中，声明了同名、同参的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的方法 ---\x3e ","类优先原则"]}),"\n",(0,s.jsxs)(r.li,{children:["如果实现类实现了多个接口，且这多个接口中定义了同名、同参的默认方法，在实现类没有重写此方法的情况下，编译报错 ---\x3e ","接口冲突","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"如果想解决以上冲突，必须在实现类中重写此方法。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["如何在子类（或实现类）的方法中调用父类、接口中被重写的方法？","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["调用父类中声明的方法：",(0,s.jsx)(r.code,{children:"super.方法"})]}),"\n",(0,s.jsxs)(r.li,{children:["调用接口中默认的方法：",(0,s.jsx)(r.code,{children:"接口名.super.方法"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"68-接口应用之代理模式proxy",children:["6.8 接口应用之代理模式（Proxy）",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#68-接口应用之代理模式proxy",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"代理设计就是为其他对象提供一种代理以控制对这个对象的方法。"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"代码示例"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"以明星和他的小助理为例。明星参加面谈会、签合同、订票、唱歌，都需要通过他的小助理来完成。小助理就是明星的一个代理。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'public class ProxyTest {\r\n    public static void main(String[] args) {\r\n        // 定义代理类对象，实现明星的面谈会、签合同、订票、唱歌功能\r\n        Assistant proxy = new Assistant(new RealStar());\r\n        proxy.confer();\r\n        proxy.signContract();\r\n        proxy.bookTicker();\r\n        proxy.sing();\r\n    }\r\n}\r\n\r\n/**\r\n * 明星接口\r\n */\r\ninterface Star {\r\n    // 面谈会\r\n    void confer();\r\n\r\n    // 签合同\r\n    void signContract();\r\n\r\n    // 订票\r\n    void bookTicker();\r\n\r\n    // 唱歌\r\n    void sing();\r\n}\r\n\r\n/**\r\n * 明星（被代理类）\r\n */\r\nclass RealStar implements Star {\r\n    @Override\r\n    public void confer() {\r\n        System.out.println("RealStar confer");\r\n    }\r\n\r\n    @Override\r\n    public void signContract() {\r\n        System.out.println("RealStar signContract");\r\n    }\r\n\r\n    @Override\r\n    public void bookTicker() {\r\n        System.out.println("RealStar bookTicker");\r\n    }\r\n\r\n    @Override\r\n    public void sing() {\r\n        System.out.println("RealStar sing");\r\n    }\r\n}\r\n\r\n/**\r\n * 明星的助理（代理类）\r\n */\r\nclass Assistant implements Star {\r\n    private RealStar realStar;\r\n\r\n    public Assistant(RealStar realStar) {\r\n        this.realStar = realStar;\r\n    }\r\n\r\n    @Override\r\n    public void confer() {\r\n        System.out.println("小助理组织面谈会");\r\n        // 明星参加面谈会\r\n        this.realStar.confer();\r\n        System.out.println("面谈会结束后，小助理其他工作...");\r\n    }\r\n\r\n    @Override\r\n    public void signContract() {\r\n        System.out.println("小助理检查合同");\r\n        // 明星在合同上签字\r\n        this.realStar.confer();\r\n    }\r\n\r\n    @Override\r\n    public void bookTicker() {\r\n        System.out.println("小助理给明星订票");\r\n    }\r\n\r\n    @Override\r\n    public void sing() {\r\n        // 明星唱歌\r\n        this.realStar.sing();\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"应用场景"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"安全代理：屏蔽对真是角色的直接访问"}),"\n",(0,s.jsx)(r.li,{children:"远程代理：通过代理类处理远程方法调用（RMI）"}),"\n",(0,s.jsx)(r.li,{children:"延迟加载：先加载轻量级的代理对象，真正需要再加载真是对象"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"分类"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"静态代理（静态定义代理对象）"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"动态代理（动态生成代理类）"}),"\n",(0,s.jsx)(r.p,{children:"JDK自带的动态代理，需要反射等知识"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"69-接口应用之工厂模式",children:["6.9 接口应用之工厂模式",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#69-接口应用之工厂模式",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"工厂模式实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到高灵活性的目的。"}),"\n",(0,s.jsx)(r.p,{children:"​			 将选择实现类、创建对象统一管理和控制，从而将调用者和实现类解耦。"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"体现的原则"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"开闭原则（OCP）：软件实体对扩展开放，对修改关闭"}),"\n",(0,s.jsx)(r.li,{children:"依赖倒转原则（DIP）：如果A中关联B，那么尽量使得B实现某个接口，然后A与接口发生关系，不与B实现类发生关联关系"}),"\n",(0,s.jsx)(r.li,{children:"迪米特法则（LOD）：不和陌生人说话，有事去中介"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"分类"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["简单工厂模式（静态工厂模式）","：用来生产同一等级结构中的任意产品"]}),"\n",(0,s.jsx)(r.p,{children:"一个工厂类，根据方法名或者参数，返回不同的产品。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"优点：把调用者和创建者分离，实现了解耦"}),"\n",(0,s.jsx)(r.li,{children:"缺点：对于新增产品，需要修改代码。违反了开闭原则"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["工厂方法模式","：用来生产同一等级结构中的固定产品（支持新增任意产品）"]}),"\n",(0,s.jsx)(r.p,{children:"一个工厂接口，多个不同工厂接口的实现类，根据不同工厂接口的实现类，返回不同的产品。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"缺点：并没有真正的避免代码的改动。当添加新产品时，要么将判断逻辑留在抽象工厂的角色里，要么在客户端将具体工厂类写死。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["抽象工厂模式","：用来生产不同品族的全部产品（对于增加新的产品，无能为力；支持增加产品族）"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"和工厂方法模式的区别：在于需要创建对象的复杂程度上。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"610-类的成员之五内部类",children:["6.10 类的成员之五：内部类",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#610-类的成员之五内部类",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Java中允许将一个类A生命在另一个类B中，则类A就是内部类，类B称为外部类"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"分类"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"成员内部类：分为静态、非静态"}),"\n",(0,s.jsx)(r.li,{children:"局部内部类：可以定义在方法内、代码块内、构造器内"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"成员内部类"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"作用："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["一方面，作为外部类的成员：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["可以调用外部类的属性、方法：",(0,s.jsx)(r.code,{children:"外部类名.this.属性/方法"})]}),"\n",(0,s.jsx)(r.li,{children:"可以被static修饰"}),"\n",(0,s.jsx)(r.li,{children:"可以被4种不同的权限修饰（外部类的权限修饰符只可以用public和缺省2种）"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["另一方面，作为一个类：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"类内可以定义属性、方法、构造器等"}),"\n",(0,s.jsx)(r.li,{children:"可以被final修饰，表示不能被继承（言外之意，不使用final，可以被继承）"}),"\n",(0,s.jsx)(r.li,{children:"可以被abstract修饰，表示不能被实例化"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"注意点："}),"\n",(0,s.jsx)(r.p,{children:"在局部内部类（AA）的方法（show）中，如果调用局部内部类所声明的方法（method）中的局部变量（num），要求此局部变量声明为final(此final在JDK8及之后可省)"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"class Person {\r\n    public void method() {\r\n        // 局部变量\r\n        // JDK7及之前，必须显示声明为final。JDK8之后，final可省\r\n        int num = 10;\r\n        \r\n        class AA {\r\n            public void show() {\r\n                System.out.println(num);\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"实例化成员内部类对象"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["实例化静态成员内部类对象：",(0,s.jsx)(r.code,{children:"外部类.静态内部类 变量名 = new 外部类.静态内部类();"})]}),"\n",(0,s.jsxs)(r.li,{children:["实例化非静态成员内部类对象：先创建外部类对象，再通过",(0,s.jsx)(r.code,{children:"外部类对象实例.new 静态内部类()"})]}),"\n",(0,s.jsx)(r.li,{children:"例子："}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'public class InnerClassTest {\r\n    public static void main(String[] args) {\r\n        // 创建静态成员内部类\r\n        Person.Dog dog = new Person.Dog();\r\n        \r\n        // 创建非静态成员内部类\r\n        Person p = new Person();\r\n        Person.Bird bird = p.new Bird();\r\n        bird.sing();\r\n    }\r\n}\r\n\r\nclass Person {\r\n    String name;\r\n    int age;\r\n    \r\n    // 静态成员内部类\r\n    static class Dog {\r\n        String name;\r\n        int age;\r\n        \r\n        public void show() {\r\n            System.out.println("卡拉是条狗");\r\n        }\r\n    }\r\n    \r\n    // 非静态成员内部类\r\n    class Bird {\r\n        String name;\r\n        \r\n        public void sing() {\r\n            System.out.println("我是一只小小鸟");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"在成员内部类中区分调用外部类的结构"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"见Bird类的display()方法。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'class Person {\r\n    String name;\r\n    int age;\r\n    \r\n    // 静态成员内部类\r\n    static class Dog {\r\n        String name;\r\n        int age;\r\n        \r\n        public void show() {\r\n            System.out.println("卡拉是条狗");\r\n        }\r\n    }\r\n    \r\n    // 非静态成员内部类\r\n    class Bird {\r\n        String name;\r\n        \r\n        public void sing() {\r\n            System.out.println("我是一只小小鸟");\r\n        }\r\n        \r\n        public void display(String name) {\r\n            // 调用方法的形参\r\n            System.out.println(name);\r\n            // 调用内部类的属性\r\n            System.out.println(this.name);\r\n            // 调用外部类的属性（如果外部类属性是static的，this可省）\r\n            System.out.println(Person.this.name);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"开发中局部内部类的使用"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'class Person {\r\n    static String name = "张三";\r\n    int age;\r\n\r\n    // 局部内部类\r\n    public Comparable getComparable() {\r\n        // 创建了一个实现Comparable接口的局部内部类\r\n        // 方式1：\r\n//        class MyComparable implements Comparable {\r\n//            @Override\r\n//            public int compareTo(Object o) {\r\n//                return 0;\r\n//            }\r\n//        }\r\n//        return new MyComparable();\r\n\r\n        // 方式2：创建了实现Comparable接口的匿名实现类的匿名对象\r\n        return new Comparable() {\r\n            @Override\r\n            public int compareTo(Object o) {\r\n                return 0;\r\n            }\r\n        };\r\n    }\r\n}\n'})})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,e.ah)(),n.components);return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["tang%2Fjava2%2F06_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"6.1 关键字static",id:"61-关键字static",depth:2},{text:"6.2 static应用之单例设计模式",id:"62-static应用之单例设计模式",depth:2},{text:"6.3 理解main方法的语法",id:"63-理解main方法的语法",depth:2},{text:"6.4 类的成员之四：代码块",id:"64-类的成员之四代码块",depth:2},{text:"6.4 关键字final",id:"64-关键字final",depth:2},{text:"6.5 抽象类与抽象方法",id:"65-抽象类与抽象方法",depth:2},{text:"6.6 abstract应用之模板方法设计模式",id:"66-abstract应用之模板方法设计模式",depth:2},{text:"6.7 接口",id:"67-接口",depth:2},{text:"6.8 接口应用之代理模式（Proxy）",id:"68-接口应用之代理模式proxy",depth:2},{text:"6.9 接口应用之工厂模式",id:"69-接口应用之工厂模式",depth:2},{text:"6.10 类的成员之五：内部类",id:"610-类的成员之五内部类",depth:2}],title:"6 面向对象编程（下）",frontmatter:{}}}}]);