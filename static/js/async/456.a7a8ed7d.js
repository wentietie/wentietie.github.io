"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["456"],{9624:function(n,e,r){r.r(e),r.d(e,{default:function(){return l}});var i=r(85893),s=r(50065);function a(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",h3:"h3",pre:"pre",code:"code",strong:"strong",h4:"h4"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"10-枚举注解",children:["10 枚举&注解",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10-枚举注解",children:"#"})]}),"\n",(0,i.jsxs)(e.h2,{id:"101-枚举类",children:["10.1 枚举类",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#101-枚举类",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"使用场景"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"类的对象只有有限个且确定"}),"\n",(0,i.jsx)(e.p,{children:"如周一到周日、支付方式、季节、订单状态等"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"当需要定义一组常量时，强烈建议使用枚举类"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"1011-jdk50之前枚举类的使用",children:["10.1.1 JDK5.0之前枚举类的使用",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1011-jdk50之前枚举类的使用",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'/**\r\n * 枚举类的使用\r\n * 方式一：jdk5.0之前，自定义枚举类\r\n * @Author tth\r\n * @Date 2022/12/8 10:24\r\n */\r\npublic class SeasonTest {\r\n\r\n    /**\r\n    * 测试方法\r\n    */\r\n    @Test\r\n    public void test1() {\r\n        Season summer = Season.SUMMER;\r\n        System.out.println(summer.toString());\r\n    }\r\n}\r\n\r\n/**\r\n * 自定义季节枚举类\r\n */\r\nclass Season {\r\n    // 1.声明季节的属性\r\n    private final Integer seasonCode;\r\n    private final String seasonName;\r\n    private final String seasonDesc;\r\n\r\n    // 2.私有化构造器\r\n    private Season(Integer seasonCode, String seasonName, String seasonDesc) {\r\n        this.seasonCode = seasonCode;\r\n        this.seasonName = seasonName;\r\n        this.seasonDesc = seasonDesc;\r\n    }\r\n\r\n    // 3.提供当前枚举类的对象，修饰符为public static final\r\n    public static final Season SPRING = new Season(1001, "春天", "春暖花开");\r\n    public static final Season SUMMER = new Season(1002, "夏天", "烈日炎炎");\r\n    public static final Season AUTUMN = new Season(1003, "秋天", "瓜果飘香");\r\n    public static final Season WINTER = new Season(1004, "冬天", "白雪皑皑");\r\n\r\n    // 4.其他诉求1：生成季节属性的getter，以获取Season对象实例的属性\r\n    public Integer getSeasonCode() {\r\n        return seasonCode;\r\n    }\r\n\r\n    public String getSeasonName() {\r\n        return seasonName;\r\n    }\r\n\r\n    public String getSeasonDesc() {\r\n        return seasonDesc;\r\n    }\r\n\r\n    // 4.其他诉求2：生成toString()方法\r\n    @Override\r\n    public String toString() {\r\n        return "Season{" +\r\n                "seasonCode=" + seasonCode +\r\n                ", seasonName=\'" + seasonName + \'\\\'\' +\r\n                ", seasonDesc=\'" + seasonDesc + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1012-jdk50之后枚举类的使用",children:["10.1.2 JDK5.0之后枚举类的使用",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1012-jdk50之后枚举类的使用",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class SeasonTest1 {\r\n    /**\r\n     * 测试方法\r\n     */\r\n    @Test\r\n    public void test1() {\r\n        Season1 summer = Season1.SUMMER;\r\n        // Season1中没有重写toString()，此处会调用其父类java.lang.Enum的toString()，返回常量名\r\n        System.out.println(summer.toString());\r\n    }\r\n}\r\n\r\n/**\r\n * 使用enum关键字定义枚举类\r\n */\r\nenum Season1 {\r\n    // 1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象用“;”结束\r\n    SPRING(1001, "春天", "春暖花开"),\r\n    SUMMER(1002, "夏天", "烈日炎炎"),\r\n    AUTUMN(1003, "秋天", "瓜果飘香"),\r\n    WINTER(1004, "冬天", "白雪皑皑");\r\n\r\n    // 2.声明季节的属性\r\n    private final Integer seasonCode;\r\n    private final String seasonName;\r\n    private final String seasonDesc;\r\n\r\n    // 3.私有化构造器\r\n    Season1(Integer seasonCode, String seasonName, String seasonDesc) {\r\n        this.seasonCode = seasonCode;\r\n        this.seasonName = seasonName;\r\n        this.seasonDesc = seasonDesc;\r\n    }\r\n\r\n    // 4.其他诉求1：生成季节属性的getter，以获取Season对象实例的属性\r\n    public Integer getSeasonCode() {\r\n        return seasonCode;\r\n    }\r\n\r\n    public String getSeasonName() {\r\n        return seasonName;\r\n    }\r\n\r\n    public String getSeasonDesc() {\r\n        return seasonDesc;\r\n    }\r\n\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1013-javalangenum中常用方法",children:["10.1.3 java.lang.Enum中常用方法",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1013-javalangenum中常用方法",children:"#"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"toString()：返回当前对象常量的名称"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:" @Test\r\npublic void test1() {\r\n    Season1 summer = Season1.SUMMER;\r\n    // Season1中没有重写toString()，此处会调用其父类java.lang.Enum的toString()，返回常量名\r\n    System.out.println(summer.toString()); // SUMMER\r\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"values()：返回枚举类型的对象数组。可以借助该方法遍历所有的枚举值"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"@Test\r\npublic void test2() {\r\n    Season1[] season1s = Season1.values();\r\n    for (int i = 0; i < season1s.length; i++) {\r\n        System.out.println(season1s[i]); // SPRING SUMMER AUTUMN WINTER \r\n    }\r\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"valueOf(String str)：将字符串转为对应的枚举类的对象。要求字符串必须是枚举类对象的名字，否则报IllegalArgumentException异常"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'@Test\r\npublic void test3() {\r\n    Season1 spring = Season1.valueOf("SPRING");\r\n    System.out.println(spring); // SPRING\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"1014-使用enum关键字定义的枚举类实现接口",children:["10.1.4 使用enum关键字定义的枚举类实现接口",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1014-使用enum关键字定义的枚举类实现接口",children:"#"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"情况一：实现接口，在enum类中实现抽象方法"}),"\n",(0,i.jsx)(e.p,{children:"和普通类一样"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 定义接口\r\ninterface Info {\r\n    void show();\r\n}\r\n/**\r\n * 使用enum关键字定义枚举类\r\n */\r\nenum Season1 implements Info{\r\n    // 1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象用“;”结束\r\n    SPRING(1001, "春天", "春暖花开"),\r\n    SUMMER(1002, "夏天", "烈日炎炎"),\r\n    AUTUMN(1003, "秋天", "瓜果飘香"),\r\n    WINTER(1004, "冬天", "白雪皑皑");\r\n    \r\n	...\r\n    \r\n    // 重写接口中的方法\r\n    @Override\r\n    public void show() {\r\n        System.out.println("这是季节的枚举类");\r\n    }\r\n}\r\n\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"情况二：实现接口，让枚举类的对象分别实现抽象方法"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'interface Info {\r\n    void show();\r\n}\r\n/**\r\n * 使用enum关键字定义枚举类\r\n */\r\nenum Season1 implements Info{\r\n    // 1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象用“;”结束\r\n    SPRING(1001, "春天", "春暖花开"){\r\n        @Override\r\n        public void show() {\r\n            System.out.println("春眠不觉晓");   \r\n        }\r\n    },\r\n    SUMMER(1002, "夏天", "烈日炎炎"){\r\n        @Override\r\n        public void show() {\r\n            System.out.println("接天莲叶无穷碧");\r\n        }\r\n    },\r\n    AUTUMN(1003, "秋天", "瓜果飘香"){\r\n        @Override\r\n        public void show() {\r\n            System.out.println("千里共婵娟");\r\n        }\r\n    },\r\n    WINTER(1004, "冬天", "白雪皑皑"){\r\n        @Override\r\n        public void show() {\r\n            System.out.println("墙角数枝梅");\r\n        }\r\n    };\r\n\r\n    ...\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"102-注解",children:["10.2 注解",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#102-注解",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"1021-注解annotation概述",children:["10.2.1 注解（Annotation）概述",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1021-注解annotation概述",children:"#"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["注解可以像修饰符一样被使用，可以用于",(0,i.jsx)(e.strong,{children:"修饰包、类、构造器、方法、成员变量、参数、局部变量"}),"的。这些信息被保存在Annotation的“name=value”对中"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"1022-常见的annotation示例",children:["10.2.2 常见的Annotation示例",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1022-常见的annotation示例",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"文档注解"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"@Author"}),"\n",(0,i.jsx)(e.li,{children:"@Date"}),"\n",(0,i.jsx)(e.li,{children:"..."}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"JDK内置注解"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"@Override：只能用于方法。要求方法是重写的父类方法，或者是实现的接口的方法"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"@Deprecated：可以修改类、方法、属性、构造器。表示被修饰的内容已过时，但是仍然可以用"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"@SuppressWarning：抑制编译器警告"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 在eclipse中，如下定义list，在没有使用之前，会有“未使用”、“未指明泛型”警告。如下添加@SuppressWarning注解，可以消除警告\r\n@SuppressWarnings({"unused", "rawtypes"})\r\nArrayList list = new ArrayList();\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"1023-自定义annotation",children:["10.2.3 自定义Annotation",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1023-自定义annotation",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"步骤"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"注解声明为@interface"}),"\n",(0,i.jsx)(e.li,{children:"内部定义成员，如果只有一个，通常使用value表示"}),"\n",(0,i.jsx)(e.li,{children:"可以指定成员的默认值，用default定义"}),"\n",(0,i.jsx)(e.li,{children:"如果自定义的注解没有成员，表明是一个标识作用"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"如果注解有成员，在使用注解时，需要指明成员的值。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"示例"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public @interface MyAnnotation {\r\n    String value() default "Hello Annotation";\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"1024-jdk中的元注解",children:["10.2.4 JDK中的元注解",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1024-jdk中的元注解",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"定义：元注解"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"JDK的元注解是对现有注解进行解释说明的注解"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"引申：元数据"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["对现有数据修饰的数据。如",(0,i.jsx)(e.code,{children:'String name = "hello"'}),"，“hello”是核心数据，“String”、“name”都是元数据。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"JDK中的元注解"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"（关注）@Retention：指明被修饰注解的生命周期。"}),"\n",(0,i.jsx)(e.p,{children:"@Retention的value值是RetentionPolicy类型的成员变量。RetentionPolicy枚举类中各个值的含义如下："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"RetentionPolicy.SOURCE：源文件中有效，编译器直接丢掉"}),"\n",(0,i.jsx)(e.li,{children:"RetentionPolicy.CLASS（默认）：在class文件中有效，运行时JVM不会保留"}),"\n",(0,i.jsxs)(e.li,{children:["RetentionPolicy.RUNTIME：运行时有效。",(0,i.jsx)(e.strong,{children:"当运行时，JVM会保留注释，程序可以通过反射获取注解"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"（关注）@Target：指明被修饰的注解可以修饰哪些元素"}),"\n",(0,i.jsx)(e.p,{children:"@Target的value值是ElementType[]。ElementType枚举类常用值如下："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"TYPE：可以修饰类、接口、注解、枚举类"}),"\n",(0,i.jsx)(e.li,{children:"FIELD：修饰属性"}),"\n",(0,i.jsx)(e.li,{children:"METHOD：修饰方法"}),"\n",(0,i.jsx)(e.li,{children:"PARAMETER：修饰参数"}),"\n",(0,i.jsx)(e.li,{children:"CONSTRUCTOR：修饰构造器"}),"\n",(0,i.jsx)(e.li,{children:"LOCAL_VARIABLE：修饰局部变量"}),"\n",(0,i.jsx)(e.li,{children:"ANNOTATION_TYPE：修饰注解"}),"\n",(0,i.jsx)(e.li,{children:"PACKAGE：修饰包"}),"\n",(0,i.jsxs)(e.li,{children:["TYPE_PARAMETER：","JDK8新特性","。类型注解"]}),"\n",(0,i.jsxs)(e.li,{children:["TYPE_USE：","JDK8新特性","。类型注解。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"（了解）@Documented：表示被修饰的注解将被javadoc工具提取生成文档。默认情况下，javadoc是不包括注解的"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"（了解）@Inherited：表示被修饰的注解具有继承性"}),"\n",(0,i.jsx)(e.p,{children:"如果一个父类使用了被Inherited修饰的注解，则子类就默认使用了该注解。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"1025-利用反射获取注解信息",children:["10.2.5 利用反射获取注解信息",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1025-利用反射获取注解信息",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在反射部分提及"}),"\n",(0,i.jsxs)(e.h3,{id:"1026-jdk8中注解新特性",children:["10.2.6 JDK8中注解新特性",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1026-jdk8中注解新特性",children:"#"})]}),"\n",(0,i.jsxs)(e.h4,{id:"10261-可重复注解",children:["10.2.6.1 可重复注解",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10261-可重复注解",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在一个类或者属性或其他结构上使用多次相同注解"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"JDK8之前实现可重复注解"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 可重复注解的使用\r\n@MyAnnotations({@MyAnnotation("hello"), @MyAnnotation("hi")})\r\nclass Person {\r\n    private String name;\r\n    private Integer age;\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n}\r\n\r\n// 定义MyAnnotation注解\r\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface MyAnnotation {\r\n    String value() default "Hello Annotation";\r\n}\r\n\r\n// 定义MyAnnotations注解\r\npublic @interface MyAnnotations {\r\n    MyAnnotation[] value();\r\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"JDK8新特性实现可重复注解"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 可重复注解的使用\r\n@MyAnnotation("hello")\r\n@MyAnnotation("hi")\r\nclass Person {\r\n    private String name;\r\n    private Integer age;\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n}\r\n\r\n// 定义MyAnnotation。重点是使用@Repeatable修饰\r\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(MyAnnotations.class)\r\npublic @interface MyAnnotation {\r\n    String value() default "Hello Annotation";\r\n}\r\n\r\n// 定义MyAnnotations。注意MyAnnotations注解的@Target = MyAnnotation注解的@Target， 注意MyAnnotations注解的@Inherited = MyAnnotation注解的 @Inherited\r\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface MyAnnotations {\r\n    MyAnnotation[] value();\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"10262-类型注解",children:["10.2.6.2 类型注解",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10262-类型注解",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"JDK8之前，注解只能是在声明的地方使用；JDK8之后，注解可以应用在任何地方。"}),"\n",(0,i.jsx)(e.p,{children:"JDK8之后，元注解@Target的参数类型ElementType枚举值多了两个："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如泛型声明）"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 声明注解\r\n@Target({TYPE_PARAMETER})\r\n@Retention(RetentionPolicy.CLASS)\r\npublic @interface MyAnnotation {\r\n    String value() default "Hello Annotation";\r\n}\r\n\r\n// 使用注解：使用注解修饰泛型变量\r\nclass Generic <@MyAnnotation T> {\r\n\r\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 声明注解\r\n@Target({TYPE_USE})\r\n@Retention(RetentionPolicy.CLASS)\r\npublic @interface MyAnnotation {\r\n    String value() default "Hello Annotation";\r\n}\r\n\r\n// 使用注解\r\nclass Generic <T> {\r\n    // 修饰异常\r\n    public void show() throws @MyAnnotation RuntimeException{\r\n        // 修饰变量\r\n        ArrayList<@MyAnnotation String> list = new ArrayList<>();\r\n        int num = (@MyAnnotation int) 10L;\r\n    }\r\n}\n'})}),"\n"]}),"\n"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(a,{...n})}):a(n)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["tang%2Fjava2%2F10_%E6%9E%9A%E4%B8%BE%26%E6%B3%A8%E8%A7%A3.md"]={toc:[{text:"10.1 枚举类",id:"101-枚举类",depth:2},{text:"10.1.1 JDK5.0之前枚举类的使用",id:"1011-jdk50之前枚举类的使用",depth:3},{text:"10.1.2 JDK5.0之后枚举类的使用",id:"1012-jdk50之后枚举类的使用",depth:3},{text:"10.1.3 java.lang.Enum中常用方法",id:"1013-javalangenum中常用方法",depth:3},{text:"10.1.4 使用enum关键字定义的枚举类实现接口",id:"1014-使用enum关键字定义的枚举类实现接口",depth:3},{text:"10.2 注解",id:"102-注解",depth:2},{text:"10.2.1 注解（Annotation）概述",id:"1021-注解annotation概述",depth:3},{text:"10.2.2 常见的Annotation示例",id:"1022-常见的annotation示例",depth:3},{text:"10.2.3 自定义Annotation",id:"1023-自定义annotation",depth:3},{text:"10.2.4 JDK中的元注解",id:"1024-jdk中的元注解",depth:3},{text:"10.2.5 利用反射获取注解信息",id:"1025-利用反射获取注解信息",depth:3},{text:"10.2.6 JDK8中注解新特性",id:"1026-jdk8中注解新特性",depth:3},{text:"10.2.6.1 可重复注解",id:"10261-可重复注解",depth:4},{text:"10.2.6.2 类型注解",id:"10262-类型注解",depth:4}],title:"10 枚举&注解",frontmatter:{}}}}]);