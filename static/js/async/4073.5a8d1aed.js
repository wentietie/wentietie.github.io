"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["4073"],{38552:function(n,s,e){e.r(s),e.d(s,{default:function(){return d}});var r=e(85893),i=e(50065);function l(n){let s=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",code:"code",pre:"pre"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.h1,{id:"12-java泛型",children:["12 Java泛型",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#12-java泛型",children:"#"})]}),"\n",(0,r.jsxs)(s.h2,{id:"121-概述",children:["12.1 概述",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#121-概述",children:"#"})]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"定义"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"所谓泛型，就是允许在定义类、接口时通过一个标识表明类中某个属性的类型、某个方法的返回值、参数类型。这个类型参数将在使用时（如：继承或者实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。"}),"\n",(0,r.jsxs)(s.h2,{id:"122-自定义泛型结构",children:["12.2 自定义泛型结构",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#122-自定义泛型结构",children:"#"})]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"自定义泛型类、泛型接口"}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"泛型类、泛型接口可能有多个参数，此时应该将多个参数放到一对尖括号中，并用逗号隔开。如<E1, E2, E3>"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"泛型如果不指定，将被擦除，单行对应的类型均按照Object处理，但不等价于Object"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["JDK7中，实例化泛型类时可以简化为：",(0,r.jsx)(s.code,{children:"ArrayList<String> list = new ArrayList<>()"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"泛型不能是基本数据类型，可以使用包装类替换"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"泛型类或者泛型接口中，不能在静态方法中使用类的泛型"}),"\n",(0,r.jsx)(s.p,{children:"泛型的具体类型需要在类实例化的时候指定，静态方法在类实例化之前就可以被调用"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"异常类不能有泛型"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["创建泛型数组：",(0,r.jsx)(s.code,{children:"T[] arr = (T[]) new Object[10]"})]}),"\n",(0,r.jsx)(s.p,{children:"不可以使用 T[] arr = new T[10]"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"父类有泛型，子类可以选择保留泛型，也可以选择指定泛型类型"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"class Father<T1, T2>{}\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"子类不保留父类的泛型：按需实现"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"没有类型（泛型会被擦除）"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"class Son1 extends Father{}\r\n// 等价于 class Son1 extends Father<Object, Object>\n"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"具体类型"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"class Son2 extends Father<Integer, String> {}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"子类保留父类泛型：泛型子类"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"全部保留"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"class Son3<T1, T2> extends Father<T1, T2>{}\n"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"部分保留"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"class Son4<T2> extends Father<Integer, T2>{}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"自定义泛型方法"}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"泛型方法，是在方法中出现了泛型的结构。该泛型结构与所在类的泛型参数没有任何关系"}),"\n",(0,r.jsx)(s.p,{children:"换句话说，泛型方法所在的类是不是泛型类都没有关系"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"泛型方法可以声明为静态的。"}),"\n",(0,r.jsx)(s.p,{children:"因为泛型参数是在调用方法的时候确定的，并非实例化类的时候才确定"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"class GenericTest<T> {\r\n    /**\r\n    * 定义泛型方法\r\n    * 第一个<E> 表明泛型的类类型。如果不写，后边的E会被识别为某一个类\r\n    */\r\n    public <E> List<E> copyFromArray(E[] arr) {\r\n        ArrayList<E> list = new ArrayList<>();\r\n        for(E e: arr) {\r\n            list.add(e)\r\n        }\r\n        return list;\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(s.h2,{id:"123-泛型在继承方面的体现",children:["12.3 泛型在继承方面的体现",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#123-泛型在继承方面的体现",children:"#"})]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["类A是类B的父类，",(0,r.jsx)(s.code,{children:"G<A>"}),"和",(0,r.jsx)(s.code,{children:"G<B>"}),"不具备子父类关系，二者是并列关系。即："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"public void test() {\r\n    Object o = null;\r\n    String s = null;\r\n    o = s; // 代码正确\r\n    \r\n    List<Object> oList = null;\r\n    List<String> sList = null;\r\n    oList = sList; // 编译不通过\r\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["补充","：类A是类B的父类(接口)，那么",(0,r.jsx)(s.code,{children:"A<G>"}),"是",(0,r.jsx)(s.code,{children:"B<G>"}),"的父类"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"public void test() {\r\n    List<Object> list = null;\r\n    ArrayList<Object> aList = null;\r\n    list = aList; // 代码正确\r\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["类A是类B的父类，",(0,r.jsx)(s.code,{children:"G<A>"}),"和",(0,r.jsx)(s.code,{children:"G<B>"}),"二者共同的父类是",(0,r.jsx)(s.code,{children:"G<?>"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"124-通配符的使用",children:["12.4 通配符的使用",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#124-通配符的使用",children:"#"})]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["类A是类B的父类，",(0,r.jsx)(s.code,{children:"G<A>"}),"和",(0,r.jsx)(s.code,{children:"G<B>"}),"二者共同的父类是",(0,r.jsx)(s.code,{children:"G<?>"})]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"public void test() {\r\n    List<Object> oList = null;\r\n    List<String> sList = null;\r\n    \r\n    List<?> list = null;\r\n    list = oList; // 代码正确\r\n    list = sList; // 代码正确\r\n    \r\n    print(oList); // 代码正确\r\n    print(sList); // 代码正确\r\n}\r\n\r\nprivate void print(List<?> list) {\r\n    Iterator<?> iterator = list.iterator();\r\n    while (iterator.hasNext()) {\r\n        System.out.println(iterator.next());\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"通配符的写入与读取"}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'public void test() {\r\n    List<String> sList = new ArrayList<>();\r\n    sList.add("AA");\r\n    sList.add("BB");\r\n    sList.add("CC");\r\n    \r\n    List<?> list = null;\r\n    list = sList; // 代码正确\r\n    // 写入（添加）元素：对于List<?>除了null不能add其他数据\r\n    list.add("DD");//编译不通过\r\n    // 读取元素：允许读取数据，读取到的数据是Object类型\r\n    Object o = list.get(0);\r\n}\n'})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"有限制条件的通配符"}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"通配符指定上限"}),"\n",(0,r.jsx)(s.p,{children:"上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口。即<="}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"通配符指定下线"}),"\n",(0,r.jsx)(s.p,{children:"下限super：使用时指定的类型不能小于操作的类，即>="}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"举例"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"? extends A"})}),"\n",(0,r.jsx)(s.p,{children:"?可以是类A，也可以是类A的子类"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"? super A"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"?"}),"可以是类A，也可以是类A的父类"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:"public class Test {\r\n    public void test() {\r\n        List<Student> sList = null;\r\n        List<Person> pList = null;\r\n        List<Object> oList = null;\r\n        \r\n        List<? extends Person> list1 = null;\r\n        list1 = sList;\r\n        list1 = pList;\r\n        list1 = oList;//编译不通过\r\n        // 添加数据：除了null，别的不允许\r\n        list1.add(new Student());//编译不通过\r\n        \r\n        List<? super Person> list2 = null;\r\n        list2 = sList;//编译不通过\r\n        list2 = pList;\r\n        list2 = oList;\r\n        // 添加数据：允许添加\r\n        list2.add(new Person());\r\n        list2.add(new Student());\r\n        \r\n    }\r\n}\r\nclass Person{}\r\nclass Student extends Person{}\n"})}),"\n"]}),"\n"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),n.components);return s?(0,r.jsx)(s,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["tang%2Fjava2%2F12_Java%E6%B3%9B%E5%9E%8B.md"]={toc:[{text:"12.1 概述",id:"121-概述",depth:2},{text:"12.2 自定义泛型结构",id:"122-自定义泛型结构",depth:2},{text:"12.3 泛型在继承方面的体现",id:"123-泛型在继承方面的体现",depth:2},{text:"12.4 通配符的使用",id:"124-通配符的使用",depth:2}],title:"12 Java泛型",frontmatter:{}}}}]);