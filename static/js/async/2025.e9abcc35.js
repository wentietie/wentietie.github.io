"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["2025"],{97392:function(n,e,r){r.r(e),r.d(e,{default:()=>o});var s=r("85893"),l=r("50065");let i=r.p+"static/image/image-20220826144824327.a8218613.png",c=r.p+"static/image/image-20220830155133893.9fb2810f.png",d=r.p+"static/image/image-20220830165134692.77975a72.png",t=r.p+"static/image/image-20220906164035052.eaee422d.png";function h(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",blockquote:"blockquote",ul:"ul",li:"li",img:"img",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",strong:"strong"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"vue3快速入门",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#vue3快速入门",children:"#"}),"Vue3快速入门"]}),"\n",(0,s.jsxs)(e.h1,{id:"1创建vue30工程",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1创建vue30工程",children:"#"}),"1.创建Vue3.0工程"]}),"\n",(0,s.jsxs)(e.h2,{id:"11-使用vue-cli创建",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11-使用vue-cli创建",children:"#"}),"1.1 使用vue-cli创建"]}),"\n",(0,s.jsx)(e.p,{children:"==创建Vue3工程，需要保证@vue/cli的版本在4.5.0以上=="}),"\n",(0,s.jsxs)(e.p,{children:["==官方文档：==",(0,s.jsx)(e.a,{href:"https://cli.vuejs.org/zh/guide/creating-a-project.html",rel:"noopener noreferrer",target:"_blank",children:"https://cli.vuejs.org/zh/guide/creating-a-project.html"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sh",meta:"",children:"# 查看@vue/cli版本\r\nvue -V\r\n# 安装或升级@vue/cli\r\nnpm install -g @vue/cli\r\n# 创建项目\r\nvue create <project_name>(项目名)\r\n# 创建过程中，选择vue3\r\n# 启动项目\r\ncd <project_name>\r\nnpm run serve\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"12使用vite创建",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12使用vite创建",children:"#"}),"1.2使用vite创建"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"vite简介"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["==vite官网：==",(0,s.jsx)(e.a,{href:"https://vitejs.cn/",rel:"noopener noreferrer",target:"_blank",children:"https://vitejs.cn/"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概念"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"新一代前端构建工具"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"优势"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"开发环境中，无需打包，可快速冷启动"}),"\n",(0,s.jsx)(e.li,{children:"轻量快速的热重载（HMR）"}),"\n",(0,s.jsx)(e.li,{children:"真正的按需编译，不再等待整个应用编译完成"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"传统构建与vite构建对比图"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220826144824327",src:i})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"创建过程"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sh",meta:"",children:"# 创建工程\r\nnpm init vite-app <project_name>\r\n# 首次使用vite-app，创建过程中需要安装，直接输入y回车即可\r\n# 安装依赖\r\ncd <project_name>\r\nnpm install # 或者使用‘yarn’命令\r\n# 启动项目\r\nnpm run dev # 或者使用‘yarn dev’命令\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"13-分析工程结构",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13-分析工程结构",children:"#"}),"1.3 分析工程结构"]}),"\n",(0,s.jsx)(e.p,{children:"==以下分析均使用vue-cli创建的项目=="}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"main.js文件"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 引入的不再是Vue构造函数了，而是一个名为createApp的工厂函数\r\nimport { createApp } from 'vue'\r\nimport App from './App.vue'\r\n\r\ncreateApp(App).mount('#app')\r\n/**\r\n * 以上代码可以进行如下拆解\r\n * ===================================\r\n * 创建应用实例对象--app(类似于vue2中的vm实例，但app比vm更“轻量”)\r\n * const app = createApp(App)\r\n * 挂载\r\n * app.mount('#app')\r\n * ====================================\r\n */\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"App.vue文件"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:'<template>\r\n  \x3c!-- Vue3组件中的模板结构可以没有根标签 --\x3e\r\n  <img alt="Vue logo" src="./assets/logo.png">\r\n  <HelloWorld msg="Welcome to Your Vue.js App"/>\r\n</template>\r\n...\n'})}),"\n",(0,s.jsxs)(e.h1,{id:"2常用composition-api",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2常用composition-api",children:"#"}),"2.常用Composition API"]}),"\n",(0,s.jsxs)(e.h2,{id:"21-拉开序幕的setup",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21-拉开序幕的setup",children:"#"}),"2.1 拉开序幕的setup"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"什么是setup"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Vue3.0中一个新的==配置项==，值为一个函数。"}),"\n",(0,s.jsx)(e.li,{children:"是所有Composition API“表演的舞台”"}),"\n",(0,s.jsx)(e.li,{children:"组件中所用到的数据、方法等，均要配置在setup中"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"setup函数的两种返回值"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"返回一个对象：对象中的属性、方法，在模板中均可直接使用（重点关注！！！）"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  <h2>人员信息</h2>\r\n  <h4>姓名：{{name}}</h4>\r\n  <h4>年龄：{{age}}</h4>\r\n  <button @click=\"sayHello\">sayHello</button>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'App',\r\n  // setup函数，返回一个对象（暂时不考虑响应式问题）\r\n  setup() {\r\n    // 定义数据\r\n    let name = '张三'\r\n    let age = 18\r\n\r\n    // 定义方法\r\n    function sayHello() {\r\n      // 方法中使用变量时，前边不用再加“this.”\r\n      alert(`我叫${name}, 今年${age}岁，你好啊~`)\r\n    }\r\n\r\n    // 将数据和方法包装成一个对象返回  \r\n    return {\r\n      name,\r\n      age,\r\n      sayHello\r\n    }\r\n  }\r\n}\r\n<\/script>\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"返回一个渲染函数：可以自定义渲染内容（了解）"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"...\r\n<script>\r\nimport {h} from 'vue'\r\n\r\nexport default {\r\n  name: 'App',\r\n  // setup函数，返回一个渲染函数\r\n  setup() {\r\n    // 和Vue2中vm的render配置项一致\r\n    // h(param1, param2)参数说明：param1 标签， param2 标签内容\r\n    return () => {return h('h1', 'Vue3学习')}\r\n  }\r\n}\r\n<\/script>\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["尽量不要与Vue2.x配置混用","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Vue2.x配置（data、methods、computed...）可以访问到setup中的属性、方法"}),"\n",(0,s.jsx)(e.li,{children:"setup中不能访问到Vue2.x配置（data、methods、computed...）"}),"\n",(0,s.jsx)(e.li,{children:"如果重名，setup优先"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"setup不能是一个async函数，因为async函数返回值不再是return的对象，而是promise，模板看不到return对象中的属性（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"22-ref函数",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22-ref函数",children:"#"}),"2.2 ref函数"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"定义一个响应式数据"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用方法"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["声明变量：",(0,s.jsx)(e.code,{children:"let xxx = ref(initValue)"}),")(创建了一个包含响应式数据的","引用对象（reference对象，简称ref对象）",")"]}),"\n",(0,s.jsxs)(e.p,{children:["需要引入",(0,s.jsx)(e.code,{children:"ref"}),"函数：",(0,s.jsx)(e.code,{children:"import {ref} from 'vue'"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["js中操作数据：",(0,s.jsx)(e.code,{children:"xxx.value"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["模板中读取数据：",(0,s.jsx)(e.code,{children:"<div>xxx</div>"}),"(不需要.value)"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"完整代码"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  <h1>人员信息</h1>\r\n  \x3c!-- 模板中读取数据 --\x3e\r\n  <h2>姓名：{{name}}</h2>\r\n  <h2>年龄：{{age}}</h2>\r\n  <h3>工作类型：{{job.type}}</h3>\r\n  <h3>工作薪资：{{job.salary}}</h3>\r\n  <button @click=\"changePersonInfo\">修改人员信息</button>\r\n</template>\r\n\r\n<script>\r\n// 引入ref函数\r\nimport {ref} from 'vue'\r\n\r\nexport default {\r\n  name: 'App',\r\n  setup() {\r\n    // 定义基本类型数据\r\n    let name = ref('张三')\r\n    let age = ref(18)\r\n    // 定义一个对象\r\n    let job = ref({\r\n      type: '前端开发工程师',\r\n      salary: '30K'\r\n    })\r\n\r\n    function changePersonInfo() {\r\n      // 修改基本类型数据\r\n      name.value = '李四'\r\n      age.value = 48\r\n      // 修改对象中的属性\r\n      job.value.type = 'UI设计师'\r\n      job.value.salary = '80K'\r\n    }\r\n\r\n    return {\r\n      name,\r\n      age,\r\n      job,\r\n      changePersonInfo\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n\r\n<style>\r\n#app {\r\n  font-family: Avenir, Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  /* text-align: center; */\r\n  color: #2c3e50;\r\n  margin: 20px;\r\n}\r\n</style>\r\n\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"备注"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"ref()接收的数据可以是基本类型，也可以是对象类型"}),"\n",(0,s.jsxs)(e.li,{children:["基本类型的数据：响应式依然是靠",(0,s.jsx)(e.code,{children:"Object.defineProperty()"}),"的",(0,s.jsx)(e.code,{children:"get"}),"与",(0,s.jsx)(e.code,{children:"set"}),"完成"]}),"\n",(0,s.jsxs)(e.li,{children:["对象类型的数据：内部“求助”了Vue3.0中的一个新函数---",(0,s.jsx)(e.code,{children:"reactive"}),"函数"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"23-reactive函数",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23-reactive函数",children:"#"}),"2.3 reactive函数"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"定义一个==对象类型==的响应式数据"}),"\n",(0,s.jsx)(e.p,{children:"只能定义对象类型的数据，不能定义基本类型的数据"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["声明变量：",(0,s.jsx)(e.code,{children:"const 代理对象 = reactive(源对象)"})]}),"\n",(0,s.jsxs)(e.p,{children:["需要引入",(0,s.jsx)(e.code,{children:"reactive"}),"函数：",(0,s.jsx)(e.code,{children:"import {reactive} from 'vue'"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["JS使用：",(0,s.jsx)(e.code,{children:"console.log(代理对象)"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["模板中使用：",(0,s.jsx)(e.code,{children:"<div>{{代理对象}}</div>"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["==接收一个对象或数组，返回一个","代理对象（Proxy的实例对象，简称proxy对象）","=="]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"说明"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"reactive"}),"定义的响应式数据是“深层次的”"]}),"\n",(0,s.jsx)(e.li,{children:"内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"24-vue30中的响应式原理",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24-vue30中的响应式原理",children:"#"}),"2.4 Vue3.0中的响应式原理"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"vue2.x的响应式"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"实现原理"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["对象类型：通过",(0,s.jsx)(e.code,{children:"Object.defineProperty()"}),"对属性的读取、修改进行拦截（数据劫持）"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"Object.defineProperty(源对象, '属性名', {\r\n    get() {...},\r\n    set(value) {...}\r\n})\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"数组对象：通过重写更新数组的一系列方法来实现拦截（对数据的变更方法进行包裹）"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"存在问题"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"新增属性、删除属性，界面不会更新"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"...\r\n<script>\r\nexport default {\r\n  name: 'App',\r\n  data() {\r\n      return {\r\n          person: {\r\n              name: '张三',\r\n              age: 18\r\n          }\r\n      }\r\n  },\r\n  methods: {\r\n      addSex() {\r\n          // 使用如下代码添加属性，界面不会更新\r\n          this.person.sex = '男'\r\n          // 解决方法：借助vue封装的API\r\n          this.$set(this.person, 'sex', '男')\r\n          // 或者直接使用Vue调用API\r\n          Vue.set(this.person, 'sex', '男')\r\n      },\r\n      deleteName() {\r\n          // 使用如下代码删除属性，界面不会更新\r\n          delete this.person.name\r\n           // 解决方法：借助vue封装的API\r\n          this.$delete(this.person, 'name')\r\n          // 或者直接使用Vue调用API\r\n          Vue.delete(this.person, 'name')\r\n      }\r\n  }\r\n}\r\n<\/script>\r\n...\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"直接通过下标修改数组，界面 不会自动更新"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"...\r\n<script>\r\nexport default {\r\n  name: 'App',\r\n  data() {\r\n      return {\r\n          hobbies: ['吃饭', '睡觉', '打豆豆']\r\n      }\r\n  },\r\n  methods: {\r\n      updateHobby() {\r\n          // 使用如下方法修改第一个爱好，界面不会更新\r\n          this.hobbies[0] = '狂阶'\r\n          // 可以使用如下方法解决\r\n          // 方法一：借助Vue的API\r\n          this.$set(this.hobbies, 0, '逛街')\r\n          // 或者使用Vue直接调用\r\n          Vue.$set(this.hobbies, 0, '逛街')\r\n          // 方法二：使用数组的变更方法（vue自己封装了的）\r\n          this.hobbies.splice(0, 1, '逛街')\r\n      }\r\n  }\r\n}\r\n<\/script>\r\n...\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Vue3.0响应式"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"实现原理"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"通过Reflect（反射）：对源对象的属性进行操作"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"new Proxy(源对象, {\r\n    /**\r\n    * 拦截读取属性值\r\n    * @param target 源对象\r\n    * @param prop 属性名\r\n    */\r\n    get(target, prop) {return Reflect.get(target, prop)},\r\n    \r\n    /**\r\n    * 拦截设置属性值或添加新属性\r\n    * @param target 源对象\r\n    * @param prop 属性名\r\n    */\r\n    set(target, prop, value) {return Reflect.set(target, prop, value)},\r\n    \r\n    /**\r\n    * 拦截删除属性\r\n    * @param target 源对象\r\n    * @param prop 属性名\r\n    */\r\n    deleteProperty(target, prop) {return Reflect.deleteProperty(target, prop)}\r\n})\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"25-setup的两个注意点",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#25-setup的两个注意点",children:"#"}),"2.5 setup的两个注意点"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"setup执行时机"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["在beforeCreate之前执行一次，this是",(0,s.jsx)(e.code,{children:"undefined"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"setup参数"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["props：值为对象，包含组件外部传递过来，且在组件内部","声明接收","了的属性"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"\x3c!-- 父组件 --\x3e\r\n<Demo msg=\"hello\"></Demo>\r\n\r\n\x3c!-- 子组件 --\x3e\r\n<script>\r\n...\r\n	props: ['msg'] // 只有在此处声明接收父组件传过来的属性，setup函数中的props才能获取到值\r\n	setup(props) {\r\n    	console.log(props)\r\n	}\r\n...\r\n<\/script>\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"contetx：上下文对象，包含以下属性"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["attrs：值为对象，包含组件外部传递过来，但是props配置","没有声明","的属性，相当于vue2.x中的",(0,s.jsx)(e.code,{children:"vm.$attrs"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["slots：收到的插槽内容，相当于vue2.x中的",(0,s.jsx)(e.code,{children:"vm.$slots"})]}),"\n","\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["emit：分发自定义事件的函数，相当于vue2.x中的",(0,s.jsx)(e.code,{children:"vm.$emit"})]}),"\n","\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"26-reactive对比ref",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#26-reactive对比ref",children:"#"}),"2.6 reactive对比ref"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"从定义数据的角度对比"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["ref用来定义","基本类型数据"]}),"\n",(0,s.jsxs)(e.li,{children:["reactive用来定义","对象或数组类型数据"]}),"\n",(0,s.jsxs)(e.li,{children:["备注：ref也可以用来定义","对象或数组类型数据","，它内部会通过",(0,s.jsx)(e.code,{children:"reactive"}),"转化为","代理对象"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"从原理的角度对比"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["ref通过",(0,s.jsx)(e.code,{children:"Object.defineProperty()"}),"的",(0,s.jsx)(e.code,{children:"get"}),"和",(0,s.jsx)(e.code,{children:"set"}),"来实现响应式（数据劫持）"]}),"\n",(0,s.jsxs)(e.li,{children:["reactive通过使用","Proxy","来实现响应式（数据劫持），并通过","Reflect","操作","源对象","内部的数据"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"从使用的角度对比"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["ref定义的数据：js中操作数据","需要",(0,s.jsx)(e.code,{children:".value"}),"，模板中使用时","不需要",(0,s.jsx)(e.code,{children:".value"})]}),"\n",(0,s.jsxs)(e.li,{children:["reactive定义的数据：在js和模板中操作和使用，","均不需要",(0,s.jsx)(e.code,{children:".value"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"27-计算函数computed",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#27-计算函数computed",children:"#"}),"2.7 计算函数computed"]}),"\n",(0,s.jsx)(e.p,{children:"==与Vue2.x中computed配置功能一致=="}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用方法"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 引入\r\nimport { reactive, computed } from 'vue'\r\nexport default {\r\n    name: 'Demo',\r\n    props: ['msg'],\r\n    setup() {\r\n        let person = reactive({\r\n            firstName: '张',\r\n            lastName: '三'\r\n        })\r\n\r\n        // 计算属性，简单写法（只能读不能改）\r\n        person.fullName = computed(() => {\r\n            return person.firstName + '-' +person.lastName\r\n        })\r\n\r\n        // 计算属性，复杂写法（能读能改）\r\n        person.fullName = computed({\r\n            get() {\r\n                return person.firstName + '-' + person.lastName\r\n            },\r\n            set(value) {\r\n                const nameArr = value.split('-')\r\n                person.firstName = nameArr[0]\r\n                person.lastName = nameArr[1]\r\n            }\r\n        })\r\n\r\n        return {\r\n            person\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"28-监视函数watch",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#28-监视函数watch",children:"#"}),"2.8 监视函数watch"]}),"\n",(0,s.jsx)(e.p,{children:"==与vue2.x中的watch配置共一致=="}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"两个小“坑”："}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"==监视reactive定义的响应式数据时，oldValue无法正确获取，强制开启了深度监视（deep配置无效）=="}),"\n",(0,s.jsx)(e.li,{children:"==监视reactive定义的响应式数据中的某个属性（对象类型）时，deep配置有效=="}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"watch(prop, function, config)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"prop：要监视的变量"}),"\n",(0,s.jsx)(e.li,{children:"function：(newValue, oldValue) => {}，变量发生变化时的回调"}),"\n",(0,s.jsx)(e.li,{children:"config：是个对象，编写watch的一些配置，如{immediate: true; deep: true}，可以为空"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"具体代码"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"export default {\r\n    name: 'Demo',\r\n    props: ['msg'],\r\n    setup() {\r\n        // 定义数据库\r\n        let num = ref(0)\r\n        let msg = ref('hello')\r\n        let person = reactive({\r\n            name: '张三',\r\n            age: 18,\r\n            job: {\r\n                s1: {\r\n                    salary: 20\r\n                }\r\n            }\r\n        })\r\n\r\n        // 监视器\r\n        // 情况一：监视ref定义的一个响应式数据\r\n        watch(num, (newValue, oldValue) => {\r\n            console.log(`num发生了变化，新值是${newValue}，原来为${oldValue}`)\r\n        },{immediate: true})\r\n\r\n        // 情况二：监视ref定义的多个响应式数据\r\n        watch([num, msg], (newValue, oldValue) => {\r\n            console.log(`num或msg发生了变化，新值是${newValue}，原来为${oldValue}`)\r\n        })\r\n\r\n        /**\r\n         * 情况三：监视reactive定义的一个响应式数据的全部属性\r\n         * 1. 此处无法正确获取oldValue的值\r\n         * 2. 强制开启了深度监视模式（deep配置无效）\r\n         */\r\n        watch(person, (newValue, oldValue) => {\r\n            console.log('person发生了改变', newValue, oldValue)\r\n        },{deep: false})\r\n\r\n        /**\r\n         * 情况四：监视reactive定义的一个响应式数据的某个属性\r\n         * 此处可以拿到oldValue\r\n         */\r\n        watch(() => person.age, (newValue, oldValue) => {\r\n            console.log('person.age发生了改变', newValue, oldValue)\r\n        })\r\n\r\n        /**\r\n         * 情况五：监视reactive定义的一个响应式数据的某些属性\r\n         * 此处可以拿到oldValue\r\n         */\r\n        watch([() => person.age, () => person.name], (newValue, oldValue) => {\r\n            console.log('person.age或person.name发生了改变', newValue, oldValue)\r\n        })\r\n\r\n        /**\r\n         * 特殊情况\r\n         * 1. 此处拿不到oldValue\r\n         * 2. 此处必须配置deep为true才可以监测到person.job的变化\r\n         */\r\n        watch(() => person.job, (newValue, oldValue) => {\r\n            console.log('person.job发生了改变', newValue, oldValue)\r\n        },{deep: true})\r\n\r\n\r\n        return {\r\n            num,\r\n            msg,\r\n            person\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"29-监视函数watcheffect",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#29-监视函数watcheffect",children:"#"}),"2.9 监视函数watchEffect"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"和watch的对比"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"watch既要指明监视的属性，也要指明监视的回调"}),"\n",(0,s.jsx)(e.li,{children:"watchEffect不用指明监视的属性，监视回调函数中用到哪个属性，就会监视哪个属性"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"和computed的对比"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"watchEffect有点像computed，但二者有如下区别："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"computed注重的是计算出来的值（回调函数的返回值），所以必须要写返回值"}),"\n",(0,s.jsx)(e.li,{children:"watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"watchEffect(() => {})"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"具体代码"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"export default {\r\n    name: 'Demo',\r\n    props: ['msg'],\r\n    setup() {\r\n        // 定义数据库\r\n        let num = ref(0)\r\n        let msg = ref('hello')\r\n        let person = reactive({\r\n            name: '张三',\r\n            age: 18,\r\n            job: {\r\n                s1: {\r\n                    salary: 20\r\n                }\r\n            }\r\n        })\r\n\r\n        // 监视器\r\n        // 回调函数中用到了num和person.job.s1.salary，所以只要这俩值一发生变化，watchEffect的回调就会被触发\r\n        watchEffect(() => {\r\n            const x1 = num.value;\r\n            const x2 = person.job.s1.salary\r\n            console.log('watchEffect执行了')\r\n        })\r\n\r\n\r\n        return {\r\n            num,\r\n            msg,\r\n            person\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"210-生命周期",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#210-生命周期",children:"#"}),"2.10 生命周期"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220830155133893",src:c})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"注意"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Vue3.0可以继续使用Vue2.x中的生命周期钩子，但有两个被更名："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"beforeDestroy"}),"改名为",(0,s.jsx)(e.code,{children:"beforeUnmount"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"destroyed"}),"改名为",(0,s.jsx)(e.code,{children:"unmounted"})]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Vue3.0中Composition API形式的生命周期钩子，与Vue3.0中钩子对应如下"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"beforeCreate"}),"===>",(0,s.jsx)(e.code,{children:"setUp()"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"created"}),"===>",(0,s.jsx)(e.code,{children:"setUp()"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"beforeMount"}),"===>",(0,s.jsx)(e.code,{children:"onBeforeMount"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"mounted"}),"===>",(0,s.jsx)(e.code,{children:"onMounted"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"beforeUpdate"}),"===>",(0,s.jsx)(e.code,{children:"onBeforeUpdate"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"updated"}),"===>",(0,s.jsx)(e.code,{children:"onUpdated"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"beforeUnmount"}),"===>",(0,s.jsx)(e.code,{children:"onBeforeUnmount"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"unmounted"}),"===>",(0,s.jsx)(e.code,{children:"onUnmounted"})]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"211-自定义hook函数",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#211-自定义hook函数",children:"#"}),"2.11 自定义hook函数"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"概念"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"hook本质是一个函数，把setup函数中使用的Composition API进行了封装"}),"\n",(0,s.jsx)(e.li,{children:"类似于vue2.x中的mixin"}),"\n",(0,s.jsx)(e.li,{children:"自定义hook的优势：复用代码，让setup中的逻辑更清晰易懂"}),"\n",(0,s.jsx)(e.li,{children:"个人理解：抽取setup中的可以实现某个具体功能的代码，简化setup中的代码，同时也方便后期实现代码的复用"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"具体例子"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"==需求：获取鼠标点击的点的坐标=="}),"\n",(0,s.jsx)(e.p,{children:"步骤如下："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["创建",(0,s.jsx)(e.code,{children:"src/hooks"}),"文件夹，自定义的hook函数都存放在该路径下"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["在",(0,s.jsx)(e.code,{children:"src/hooks"}),"文件夹下，创建",(0,s.jsx)(e.code,{children:"usePoint.js"}),"文件(","一般hook函数的js文件命名方式均为useXXX.js",")"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["在",(0,s.jsx)(e.code,{children:"usePoint.js"}),"文件中编写函数实现逻辑，并将函数暴露出去，代码如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"import { reactive, onMounted, onBeforeUnmount} from 'vue'\r\nexport default function() {\r\n    // 数据：鼠标点击的点的坐标\r\n    let point = reactive({\r\n        x: 0,\r\n        y: 0\r\n    })\r\n\r\n    // 方法：获取鼠标点击的点的坐标\r\n    function getPoint(event) {\r\n        point.x = event.pageX\r\n        point.y = event.pageY\r\n    }\r\n\r\n    // 生命周期钩子：页面挂载时触发\r\n    onMounted(() => {\r\n        window.addEventListener('click', getPoint)\r\n    })\r\n\r\n    // 生命周期钩子：页面卸载时触发\r\n    onBeforeUnmount(() => {\r\n        window.removeEventListener('click', getPoint)\r\n    })\r\n\r\n    // 返回坐标\r\n    return point\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["使用",(0,s.jsx)(e.code,{children:"usePoint.js"}),"中的函数"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  \x3c!-- 显示点的坐标 --\x3e\r\n  <h2>坐标：（{{point.x}}, {{point.y}}）</h2>\r\n</template>\r\n\r\n<script>\r\n// 引入hook函数usePoint \r\nimport usePoint from '../hooks/usePoint'\r\nexport default {\r\n    name: 'Demo',\r\n    props: ['msg'],\r\n    setup() {\r\n        // 使用usePoint，并拿到点的坐标\r\n        let point = usePoint()\r\n\r\n        return {\r\n            num,\r\n            point\r\n        }\r\n    }\r\n}\r\n<\/script>\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"最终效果如下"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220830165134692",src:d})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"210-torefs",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#210-torefs",children:"#"}),"2.10 toRefs"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"创建一个ref对象，其value值指向另一个对象中的某个属性"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"const name = toRef(对象变量, '变量属性名')"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"应用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"要将响应式对象中的某个属性单独提供给外部使用时"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"扩展"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"toRefs"}),"和",(0,s.jsx)(e.code,{children:"toRef"}),"功能一致，但可以批量创建多个ref对象，语法：",(0,s.jsx)(e.code,{children:"toRefs(对象变量)"})]}),"\n",(0,s.jsxs)(e.p,{children:["==备注：==可以借助",(0,s.jsx)(e.code,{children:"toRefs"}),"函数，简化模板编码"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  \x3c!-- 页面中使用person的属性时，可以不再加'person.' --\x3e\r\n  <h2>用户信息</h2>\r\n  <h3>姓名：{{name}}</h3>\r\n  <h3>年龄：{{age}}</h3>\r\n  <h3>性别：{{sex}}</h3>\r\n  <h3>爱好：{{hobbies}}</h3>\r\n  <h3>手机号：{{phone}}</h3>\r\n  <h3>家庭住址：{{familyAddress}}</h3>\r\n  <h3>学校名称：{{collage}}</h3>\r\n  <h3>所学专业：{{major}}</h3>\r\n</template>\r\n\r\n<script>\r\nimport { reactive, toRefs } from '@vue/reactivity'\r\nexport default {\r\n    name: 'Demo',\r\n    setup() {\r\n        // 定义数据库\r\n        let person = reactive({\r\n            name: '张三',\r\n            age: 18,\r\n            sex: '男',\r\n            hobbies: ['吃饭', '睡觉'],\r\n            phone: '130XXXXXXXX',\r\n            familyAddress: '山东省济南市XXXX',\r\n            collage: '山东大学',\r\n            major: '会计'\r\n        })\r\n\r\n        return {\r\n            ...toRefs(person) // 此处使用了toRefs()组合API\r\n        }\r\n    }\r\n}\r\n<\/script>\n"})}),"\n",(0,s.jsxs)(e.h1,{id:"3其他composition-api",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3其他composition-api",children:"#"}),"3.其他Composition API"]}),"\n",(0,s.jsxs)(e.h2,{id:"31-shallowreactive与shallowref",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#31-shallowreactive与shallowref",children:"#"}),"3.1 shallowReactive与shallowRef"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"shallowReactive"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"只处理对象最外层属性的响应式（浅响应式）"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"shallowRef"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"只处理基本数据类型的响应式，不进行对象的响应式处理"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"let person1 = shallowRef({...})\r\nlet person2 = shallowReactive({...})\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用场景"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"shallowReactive：当一个对象结构比较深，但是只有外层属性才会发生变化"}),"\n",(0,s.jsx)(e.li,{children:"shallowRef：如果一个对象有数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"32-readonly与shallowreadonly",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#32-readonly与shallowreadonly",children:"#"}),"3.2 readonly与shallowReadonly"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"readonly"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"让一个响应式的数据变为只读（深只读）"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"shallowReadonly"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"让一个响应式数据变为只读（浅只读）"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 定义响应式变量\r\nlet person = reactive({...})\r\n// 深只读\r\nperson = readonly(person)\r\n// 浅只读\r\nperson = shallowReadonly(person)\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"应用场景"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"不希望数据被修改时"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"readonly与shallowReadonly也可以用来定义数据，但是定义出来的数据不是响应式的。如果想让响应式的数据变为只读，只能先用ref或reactive定义数据，然后再用readonly或者shallowReadonly定义数据变为只读。"}),"\n",(0,s.jsxs)(e.h2,{id:"33-toraw与markrow",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#33-toraw与markrow",children:"#"}),"3.3 toRaw与markRow"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"toRaw"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["作用：将一个由",(0,s.jsx)(e.code,{children:"reactive"}),"生成的","响应式对象","转为","普通对象"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的操作，不会引起页面刷新"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"let person = reactive({...})\r\nconst p = toRaw(person)\r\n// 之后对p做的修改，不会引起页面变化\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"markRow"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"作用：标记一个对象，使其永远不会再成为响应式对象"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用场景："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"1.有些值不应该被设置为响应式的，例如复杂的第三方类库"}),"\n",(0,s.jsx)(e.li,{children:"2.当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"语法："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"let person = markRow({...})\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"34-customref",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#34-customref",children:"#"}),"3.4 customRef"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"/**\r\n* @param trace 函数，通知Vue追踪value的变化。在get()中直接调用即可\r\n* @param trigger 函数， 通知Vue重新解析模板。在set()中直接调用即可\r\n* @return 返回值是一个对象。该对象包含get()(用来获取数据)、set()(用来修改数据)方法 \r\n*/\r\ncustomRef((trace, trigger) => {\r\n    return {\r\n        // 获取数据\r\n        get() {\r\n            trace() // 通知Vue追踪value的变化\r\n            return value\r\n        },\r\n        // 修改数据\r\n        set(newValue) {\r\n            clearTimeout(timer) //每次进来先清除一下定时器，防止页面抖动\r\n            timer = setTimeout(() => {\r\n                value = newValue\r\n                trigger() // 通知Vue重新解析模板\r\n            }, delay);\r\n        }\r\n    }\r\n})\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"栗子：自定义ref，实现防抖效果"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  <input type=\"text\" v-model=\"keyWord\">\r\n  <h3>{{keyWord}}</h3>\r\n</template>\r\n\r\n<script>\r\nimport {customRef} from 'vue'\r\n\r\nexport default {\r\n  name: 'App',\r\n  setup() {\r\n    let keyWord = myRef('hello', 1000) \r\n\r\n    // 自定义ref\r\n    function myRef(value, delay) {\r\n      let timer; // 定时器id\r\n      return customRef((trace, trigger) => {\r\n        return {\r\n          // 获取数据\r\n          get() {\r\n            trace() // 通知Vue追踪value的变化\r\n            return value\r\n          },\r\n          // 修改数据\r\n          set(newValue) {\r\n            clearTimeout(timer) //每次进来先清除一下定时器，防止页面抖动\r\n            timer = setTimeout(() => {\r\n              value = newValue\r\n              trigger() // 通知Vue重新解析模板\r\n            }, delay);\r\n          }\r\n        }\r\n      })\r\n    }\r\n    return {\r\n      keyWord,\r\n      myRef\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n\r\n<style>\r\n#app {\r\n  font-family: Avenir, Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  /* text-align: center; */\r\n  color: #2c3e50;\r\n  margin: 20px;\r\n}\r\n</style>\r\n\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"35-provide与inject",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#35-provide与inject",children:"#"}),"3.5 provide与inject"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"image-20220906164035052",src:t})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"实现==祖组件与后代组件间==通信"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["组组件中用",(0,s.jsx)(e.code,{children:"provide"}),"选项提供数据，后代组件用",(0,s.jsx)(e.code,{children:"inject"}),"选线来接收数据"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"语法"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"祖组件："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"setup() {\r\n	...\r\n    let car = reactive({name: '比亚迪\xb7汉', price: '25W'})\r\n    /**\r\n    * 使用provide提供数据\r\n    * 第一个参数：要传递的数据的名。inject函数使用该值来接收参数\r\n    * 第二个参数：要传递的数据的值\r\n    */\r\n    provide('car', car)\r\n    ...\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"后代组件："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"setup() {\r\n   ...\r\n   /**\r\n   * 使用inject接收数据\r\n   * 参数 祖组件中provide函数的第一个参数的值\r\n   */\r\n   let car = inject('car')\r\n    ...\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"36-响应式数据的判断",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#36-响应式数据的判断",children:"#"}),"3.6 响应式数据的判断"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["isRef：检查一个值是否为一个",(0,s.jsx)(e.code,{children:"ref"}),"对象"]}),"\n",(0,s.jsxs)(e.li,{children:["isReactive ：检查一个对象是否是由",(0,s.jsx)(e.code,{children:"reactive"}),"创建的响应式代理"]}),"\n",(0,s.jsxs)(e.li,{children:["isReadonly：检查一个对象是否是由",(0,s.jsx)(e.code,{children:"readonly"}),"创建的只读代理"]}),"\n",(0,s.jsxs)(e.li,{children:["isProxy：检查一个对象是否是由",(0,s.jsx)(e.code,{children:"reactive"}),"或者",(0,s.jsx)(e.code,{children:"readonly"}),"创建的代理"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"4composition-api的优势",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4composition-api的优势",children:"#"}),"4.Composition API的优势"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Options API 存在的问题"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"使用传统Options API时，新增或者修改一个需求，就需要在data、methods、computed等中分别进行修改"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Composition API的优势"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"可以自定义hook函数，更加优雅的组织代码，让功能相关的数据和函数更加有序的组织在一起"}),"\n",(0,s.jsxs)(e.h1,{id:"5新的组件",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5新的组件",children:"#"}),"5.新的组件"]}),"\n",(0,s.jsxs)(e.h2,{id:"51-fragment",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#51-fragment",children:"#"}),"5.1 Fragment"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"在vue2中：组件必须有一个根标签"}),"\n",(0,s.jsx)(e.li,{children:"在Vue3中：组件可以没有根标签。当不写根标签时，vue会将多个标签包含在一个Fragment虚拟元素中"}),"\n",(0,s.jsx)(e.li,{children:"好处：减少标签层级，减少内存占用（理论上）"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"52-teleport",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#52-teleport",children:"#"}),"5.2 teleport"]}),"\n",(0,s.jsxs)(e.p,{children:["==",(0,s.jsx)(e.code,{children:"teleport"}),"是将组件html结构移动到指定位置=="]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"\x3c!-- to的值可以是html标签（如html、body），也可以是css选择器 --\x3e\r\n<teleport to='指定位置' >\r\n	\x3c!-- html结构 --\x3e\r\n</teleport>xxxxxxxxxx\xa0<<teleport to='' > \xa0 \xa0 \xa0 \xa0\x3c!-- html结构 --\x3e \xa0 \xa0</teleport>\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"53-suspense",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#53-suspense",children:"#"}),"5.3 Suspense"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用场景"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["等待","异步组件","时渲染一些额外内容，让应用有更好的用户体验"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"使用步骤"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"异步引入组件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"import {defineAsyncComponent} from 'vue'\r\nlet Son = defineAsyncComponent(()=>import('./components/Son'))\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["使用",(0,s.jsx)(e.code,{children:"Suspense"}),"包裹组件，并配置好",(0,s.jsx)(e.code,{children:"default"}),"和",(0,s.jsx)(e.code,{children:"fallback"}),"插槽"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"default：默认插槽。组件往这里边放"}),"\n",(0,s.jsx)(e.li,{children:"fallback：由于各种原因，插槽未加载出来的提示信息往这里边放"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<Suspense>\r\n    <template v-slot:default>\r\n		<Son/>\r\n    </template>\r\n    <template v-slot:fallback>\r\n		加载中，请稍后\r\n    </template>\r\n</Suspense>\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"完整栗子"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"APP 组件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  <div class=\"app\">\r\n    <h2>我是APP组件</h2>\r\n    <Suspense>\r\n      <template v-slot:default>\r\n        <Son/>\r\n      </template>\r\n      <template v-slot:fallback>\r\n        加载中，请稍后\r\n      </template>\r\n    </Suspense>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport {defineAsyncComponent} from 'vue'\r\nlet Son = defineAsyncComponent(()=>import('./components/Son'))\r\n\r\nexport default {\r\n  name: 'App',\r\n  components: {Son},\r\n  \r\n}\r\n<\/script>\r\n\r\n<style>\r\n.app {\r\n background-color: gray;\r\n padding: 10px;\r\n}\r\n</style>\r\n\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Son组件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:"<template>\r\n  <div class=\"son\">\r\n    我是子组件\r\n    {{sum}}\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ref } from 'vue';\r\n    import Grandson from './Grandson.vue';\r\n    export default {\r\n        name: 'Son',\r\n        components: {Grandson},\r\n        // 为了使组件延迟加载，setup返回值是一个Promise对象\r\n        async setup() {\r\n            let sum = ref(0)\r\n            let p = new Promise((resolve, reject) => {\r\n                setTimeout(() => {\r\n                    resolve({sum})\r\n                }, 3000);\r\n            })\r\n\r\n            return await p\r\n        }\r\n    }\r\n<\/script>\r\n\r\n<style scpoed>\r\n.son {\r\n    background-color: aquamarine;\r\n    padding: 10px;\r\n    margin-top:10px;\r\n}\r\n</style>\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"6vue30和vue2x对比",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6vue30和vue2x对比",children:"#"}),"6.Vue3.0和Vue2.x对比"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==全局API的转移=="}),"\n",(0,s.jsx)(e.p,{children:"Vue3.0将Vue2.x中的全局API（Vue.xxx）调整到了应用实例（app）上"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Vue2.x全局API（Vue）"}),(0,s.jsx)(e.th,{children:"Vue3.0实例API（app）"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.config.xxx"}),(0,s.jsx)(e.td,{children:"app.config.xxx"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.config.productionTip"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"移除"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.component"}),(0,s.jsx)(e.td,{children:"app.component"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.directive"}),(0,s.jsx)(e.td,{children:"app.directive"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.mixin"}),(0,s.jsx)(e.td,{children:"app.mixin"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.use"}),(0,s.jsx)(e.td,{children:"app.use"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Vue.prototype"}),(0,s.jsx)(e.td,{children:"app.config.globalProperties"})]})]})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==data选项应始终被声明为一个函数=="}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==过渡（动画）类名的改变=="}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Vue2.x"}),(0,s.jsx)(e.th,{children:"Vue3.0"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"v-enter"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"v-enter-from"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"v-leave-to"}),(0,s.jsx)(e.td,{children:"v-leave-to"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"v-leave"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"v-leave-from"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"v-enter-to"}),(0,s.jsx)(e.td,{children:"v-enter-to"})]})]})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==移除keyCode作为v-on的修饰符，同时也不再支持config.keyCode=="}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==移除v-on.native修饰符，自定义事件用emits属性配置=="}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"父组件中绑定事件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-vue",meta:"",children:'<my-component \r\n              v-on:close = "handleComponentEvent"\r\n              v-on:click = "handleNativeClickEvent"\r\n/>\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"子组件中声明自定义事件"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"export default {\r\n    ...\r\n    emits: ['close']\r\n    ...\r\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"==移除过滤器filter=="}),"\n",(0,s.jsxs)(e.p,{children:["过滤器虽然看起来方便，但它需要一个自定义语法，打破大括号内表达式“只是JavaScript”的假设，这不仅有学习成本，还有实现成本！  ",(0,s.jsx)(e.strong,{children:"建议用方法调用或者计算属性去替换过滤器。"})]}),"\n"]}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(h,n)})):h(n)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["tang%2FVue%2F3.md"]={toc:[{id:"11-使用vue-cli创建",text:"1.1 使用vue-cli创建",depth:2},{id:"12使用vite创建",text:"1.2使用vite创建",depth:2},{id:"13-分析工程结构",text:"1.3 分析工程结构",depth:2},{id:"21-拉开序幕的setup",text:"2.1 拉开序幕的setup",depth:2},{id:"22-ref函数",text:"2.2 ref函数",depth:2},{id:"23-reactive函数",text:"2.3 reactive函数",depth:2},{id:"24-vue30中的响应式原理",text:"2.4 Vue3.0中的响应式原理",depth:2},{id:"25-setup的两个注意点",text:"2.5 setup的两个注意点",depth:2},{id:"26-reactive对比ref",text:"2.6 reactive对比ref",depth:2},{id:"27-计算函数computed",text:"2.7 计算函数computed",depth:2},{id:"28-监视函数watch",text:"2.8 监视函数watch",depth:2},{id:"29-监视函数watcheffect",text:"2.9 监视函数watchEffect",depth:2},{id:"210-生命周期",text:"2.10 生命周期",depth:2},{id:"211-自定义hook函数",text:"2.11 自定义hook函数",depth:2},{id:"210-torefs",text:"2.10 toRefs",depth:2},{id:"31-shallowreactive与shallowref",text:"3.1 shallowReactive与shallowRef",depth:2},{id:"32-readonly与shallowreadonly",text:"3.2 readonly与shallowReadonly",depth:2},{id:"33-toraw与markrow",text:"3.3 toRaw与markRow",depth:2},{id:"34-customref",text:"3.4 customRef",depth:2},{id:"35-provide与inject",text:"3.5 provide与inject",depth:2},{id:"36-响应式数据的判断",text:"3.6 响应式数据的判断",depth:2},{id:"51-fragment",text:"5.1 Fragment",depth:2},{id:"52-teleport",text:"5.2 teleport",depth:2},{id:"53-suspense",text:"5.3 Suspense",depth:2}],title:"Vue3快速入门",headingTitle:"Vue3快速入门",frontmatter:{}}}}]);