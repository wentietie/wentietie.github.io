"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["1095"],{71846:function(r,n,e){e.r(n),e.d(n,{default:function(){return i}});var s=e(85893),t=e(50065);function o(r){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",ul:"ul",li:"li"},(0,t.ah)(),r.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"class-的继承",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#class-的继承",children:"#"}),"Class 的继承"]}),"\n",(0,s.jsxs)(n.h2,{id:"简介",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简介",children:"#"}),"简介"]}),"\n",(0,s.jsx)(n.p,{children:"Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",meta:"",children:"class Point {\r\n}\r\nclass ColorPoint extends Point {\r\n}\r\n\r\n/**\r\n * 上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。\r\n * 但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。\r\n * 下面，我们在 ColorPoint 内部加上代码。\r\n */\r\n\r\nclass ColorPoint extends Point {\r\n    constructor(x, y, color) {\r\n        super(x, y); // 调用父类的constructor(x, y)\r\n        this.color = color;\r\n    }\r\n    toString() {\r\n        return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n    }\r\n}\r\n\r\n/**\r\n * 上面代码中， constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。\r\n */\n"})}),"\n",(0,s.jsx)(n.p,{children:"子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。\r\n在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",meta:"",children:"class Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    this.color = color; // ReferenceError\r\n    super(x, y);\r\n    this.color = color; // 正确\r\n  }\r\n}\r\n\r\nlet cp = new ColorPoint(25, 8, 'green');\r\ncp instanceof ColorPoint // true\r\ncp instanceof Point // true\n"})}),"\n",(0,s.jsx)(n.p,{children:"父类的静态方法，也会被子类继承。"}),"\n",(0,s.jsxs)(n.h2,{id:"objectgetprototypeof",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectgetprototypeof",children:"#"}),"Object.getPrototypeOf()"]}),"\n",(0,s.jsx)(n.p,{children:"Object.getPrototypeOf 方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Object.getPrototypeOf(ColorPoint) === Point"})}),"\n",(0,s.jsxs)(n.h2,{id:"super-关键字",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#super-关键字",children:"#"}),"super 关键字"]}),"\n",(0,s.jsx)(n.p,{children:"super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",meta:"",children:"class A {}\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * 上面代码中，子类 B 的构造函数之中的 super() ，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\r\n * 注意， super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B 的实例，\r\n * 因此 super() 在这里相当于 A.prototype.constructor.call(this) 。\r\n */\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",meta:"",children:"class A {\r\n  p() {\r\n    return 2;\r\n  }\r\n}\r\nclass B extends A {\r\n  constructor() {\r\n    super();\r\n    console.log(super.p()); // 2\r\n  }\r\n}\r\nlet b = new B();\r\n/**\r\n * ES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。\r\n */\r\nclass A {\r\n    constructor() {\r\n        this.x = 1;\r\n    }\r\n    print() {\r\n        console.log(this.x);\r\n    }\r\n}\r\nclass B extends A {\r\n    constructor() {\r\n        super();\r\n        this.x = 2;\r\n    }\r\n    m() {\r\n        super.print();\r\n    }\r\n}\r\nlet b = new B();\r\nb.m() // \n"})})]})}function c(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),r.components);return n?(0,s.jsx)(n,Object.assign({},r,{children:(0,s.jsx)(o,r)})):o(r)}let i=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["JavaScript%2Fes6%2Fes6-16.md"]={toc:[{id:"简介",text:"简介",depth:2},{id:"objectgetprototypeof",text:"Object.getPrototypeOf()",depth:2},{id:"super-关键字",text:"super 关键字",depth:2}],title:"Class 的继承",headingTitle:"Class 的继承",frontmatter:{}}}}]);