"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["3374"],{44716:function(n,r,e){e.r(r),e.d(r,{default:()=>d});var t=e("85893"),s=e("50065");let l=e.p+"static/image/14_tcpfour.185aea84.png",c=e.p+"static/image/14_tcpthree.0d4443ab.png";function i(n){let r=Object.assign({h1:"h1",a:"a",h3:"h3",blockquote:"blockquote",p:"p",ul:"ul",li:"li",code:"code",pre:"pre",strong:"strong",img:"img"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.h1,{id:"14-网络编程",children:["14 网络编程",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#14-网络编程",children:"#"})]}),"\n",(0,t.jsxs)(r.h3,{id:"141--通信要素1ip和端口号",children:["14.1  通信要素1：IP和端口号",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#141--通信要素1ip和端口号",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"IP地址：InetAddress"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"作用：用来唯一标识Internet上的计算机"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"在Java中使用InetAddress类代表IP"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"IP地址分类1"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"IPV4："}),"\n",(0,t.jsx)(r.li,{children:"IPV6："}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"IP地址分类2"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"公网地址（万维网使用）"}),"\n",(0,t.jsx)(r.li,{children:"私有地址（局域网使用）"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"本地回路地址：127.0.0.1  对应着localhost"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"InetAddress类的使用"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"实例化"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"InetAddress getByName(String host)"}),"：根据指定host获取InetAddress对象。host可以是ip地址，也可以是域名"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"InetAddress getLocalHost()"}),"：获取本机InetAddress对象"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"两个常用方法"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getHostName()"}),"：获取InetAddress对象的主机名"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getHostAddress()"}),"：获取InetAddress对象的ip地址"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"示例"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Test\r\npublic void test1() {\r\n    try {\r\n        InetAddress inte1 = InetAddress.getByName("192.168.23.37");\r\n        System.out.println(inte1);// /192.168.23.37\r\n\r\n        InetAddress inte2 = InetAddress.getByName("www.baidu.com");\r\n        System.out.println(inte2);// www.baidu.com/180.101.49.13\r\n\r\n        InetAddress inet3 = InetAddress.getLocalHost();\r\n        System.out.println(inet3); // tangtianhua00/192.168.23.37\r\n\r\n        String hostName = inet3.getHostName();\r\n        System.out.println(hostName);// tangtianhua00\r\n\r\n        String hostAddress = inet3.getHostAddress();\r\n        System.out.println(hostAddress);// 192.168.23.37\r\n    } catch (UnknownHostException e) {\r\n        e.printStackTrace();\r\n    }\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"端口号"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"作用：标识正在计算机上正在运行的程序"}),"\n",(0,t.jsx)(r.li,{children:"不同的进程对应不同的端口号"}),"\n",(0,t.jsx)(r.li,{children:"端口号的范围：0~65535"}),"\n",(0,t.jsxs)(r.li,{children:["端口分类：","\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"公认端口：0~1023，被预先定义的服务通信占用"}),"\n",(0,t.jsx)(r.li,{children:"注册端口：1024，分配给用户进程或应用程序"}),"\n",(0,t.jsx)(r.li,{children:"动态/私有端口：49152~65535"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.li,{children:"端口号和IP地址的组合得出一个网络套接字：Socket"}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"142-通信要素2网络协议",children:["14.2 通信要素2：网络协议",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#142-通信要素2网络协议",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"通信协议分层的思想"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"同层间可以通信，上一层可以调用下一层，隔层不可以通信"}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"TCP/IP协议簇"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"传输层协议中有两个非常重要的协议"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"传输控制协议TCP"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"实用TCP协议前，须先建立TCP连接，行程传输数据通道"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["传输前，采用“",(0,t.jsx)(r.strong,{children:"三次握手"}),"”方式，",(0,t.jsx)(r.strong,{children:"点对点通信"}),"，",(0,t.jsx)(r.strong,{children:"是可靠的"})]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"第一次握手：客户端发送syn报文，并置发送序号为X"}),"\n",(0,t.jsx)(r.li,{children:"第二次握手：服务端发送syn+ACK报文，并置发送序号为Y，在确认序号为X+1"}),"\n",(0,t.jsx)(r.li,{children:"第三次握手：客户端发送ACK报文，并置发送序号为Z，在确认序号为Y+1"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"TCP协议进行通信的两个应用进程：客户端、服务端"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["在连接中可以",(0,t.jsx)(r.strong,{children:"进行大数据量的传输"})]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["传输完毕，需",(0,t.jsx)(r.strong,{children:"释放已建立的连接，效率低"}),"。释放连接需要经历“",(0,t.jsx)(r.strong,{children:"四次挥手"}),"”"]}),"\n",(0,t.jsx)(r.p,{children:"挥手时，客户端和服务端都可以开始挥手，但是一般都是客户端主动挥手，断开连接"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"第一次挥手：主动方发送Fin+ACK报文，并置发送序号为X"}),"\n",(0,t.jsx)(r.li,{children:"第二次挥手：被动方发送ACK报文，并置发送序号为Z，在确认序号为X+1"}),"\n",(0,t.jsx)(r.li,{children:"第三次挥手：被动方发送Fin+ACK报文，并置发送序号为Y，在确认序号为X（此时已经断开连接）"}),"\n",(0,t.jsx)(r.li,{children:"第四次挥手：主动方发送ACK报文，并置发送序号为X，在确认序号为Y（此步骤就是为了去验证是否真的断开连接）"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"用户数据报协议UDP"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["将数据、源、目的封装成数据包，",(0,t.jsx)(r.strong,{children:"不需要建立连接"})]}),"\n",(0,t.jsx)(r.li,{children:"每个数据报的大小限制在64K内"}),"\n",(0,t.jsxs)(r.li,{children:["发送不管对方是否准备好，接收方收到也不需要确认，故",(0,t.jsx)(r.strong,{children:"是不可靠的"})]}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"可以广播发送"})}),"\n",(0,t.jsxs)(r.li,{children:["发送数据结束时",(0,t.jsx)(r.strong,{children:"无需释放资源，开销小，速度快"})]}),"\n",(0,t.jsx)(r.li,{children:"应用场景：可以接受一部分数据的丢失，比如看网络视频，可以接受一部分帧的丢失，但是不能接受卡顿。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"TCP/IP以其两个主要协议传输控制协议（TCP）和网络互联协议（IP）而得名。实际上是一组协议，包括多个具有不同功能且互为关联的协议"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"IP协议是网络层的主要协议，支持网络间互连的数据通信"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即","物理链路层、IP层、传输层、应用层"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"143-tcp网络编程",children:["14.3 TCP网络编程",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#143-tcp网络编程",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"例1. 客户端发送信息给服务端，服务端将接收到的数据显示在控制台"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"【重点难点】：熟悉客户端、服务端Socket的使用"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'/**\r\n     * 客户端\r\n     */\r\n@Test\r\npublic void client() {\r\n    Socket socket = null;\r\n    OutputStream os = null;\r\n    try {\r\n        // 1.创建Socket对象，指明服务器端的IP和端口号\r\n        String serverIp = "127.0.0.1";\r\n        int serverPort = 8899;\r\n        InetAddress serverInet = InetAddress.getByName(serverIp);\r\n        socket = new Socket(serverInet, serverPort);\r\n\r\n        // 2.获取一个输出流，用于输出数据\r\n        os = socket.getOutputStream();\r\n        // 3.输出数据\r\n        os.write("你好，我是客户端".getBytes());\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 4.关闭资源\r\n        if (null != os) {\r\n            try {\r\n                os.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != socket) {\r\n            try {\r\n                socket.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n     * 服务端\r\n     */\r\n@Test\r\npublic void server() {\r\n    ServerSocket ss = null;\r\n    Socket socket = null;\r\n    InputStream is = null;\r\n    ByteArrayOutputStream baos = null;\r\n    try {\r\n        // 1.创建服务端Socket-ServerSocket，指明自己的端口号\r\n        ss = new ServerSocket(8899);\r\n        // 2.调用accept()，接收来自于客户端的Socket\r\n        socket = ss.accept();\r\n        // 3.获取输入流，用于接收数据\r\n        is = socket.getInputStream();\r\n\r\n        // 4.读取输入流中的数据\r\n        // 方式一：不建议使用，可能会有乱码\r\n        //        byte[] buff = new byte[1024];\r\n        //        int len;\r\n        //        while ((len = is.read(buff)) != -1) {\r\n        //            String str = new String(buff, 0, len);\r\n        //            System.out.println(str);\r\n        //        }\r\n\r\n        // 方式二：推荐\r\n        baos = new ByteArrayOutputStream();\r\n        byte[] buffer = new byte[5];\r\n        int len;\r\n        while ((len = is.read(buffer)) != -1) {\r\n            baos.write(buffer, 0, len);\r\n        }\r\n\r\n        System.out.println(baos.toString());\r\n        System.out.println("收到了来自于"+socket.getInetAddress().getHostAddress()+"的数据");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 5.关闭资源\r\n        if (null != baos) {\r\n            try {\r\n                baos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != is) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != socket) {\r\n            try {\r\n                socket.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != ss) {\r\n            try {\r\n                ss.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"例2. 从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"【重点难点】"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用Socket发送、接收图片"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"服务端给用户端发送反馈，客户端接收"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'/**\r\n * 客户端\r\n */\r\n@Test\r\npublic void client() {\r\n    Socket socket = null;\r\n    OutputStream os = null;\r\n    BufferedInputStream bis = null;\r\n    InputStream is = null;\r\n    ByteArrayOutputStream baos = null;\r\n    try {\r\n        // 给服务端发送图片\r\n        String serverIp = "127.0.0.1";\r\n        int serverPort = 9900;\r\n        socket = new Socket(InetAddress.getByName(serverIp), serverPort);\r\n        os = socket.getOutputStream();\r\n        bis = new BufferedInputStream(new FileInputStream("big.png"));\r\n        byte[] buff = new byte[1024];\r\n        int len;\r\n        while ((len = bis.read(buff)) != -1) {\r\n            os.write(buff, 0, len);\r\n        }\r\n\r\n        // 关闭socket数据的输出，目的是通知客户端数据发送终止\r\n        socket.shutdownOutput();\r\n        // 接收服务端的反馈，并打印到控制台\r\n        is = socket.getInputStream();\r\n        baos = new ByteArrayOutputStream();\r\n        byte[] buff2 = new byte[10];\r\n        int len2;\r\n        while ((len2 = is.read(buff2)) != -1) {\r\n            System.out.println(buff2.length + "-" + len2);\r\n            baos.write(buff2, 0, len2);\r\n        }\r\n        System.out.println(baos.toString());\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != baos) {\r\n            try {\r\n                baos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        if (null != is) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        if (null != bis) {\r\n            try {\r\n                bis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != os) {\r\n            try {\r\n                os.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != socket) {\r\n            try {\r\n                socket.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 服务端\r\n */\r\n@Test\r\npublic void server() {\r\n    ServerSocket ss = null;\r\n    Socket socket = null;\r\n    InputStream is = null;\r\n    BufferedOutputStream bos = null;\r\n    OutputStream os = null;\r\n    try {\r\n        // 接收客户端发送来的图片，并保存到本地\r\n        ss = new ServerSocket(9900);\r\n        socket = ss.accept();\r\n        is = socket.getInputStream();\r\n        Date date = new Date();\r\n        bos = new BufferedOutputStream(new FileOutputStream(date.getTime()+".png"));\r\n        byte[] buff = new byte[1024];\r\n        int len;\r\n        // read()是一个阻塞式的方法。如果客户端socket不停止发送数据，服务端就会一直等待\r\n        while ((len = is.read(buff)) != -1) {\r\n            bos.write(buff, 0, len);\r\n        }\r\n\r\n        // 服务端给客户端反馈\r\n        os = socket.getOutputStream();\r\n        os.write("图片保存成功！".getBytes());\r\n\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != os) {\r\n            try {\r\n                os.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        if (null != bos) {\r\n            try {\r\n                bos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != is) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != socket) {\r\n            try {\r\n                socket.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != ss) {\r\n            try {\r\n                ss.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.h3,{id:"144-udp网络编程",children:["14.4 UDP网络编程",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#144-udp网络编程",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"例1. 接收端接收发送端发送的消息，并打印"}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'/**\r\n     * 发送端\r\n     */\r\n@Test\r\npublic void sender() {\r\n    DatagramSocket socket = null;\r\n    try {\r\n        socket = new DatagramSocket();\r\n\r\n        InetAddress inet = InetAddress.getByName("127.0.0.1");\r\n\r\n        String str = "我是UDP方式发送的导弹";\r\n        byte[] data = str.getBytes();\r\n        DatagramPacket packet = new DatagramPacket(data, 0, data.length, inet, 9090);\r\n\r\n        socket.send(packet);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != socket) {\r\n            socket.close();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n     * 接收端\r\n     */\r\n@Test\r\npublic void receiver(){\r\n    DatagramSocket socket = null;\r\n    try {\r\n        socket = new DatagramSocket(9090);\r\n\r\n        byte[] buffer = new byte[100];\r\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\r\n        socket.receive(packet);\r\n\r\n        System.out.println(new String(packet.getData(), 0, packet.getLength()));\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (null != socket) {\r\n            socket.close();\r\n        }\r\n    }\r\n\r\n}\n'})}),"\n",(0,t.jsxs)(r.h3,{id:"145-url编程",children:["14.5 URL编程",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#145-url编程",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"URL"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"URL：统一资源定位符，它表示Internet上某一资源的地址"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"URL的基本结构由5部分组成："}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"<传输协议>://<主机名>:<端口号>/<资源地址>?参数列表"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"URL构造器与常用方法"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"URL(String spec)"}),"：构造器"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getProtocol()"}),"：获取URL的协议名"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getHost()"}),"：获取URL的主机名"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"int getPort()"}),"：获取URL的端口号"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getPath()"}),"：获取URL的文件路径"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getFile()"}),"：获取URL的文件名"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"String getQuery()"}),"：获取URL中的参数"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Test\r\npublic void test() throws MalformedURLException {\r\n    URL url = new URL("http://localhost:8080/examples/beauty.jpg?username=tth&password=123456");\r\n    // 获取URL的协议名\r\n    System.out.println(url.getProtocol()); // http\r\n    // 获取URL的主机名\r\n    System.out.println(url.getHost()); // localhost\r\n    // 获取URL的端口号\r\n    System.out.println(url.getPort()); // 8080\r\n    // 获取URL的文件路径\r\n    System.out.println(url.getPath()); // /examples/beauty.jpg\r\n    // 获取URL的文件名\r\n    System.out.println(url.getFile()); // /examples/beauty.jpg?username=tth&password=123456\r\n    // 获取URL的参数\r\n    System.out.println(url.getQuery()); // username=tth&password=123456\r\n}\n'})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"例1. 从url中下载图片并保存到本地"}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Test\r\npublic void test2() {\r\n    HttpURLConnection urlConnection = null;\r\n    InputStream is = null;\r\n    FileOutputStream fos = null;\r\n    try {\r\n        // 1.实例化url\r\n        URL url = new URL("http://localhost:8080/examples/lbxx.jpg?username=tth&password=123456");\r\n\r\n        // 2.获取HTTP连接\r\n        urlConnection = (HttpURLConnection) url.openConnection();\r\n\r\n        // 3.连接\r\n        urlConnection.connect();\r\n\r\n        // 4.获取流，下载url中的文件，保存到本地\r\n        is = urlConnection.getInputStream();\r\n        fos = new FileOutputStream("lbxx.jpg");\r\n        byte[] buff = new byte[1024];\r\n        int len;\r\n        while ((len = is.read(buff)) != -1) {\r\n            fos.write(buff, 0, len);\r\n        }\r\n\r\n        System.out.println("图片保存成功！");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        // 5.关闭资源\r\n        if (null != fos) {\r\n            try {\r\n                fos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != is) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        if (null != urlConnection) {\r\n            urlConnection.disconnect();\r\n        }\r\n    }\r\n}\n'})})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),n.components);return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(i,{...n})}):i(n)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["tang%2Fjava2%2F14_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.md"]={toc:[{text:"14.1  通信要素1：IP和端口号",id:"141--通信要素1ip和端口号",depth:3},{text:"14.2 通信要素2：网络协议",id:"142-通信要素2网络协议",depth:3},{text:"14.3 TCP网络编程",id:"143-tcp网络编程",depth:3},{text:"14.4 UDP网络编程",id:"144-udp网络编程",depth:3},{text:"14.5 URL编程",id:"145-url编程",depth:3}],title:"14 网络编程",frontmatter:{}}}}]);