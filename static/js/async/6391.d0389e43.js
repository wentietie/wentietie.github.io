"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["6391"],{35950:function(n,e,r){r.r(e),r.d(e,{default:()=>k});var i=r("85893"),s=r("50065");let l=r.p+"static/image/image-20211227134632163.701f45bc.png",d=r.p+"static/image/image-20211227134217772.71bd0f57.png",c=r.p+"static/image/image-20211227175645777.8dfd8783.png",a=r.p+"static/image/image-20211228111016993.2790a880.png",t=r.p+"static/image/image-20211228111041720.68e93c35.png",h=r.p+"static/image/image-20211228111100399.3aa12af8.png",o=r.p+"static/image/image-20211228111131977.dcc00ec7.png",x=r.p+"static/image/image-20211228111149199.effb0664.png",j=r.p+"static/image/image-20211228111201555.2d2df939.png",p=r.p+"static/image/image-20211228142017753.7832cad6.png",u=r.p+"static/image/image-20211229173735944.f80b74dd.png",m=r.p+"static/image/image-20211229175126825.915bfb8c.png",g=r.p+"static/image/image-20211229164242551.894ea27d.png",v=r.p+"static/image/image-20211229171630731.6a9b60da.png",b=r.p+"static/image/image-20211230102634432.52724372.png",f=r.p+"static/image/image-20211230144621521.d64a52ed.png",S=r.p+"static/image/image-20211230145041397.17d1916b.png",N=r.p+"static/image/image-20211231154953574.b4fd2ffd.png",y=r.p+"static/image/image-20220104150119181.6957a0b9.png",A=r.p+"static/image/image-20220104160107383.8d7b19b4.png",C=r.p+"static/image/image-20220105111056369.121cf857.png",T=r.p+"static/image/image-20220104221343947.df0fcc01.png";function O(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",h3:"h3",h4:"h4",strong:"strong",code:"code",img:"img",pre:"pre",h5:"h5"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"19-设计模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#19-设计模式",children:"#"}),"19 设计模式"]}),"\n","\n",(0,i.jsxs)(e.h2,{id:"1七大原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1七大原则",children:"#"}),"1.七大原则"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"设计原则的核心思想："}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起"}),"\n",(0,i.jsx)(e.li,{children:"针对接口编程，而非针对实现编程"}),"\n",(0,i.jsx)(e.li,{children:"为了交互对象之间的松耦合设计而努力"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"11-单一职责原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11-单一职责原则",children:"#"}),"1.1 单一职责原则"]}),"\n",(0,i.jsxs)(e.h4,{id:"111-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#111-基本介绍",children:"#"}),"1.1.1 基本介绍"]}),"\n",(0,i.jsxs)(e.p,{children:["对类来说，",(0,i.jsx)(e.strong,{children:"一个类应该只负责一项职责"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"eg."})," 某个Dao类既操作user表，又操作order表。这个时候就应该把该Dao类拆分成一个UserDao类、一个OrderDao类。"]}),"\n",(0,i.jsxs)(e.h4,{id:"112-注意事项和细节",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#112-注意事项和细节",children:"#"}),"1.1.2 注意事项和细节"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"降低类的复杂度，一个类只负责一个一项职责。"}),"\n",(0,i.jsx)(e.li,{children:"提高类的可读性、可维护性"}),"\n",(0,i.jsx)(e.li,{children:"降低变更引起的风险"}),"\n",(0,i.jsxs)(e.li,{children:["通常情况下，我们应当遵守单一职责原则。",(0,i.jsx)(e.strong,{children:"只有逻辑足够简单，才可以在代码级违反单一原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。"})]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"12-接口隔离原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12-接口隔离原则",children:"#"}),"1.2 接口隔离原则"]}),"\n",(0,i.jsxs)(e.h4,{id:"121-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#121-基本介绍",children:"#"}),"1.2.1 基本介绍"]}),"\n",(0,i.jsx)(e.p,{children:"客户端不应该依赖(即使用)它不需要的接口。即一个类对另一个类的依赖应该建立在最小的接口上。"}),"\n",(0,i.jsxs)(e.h4,{id:"122-例子",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#122-例子",children:"#"}),"1.2.2 例子"]}),"\n",(0,i.jsx)(e.p,{children:"Interface1中有5个方法，类B和类D是它的实现类。类A通过接口Interface1依赖（使用）类B，使用类B中的fun1、fun2、fun3方法； 类C通过接口Interface1依赖（使用）类D，使用类D中的fun1、fun4、fun5方法。"}),"\n",(0,i.jsxs)(e.h4,{id:"1221-未遵循接口隔离原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1221-未遵循接口隔离原则",children:"#"}),"1.2.2.1 未遵循接口隔离原则"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211227134632163",src:l})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'package com.tth.learn.principle.segregation;\r\n\r\npublic class Segregation1 {\r\n\r\n}\r\n\r\ninterface Interface1 {\r\n    void fun1();\r\n    void fun2();\r\n    void fun3();\r\n    void fun4();\r\n    void fun5();\r\n}\r\n\r\nclass B implements Interface1 {\r\n    @Override\r\n    public void fun1() {\r\n        System.out.println("B 实现了 fun1");\r\n    }\r\n\r\n    @Override\r\n    public void fun2() {\r\n        System.out.println("B 实现了 fun2");\r\n    }\r\n\r\n    @Override\r\n    public void fun3() {\r\n        System.out.println("B 实现了 fun3");\r\n    }\r\n\r\n    @Override\r\n    public void fun4() {\r\n        System.out.println("B 实现了 fun4");\r\n    }\r\n\r\n    @Override\r\n    public void fun5() {\r\n        System.out.println("B 实现了 fun5");\r\n    }\r\n}\r\n\r\nclass D implements Interface1 {\r\n    @Override\r\n    public void fun1() {\r\n        System.out.println("D 实现了 fun1");\r\n    }\r\n\r\n    @Override\r\n    public void fun2() {\r\n        System.out.println("D 实现了 fun2");\r\n    }\r\n\r\n    @Override\r\n    public void fun3() {\r\n        System.out.println("D 实现了 fun3");\r\n    }\r\n\r\n    @Override\r\n    public void fun4() {\r\n        System.out.println("D 实现了 fun4");\r\n    }\r\n\r\n    @Override\r\n    public void fun5() {\r\n        System.out.println("D 实现了 fun5");\r\n    }\r\n}\r\n\r\n/**\r\n * A类通过接口Interface1依赖（使用）B类，但是只会拥戴1,2,3方法\r\n */\r\nclass A {\r\n    \r\n    public void depend1(Interface1 i) {\r\n        i.fun1();\r\n    }\r\n\r\n    public void depend2(Interface1 i) {\r\n        i.fun2();\r\n    }\r\n\r\n    public void depend3(Interface1 i) {\r\n        i.fun3();\r\n    }\r\n}\r\n\r\nclass C {\r\n    public void depend1(Interface1 i) {\r\n        i.fun1();\r\n    }\r\n\r\n    public void depend4(Interface1 i) {\r\n        i.fun4();\r\n    }\r\n\r\n    public void depend5(Interface1 i) {\r\n        i.fun5();\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h4,{id:"1222-遵循接口隔离原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1222-遵循接口隔离原则",children:"#"}),"1.2.2.2 遵循接口隔离原则"]}),"\n",(0,i.jsx)(e.p,{children:"按照隔离接口原则应该这样处理："}),"\n",(0,i.jsx)(e.p,{children:"将Interface1按照下图所示拆分成3个接口，A通过Interface1、Interface2依赖类B，C通过Interface1、Interface3依赖类D。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211227134217772",src:d})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'package com.tth.learn.principle.segregation.improve;\r\n\r\npublic class Segregation1 {\r\n    public static void main(String[] args) {\r\n        A a = new A();\r\n        a.depend1(new B()); // A类依赖（使用）B类\r\n        a.depend2(new B());\r\n        a.depend3(new B());\r\n\r\n        C c = new C();\r\n        c.depend1(new D());\r\n        c.depend4(new D());\r\n        c.depend5(new D());\r\n    }\r\n}\r\n\r\ninterface Interface1 {\r\n    void fun1();\r\n}\r\ninterface Interface2 {\r\n    void fun2();\r\n    void fun3();\r\n}\r\ninterface Interface3 {\r\n    void fun4();\r\n    void fun5();\r\n}\r\n\r\nclass B implements Interface1, Interface2 {\r\n    @Override\r\n    public void fun1() {\r\n        System.out.println("B 实现了 fun1");\r\n    }\r\n\r\n    @Override\r\n    public void fun2() {\r\n        System.out.println("B 实现了 fun2");\r\n    }\r\n\r\n    @Override\r\n    public void fun3() {\r\n        System.out.println("B 实现了 fun3");\r\n    }\r\n}\r\n\r\nclass D implements Interface1, Interface3 {\r\n    @Override\r\n    public void fun1() {\r\n        System.out.println("D 实现了 fun1");\r\n    }\r\n\r\n    @Override\r\n    public void fun4() {\r\n        System.out.println("D 实现了 fun4");\r\n    }\r\n\r\n    @Override\r\n    public void fun5() {\r\n        System.out.println("D 实现了 fun5");\r\n    }\r\n}\r\n\r\n/**\r\n * A类通过接口Interface1、Interface2依赖（使用）B类，但是只会拥有1,2,3方法\r\n */\r\nclass A {\r\n    public void depend1(Interface1 i) {\r\n        i.fun1();\r\n    }\r\n\r\n    public void depend2(Interface2 i) {\r\n        i.fun2();\r\n    }\r\n\r\n    public void depend3(Interface2 i) {\r\n        i.fun3();\r\n    }\r\n}\r\n\r\n/**\r\n * C类通过接口Interface1、Interface3依赖（使用）D类，但是只会拥戴1,4,5方法\r\n */\r\nclass C {\r\n    public void depend1(Interface1 i) {\r\n        i.fun1();\r\n    }\r\n\r\n    public void depend4(Interface3 i) {\r\n        i.fun4();\r\n    }\r\n\r\n    public void depend5(Interface3 i) {\r\n        i.fun5();\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"13-依赖倒转原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13-依赖倒转原则",children:"#"}),"1.3 依赖倒转原则"]}),"\n",(0,i.jsxs)(e.h4,{id:"131-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#131-基本介绍",children:"#"}),"1.3.1 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"高层模块不应该依赖低层模块，二者都应该依赖其抽象"}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"抽象不应该依赖细节，细节应该依赖抽象"})}),"\n",(0,i.jsx)(e.li,{children:"依赖倒转的中心思想：面向接口编程"}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"依赖倒转原则的设计理念"}),"：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"使用接口或抽象类的目的"}),"是制定好规范，而不设计任何具体操作，把展现细节的任务交给他们的实现类。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"变量的声明类型尽量是抽象类或接口"}),"。这样我们的变量引用和实际对象间，就存在一个缓冲层，有利于程序的扩展和优化。"]}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"继承时遵循里氏替换原则"})}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"132-个人理解",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#132-个人理解",children:"#"}),"1.3.2 个人理解"]}),"\n",(0,i.jsx)(e.p,{children:"类A在依赖（使用）类B时，不要直接使用类B，而是使用接口1，其中类B需要实现接口1。"}),"\n",(0,i.jsxs)(e.h4,{id:"133-例子",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#133-例子",children:"#"}),"1.3.3 例子"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"例子"})," 完成Person接收消息的功能"]}),"\n",(0,i.jsxs)(e.h5,{id:"1331-没有遵循依赖倒转原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1331-没有遵循依赖倒转原则",children:"#"}),"1.3.3.1 没有遵循依赖倒转原则"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'package com.tth.learn.principle.inversion;\r\n\r\npublic class DependecyInversion {\r\n    public static void main(String[] args) {\r\n        Person person = new Person();\r\n        person.receive(new Email());\r\n    }\r\n}\r\n\r\nclass Email {\r\n    public String getInfo() {\r\n        return "电子邮件信息： hello world";\r\n    }\r\n}\r\n\r\nclass Person{\r\n    public void receive(Email email) {\r\n        System.out.println(email.getInfo());\r\n    }\r\n}\r\n\n'})}),"\n",(0,i.jsxs)(e.h5,{id:"1332-遵循依赖倒转原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1332-遵循依赖倒转原则",children:"#"}),"1.3.3.2 遵循依赖倒转原则"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"没有使用依赖倒转原则的代码存在的问题："})," 如果我们获取的对象是微信、短信等，则新增类，同时Person类还应该增加相应的接收方法。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"解决："})," 引入一个抽象接口IReceiver，表示接收者，使Person和IReceiver产生依赖关系，让Email、WeiXin各自实现IReceiver接口。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'package com.tth.learn.principle.inversion.improve;\r\n\r\npublic class DependecyInversion {\r\n    public static void main(String[] args) {\r\n        Person person = new Person();\r\n        person.receive(new Email());\r\n        person.receive(new WeiXin());\r\n    }\r\n}\r\n\r\n// 定义接口\r\ninterface IReceiver{\r\n    String getInfo();\r\n}\r\n\r\nclass Email implements IReceiver{\r\n    @Override\r\n    public String getInfo() {\r\n        return "电子邮件信息： hello world";\r\n    }\r\n}\r\n\r\nclass WeiXin implements IReceiver{\r\n    @Override\r\n    public String getInfo() {\r\n        return "微信信息： hello world";\r\n    }\r\n}\r\n\r\nclass Person{\r\n    public void receive(IReceiver receiver) {\r\n        System.out.println(receiver.getInfo());\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h4,{id:"134-依赖关系传递的三种方式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#134-依赖关系传递的三种方式",children:"#"}),"1.3.4 依赖关系传递的三种方式"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"依赖关系传递的3种方式"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"接口传递"}),"\n",(0,i.jsx)(e.li,{children:"构造方法传递"}),"\n",(0,i.jsx)(e.li,{children:"setter方式传递"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"例子"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"现有一需求，要求实现不同品牌电视机的开机功能。具体功能如下："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"点击电视的开机按钮后，电视机首先都会判断是否通电。该方法所有品牌都一样。"}),"\n",(0,i.jsx)(e.li,{children:"确定通电后，电视机会点亮屏幕。因不同品牌电视机硬件不同，所以不同品牌的电视机点亮屏幕的方法不同。"}),"\n",(0,i.jsx)(e.li,{children:"电视机屏幕点亮后，开机功能完成"}),"\n",(0,i.jsx)(e.li,{children:"暂时不考虑电视机没通电的情况"}),"\n"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"定义接口IOpenAndClose，电视机的开机或关机方法"}),"\n",(0,i.jsx)(e.li,{children:"定义接口ITV，用来存放不同品牌的电视机的操作"}),"\n",(0,i.jsx)(e.li,{children:"定义类OpenAndClose实现接口IOpenAndClose，OpenAndClose实现开机方法时，需要使用ITV中的点亮屏幕方法"}),"\n",(0,i.jsx)(e.li,{children:"创建特定品牌的电视机类如HaiXinTV，实现海信电视的点亮屏幕的操作"}),"\n",(0,i.jsx)(e.li,{children:"在客户端中测试长虹电视机的开机方法"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["以下按照",(0,i.jsx)(e.strong,{children:"接口传递"})," 方式、",(0,i.jsx)(e.strong,{children:"构造方法传递"})," 方式、 ",(0,i.jsx)(e.strong,{children:"setter传递"})," 方式分别实现以上例子"]}),"\n",(0,i.jsxs)(e.h5,{id:"1341-接口传递",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1341-接口传递",children:"#"}),"1.3.4.1 接口传递"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["电视机操作接口",(0,i.jsx)(e.code,{children:"ITV"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * @author tth\r\n * @description 电视机操作接口\r\n * @date 2023/5/30 17:21\r\n */\r\npublic interface ITV {\r\n    // 点亮屏幕\r\n    void openScreen();\r\n\r\n    // 播放节目\r\n    void playProgram(Object o);\r\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["开关机接口",(0,i.jsx)(e.code,{children:"IOpenAndClose"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * @author tth\r\n * @description 开关机接口\r\n * @date 2023/5/30 17:21\r\n */\r\npublic interface IOpenAndClose {\r\n    // 开机\r\n    void open(ITV tv);\r\n\r\n    // 关机\r\n    void close(ITV tv);\r\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["开关机类",(0,i.jsx)(e.code,{children:"OpenAndClose"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 开关机类--通过接口传递依赖\r\n * @Author tth\r\n * @Date 2023/5/30 17:22\r\n */\r\npublic class OpenAndClose implements IOpenAndClose{\r\n    @Override\r\n    public void open(ITV tv) {\r\n        // 先确定是否通电。若通电，则执行以下操作，否则暂不考虑\r\n        tv.openScreen();\r\n        System.out.println("开机完成！");\r\n    }\r\n\r\n    @Override\r\n    public void close(ITV tv) {\r\n        // 暂不实现\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["海信牌电视机类",(0,i.jsx)(e.code,{children:"HaiXinTV"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 海信电视机\r\n * @Author tth\r\n * @Date 2023/5/30 17:23\r\n */\r\npublic class HaiXinTV implements ITV {\r\n    @Override\r\n    public void openScreen() {\r\n        System.out.println("海信电视机点亮屏幕啦...");\r\n    }\r\n\r\n    @Override\r\n    public void playProgram(Object o) {\r\n        System.out.println("海信电视机播放节目啦...");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["客户端",(0,i.jsx)(e.code,{children:"Client"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * 客户端，用来测试\r\n * @Author tth\r\n * @Date 2023/5/30 17:20\r\n */\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        OpenAndClose openAndClose = new OpenAndClose();\r\n        HaiXinTV tv = new HaiXinTV();\r\n        openAndClose.open(tv); // 开机时，传入ITV接口的实现类\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.h5,{id:"1342-构造方法传递",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1342-构造方法传递",children:"#"}),"1.3.4.2 构造方法传递"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["电视机操作接口",(0,i.jsx)(e.code,{children:"ITV"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * @author tth\r\n * @description 电视机操作接口\r\n * @date 2023/5/30 17:21\r\n */\r\npublic interface ITV {\r\n    // 点亮屏幕\r\n    void openScreen();\r\n\r\n    // 播放节目\r\n    void playProgram(Object o);\r\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["开关机接口",(0,i.jsx)(e.code,{children:"IOpenAndClose"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * @author tth\r\n * @description 开关机接口\r\n * @date 2023/5/30 17:21\r\n */\r\npublic interface IOpenAndClose {\r\n    // 开机\r\n    void open();\r\n\r\n    // 关机\r\n    void close();\r\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["开关机类",(0,i.jsx)(e.code,{children:"OpenAndClose"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 开关机类-通过构造方法传递依赖\r\n * @Author tth\r\n * @Date 2023/5/30 17:22\r\n */\r\npublic class OpenAndClose implements IOpenAndClose {\r\n    private ITV tv;\r\n\r\n    public OpenAndClose(ITV tv) {\r\n        this.tv = tv;\r\n    }\r\n\r\n    @Override\r\n    public void open() {\r\n        // 先确定是否通电。若通电，则执行以下操作，否则暂不考虑\r\n        this.tv.openScreen();\r\n        System.out.println("开机完成！");\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n        // 暂不实现\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["海信牌电视机类",(0,i.jsx)(e.code,{children:"HaiXinTV"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 海信电视机\r\n * @Author tth\r\n * @Date 2023/5/30 17:23\r\n */\r\npublic class HaiXinTV implements ITV {\r\n    @Override\r\n    public void openScreen() {\r\n        System.out.println("海信电视机点亮屏幕啦...");\r\n    }\r\n\r\n    @Override\r\n    public void playProgram(Object o) {\r\n        System.out.println("海信电视机播放节目啦...");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["客户端",(0,i.jsx)(e.code,{children:"Client"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * 客户端，用来测试\r\n * @Author tth\r\n * @Date 2023/5/30 17:20\r\n */\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        OpenAndClose openAndClose = new OpenAndClose(new HaiXinTV());\r\n        openAndClose.open();\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.h5,{id:"1343-setter方式传递",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1343-setter方式传递",children:"#"}),"1.3.4.3 setter方式传递"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["电视机操作接口",(0,i.jsx)(e.code,{children:"ITV"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * @author tth\r\n * @description 电视机操作接口\r\n * @date 2023/5/30 17:21\r\n */\r\npublic interface ITV {\r\n    // 点亮屏幕\r\n    void openScreen();\r\n\r\n    // 播放节目\r\n    void playProgram(Object o);\r\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["开关机接口",(0,i.jsx)(e.code,{children:"IOpenAndClose"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * @author tth\r\n * @description 开关机接口\r\n * @date 2023/5/30 17:21\r\n */\r\npublic interface IOpenAndClose {\r\n    // 开机\r\n    void open();\r\n\r\n    // 关机\r\n    void close();\r\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["开关机类",(0,i.jsx)(e.code,{children:"OpenAndClose"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 开关机类-通过setter方式传递依赖\r\n * @Author tth\r\n * @Date 2023/5/30 17:22\r\n */\r\npublic class OpenAndClose implements IOpenAndClose {\r\n    private ITV tv;\r\n\r\n    public void setTv(ITV tv) {\r\n        this.tv = tv;\r\n    }\r\n\r\n    @Override\r\n    public void open() {\r\n        // 先确定是否通电。若通电，则执行以下操作，否则暂不考虑\r\n        this.tv.openScreen();\r\n        System.out.println("开机完成！");\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n        // 暂不实现\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["海信牌电视机类",(0,i.jsx)(e.code,{children:"HaiXinTV"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'/**\r\n * 海信电视机\r\n * @Author tth\r\n * @Date 2023/5/30 17:23\r\n */\r\npublic class HaiXinTV implements ITV {\r\n    @Override\r\n    public void openScreen() {\r\n        System.out.println("海信电视机点亮屏幕啦...");\r\n    }\r\n\r\n    @Override\r\n    public void playProgram(Object o) {\r\n        System.out.println("海信电视机播放节目啦...");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["客户端",(0,i.jsx)(e.code,{children:"Client"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n * 客户端，用来测试\r\n * @Author tth\r\n * @Date 2023/5/30 17:20\r\n */\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        OpenAndClose openAndClose = new OpenAndClose();\r\n        openAndClose.setTv(new HaiXinTV());\r\n        openAndClose.open();\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.h4,{id:"135-注意事项和细节",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#135-注意事项和细节",children:"#"}),"1.3.5 注意事项和细节"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"低层模块尽量都要有抽象类或接口，或者二者都有，程序稳定性更好"}),"\n",(0,i.jsx)(e.li,{children:"变量的类型尽量是抽象类或接口，这样变量的引用和实际对象之间，就存在一个缓冲层，利于程序的烤鱼站"}),"\n",(0,i.jsx)(e.li,{children:"继承时，需要遵循里氏替换原则"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"14-里氏替换原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#14-里氏替换原则",children:"#"}),"1.4 里氏替换原则"]}),"\n",(0,i.jsxs)(e.h4,{id:"141-里氏替换原则产生的原因",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#141-里氏替换原则产生的原因",children:"#"}),"1.4.1 里氏替换原则产生的原因"]}),"\n",(0,i.jsx)(e.p,{children:"面向对象中继承的弊端："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"继承会给程序带来侵入性"}),"\n",(0,i.jsx)(e.li,{children:"继承会降低程序的可移植性"}),"\n",(0,i.jsx)(e.li,{children:"继承增加了对象之间的耦合性"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"为解决以上弊端，在使用继承时，引出里氏替换原则。"}),"\n",(0,i.jsxs)(e.h4,{id:"142-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#142-基本介绍",children:"#"}),"1.4.2 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["如果S是T的子类型，对于S类型的任意对象，使得以T定义的所有程序P在所有t1对象换成s1对象时，程序P的行为没有发生任何变化。\r\n",(0,i.jsx)(e.strong,{children:"所有引用基类的地方必须能够透明的使用子类。"}),"===>",(0,i.jsx)(e.strong,{children:"对象继承的原则"})]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["替换的前提：面向对象的多态性","，即同一个行为具有多个不同的表现形式或者形态的能力。也可以理解为多条就是同一个接口，拥有多个不同的实现类。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["在使用继承时，",(0,i.jsx)(e.strong,{children:"子类尽量不要重写父类方法"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["里氏替换原则告诉我们：继承实际上让两个类耦合性增强了， 在适当的情况下，可以通过",(0,i.jsx)(e.strong,{children:"聚合"}),"、",(0,i.jsx)(e.strong,{children:"组合"}),"、",(0,i.jsx)(e.strong,{children:"依赖"}),"来解决问题。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"组合"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class Base{}\r\nclass A extend Base{\r\n    int fun1(int a, int b) {return a + b;}\r\n}\r\nclass  B extend Base{\r\n    // 组合\r\n    private A a  = new A();\r\n    int fun1(int a, int b) {return a - b;}\r\n    int fun2(int a, int b) {return a.fun1(a, b);}\r\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"聚合"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"依赖"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"违反里氏替换原则的场景"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"子类抛出了基类中未定义的异常"}),"\n",(0,i.jsx)(e.p,{children:"以JDK的集合框架为例，如果自定义一个List的派生类，如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class CustomList<T> extends ArrayList<T> {\r\n    @Override\r\n    public T get(int index) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["以上例子重写了get方法，抛出了",(0,i.jsx)(e.code,{children:"UnsupportedOperationException"}),"异常。在JDK源码中，LIst的get方法仅会抛出",(0,i.jsx)(e.code,{children:"IndexOutOfBoundsException"}),"异常（见下面代码），此时子类抛出",(0,i.jsx)(e.code,{children:"UnsupportedOperationException"}),"异常并不是基类所期待的，所以该子类违反了里氏替换原则。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"/**\r\n     * Returns the element at the specified position in this list.\r\n     *\r\n     * @param index index of the element to return\r\n     * @return the element at the specified position in this list\r\n     * @throws IndexOutOfBoundsException if the index is out of range\r\n     *         ({@code index < 0 || index >= size()})\r\n     */\r\n    E get(int index);\n"})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"子类方法改变了基类方法的语义或者引入了副作用"}),"\n",(0,i.jsx)(e.p,{children:"同样，以JDK的集合框架为例，如果自定义一个List的派生类，如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class CustomList<T> extends ArrayList<T> {\r\n    @Override\r\n    public T get(int index) {\r\n        if (index >= size()){\r\n            return null;\r\n        }\r\n        return get(index);\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["以上代码中，当下标>list长度时，返回空而非抛出",(0,i.jsx)(e.code,{children:"IndexOutOfBoundsException"}),"异常，此时子类改变了基类方法的语义。所以该子类也违反了里氏替换原则。"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"15-开闭原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#15-开闭原则",children:"#"}),"1.5 开闭原则"]}),"\n","\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"基本介绍"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"开闭原则是编程中最基础、最重要的原则"}),"\n",(0,i.jsxs)(e.li,{children:["一个类（软件实体）中，模块和函数应该",(0,i.jsx)(e.strong,{children:"对扩展开放"}),"（即对提供方开放），",(0,i.jsx)(e.strong,{children:"对修改关闭"}),"（即对使用方关闭），即当给类增加新的功能时，尽量不修改代码或者尽可能少修改代码。用抽象架构框架，用实现扩展细节。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"当软件需要变化时，尽量通过扩展软件实体的行为来实现改变，而不是通过修改已有的代码来实现变化"}),"。"]}),"\n",(0,i.jsx)(e.li,{children:"编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"16-迪米特法则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#16-迪米特法则",children:"#"}),"1.6 迪米特法则"]}),"\n","\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"基本介绍"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["迪米特法则又叫",(0,i.jsx)(e.strong,{children:"最少知道原则"}),"，即一个类",(0,i.jsx)(e.strong,{children:"对自己依赖的类知道的越少越好"}),"。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装到类的内部。对外除了提供的public方法，不对外泄露任何消息。"]}),"\n",(0,i.jsxs)(e.li,{children:["迪米特法则还有一个更简单的定义：",(0,i.jsx)(e.strong,{children:"只与直接的朋友通信"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"直接的朋友"}),"：每个对象都与其他对象有耦合关系，只要两个对象之间有耦合关机，我们就说两个对象之间是",(0,i.jsx)(e.strong,{children:"朋友关系"}),"。耦合的方式（依赖、关联、组合、聚合等）。我们称出现成员变量、方法参数、方法返回值中的类为",(0,i.jsx)(e.strong,{children:"直接朋友"}),"。而出现在局部变量中的类不是直接朋友（而是陌生人）。",(0,i.jsx)(e.strong,{children:"陌生类最好不要以局部变量的形式出现在类的内部。"})]}),"\n",(0,i.jsxs)(e.li,{children:["核心：",(0,i.jsx)(e.strong,{children:"降低类之间的耦合"}),"，但并非完全没有依赖关系"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"17-合成复用原则",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17-合成复用原则",children:"#"}),"1.7 合成复用原则"]}),"\n","\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"基本介绍"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"尽量使用合成/聚合的方式，而不是使用继承。"})}),"\n",(0,i.jsxs)(e.h2,{id:"2uml类图",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2uml类图",children:"#"}),"2.UML类图"]}),"\n",(0,i.jsxs)(e.h3,{id:"21-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21-基本介绍",children:"#"}),"2.1 基本介绍"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Unified modeling language，统一建模语言，是一种用于软件系统分析和设计的语言工具，他帮助软件开发人员进行思考和记录思路的结果。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"常用符号"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211227175645777",src:c})}),"\n",(0,i.jsxs)(e.h3,{id:"22-uml类图的画法",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22-uml类图的画法",children:"#"}),"2.2 UML类图的画法"]}),"\n","\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"依赖"}),"： A在类中用到了B类，则A和B类之间就存在依赖关系。可以是类的成员变量、方法的返回类型、方法接收的参数类型、方法中的局部变量。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228111016993",src:a})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"泛化（继承）"}),"：泛化就是继承，是依赖关系的特例。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228111041720",src:t})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"实现"}),"：类实现了接口，是依赖关系的特例。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228111100399",src:h})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"关联"}),"：指的是类与类之间的联系，是依赖的特例。具有",(0,i.jsx)(e.strong,{children:"导航性"}),"（即双向关系或者单项关系）、",(0,i.jsx)(e.strong,{children:"多重性"}),"（一对一、一对多、多对多）"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228111131977",src:o})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"聚合"}),"：表示整体和部分的关系，整体与部分可以分开（比如电脑中有鼠标和键盘类，但是键盘和鼠标又可以从电脑上拆下来，所以电脑与鼠标、电脑与键盘是聚合关系），是关联关系的特例。具有导航性和多重性。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228111149199",src:x})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"组合"}),"：表示整体和部分的关系，整体与部分不可以分开（比如人中有头和四肢类，但是头和四肢不能从人上拆下来，所以人和头、人和四肢是组合关系。人有身份证，身份证可以从人身上拆下来，所以人和身份证是聚合关系）。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228111201555",src:j})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"聚合与组合"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class A {\r\n    private B b; // 聚合\r\n    private C c  = new C(); // 组合关系\r\n}\r\nclass B {}\r\nclass C {}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["如果程序中A实体中定义了对IDCard进行",(0,i.jsx)(e.strong,{children:"级联删除"}),"（即删除Person时连同IDCard一起删除），那么IDCard和Person就是组合了。"]}),"\n",(0,i.jsxs)(e.h2,{id:"3设计模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3设计模式",children:"#"}),"3.设计模式"]}),"\n",(0,i.jsxs)(e.h3,{id:"31-概述",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#31-概述",children:"#"}),"3.1 概述"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["设计模式是某类问题的",(0,i.jsx)(e.strong,{children:"通用解决方案"}),"，代表了最佳实践"]}),"\n",(0,i.jsx)(e.li,{children:"本质：提高软件的维护性、通用性、扩展性，降低软件的复杂性"}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"分为3种类型"}),"：","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"创建型模式"}),"：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"结构性模式"}),"：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"行为型模式"}),"：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、终结者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"32-单例模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#32-单例模式",children:"#"}),"3.2 单例模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"321-定义",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#321-定义",children:"#"}),"3.2.1 定义"]}),"\n",(0,i.jsxs)(e.p,{children:["即采取一定的方法保证整个软件系统中，对于某个类",(0,i.jsx)(e.strong,{children:"只能存在一个对象实例"}),"，并且该类",(0,i.jsx)(e.strong,{children:"只提供一个取得该对象实例的方法"}),"（静态方法）。"]}),"\n",(0,i.jsxs)(e.h4,{id:"322-实现方式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#322-实现方式",children:"#"}),"3.2.2 实现方式"]}),"\n","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"饿汉式（静态常量）"}),"\n",(0,i.jsx)(e.li,{children:"饿汉式（静态代码块）"}),"\n",(0,i.jsx)(e.li,{children:"懒汉式（线程不安全）"}),"\n",(0,i.jsx)(e.li,{children:"懒汉式（同步方法）"}),"\n",(0,i.jsx)(e.li,{children:"懒汉式（同步代码块）"}),"\n",(0,i.jsx)(e.li,{children:"双重检查"}),"\n",(0,i.jsx)(e.li,{children:"静态内部类"}),"\n",(0,i.jsx)(e.li,{children:"枚举"}),"\n"]}),"\n",(0,i.jsxs)(e.h5,{id:"3221饿汉式静态常量",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3221饿汉式静态常量",children:"#"}),"3.2.2.1",(0,i.jsx)(e.strong,{children:"饿汉式（静态常量）"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class HungryManType1 {\r\n	// 1.构造器私有化\r\n	private HungryManType1() {}\r\n\r\n	// 2.本类内部创建对象实例\r\n	private final static HungryManType1 instance = new HungryManType1();\r\n\r\n	// 3.公共静态方法，返回实例对象\r\n	public static HungryManType1 getInstance() {\r\n		return instance;\r\n	}\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：写法简单，在类装载的时候完成实例化，避免了线程同步问题"}),"\n",(0,i.jsxs)(e.li,{children:["缺点：没有用到懒加载效果。如果从始至终没有用到这个实例，则会造成","内存浪费","。"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n","\n",(0,i.jsxs)(e.h5,{id:"3222饿汉式静态代码块",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3222饿汉式静态代码块",children:"#"}),"3.2.2.2",(0,i.jsx)(e.strong,{children:"饿汉式（静态代码块）"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class HungryManType2 {\r\n	// 1.构造器私有化\r\n	private HungryManType2() {}\r\n\r\n	// 2.本类内部创建对象实例\r\n	private static HungryManType2 instance;\r\n\r\n	// 3.在静态代码块中创建实例\r\n	static {\r\n		instance = new HungryManType2();\r\n	}\r\n	\r\n	// 4.公共静态方法，返回实例对象\r\n	public static HungryManType2 getInstance() {\r\n		return instance;\r\n	}\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：写法简单，在类装载的时候完成实例化，避免了线程同步问题"}),"\n",(0,i.jsxs)(e.li,{children:["缺点：没有用到懒加载效果。如果从始至终没有用到这个实例，则会造成","内存浪费","。"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n","\n",(0,i.jsxs)(e.h5,{id:"3223懒汉式线程不安全",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3223懒汉式线程不安全",children:"#"}),"3.2.2.3",(0,i.jsx)(e.strong,{children:"懒汉式（线程不安全）"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class LazyManType1{\r\n    // 1.本类内部创建对象实例\r\n    private static LazyManType1 instance;\r\n\r\n    // 2.构造器私有化\r\n    private LazyManType1() {};\r\n\r\n    // 3.公共静态方法，返回实例对象\r\n    public static LazyManType1 getInstance() {\r\n        if (null == instance) {\r\n            instance = new LazyManType1();\r\n        }\r\n        return instance;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：起到了懒加载效果"}),"\n",(0,i.jsxs)(e.li,{children:["缺点：","线程不安全，只能在单例模式下使用"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"实际开发不要使用该方法。"}),"\n",(0,i.jsxs)(e.h5,{id:"3224懒汉式同步方法",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3224懒汉式同步方法",children:"#"}),"3.2.2.4",(0,i.jsx)(e.strong,{children:"懒汉式（同步方法）"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class LazyManType2{\r\n    // 1.本类内部创建对象实例\r\n    private static LazyManType2 instance;\r\n\r\n    // 2.构造器私有化\r\n    private LazyManType2() {};\r\n\r\n    // 3.公共同步静态方法，返回实例对象---加入synchronized解决线程安全问题\r\n    public static synchronized LazyManType2 getInstance() {\r\n        if (null == instance) {\r\n            instance = new LazyManType2();\r\n        }\r\n        return instance;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：起到了懒加载效果，线程安全"}),"\n",(0,i.jsxs)(e.li,{children:["缺点：","方法进行同步效率太低"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"实际开发不推荐使用。"}),"\n",(0,i.jsxs)(e.h5,{id:"3225懒汉式同步代码块",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3225懒汉式同步代码块",children:"#"}),"3.2.2.5",(0,i.jsx)(e.strong,{children:"懒汉式（同步代码块）"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class LazyManType3{\r\n    // 1.本类内部创建对象实例\r\n    private static LazyManType3 instance;\r\n\r\n    // 2.构造器私有化\r\n    private LazyManType3() {};\r\n\r\n    // 3.公共同步静态代码块，返回实例对象\r\n    public static LazyManType3 getInstance() {\r\n        if (null == instance) {\r\n            synchronized (LazyManType3.class) {\r\n                instance = new LazyManType3();\r\n            }\r\n\r\n        }\r\n        return instance;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["本意是优化同步方法的方式，但是实际上","并不能起到线程同步的作用","。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"实际开发不能使用。"}),"\n",(0,i.jsxs)(e.h5,{id:"3226双重检查",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3226双重检查",children:"#"}),"3.2.2.6",(0,i.jsx)(e.strong,{children:"双重检查"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class DoubleCheckType{\r\n    // 1.本类内部创建对象实例\r\n    // volatile保证变量如果有修改，能够立刻刷到内存中，一定程度上还能达到同步的效果\r\n    private static volatile DoubleCheckType instance;\r\n\r\n    // 2.构造器私有化\r\n    private DoubleCheckType() {};\r\n\r\n    // 3.公共方法，加入双重检查代码，解决线程安全问题，返回实例对象\r\n    public static DoubleCheckType getInstance() {\r\n        if (null == instance) {\r\n            synchronized (LazyManType3.class) {\r\n                if (null == instance) {\r\n                    instance = new DoubleCheckType();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：线程安全，延时加载，效率高"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["实际开发","推荐使用","。"]}),"\n",(0,i.jsxs)(e.h5,{id:"3227静态内部类",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3227静态内部类",children:"#"}),"3.2.2.7",(0,i.jsx)(e.strong,{children:"静态内部类"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"静态内部类的特点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"外部类装载的时候，静态内部类并不一定会立即被装载"}),"\n",(0,i.jsx)(e.li,{children:"静态内部类只会在第一次加载类的时候初始化"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"class StaticInnerClassType{\r\n    // 1.构造器私有化\r\n    private StaticInnerClassType() {};\r\n\r\n    // 2.静态内部类，以及他的静态属性\r\n    private static class SingletonInstance {\r\n        private static final StaticInnerClassType INSTANCE = new StaticInnerClassType();\r\n    }\r\n\r\n    // 3.公共方法，加入双重检查代码，解决线程安全问题，返回实例对象\r\n    public static StaticInnerClassType getInstance() {\r\n        return SingletonInstance.INSTANCE;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：线程安全，利用静态内部类特点实现延迟加载，效率高"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["借助底层JVM类的装载机制保证初始化时只有一个实例，实际开发","推荐使用","。"]}),"\n",(0,i.jsxs)(e.h5,{id:"3228枚举",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3228枚举",children:"#"}),"3.2.2.8",(0,i.jsx)(e.strong,{children:"枚举"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'enum EnumType{\r\n    INSTANCE;\r\n    public void sayOk() {\r\n        System.out.println("ok~");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"分析"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"优点：线程安全，防止反序列化重新创建新的对象"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"结论"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["实际开发","推荐使用","。"]}),"\n",(0,i.jsxs)(e.h4,{id:"323-源码单例举例",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#323-源码单例举例",children:"#"}),"3.2.3 源码单例举例"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211228142017753",src:p})}),"\n",(0,i.jsxs)(e.h4,{id:"324-使用场景",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#324-使用场景",children:"#"}),"3.2.4 使用场景"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"需要频繁的创建和销毁的对象"}),"\n",(0,i.jsx)(e.li,{children:"创建对象时耗时过多或者耗费资源过多但又经常用到的对象"}),"\n",(0,i.jsx)(e.li,{children:"工具类对象"}),"\n",(0,i.jsx)(e.li,{children:"频繁访问数据库或者文件的对象（如数据源、session工厂等）"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"33-工厂模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#33-工厂模式",children:"#"}),"3.3 工厂模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"331-简单工厂模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#331-简单工厂模式",children:"#"}),"3.3.1 简单工厂模式"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"基本介绍"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["属于创建型模式，是工厂模式的一种。简单工厂模式是",(0,i.jsx)(e.strong,{children:"由一个工厂对象决定创建出哪一种产品类的实例"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["本质：定义了一个创建对象的","类","，由这个类来",(0,i.jsx)(e.strong,{children:"封装实例化对象的行为"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"使用场景：当需要大量的创建某类或者某批对象时，就会用到工厂模式。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"简单工厂模式也叫静态工厂模式。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211229173735944",src:u})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"332-工厂方法模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#332-工厂方法模式",children:"#"}),"3.3.2 工厂方法模式"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"基本介绍"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["本质：定义了一个创建对象的","抽象方法","，由子类决定要实例化的类。工厂方法模式",(0,i.jsx)(e.strong,{children:"将对象的实例化推迟到子类"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211229175126825",src:m})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"333-抽象工厂模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#333-抽象工厂模式",children:"#"}),"3.3.3 抽象工厂模式"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"基本介绍"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["本质：定义了一个","interface","，用于创建或有依赖关系对象的对象簇，无需指明具体的类。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["抽象工厂模式",(0,i.jsx)(e.strong,{children:"可以将简单工厂模式和工厂方法模式进行整合"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["从设计层面看，抽象工厂模式就随对简单工厂模式的进一步抽象----将工厂抽象成两层，即抽象工厂和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类，如此便将单个的简单工厂类变成了",(0,i.jsx)(e.strong,{children:"工厂簇"}),"，更利于代码的维护和扩展。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211229164242551",src:g})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"334-源码工厂模式举例",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#334-源码工厂模式举例",children:"#"}),"3.3.4 源码工厂模式举例"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211229171630731",src:v})}),"\n",(0,i.jsxs)(e.h4,{id:"335-小结",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#335-小结",children:"#"}),"3.3.5 小结"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"意义"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"将实例化对象的代码提取出来，放到一个类中统一管理和维护，以达到和主项目依赖关系的解耦，从而提高项目的可扩展性和可维护性。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"三种工程模式"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"简单工厂模式"}),"\n",(0,i.jsx)(e.li,{children:"工厂方法模式"}),"\n",(0,i.jsx)(e.li,{children:"抽象工厂模式"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:["设计模式的",(0,i.jsx)(e.strong,{children:"依赖抽象"}),"原则"]}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。"}),"\n",(0,i.jsx)(e.li,{children:"不要让类继承具体类，而应继承抽象类或者实现接口。"}),"\n",(0,i.jsx)(e.li,{children:"不要覆盖类中已经实现的方法。"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"34-原型模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#34-原型模式",children:"#"}),"3.4 原型模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"341-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#341-基本介绍",children:"#"}),"3.4.1 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义"}),"：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象"]}),"\n",(0,i.jsxs)(e.li,{children:["是一种","创建型设计模式","，允许一个对象再创建另外一个可定制的对象，无需知道创建细节"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"工作原理"}),"：通过将一个原型对象传给那个要发起创建的对象，这个要发起创建的对象通过请求原型对象拷贝他们自己来实现创建，即","对象.clone()"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"形象理解"}),"：孙悟空拔出猴毛，变出其他孙大圣"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"342-克隆羊例子",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#342-克隆羊例子",children:"#"}),"3.4.2 克隆羊例子"]}),"\n",(0,i.jsx)(e.p,{children:"创建5只属性一样的羊。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"关键"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Sheep类实现Cloneable接口，并重写clone()。客户端创建完第一只羊之后，调用clone()方法完成其他4只羊的创建。"}),"\n","\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:"package com.tth.learn.prototype;\r\n\r\npublic class Sheep implements Cloneable{\r\n    private String name;\r\n    private int age;\r\n    private String color;\r\n\r\n    public Sheep(String name, int age, String color) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.color = color;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getColor() {\r\n        return color;\r\n    }\r\n\r\n    public void setColor(String color) {\r\n        this.color = color;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Shape{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", color='\" + color + '\\'' +\r\n                '}';\r\n    }\r\n\r\n    @Override\r\n    protected Object clone() {\r\n        Sheep shape = null;\r\n        try {\r\n            shape = (Sheep) super.clone();\r\n        }catch (CloneNotSupportedException e) {\r\n            System.out.println(e.getMessage());\r\n        }\r\n        return shape;\r\n    }\r\n}\n"})}),"\n","\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'package com.tth.learn.prototype;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Sheep sheep = new Sheep("Tom", 1, "白色");\r\n        Sheep sheep2 = (Sheep)sheep.clone();\r\n        Sheep sheep3 = (Sheep)sheep.clone();\r\n        Sheep sheep4 = (Sheep)sheep.clone();\r\n        Sheep sheep5 = (Sheep)sheep.clone();\r\n\r\n        System.out.println(sheep);\r\n        System.out.println(sheep2);\r\n        System.out.println(sheep3);\r\n        System.out.println(sheep4);\r\n        System.out.println(sheep5);\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h4,{id:"343-源码原型模式举例",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#343-源码原型模式举例",children:"#"}),"3.4.3 源码原型模式举例"]}),"\n","\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",meta:"",children:'<bean id="monster" class="com.tth.learning.springsource.Monster" scope="prototype">\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211230102634432",src:b})}),"\n",(0,i.jsxs)(e.h4,{id:"344-浅拷贝和深拷贝",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#344-浅拷贝和深拷贝",children:"#"}),"3.4.4 浅拷贝和深拷贝"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"浅拷贝"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"基本数据类型：值传递，即将该属性值复制一份给新的对象"}),"\n",(0,i.jsx)(e.li,{children:"引用数据类型（数组、对象等）：引用传递，即指向同一个内存地址"}),"\n",(0,i.jsxs)(e.li,{children:["浅拷贝是使用默认的","clone()","方法来实现的"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"深拷贝"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["深拷贝实现方式：","重写clone()","或者通过","对象实例化(推荐)","实现深拷贝"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"通过重写clone()方法实现深拷贝"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211230144621521",src:f})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'// Teacher类\r\npublic class Teacher implements Cloneable{\r\n    private String name;\r\n    private String major;\r\n\r\n    public Teacher(String name, String major) {\r\n        this.name = name;\r\n        this.major = major;\r\n    }\r\n\r\n    @Override\r\n    protected Object clone() throws CloneNotSupportedException {\r\n        return super.clone();\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getMajor() {\r\n        return major;\r\n    }\r\n\r\n    public void setMajor(String major) {\r\n        this.major = major;\r\n    }\r\n}\r\n// Student类\r\npublic class Student implements Cloneable{\r\n    private String name;\r\n    private int age;\r\n    private Teacher teacher;\r\n\r\n    public Student(String name, int age, String teacherName, String teacherMajor) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.teacher = new Teacher(teacherName, teacherMajor);\r\n    }\r\n\r\n    // 方式一：重写clone方法，实现深拷贝\r\n    @Override\r\n    protected Object clone() throws CloneNotSupportedException {\r\n        Student student = null;\r\n        // 完成对基本类型以及String类型属性的克隆\r\n        student = (Student) super.clone();\r\n        // 借助引用对象的clone()方法，完成对引用对象的克隆\r\n        student.setTeacher((Teacher) teacher.clone());\r\n        return student;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Teacher getTeacher() {\r\n        return teacher;\r\n    }\r\n\r\n    public void setTeacher(Teacher teacher) {\r\n        this.teacher = teacher;\r\n    }\r\n}\r\n\r\n// 使用\r\npublic class Client {\r\n    public static void main(String[] args) throws Exception {\r\n        Student s1 = new Student("明世隐", 14, "诸葛亮", "数学");\r\n        Student s2 = (Student)s1.clone();\r\n\r\n        System.out.println("s1="+s1.hashCode()+" s1.name="+s1.getName()+" s1.teacher="+s1.getTeacher().hashCode());\r\n        System.out.println("s2="+s2.hashCode()+" s2.name="+s2.getName()+" s2.teacher="+s2.getTeacher().hashCode());\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"通过对象的序列化实现深拷贝"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211230145041397",src:S})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'// Teacher类\r\npublic class Teacher implements Serializable{\r\n    private String name;\r\n    private String major;\r\n\r\n    public Teacher(String name, String major) {\r\n        this.name = name;\r\n        this.major = major;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getMajor() {\r\n        return major;\r\n    }\r\n\r\n    public void setMajor(String major) {\r\n        this.major = major;\r\n    }\r\n}\r\n\r\n// Student类\r\npublic class Student implements Serializable{\r\n    private String name;\r\n    private int age;\r\n    private Teacher teacher;\r\n\r\n    public Student(String name, int age, String teacherName, String teacherMajor) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.teacher = new Teacher(teacherName, teacherMajor);\r\n    }\r\n\r\n    // 方式2：通过对象的序列化实现深拷贝\r\n    public Object deepClone() {\r\n        // 创建对象流\r\n        ByteArrayOutputStream bos = null;\r\n        ObjectOutputStream oos = null;\r\n        ByteArrayInputStream bis = null;\r\n        ObjectInputStream ois = null;\r\n        try {\r\n            // 序列化\r\n            bos = new ByteArrayOutputStream(); // 创建输出流\r\n            oos = new ObjectOutputStream(bos);\r\n            oos.writeObject(this); // 当前这个对象以对象流的方式输出\r\n            // 反序列化\r\n            bis = new ByteArrayInputStream(bos.toByteArray()); // 创建输入流\r\n            ois = new ObjectInputStream(bis);\r\n            Student student = (Student)ois.readObject();\r\n            return student;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        } finally {\r\n            // 关闭流\r\n            try {\r\n                bos.close();\r\n                oos.close();\r\n                bis.close();\r\n                ois.close();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Teacher getTeacher() {\r\n        return teacher;\r\n    }\r\n\r\n    public void setTeacher(Teacher teacher) {\r\n        this.teacher = teacher;\r\n    }\r\n}\r\n\r\n// 使用\r\npublic class Client {\r\n    public static void main(String[] args) throws Exception {\r\n        Student s1 = new Student("明世隐", 14, "诸葛亮", "数学");\r\n        Student s3 = (Student)s1.deepClone();\r\n\r\n        System.out.println("s1="+s1.hashCode()+" s1.name="+s1.getName()+" s1.teacher="+s1.getTeacher().hashCode());\r\n        System.out.println("s3="+s3.hashCode()+" s3.name="+s3.getName()+" s3.teacher="+s3.getTeacher().hashCode());\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"345-小结",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#345-小结",children:"#"}),"3.4.5 小结"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"原型模式的注意事项和优缺点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["当创建的对象比较复杂时，可以利用原型模式",(0,i.jsx)(e.strong,{children:"简化对象的创建过程"}),"，同时也能",(0,i.jsx)(e.strong,{children:"提高效率"})]}),"\n",(0,i.jsx)(e.li,{children:"不用重新初始化对象，而是动态的获取对象运行时的状态"}),"\n",(0,i.jsx)(e.li,{children:"如果原式对象的属性增加或者减少，其他克隆对象的也会相应变化，无需修改代码"}),"\n",(0,i.jsx)(e.li,{children:"缺点：需要为每一个类配备一个克隆方法，这对于全新的类来说不是很难，但对已有的类改造时，需要修改源代码，违背了ocp原则"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"35-建造者模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#35-建造者模式",children:"#"}),"3.5 建造者模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"351-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#351-基本介绍",children:"#"}),"3.5.1 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"本质：将产品和产品建造过程解耦"}),"\n",(0,i.jsxs)(e.li,{children:["是一种","创建型设计模式","。它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同属性的对象"]}),"\n",(0,i.jsx)(e.li,{children:"建造者模式是一步一步的创建一个复杂对象。它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构造过程"}),"\n",(0,i.jsxs)(e.li,{children:["建造者的","四个角色","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Product(产品)"}),"：产品对象"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Builder(抽象建造者)"}),"：穿件一个Product对象各个部件指定的接口或抽象类"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ConcreteBuilder(具体建造者)"}),"：实现接口或抽象类，构建和装配各个组件"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Director(指挥者)"}),"：构建一个使用Builder接口的对象。","作用是",(0,i.jsx)(e.strong,{children:"①"}),"隔离客户与对象的生产过程",(0,i.jsx)(e.strong,{children:"②"}),"负责控制产品对象的生产过程。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"352-盖房子例子",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#352-盖房子例子",children:"#"}),"3.5.2 盖房子例子"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20211231154953574",src:N})}),"\n",(0,i.jsxs)(e.h4,{id:"353-小结",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#353-小结",children:"#"}),"3.5.3 小结"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"建造者模式的注意事项和优缺点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["客户端不比知道产品内部的",(0,i.jsx)(e.strong,{children:"组成"}),"细节，将产品本身与产品床创建过程解耦，使得相同的创建过程可以创建不同的产品对象。"]}),"\n",(0,i.jsxs)(e.li,{children:["每一个具体建造者都是相对独立的，因此可以很方便的替换具体建造者或者增加新的建造者，",(0,i.jsx)(e.strong,{children:"用户使用不同的具体建造者即可得到不同的对象产品"}),"。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"可以更加惊喜的控制产品的创建过程"}),"。将复杂产品的创建步骤分解在不同的方法中，是的创建过程更加清晰，也更方便使用程序来控制创建过程。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"增加新的具体建造者无须修改原有类库代码"}),"，符合",(0,i.jsx)(e.strong,{children:"开闭原则"})]}),"\n",(0,i.jsxs)(e.li,{children:["使用建造者模式创建的产品一般具有较多的共同点，其组成部分相似。",(0,i.jsx)(e.strong,{children:"如果产品之间的差异性很大，则不适合使用建造者模式"}),"。"]}),"\n",(0,i.jsxs)(e.li,{children:["抽象工厂模式VS建造者模式","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"抽象工厂模式"}),"实现对产品家族的创建，一个产品家族是这样一系列的产品：具有不同分类纬度的产品组合，采用抽象工厂模式不需要关系构建过程，之关系什么产品由什么工厂生产即可。抽象工厂模式是一个函数生成一个对象。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"建造者模式"}),"是把对象的创建分散开来，不同的方法创建对象不同的组成部分，最终将所有函数结合起来才能生成一个对象。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"36-适配器模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#36-适配器模式",children:"#"}),"3.6 适配器模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"361-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#361-基本介绍",children:"#"}),"3.6.1 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义"}),"：适配器模式将某个类的接口转换成客户端期望的另一个接口表示。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"目的"}),"：兼容。让原本因接口不匹配不能一起工作的两个类可以协同工作。"]}),"\n",(0,i.jsxs)(e.li,{children:["是一种","结构型设计模式"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"分类"}),"：","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"类适配器模式"}),"\n",(0,i.jsx)(e.li,{children:"对象适配器模式"}),"\n",(0,i.jsx)(e.li,{children:"接口适配器模式"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"362-类适配器模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#362-类适配器模式",children:"#"}),"3.6.2 类适配器模式"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义："}),"是一个类(Adapter)，通过",(0,i.jsx)(e.strong,{children:"继承被适配类"}),"，实现目标类的接口，完成被",(0,i.jsx)(e.strong,{children:"适配类(src)->目标类(dst)"})," 的实现。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"优缺点"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"缺点"}),"：由于java是单继承，类适配器需要继承src类，所以det必须是接口，有一定的局限性"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"缺点"}),"：src类的方法在Adapter中会暴露出来，也增加了使用的成本"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"优点"}),"：由于继承了src类，所以它可以根据需求重写src类，使得Adapter的灵活性增强了"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"363-对象适配器模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#363-对象适配器模式",children:"#"}),"3.6.3 对象适配器模式"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义："}),"基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是","持有src类的实例","，以解决兼容性问题。即：持有src类，实现dst接口（或继承dst类），完成src->dst的适配。"]}),"\n",(0,i.jsx)(e.li,{children:"根据“合成复用原则”，在系统中尽量使用关联关系来替代继承类。"}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"对象适配器模式是适配器模式中最常用的一种"}),"。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"优缺点："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"优点："}),"对象适配器是对类适配器的一种升级。根据合成复用原则，使用组合替代继承，它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"缺点："}),"使用成本更低，更灵活。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"364-接口适配器模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#364-接口适配器模式",children:"#"}),"3.6.4 接口适配器模式"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义："})," 当不需要全部实现接口提供的方法时，可以先设计一个","抽象类","实现接口，\r\n并","为该接口中每个方法提供一个默认实现（空方法）","，\r\n那么","抽象类的子类可有选择的覆盖父类的某些方法来实现需求","。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"使用场景："})," 适用于一个接口不想使用其所有方法的情况。"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"365-源码适配器模式举例",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#365-源码适配器模式举例",children:"#"}),"3.6.5 源码适配器模式举例"]}),"\n",(0,i.jsx)(e.p,{children:"适配器模式在SpringMVC中的应用。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20220104150119181",src:y})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"例子：手写简单SpringMVC DispatcherServlet.doDispatch()方法"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20220104160107383",src:A})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",meta:"",children:'// ========================Controller类============================================\r\npackage com.tth.designpattern.adapter.springmvcadapter;\r\n\r\npublic interface Controller {\r\n}\r\n\r\nclass HttpController implements Controller {\r\n    public void doHttpController() {\r\n        System.out.println("HttpController...");\r\n    }\r\n}\r\n\r\nclass SimpleController implements Controller {\r\n    public void doSimpleController() {\r\n        System.out.println("SimpleController...");\r\n    }\r\n}\r\n\r\nclass AnnotationController implements Controller {\r\n    public void doAnnotationController() {\r\n        System.out.println("AnnotationController...");\r\n    }\r\n}\r\n\r\n// ========================HandlerAdapter类============================================\r\npublic interface HandlerAdapter {\r\n    // 判断当前handler对应的类是否是指定的HandlerAdapter类\r\n    boolean supports(Object handler);\r\n    // 具体HandlerAdapter对象的处理方法\r\n    void handle(Object handler);\r\n}\r\n\r\nclass HttpHandlerAdapter implements HandlerAdapter {\r\n\r\n    /**\r\n     * 判断当前handler对应的类是否HttpHandlerAdapter类\r\n     * @param handler\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean supports(Object handler) {\r\n        return (handler instanceof HttpController);\r\n    }\r\n\r\n    /**\r\n     * 执行HttpController对应的方法\r\n     * @param handler\r\n     */\r\n    @Override\r\n    public void handle(Object handler) {\r\n        // 此处将handler强转为HttpController类，并调用HttpController类中的doHttpController()\r\n        // 因为handle()方法是在supports()方法返回为true的前提下调用的，所以强转肯定是成功的\r\n        ((HttpController)handler).doHttpController();\r\n    }\r\n}\r\n\r\nclass SimpleHandlerAdapter implements HandlerAdapter {\r\n    /**\r\n     * 判断当前handler对应的类是否SimpleHandlerAdapter类\r\n     * @param handler\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean supports(Object handler) {\r\n        return (handler instanceof SimpleController);\r\n    }\r\n\r\n    /**\r\n     * 执行SimpleController对应的方法\r\n     * @param handler\r\n     */\r\n    @Override\r\n    public void handle(Object handler) {\r\n        // 此处将handler强转为SimpleController类，并调用SimpleController类中的doSimpleController()\r\n        // 因为handle()方法是在supports()方法返回为true的前提下调用的，所以强转肯定是成功的\r\n        ((SimpleController)handler).doSimpleController();\r\n    }\r\n}\r\n\r\nclass AnnotationHandlerAdapter implements HandlerAdapter {\r\n    /**\r\n     * 判断当前handler对应的类是否AnnotationHandlerAdapter类\r\n     * @param handler\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean supports(Object handler) {\r\n        return (handler instanceof AnnotationController);\r\n    }\r\n\r\n    /**\r\n     * 执行AnnotationController对应的方法\r\n     * @param handler\r\n     */\r\n    @Override\r\n    public void handle(Object handler) {\r\n        // 此处将handler强转为AnnotationController类，并调用AnnotationController类中的doAnnotationController()\r\n        // 因为handle()方法是在supports()方法返回为true的前提下调用的，所以强转肯定是成功的\r\n        ((AnnotationController)handler).doAnnotationController();\r\n    }\r\n}\r\n\r\n// ========================DispatcherServlet类============================================\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class DispatcherServlet {\r\n    List<HandlerAdapter> handlerAdapters = new ArrayList<>();\r\n\r\n    public DispatcherServlet() {\r\n        handlerAdapters.add(new AnnotationHandlerAdapter());\r\n        handlerAdapters.add(new HttpHandlerAdapter());\r\n        handlerAdapters.add(new SimpleHandlerAdapter());\r\n    }\r\n\r\n    public void doDispatch() {\r\n        // 模拟SpringMVC从request中获取handler对象\r\n        AnnotationController controller = new AnnotationController();\r\n        // 得到对应的适配器\r\n        HandlerAdapter adapter = getHandler(controller);\r\n        // 通过适配器执行对应的controller方法\r\n        adapter.handle(controller);\r\n    }\r\n\r\n    protected HandlerAdapter getHandler(Controller controller) {\r\n        for (HandlerAdapter adapter: this.handlerAdapters) {\r\n            if (adapter.supports(controller)){\r\n                return adapter;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        // ========================测试入口============================================\r\n        new DispatcherServlet().doDispatch();\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.h4,{id:"366-小结",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#366-小结",children:"#"}),"3.6.6 小结"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["按照",(0,i.jsx)(e.strong,{children:"src是以怎样的形式转给到Adapter"}),"被分为3种不同的适配器：","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"类适配器"}),"：以类给到，在Adapter里，",(0,i.jsx)(e.strong,{children:"将src当做类"}),"，继承"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"对象适配器"}),"：以对象给到，在Adapter里，",(0,i.jsx)(e.strong,{children:"将src作为一个对象"}),"，持有"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"接口适配器"}),"：以接口给到，在Adapter里，",(0,i.jsx)(e.strong,{children:"将src作为一个接口"}),"，实现"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Adapter模式","最大的作用","是将原本不兼容的接口融合在一起工作"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"37-桥接模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#37-桥接模式",children:"#"}),"3.7 桥接模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"371-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#371-基本介绍",children:"#"}),"3.7.1 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义："})," 将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。"]}),"\n",(0,i.jsxs)(e.li,{children:["是一种","结构型设计模式"]}),"\n",(0,i.jsxs)(e.li,{children:["基于",(0,i.jsx)(e.strong,{children:"类的最小设计原则"}),"，通过使用封装、聚合、继承，让不同的类承担不同的职责。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"主要特点："})," 把抽象和行为实现分离开来，从而保持各部分的独立性以及应对他们的功能扩展。"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"372-原理图类图",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#372-原理图类图",children:"#"}),"3.7.2 原理图（类图）"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20220105111056369",src:C})}),"\n",(0,i.jsxs)(e.h4,{id:"373-源码桥接模式举例",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#373-源码桥接模式举例",children:"#"}),"3.7.3 源码桥接模式举例"]}),"\n",(0,i.jsx)(e.p,{children:"JDBC源码"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"image-20220104221343947",src:T})}),"\n",(0,i.jsxs)(e.h4,{id:"374-小结",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#374-小结",children:"#"}),"3.7.4 小结"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"桥接模式的优缺点"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"优点"}),"实现了抽象和实现部分的分离，极大提供了系统的灵活性，让抽象部分和实现部分独立开来，有助于系统进行分层设计，从而产生更好的结构化系统。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"优点"}),"对于系统的高层部分，只需要知道抽象部分和实现接口即可，其他交于具体业务来完成。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"优点"}),"桥接模式替代多层继承，可以减少子类个数，降低系统的管理和维护成本。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"缺点"}),"桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"缺点"}),"桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围具有一定的局限性。"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"桥接模式应用场景"}),"\n"]}),"\n","\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"桥接模式应用场景举例："})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"JDBC驱动程序"}),"\n",(0,i.jsxs)(e.li,{children:["银行转账系统","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["转账分类：网上转账、柜台转账、ATM转账 ",(0,i.jsx)(e.code,{children:"抽象层"})]}),"\n",(0,i.jsxs)(e.li,{children:["转账用户类型：普通用户、银卡用户、金卡用户... ",(0,i.jsx)(e.code,{children:"实现层"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["消息管理","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["消息类型：即时消息、延时消息 ",(0,i.jsx)(e.code,{children:"抽象层"})]}),"\n",(0,i.jsxs)(e.li,{children:["消息分类：手机短信、邮件消息、QQ消息... ",(0,i.jsx)(e.code,{children:"实现层"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"38-装饰者模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#38-装饰者模式",children:"#"}),"3.8 装饰者模式"]}),"\n",(0,i.jsxs)(e.h4,{id:"381-基本介绍",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#381-基本介绍",children:"#"}),"3.8.1 基本介绍"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"定义："}),"动态的将新的功能附加到对象上。","在对象功能扩展方面，比继承更有弹性。"]}),"\n",(0,i.jsxs)(e.li,{children:["体现了","开闭原则（ocp）"]}),"\n"]}),"\n",(0,i.jsxs)(e.h4,{id:"382-原理图",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#382-原理图",children:"#"}),"3.8.2 原理图"]}),"\n",(0,i.jsxs)(e.h4,{id:"383-星巴克点餐例子",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#383-星巴克点餐例子",children:"#"}),"3.8.3 星巴克点餐例子"]}),"\n",(0,i.jsx)(e.p,{children:"咖啡分为"}),"\n",(0,i.jsxs)(e.h4,{id:"384源码装饰者模式",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#384源码装饰者模式",children:"#"}),"3.8.4源码装饰者模式"]})]})}function I(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(O,n)})):O(n)}let k=I;I.__RSPRESS_PAGE_META={},I.__RSPRESS_PAGE_META["tang%2Fjava2%2F19_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md"]={toc:[{id:"1七大原则",text:"1.七大原则",depth:2},{id:"11-单一职责原则",text:"1.1 单一职责原则",depth:3},{id:"111-基本介绍",text:"1.1.1 基本介绍",depth:4},{id:"112-注意事项和细节",text:"1.1.2 注意事项和细节",depth:4},{id:"12-接口隔离原则",text:"1.2 接口隔离原则",depth:3},{id:"121-基本介绍",text:"1.2.1 基本介绍",depth:4},{id:"122-例子",text:"1.2.2 例子",depth:4},{id:"1221-未遵循接口隔离原则",text:"1.2.2.1 未遵循接口隔离原则",depth:4},{id:"1222-遵循接口隔离原则",text:"1.2.2.2 遵循接口隔离原则",depth:4},{id:"13-依赖倒转原则",text:"1.3 依赖倒转原则",depth:3},{id:"131-基本介绍",text:"1.3.1 基本介绍",depth:4},{id:"132-个人理解",text:"1.3.2 个人理解",depth:4},{id:"133-例子",text:"1.3.3 例子",depth:4},{id:"134-依赖关系传递的三种方式",text:"1.3.4 依赖关系传递的三种方式",depth:4},{id:"135-注意事项和细节",text:"1.3.5 注意事项和细节",depth:4},{id:"14-里氏替换原则",text:"1.4 里氏替换原则",depth:3},{id:"141-里氏替换原则产生的原因",text:"1.4.1 里氏替换原则产生的原因",depth:4},{id:"142-基本介绍",text:"1.4.2 基本介绍",depth:4},{id:"15-开闭原则",text:"1.5 开闭原则",depth:3},{id:"16-迪米特法则",text:"1.6 迪米特法则",depth:3},{id:"17-合成复用原则",text:"1.7 合成复用原则",depth:3},{id:"2uml类图",text:"2.UML类图",depth:2},{id:"21-基本介绍",text:"2.1 基本介绍",depth:3},{id:"22-uml类图的画法",text:"2.2 UML类图的画法",depth:3},{id:"3设计模式",text:"3.设计模式",depth:2},{id:"31-概述",text:"3.1 概述",depth:3},{id:"32-单例模式",text:"3.2 单例模式",depth:3},{id:"321-定义",text:"3.2.1 定义",depth:4},{id:"322-实现方式",text:"3.2.2 实现方式",depth:4},{id:"323-源码单例举例",text:"3.2.3 源码单例举例",depth:4},{id:"324-使用场景",text:"3.2.4 使用场景",depth:4},{id:"33-工厂模式",text:"3.3 工厂模式",depth:3},{id:"331-简单工厂模式",text:"3.3.1 简单工厂模式",depth:4},{id:"332-工厂方法模式",text:"3.3.2 工厂方法模式",depth:4},{id:"333-抽象工厂模式",text:"3.3.3 抽象工厂模式",depth:4},{id:"334-源码工厂模式举例",text:"3.3.4 源码工厂模式举例",depth:4},{id:"335-小结",text:"3.3.5 小结",depth:4},{id:"34-原型模式",text:"3.4 原型模式",depth:3},{id:"341-基本介绍",text:"3.4.1 基本介绍",depth:4},{id:"342-克隆羊例子",text:"3.4.2 克隆羊例子",depth:4},{id:"343-源码原型模式举例",text:"3.4.3 源码原型模式举例",depth:4},{id:"344-浅拷贝和深拷贝",text:"3.4.4 浅拷贝和深拷贝",depth:4},{id:"345-小结",text:"3.4.5 小结",depth:4},{id:"35-建造者模式",text:"3.5 建造者模式",depth:3},{id:"351-基本介绍",text:"3.5.1 基本介绍",depth:4},{id:"352-盖房子例子",text:"3.5.2 盖房子例子",depth:4},{id:"353-小结",text:"3.5.3 小结",depth:4},{id:"36-适配器模式",text:"3.6 适配器模式",depth:3},{id:"361-基本介绍",text:"3.6.1 基本介绍",depth:4},{id:"362-类适配器模式",text:"3.6.2 类适配器模式",depth:4},{id:"363-对象适配器模式",text:"3.6.3 对象适配器模式",depth:4},{id:"364-接口适配器模式",text:"3.6.4 接口适配器模式",depth:4},{id:"365-源码适配器模式举例",text:"3.6.5 源码适配器模式举例",depth:4},{id:"366-小结",text:"3.6.6 小结",depth:4},{id:"37-桥接模式",text:"3.7 桥接模式",depth:3},{id:"371-基本介绍",text:"3.7.1 基本介绍",depth:4},{id:"372-原理图类图",text:"3.7.2 原理图（类图）",depth:4},{id:"373-源码桥接模式举例",text:"3.7.3 源码桥接模式举例",depth:4},{id:"374-小结",text:"3.7.4 小结",depth:4},{id:"38-装饰者模式",text:"3.8 装饰者模式",depth:3},{id:"381-基本介绍",text:"3.8.1 基本介绍",depth:4},{id:"382-原理图",text:"3.8.2 原理图",depth:4},{id:"383-星巴克点餐例子",text:"3.8.3 星巴克点餐例子",depth:4},{id:"384源码装饰者模式",text:"3.8.4源码装饰者模式",depth:4}],title:"19 设计模式",headingTitle:"19 设计模式",frontmatter:{}}}}]);