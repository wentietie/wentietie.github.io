"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["3955"],{78926:function(i,n,e){e.r(n),e.d(n,{default:function(){return r}});var s=e(85893),t=e(50065);function c(i){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",div:"div",ul:"ul",li:"li"},(0,t.ah)(),i.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"长列表渲染优化",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#长列表渲染优化",children:"#"}),"长列表渲染优化"]}),"\n",(0,s.jsx)(n.p,{children:"今天咱们来看两个可以 直接提升渲染性能的 CSS 属性。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"content-visibility"})," ",(0,s.jsx)(n.code,{children:"contain-intrinsic-size"}),"\r\n这两个 CSS 属性，主要针对 长列表渲染。"]}),"\n",(0,s.jsxs)(n.h2,{id:"content-visibility",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#content-visibility",children:"#"}),"content-visibility"]}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"TIP"}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsx)(n.p,{children:"\ncontent-visibility是CSS新增的属性，主要用来提高页面渲染性能，它可以控制一个元素是否渲染其内容，并且允许浏览器跳过这些元素的布局与渲染。"})})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"visible"}),": 默认值，没有效果。元素的内容被正常布局和呈现"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hidden"}),": 元素跳过它的内容。跳过的内容不能被用户代理功能访问.\r\n例如在页面中查找、标签顺序导航等，也不能被选择或聚焦。这类似于给内容设置display:    none。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"auto"}),"：该元素打开布局包含、样式包含和绘制包含。如果该元素与用户不相关，它也会跳过其内容。\r\n与hidden不同，跳过的内容必须仍可正常用于用户代理功能，例如在页面中查找、tab 顺序导航等，并且必须正常可聚焦和可选择。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"content-visibility-hidden手动管理可见性",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#content-visibility-hidden手动管理可见性",children:"#"}),"content-visibility: hidden手动管理可见性"]}),"\n",(0,s.jsxs)(n.p,{children:["上面说到",(0,s.jsx)(n.code,{children:"content-visibility: hidden"}),"的效果与",(0,s.jsx)(n.code,{children:"display: none"}),"类似，但其实两者还是有比较大的区别的："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"content-visibility: hidden"})," 只是隐藏了子元素，自身不会被隐藏"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"content-visibility: hidden"})," 隐藏内容的渲染状态会被缓存，所以当它被移除或者设为可见时，浏览器不会重新渲染，而是会应用缓存，所以对于需要频繁切换显示隐藏的元素，这个属性能够极大地提高渲染性能。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"content-visibility-auto-跳过渲染工作",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#content-visibility-auto-跳过渲染工作",children:"#"}),"content-visibility: auto 跳过渲染工作"]}),"\n",(0,s.jsx)(n.p,{children:"我们仔细想想，页面上虽然会有很多元素，但是它们会同时呈现在用户眼前吗？很显然是不会的。"}),"\n",(0,s.jsx)(n.p,{children:"用户每次能够真实看到就只有设备可见区那些内容，对于非可见区的内容只要页面不发生滚动，用户就永远看不到。虽然用户看不到，但浏览器却会实实在在的去渲染，以至于浪费大量的性能。所以我们得想办法让浏览器不渲染非可视区的内容就能够达到提高页面渲染性能的效果。"}),"\n",(0,s.jsxs)(n.p,{children:["此时就可以直接使用 ",(0,s.jsx)(n.code,{children:"content-visibility: auto"})," 它可以用来跳过屏幕外的内容渲染，对于这种有大量离屏内容的长列表，可以大大减少页面渲染时间。"]}),"\n",(0,s.jsxs)(n.p,{children:["首先是没有添加",(0,s.jsx)(n.code,{children:"content-visibility: auto"}),"的效果，无论这些元素是否在可视区，都会被渲染"]}),"\n",(0,s.jsxs)(n.h2,{id:"contain-intrinsic-size-救场",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#contain-intrinsic-size-救场",children:"#"}),"contain-intrinsic-size 救场"]}),"\n",(0,s.jsxs)(n.p,{children:["页面在滚动过程中滚动条一直抖动，这是一个不能接受的体验问题，为了更好地实现content-visibility，浏览器需要应用",(0,s.jsx)(n.code,{children:"size containment"}),"\r\n以确保内容的渲染结果不会以任何方式影响元素的大小。\r\n这意味着该元素将像空的一样布局。如果元素没有在常规块布局中指定的高度，那么它将是0高度。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个时候我们可以使用",(0,s.jsx)(n.code,{children:"contain-intrinsic-size"}),"来指定的元素自然大小，确保我们未渲染子元素的 div 仍然占据空间，同时也保留延迟渲染的好处。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们只需要给添加了",(0,s.jsx)(n.code,{children:"content-visibility:auto"}),"的元素添加上",(0,s.jsx)(n.code,{children:"contain-intrinsic-size"}),"就能够解决滚动条抖动的问题。\r\n当然，这个高度约接近真实渲染的高度，效果会越好，如果实在无法知道准确的高度，我们也可以给一个大概的值，也会使滚动条的问题相对减少。"]})]})}function d(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),i.components);return n?(0,s.jsx)(n,Object.assign({},i,{children:(0,s.jsx)(c,i)})):c(i)}let r=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["notes%2FCSS%2Flonglist.md"]={toc:[{id:"content-visibility",text:"content-visibility",depth:2},{id:"content-visibility-hidden手动管理可见性",text:"content-visibility: hidden手动管理可见性",depth:2},{id:"content-visibility-auto-跳过渲染工作",text:"content-visibility: auto 跳过渲染工作",depth:2},{id:"contain-intrinsic-size-救场",text:"contain-intrinsic-size 救场",depth:2}],title:"长列表渲染优化",headingTitle:"长列表渲染优化",frontmatter:{}}}}]);