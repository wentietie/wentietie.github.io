"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["1837"],{26652:function(n,r,e){e.r(r),e.d(r,{default:function(){return c}});var t=e(85893),i=e(50065);function a(n){let r=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",blockquote:"blockquote",p:"p",ul:"ul",li:"li",pre:"pre",code:"code"},(0,i.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.h1,{id:"18-juc并发编程",children:["18 JUC并发编程",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#18-juc并发编程",children:"#"})]}),"\n",(0,t.jsxs)(r.h2,{id:"181集合类不安全",children:["18.1.集合类不安全",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#181集合类不安全",children:"#"})]}),"\n",(0,t.jsxs)(r.h3,{id:"1811-list不安全",children:["18.1.1 List不安全",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1811-list不安全",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"解决方案"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用Vector"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"List<String> list = new Vector<>)();\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用Collections.synchronizedList"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"List<String> list = Collections.synchronizedList(new ArrayList<>());\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用CopyOnWriteArrayList----JUC编程"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"List<String> list = new CopyOnWriteArrayList<>();\n"})}),"\n",(0,t.jsx)(r.p,{children:"CopyOnWriteArrayList和Vector相比，CopyOnWriteArrayList使用Lock实现的同步，Vector使用的是synchronized，前者效率更高。"}),"\n",(0,t.jsx)(r.p,{children:"CopyOnWrite 写入时复制。------ COW 计算机程序设计领域的一种优化策略。"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"// CopyOnWriteArrayList.add()源码\r\n\r\npublic boolean add(E e) {\r\n        final ReentrantLock lock = this.lock;\r\n        lock.lock();\r\n        try {\r\n            Object[] elements = getArray();\r\n            int len = elements.length;\r\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\r\n            newElements[len] = e;\r\n            setArray(newElements);\r\n            return true;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"1812-set不安全",children:["18.1.2 Set不安全",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1812-set不安全",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"解决方案"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用Collections.synchronizedSet"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"List<String> list = CCollections.synchronizedSet(new HashSet<>());\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用CopyOnWriteArrayList----JUC编程"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"List<String> list =  new CopyOnWriteArraySet<>();\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"1813-hashmap",children:["18.1.3 HashMap",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1813-hashmap",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"解决方案"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用Collections.synchronizedMap"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"Map<String, String> map2 = Collections.synchronizedMap(new HashMap<>());\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"使用ConcurrentHashMap----JUC编程"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"Map<String, String> map = new ConcurrentHashMap<>();\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"1814-代码总结",children:["18.1.4 代码总结",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1814-代码总结",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.modules.Thread;\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.CopyOnWriteArrayList;\r\nimport java.util.concurrent.CopyOnWriteArraySet;\r\n\r\npublic class UnSafeList {\r\n    public static void main(String[] args) {\r\n        addList();\r\n        addSet();\r\n        addMap();\r\n    }\r\n\r\n    public static void addList() {\r\n        // 不安全\r\n        List<String> list1 = new ArrayList<>();\r\n        // 使用工具类\r\n        List<String> list2 = Collections.synchronizedList(new ArrayList<>());\r\n        // JUC\r\n        List<String> list = new CopyOnWriteArrayList<>();\r\n        for (int i = 1; i <= 10; i++) {\r\n            new Thread(()->{\r\n                list.add(UUID.randomUUID().toString().substring(0,5));\r\n                System.out.println(list);\r\n            }, i+"").start();\r\n        }\r\n    }\r\n\r\n    public static void addSet() {\r\n        // 不安全\r\n        Set<String> set1 = new HashSet<>();\r\n        // 使用工具类\r\n        Set<String> set2 = Collections.synchronizedSet(new HashSet<>());\r\n        // JUC\r\n        Set<String> set = new CopyOnWriteArraySet<>();\r\n        for (int i = 1; i < 11; i++) {\r\n            new Thread(() -> {\r\n                set.add(UUID.randomUUID().toString().substring(0,5));\r\n                System.out.println(set);\r\n            }, String.valueOf(i)).start();\r\n        }\r\n    }\r\n\r\n    public static void addMap() {\r\n        // 不安全\r\n        Map<String, String> map1 = new HashMap<>();\r\n        // 使用工具类\r\n        Map<String, String> map2 = Collections.synchronizedMap(new HashMap<>());\r\n        // JUC\r\n        Map<String, String> map = new ConcurrentHashMap<>();\r\n\r\n        for (int i = 1; i < 11; i++) {\r\n            new Thread(() -> {\r\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));\r\n                System.out.println(map);\r\n            }, String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.h2,{id:"182callable",children:["18.2.Callable",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#182callable",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.modules.Thread;\r\n\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.FutureTask;\r\n\r\npublic class CallableTest {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        MyThread myThread = new MyThread();\r\n        //适配类\r\n        FutureTask futureTask = new FutureTask(myThread);\r\n        new Thread(futureTask, "A").start();\r\n        new Thread(futureTask, "B").start(); // 两个线程，只会打印一次“---call---”，是因为结果会被缓存。有缓存，会提高效率\r\n        //获取Callable返回值。此方法可能会产生阻塞，一般把它放到最后一行，或者使用异步通信。\r\n        String result = futureTask.get().toString();\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\nclass MyThread implements Callable<String> {\r\n    @Override\r\n    public String call() throws Exception {\r\n        System.out.println("---call---");\r\n        return "111";\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"细节："}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"有缓存----效率高"}),"\n",(0,t.jsx)(r.li,{children:"futureTask.get()可能会发生阻塞"}),"\n"]}),"\n",(0,t.jsxs)(r.h2,{id:"183常用辅助类",children:["18.3.常用辅助类",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#183常用辅助类",children:"#"})]}),"\n",(0,t.jsxs)(r.h3,{id:"1831-countdownlanch",children:["18.3.1 CountDownLanch",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1831-countdownlanch",children:"#"})]}),"\n",(0,t.jsx)(r.p,{children:"其实是个减法计数器。"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"CountDownLatch countDownLatch = new CountDownLatch(6);\n"})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"原理"}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"countDownLatch.countDown()"}),"数量减一；"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"countDownLatch.await()"}),"等待计数器归零，然后再向下执行。"]}),"\n",(0,t.jsxs)(r.p,{children:["每个线程执行完毕后，调用",(0,t.jsx)(r.code,{children:"countDownLatch.countDown()"}),"方法，会执行减一操作。"]}),"\n",(0,t.jsxs)(r.h3,{id:"1832-cyclicbarrier",children:["18.3.2 CyclicBarrier",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1832-cyclicbarrier",children:"#"})]}),"\n",(0,t.jsx)(r.p,{children:"其实是个加法计数器。"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {\r\n    System.out.println("召唤神龙成功");\r\n});\r\n\r\nfor (int i = 1; i <= 7; i++) {\r\n    final int temp = i;\r\n    new Thread(()-> {\r\n        System.out.println(Thread.currentThread().getName()+"收集了"+temp+"个龙珠");\r\n        try {\r\n            cyclicBarrier.await();//等待\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (BrokenBarrierException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }).start();\r\n}\n'})}),"\n",(0,t.jsxs)(r.h3,{id:"1833-semaphore",children:["18.3.3 Semaphore",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1833-semaphore",children:"#"})]}),"\n",(0,t.jsx)(r.p,{children:"抢车位。一般限流时使用。"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'	// 3个车位，6辆车，抢车位\r\n        Semaphore semaphore = new Semaphore(3);\r\n        for (int i = 1; i <= 6; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    semaphore.acquire(); // 抢到车位\r\n                    System.out.println(Thread.currentThread().getName()+"抢到车位");\r\n                    TimeUnit.SECONDS.sleep(3);\r\n                    System.out.println(Thread.currentThread().getName()+"离开车位");\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    semaphore.release();// 离开车位\r\n                }\r\n            }, String.valueOf(i)).start();\r\n        }\n'})}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"原理"}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"semaphore.acquire();"}),"获得。假设已经满了，就会等待，一直到被释放为止。"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"semaphore.release();"}),"释放。会将当前的信号释放，唤醒正在等待的县程。"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"作用"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"多个共享资源互斥时使用"}),"\n",(0,t.jsx)(r.li,{children:"并发限流，控制最大线程数"}),"\n"]}),"\n",(0,t.jsxs)(r.h2,{id:"184线程池",children:["18.4.线程池",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#184线程池",children:"#"})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"使用线程池的好处"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"降低资源消耗"}),"\n",(0,t.jsx)(r.li,{children:"提高响应速度"}),"\n",(0,t.jsx)(r.li,{children:"可以控制最大线程数"}),"\n",(0,t.jsx)(r.li,{children:"方便管理线程"}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"1841-三大方法",children:["18.4.1 “三大方法”",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1841-三大方法",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.modules.Thread;\r\n\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\n/**\r\n * Executors 工具类：3大方法\r\n */\r\npublic class ThreadPoolDemo {\r\n    public static void main(String[] args) {\r\n        // 创建线程池---线程池中只有一个线程\r\n        ExecutorService service1 = Executors.newSingleThreadExecutor();\r\n        // 创建线程池---指定线程池中线程数量\r\n        ExecutorService service2 = Executors.newFixedThreadPool(5);\r\n        // 创建线程池---线程池大小可伸缩，遇强则强遇弱则弱\r\n        ExecutorService service3 = Executors.newCachedThreadPool();\r\n\r\n        try{\r\n            for (int i = 1; i <= 10; i++) {\r\n                // 创建线程\r\n                service3.execute(() -> {\r\n                    System.out.println(Thread.currentThread().getName()+" ok");\r\n                });\r\n            }\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 线程池使用完毕，关闭线程池\r\n            service3.shutdown();\r\n        }\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.p,{children:["创建线程池不要使用",(0,t.jsx)(r.code,{children:"Executors"}),"工具类，而是使用底层方法",(0,t.jsx)(r.code,{children:"ThreadPoolExecutor"}),"。"]}),"\n",(0,t.jsxs)(r.p,{children:["使用",(0,t.jsx)(r.code,{children:"Executors"}),"工具类的弊端如下："]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"FixedThreadPool"}),"和",(0,t.jsx)(r.code,{children:"SingleThreadPool"}),"：允许请求的队列长度是",(0,t.jsx)(r.code,{children:"Integer.MAX_VALUE"}),"(约为21亿)，可能会堆积大量请求，导致OOM。"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"CachedThreadPool"}),"和",(0,t.jsx)(r.code,{children:"ScheduledThreadPool"}),"：允许创建的线程数量是",(0,t.jsx)(r.code,{children:"Integer.MAX_VALUE"}),"(约为21亿)，可能会创建大量线程，导致OOM。"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"1842-七大参数",children:['18.4.2 "七大参数"',(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1842-七大参数",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.modules.Thread;\r\n\r\nimport java.util.concurrent.*;\r\n\r\n/**\r\n * Executors 工具类：7大参数\r\n */\r\npublic class ThreadPoolDemo {\r\n    public static void main(String[] args) {\r\n        // 使用ThreadPoolExecutor创建线程池\r\n        // 最大线程数=max+queue长度\r\n        ExecutorService service = new ThreadPoolExecutor(\r\n                2, //核心线程数\r\n                5,//最大线程数\r\n                3,// 超时多长时间没被调用就会释放\r\n                TimeUnit.SECONDS,// 超时单位\r\n                new ArrayBlockingQueue<>(3),// 阻塞队列\r\n                Executors.defaultThreadFactory(),// 线程工厂，创建线程，一般不用动\r\n                new ThreadPoolExecutor.AbortPolicy() // 拒绝策略\r\n        );\r\n\r\n        try{\r\n            for (int i = 1; i <= 8; i++) {\r\n                // 创建线程\r\n                service.execute(() -> {\r\n                    System.out.println(Thread.currentThread().getName()+" ok");\r\n                });\r\n            }\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 线程池使用完毕，关闭线程池\r\n            service.shutdown();\r\n        }\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.h3,{id:"1843-四大拒绝策略",children:['18.4.3 "四大拒绝策略"',(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1843-四大拒绝策略",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.modules.Thread;\r\n\r\nimport java.util.concurrent.*;\r\n\r\n/**\r\n * Executors 工具类：4大拒绝策略\r\n */\r\npublic class ThreadPoolDemo {\r\n    public static void main(String[] args) {\r\n        // 使用ThreadPoolExecutor创建线程池\r\n        ExecutorService service = new ThreadPoolExecutor(\r\n                2, //核心线程数\r\n                5,//最大线程数\r\n                3,// 超时多长时间没被调用就会释放，释放的是（最大线程-核心线程）\r\n                TimeUnit.SECONDS,// 超时单位\r\n                new ArrayBlockingQueue<>(3),// 阻塞队列\r\n                Executors.defaultThreadFactory(),// 线程工厂，创建线程，一般不用动\r\n//                new ThreadPoolExecutor.AbortPolicy() // 缓存队列已满，且超出最大线程数，抛出异常\r\n//                new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的回哪去\r\n//                new ThreadPoolExecutor.DiscardPolicy() // 超出的线程会被丢弃，不会抛出异常\r\n                new ThreadPoolExecutor.DiscardOldestPolicy() //超出的线程会尝试着和最老的进程竞争，成功与否不敢保证\r\n        );\r\n\r\n        try{\r\n            for (int i = 1; i <= 28; i++) {\r\n                // 创建线程\r\n                service.execute(() -> {\r\n                    System.out.println(Thread.currentThread().getName()+" ok");\r\n                });\r\n            }\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 线程池使用完毕，关闭线程池\r\n            service.shutdown();\r\n        }\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.h3,{id:"1844-线程池的最大大小如何设置",children:["18.4.4 线程池的最大大小如何设置？",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1844-线程池的最大大小如何设置",children:"#"})]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"CPU密集型：电脑CPU几核就是几，可以保持CPU的效率最高"}),"\n",(0,t.jsxs)(r.p,{children:["使用",(0,t.jsx)(r.code,{children:"Runtime.getRuntime().availableProcessors()"}),"获取CPU核数！"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"IO密集型：程序中十分耗IO的线程数*2"}),"\n"]}),"\n",(0,t.jsx)(r.li,{}),"\n"]}),"\n",(0,t.jsxs)(r.h2,{id:"185forkjoin",children:["18.5.ForkJoin",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#185forkjoin",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.JUC;\r\n\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.ForkJoinPool;\r\nimport java.util.concurrent.RecursiveTask;\r\nimport java.util.stream.LongStream;\r\n\r\n\r\npublic class ForkJoinDemo {\r\n    public static void main(String[] args) {\r\n        System.out.println("核数："+Runtime.getRuntime().availableProcessors());\r\n        // 普通累加\r\n        test1();\r\n        // 使用ForkJoin\r\n        test2();\r\n        // 使用流\r\n        test3();\r\n    }\r\n\r\n    /**\r\n     * 普通累加\r\n     */\r\n    public static void test1() {\r\n        System.out.println("test1===========================");\r\n        Long start = System.currentTimeMillis();\r\n        \r\n        Long sum = 0L;\r\n        for (Long i = 1L; i <= 10_0000_0000; i++) {\r\n            sum += i;\r\n        }\r\n        \r\n        Long end = System.currentTimeMillis();\r\n        System.out.println("sum="+sum+"   耗时："+ (end - start) + "ms");\r\n    }\r\n\r\n    /**\r\n     * 使用ForkJoin\r\n     * *******************************************************\r\n     * 使用方法：\r\n     * 1、通过ForkJoin池执行，故需要ForkJoinPool forkJoinPool= new ForkJoinPool();\r\n     * 2、执行ForkJoin任务，即forkJoinPool.execute(ForkJoinTask)或者forkJoinPool.submit(ForkJoinTask)。前者没有返回值，后者可以获取返回值。此处我们需要返回值，故使用submit方法\r\n     * 3、创建ForkJoinTask类。该类有两个常用子类：RecursiveAction(递归事件，没有返回值)、 RecursiveTask(递归任务，有返回值)。此处我们需要返回值，故使用RecursiveTask子类\r\n     * 4、编写自己的类继承RecursiveTask类，并实现其中的抽象方法compute()。在该方法中进行计算并返回\r\n     * 5、在compute()方法中，调用RecursiveTask.fork()拆分任务，将任务压入到线程队列；使用RecursiveTask.join()方法获取单个任务的值\r\n     *\r\n     *\r\n     */\r\n    public static void test2() {\r\n        System.out.println("test2===========================");\r\n        Long start = System.currentTimeMillis();\r\n        \r\n        Long sum = 0L;\r\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\r\n        MyForkJoinTask myForkJoinTask = new MyForkJoinTask(0L, 10_0000_0000L);\r\n        forkJoinPool.submit(myForkJoinTask);\r\n        try {\r\n            sum = myForkJoinTask.get();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        Long end = System.currentTimeMillis();\r\n        System.out.println("sum="+sum+"   耗时："+ (end - start) + "ms");\r\n    }\r\n\r\n    /**\r\n     * 使用流\r\n     */\r\n    public static void test3() {\r\n        System.out.println("test3===========================");\r\n        Long start = System.currentTimeMillis();\r\n        \r\n        Long sum = LongStream.rangeClosed(0L, 10_0000_0000).parallel().reduce(0, Long::sum);\r\n        \r\n        Long end = System.currentTimeMillis();\r\n        System.out.println("sum="+sum+"   耗时："+ (end - start) + "ms");\r\n    }\r\n}\r\n\r\nclass MyForkJoinTask extends RecursiveTask<Long> {\r\n    private Long start = 0L;\r\n    private Long end = 10_0000_0000L;\r\n    private Long temp = 1_0000L;\r\n\r\n    public MyForkJoinTask(Long start, Long end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n\r\n    @Override\r\n    protected Long compute() {\r\n        Long sum = 0L;\r\n        // 如果end > temp,直接累加；否则使用ForkJoin分支合并\r\n        if ((end - start) > temp) {\r\n            for (Long i = start; i <= end; i++) {\r\n                sum += i;\r\n            }\r\n        }else {\r\n            Long middle = (start + end) / 2;\r\n            MyForkJoinTask task1 = new MyForkJoinTask(start, middle);\r\n            task1.fork();// 拆分任务，把任务压入到线程队列\r\n            MyForkJoinTask task2 = new MyForkJoinTask(middle +1, end);\r\n            task2.fork();\r\n            sum = task1.join() + task2.join();\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"\r\n核数：12\r\ntest1===========================\r\nsum=500000000500000000   耗时：4871ms\r\ntest2===========================\r\nsum=500000000500000000   耗时：4142ms\r\ntest3===========================\r\nsum=500000000500000000   耗时：131ms\r\n\r\nProcess finished with exit code 0\n"})}),"\n",(0,t.jsxs)(r.h2,{id:"186异步回调",children:["18.6.异步回调",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#186异步回调",children:"#"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package io.renren.JUC;\r\n\r\nimport java.util.concurrent.CompletableFuture;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/**\r\n * 异步回调\r\n */\r\npublic class AsyncDemo {\r\n    public static void main(String[] args) {\r\n\r\n        test1();\r\n        test2();\r\n\r\n    }\r\n\r\n    /**\r\n     * 没有返回值的异步回调\r\n     */\r\n    public static void test1() {\r\n        System.out.println("test1================================");\r\n        CompletableFuture<Void> voidC = CompletableFuture.runAsync(() -> {\r\n            try {\r\n                TimeUnit.SECONDS.sleep(3);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println("没有返回值的异步回调");\r\n        });\r\n\r\n        System.out.println("主线程代码");\r\n\r\n        try {\r\n            System.out.println("获取返回值====>"+voidC.get());\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 有返回值的异步回调\r\n     */\r\n    public static void test2() {\r\n        System.out.println("\\ntest2================================");\r\n        CompletableFuture<Integer> integerC = CompletableFuture.supplyAsync(() -> {\r\n            try {\r\n                TimeUnit.SECONDS.sleep(3);\r\n                System.out.println("有返回值的异步请求");\r\n                int i = 10/0;\r\n                return 200;\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n                return 300;\r\n            }\r\n        });\r\n\r\n        System.out.println("主线程代码");\r\n\r\n        // 请求成功后的处理\r\n        try {\r\n            System.out.println(integerC.whenComplete((t, u) -> {\r\n                System.out.println("t=======>" + t);\r\n                System.out.println("u=======>" + u);\r\n            }).exceptionally(e -> {\r\n                e.getMessage();\r\n                return 500;\r\n            }).get());\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n\n'})})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),n.components);return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}let c=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["tang%2Fjava2%2F18_JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.md"]={toc:[{text:"18.1.集合类不安全",id:"181集合类不安全",depth:2},{text:"18.1.1 List不安全",id:"1811-list不安全",depth:3},{text:"18.1.2 Set不安全",id:"1812-set不安全",depth:3},{text:"18.1.3 HashMap",id:"1813-hashmap",depth:3},{text:"18.1.4 代码总结",id:"1814-代码总结",depth:3},{text:"18.2.Callable",id:"182callable",depth:2},{text:"18.3.常用辅助类",id:"183常用辅助类",depth:2},{text:"18.3.1 CountDownLanch",id:"1831-countdownlanch",depth:3},{text:"18.3.2 CyclicBarrier",id:"1832-cyclicbarrier",depth:3},{text:"18.3.3 Semaphore",id:"1833-semaphore",depth:3},{text:"18.4.线程池",id:"184线程池",depth:2},{text:"18.4.1 “三大方法”",id:"1841-三大方法",depth:3},{text:'18.4.2 "七大参数"',id:"1842-七大参数",depth:3},{text:'18.4.3 "四大拒绝策略"',id:"1843-四大拒绝策略",depth:3},{text:"18.4.4 线程池的最大大小如何设置？",id:"1844-线程池的最大大小如何设置",depth:3},{text:"18.5.ForkJoin",id:"185forkjoin",depth:2},{text:"18.6.异步回调",id:"186异步回调",depth:2}],title:"18 JUC并发编程",frontmatter:{}}}}]);