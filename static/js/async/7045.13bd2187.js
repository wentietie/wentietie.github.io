"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["7045"],{78225:function(e,n,r){r.r(n),r.d(n,{default:function(){return t}});var a=r(85893),i=r(50065);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h3:"h3",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"浏览器刷新过程",children:["浏览器刷新过程",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器刷新过程",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"浏览器刷新做的只是重新加载网页数据【强制刷新的区别只是不使用浏览器缓存下来的HTML、JS数据，所有本页面用到的HTML、JS都需要重新向服务器获取】，并重新解析生成 DOM 树，当然还同时会重新解释执行 JavaScript 代码，之后重新绘制页面，注册绑定事件，之前页面在活动的时候对 JavaScript 变量做的数据赋值数据都会消失。"}),"\n",(0,a.jsxs)(n.h3,{id:"相关浏览器事件",children:["相关浏览器事件",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#相关浏览器事件",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"onbeforeunload：浏览器的刷新和关闭之前执行的方法"}),"\n",(0,a.jsx)(n.li,{children:"onunload：已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。"}),"\n",(0,a.jsx)(n.li,{children:"onload：资源已加载时被触发。"}),"\n"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(s,{...e})}):s(e)}let t=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["notes%2Fbrowser%2Frefresh.md"]={toc:[{text:"相关浏览器事件",id:"相关浏览器事件",depth:3}],title:"浏览器刷新过程",frontmatter:{}}}}]);