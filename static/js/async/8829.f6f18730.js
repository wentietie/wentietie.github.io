"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["8829"],{53576:function(n,r,e){e.r(r),e.d(r,{default:()=>h});var l=e("85893"),i=e("50065");let s=e.p+"static/image/08_img.87e5d71e.png";function c(n){let r=Object.assign({h1:"h1",a:"a",h3:"h3",ul:"ul",li:"li",p:"p",strong:"strong",blockquote:"blockquote",pre:"pre",code:"code",img:"img"},(0,i.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(r.h1,{id:"8-多线程",children:["8 多线程",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#8-多线程",children:"#"})]}),"\n",(0,l.jsxs)(r.h3,{id:"81-基本概念",children:["8.1 基本概念",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#81-基本概念",children:"#"})]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["程序（program）","：是为了完成特定的任务、用某种语言编写的一组指令的集合。即一段静态的代码，静态对象"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["进程（process）","：是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程，有他自身的产生、存在和消亡的过程"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"程序是静态的，进程是动态的"}),"\n",(0,l.jsxs)(r.li,{children:["进程作为","资源分配的单位","，系统在运行时会为每个进程分配不同的内存区域"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["线程（thread）","：进程可以进一步细化为线程，是一个程序内部的一条执行路径"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"若一个进程同一时间可以并行执行多个线程，那么这个进程就是支持多线程的"}),"\n",(0,l.jsxs)(r.li,{children:["线程作为","调度和执行的单位","，",(0,l.jsx)(r.strong,{children:"每个线程拥有独立的运行栈和程序计数器（pc）"}),"，线程切换的开销小"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"一个进程中的多个线程共享相同的方法区、堆"}),"，他们从同一堆中分配对象，可以访问相同的变量和对象。这使得线程间通信更简便、高效。但多个线程操作共享的系统资源就会带来安全隐患"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["单核CPU","：其实是一种假的多线程，因为他在一个时间单元内，也只能执行一个线程的任务"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["多核CPU","：多核CPU才能更好的发挥多线程的效率"]}),"\n",(0,l.jsx)(r.p,{children:"一个Java应用程序java.exe，其实至少有3个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["并行","：多个CPU同事执行多个任务。如：多个人同时做不同的事情"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["并发","：一个CPU（采用时间片）同时执行多个任务。如：秒杀，多个人同时做一件事"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["多线程的优点","："]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"提高应用程序的相应。对图形化界面更有意义，可增强用户体验"}),"\n",(0,l.jsx)(r.li,{children:"提高计算机系统CPU的利用率"}),"\n",(0,l.jsx)(r.li,{children:"改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["何时需要多线程","："]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"程序需要同时执行两个或多个任务"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索。"}),"\n",(0,l.jsx)(r.p,{children:"比如点外卖时，手指上划，获取数据和图片加载就是两个线程"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"需要一些后台运行的程序时"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"82-线程的创建和使用",children:["8.2 线程的创建和使用",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#82-线程的创建和使用",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["更深的课程：",(0,l.jsx)(r.a,{href:"https://www.bilibili.com/video/BV18b411M7xz?p=45&vd_source=555f33f5f6791940abce98aa27017451",target:"_blank",rel:"noopener noreferrer",children:"45_Callable接口_哔哩哔哩_bilibili"})]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"线程创建的方法"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"方法一：继承Thread类"}),"\n",(0,l.jsx)(r.li,{children:"方法二：实现Runnable接口"}),"\n",(0,l.jsx)(r.li,{children:"方法三：实现Callable接口（JDK5.0新增）"}),"\n",(0,l.jsx)(r.li,{children:"方法四：使用线程池（JDK5.0新增）"}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方式一：继承Thread类"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"步骤"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"创建一个继承Thread类的子类"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"在子类中重写Thread的run()方法"}),"\n",(0,l.jsx)(r.p,{children:"将线程需要执行的操作，声明在run()方法中"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"创建子类的实例对象"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"调用子类实例对象的start()方法"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["start()方法的作用","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"启动当前线程"}),"\n",(0,l.jsxs)(r.li,{children:["调用",(0,l.jsx)(r.strong,{children:"当前线程"}),"的run()方法"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["不可以让已经start()的线程重新start()。","否则会报IllegalThreadStateException"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方式二：实现Runnable接口"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"步骤"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"创建一个实现Runnable接口的类"}),"\n",(0,l.jsx)(r.li,{children:"实现类中去重写Runnable接口的抽象方法run()"}),"\n",(0,l.jsx)(r.li,{children:"创建实现类的对象"}),"\n",(0,l.jsx)(r.li,{children:"将次对象作为参数传递到Thread类的构造器中，创建Thread类对象"}),"\n",(0,l.jsx)(r.li,{children:"通过Thread类的对象调用run()"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["二者的联系如下：","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"Thread本身也实现了Runnable接口"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["相同点：","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"两种方式都要重写run()，将线程要执行的逻辑写在run()中"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方式三：实现Callable接口"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"步骤"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"创建一个实现Callable的实现类"}),"\n",(0,l.jsx)(r.li,{children:"实现call()方法：将此线程需要执行的操作声明在此方法中。call()是可以有返回值的"}),"\n",(0,l.jsx)(r.li,{children:"创建Callable实现类的对象"}),"\n",(0,l.jsx)(r.li,{children:"创建FutureTask对象：将上述Callable实现类对象，作为参数传递到FutureTask构造器中"}),"\n",(0,l.jsx)(r.li,{children:"创建Thread对象并运行：需要将FutureTask对象作为参数传递到Thread构造器中"}),"\n",(0,l.jsx)(r.li,{children:"（可选）获取Callable实现类中call()的返回值：借助FutureTask对象的get()方法获取"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等"}),"\n",(0,l.jsx)(r.li,{children:"FutureTask是Future接口的唯一实现类"}),"\n",(0,l.jsx)(r.li,{children:"FutureTask同时实现了Runnable、Future接口。既可以作为Runnable被线程执行，又可以作为Future得到Callable中call()的返回值"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["与实现Runnable相比，Callable功能更强大","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"相比run()方法，Callable接口中的call()可以有返回值"}),"\n",(0,l.jsx)(r.li,{children:"call()方法可以抛出异常"}),"\n",(0,l.jsx)(r.li,{children:"Callable支持泛型"}),"\n",(0,l.jsx)(r.li,{children:"需要借助FutureTask类，来获取返回结果"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:"package com.tth.learn.java;\r\n\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.FutureTask;\r\n\r\n/**\r\n * 创建线程的方式三：实现Callable接口（JDK5.0新增）\r\n * @Author tth\r\n * @Date 2022/11/3 17:37\r\n */\r\npublic class CreateThreadTest3 {\r\n    public static void main(String[] args) {\r\n        // 3.创建Callable实现类对象\r\n        MyThreadByCallable mtc = new MyThreadByCallable();\r\n\r\n        // 4.创建FutureTask对象\r\n        FutureTask futureTask = new FutureTask(mtc);\r\n\r\n        // 5.创建Thread对象，并启动线程\r\n        new Thread(futureTask).start();\r\n\r\n        try {\r\n            // 6.获取call()中返回值\r\n            Object o = futureTask.get();\r\n            System.out.println(o);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n// 1.创建Callable的实现类\r\nclass MyThreadByCallable implements Callable {\r\n    // 2.重写call()\r\n    @Override\r\n    public Object call() throws Exception {\r\n        int sum = 0;\r\n        for (int i = 1; i <= 100; i++) {\r\n            if (i % 2 == 0) {\r\n                System.out.println(i);\r\n                sum += i;\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方式四：使用线程池"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"经常创建和销毁、使用量特别大的资源。如并发情况下的线程，对性能影响很大"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"提高响应速度（减少了创建新线程的时间）"}),"\n",(0,l.jsx)(r.li,{children:"降低资源消耗（重复利用线程池中的线程，不需要每次都创建）"}),"\n",(0,l.jsxs)(r.li,{children:["便于线程管理：","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"corePoolSize：核心池的大小"}),"\n",(0,l.jsx)(r.li,{children:"maximumPoolSize：最大线程数"}),"\n",(0,l.jsx)(r.li,{children:"KeepAliveTime：线程没有任务时最多保持多长时间会终止"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["ExecutorService","："]}),"\n",(0,l.jsxs)(r.li,{children:["Executors","："]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"83-thread类中的方法",children:["8.3 Thread类中的方法",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#83-thread类中的方法",children:"#"})]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["start()","：启动当前线程；调用当前线程的run()"]}),"\n",(0,l.jsxs)(r.li,{children:["run()","：通常都需要重写该方法，将创建的线程要执行的操作声明在此方法中"]}),"\n",(0,l.jsxs)(r.li,{children:["currentThread()","：静态方法，返回执行当前代码的线程"]}),"\n",(0,l.jsxs)(r.li,{children:["getName()","：获取当前线程的名字"]}),"\n",(0,l.jsxs)(r.li,{children:["setName()","：设置当前线程的名字"]}),"\n",(0,l.jsxs)(r.li,{children:["yield()","：释放当前CPU的执行权（当然下一个CPU的执行权也有可能被争取到）"]}),"\n",(0,l.jsxs)(r.li,{children:["join()","：在线程a中调用线程b的join()，此时线程a就会进入阻塞状态，直到线程b执行完成后，线程a才会结束阻塞状态"]}),"\n",(0,l.jsxs)(r.li,{children:["stop()","：已过时。强制结束当前线程，不推荐使用"]}),"\n",(0,l.jsxs)(r.li,{children:["sleep(long millis)","：静态方法，让当前线程“睡眠”指定的millis毫秒。在指定的millis毫秒时间内，当前线程是阻塞的装填"]}),"\n",(0,l.jsxs)(r.li,{children:["isAlive()","：判断当前线程是否存活"]}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"84-线程的调度",children:["8.4 线程的调度",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#84-线程的调度",children:"#"})]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"CPU调度策略"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"时间片：执行一段时间的A，再去执行一定时间的B，再去执行一定时间的C......"}),"\n",(0,l.jsx)(r.li,{children:"抢占式：高优先级的线程抢占CPU"}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"Java的调度方法"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"同优先级线程组成先进先出队列，使用时间片策略"}),"\n",(0,l.jsx)(r.li,{children:"对于高优先级的，使用优先调度的抢占式策略"}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"线程的优先级"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"线程优先级的等级"}),"\n",(0,l.jsx)(r.p,{children:"共10档，有三个常量，如下："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["MAX_PRIORITY","：10。最大的优先级"]}),"\n",(0,l.jsxs)(r.li,{children:["MIN_PRIORITY","：1。最小的优先级"]}),"\n",(0,l.jsxs)(r.li,{children:["NORM_PRIORITY","：5。默认的优先级"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"涉及的方法"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["getPriority()","：返回线程的优先级"]}),"\n",(0,l.jsxs)(r.li,{children:["setPriority(int newPriority)","：改变线程的优先级"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"说明"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"线程创建时，继承父线程的优先级"}),"\n",(0,l.jsx)(r.li,{children:"低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"85-线程的分类",children:["8.5 线程的分类",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#85-线程的分类",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["Java中的线程分类两类，一种是","守护线程","，一种是","用户线程","。"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"它们几乎在每个方面都是相同的，唯一的区别就是判断JVM何时离开"}),"\n",(0,l.jsxs)(r.li,{children:["守护线程是用来服务用户线程的，通过在start()前调用",(0,l.jsx)(r.code,{children:"线程实例对象.setDaemon(true)"}),"可以把一个用户线程变成一个守护线程"]}),"\n",(0,l.jsx)(r.li,{children:"Java垃圾回收就是一个典型的守护线程"}),"\n",(0,l.jsx)(r.li,{children:"若JVM中都是守护线程，当前JVM将退出"}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"86-线程的生命周期",children:["8.6 线程的生命周期",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#86-线程的生命周期",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:s,alt:""})}),"\n",(0,l.jsxs)(r.h3,{id:"87-线程的同步",children:["8.7 线程的同步",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#87-线程的同步",children:"#"})]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"线程同步的方法"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"方法一：同步代码块"}),"\n",(0,l.jsx)(r.li,{children:"方法二：同步方法"}),"\n",(0,l.jsx)(r.li,{children:"方法三：使用Lock锁"}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方式一：同步代码块"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"语法："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:"synchronized(同步监视器) {\r\n    // 需要被同步的代码，即操作共享数据的代码\r\n}\n"})}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"说明"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"同步监视器：即锁，任何一个类的对象，都可以充当锁。"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"要求：多个线程共用同一把锁"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"补充："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"在实现Runnable接口创建多线程的方式中，可以考虑使用this、或者声明一个实现类的属性（该属性是一个类的实例）作为同步监视器"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:'class Window2 implements Runnable {\r\n    // 此处可以不使用static。因为虽然开了3个窗口，但是实际上共用的是一个Window对象\r\n    private int ticket = 100;\r\n\r\n    // 声明一个对象属性同步锁\r\n    private Object obj = new Object();\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            // 使用实现类的对象属性作为同步锁\r\n            synchronized (obj) {\r\n             // 使用this作为同步锁\r\n//            synchronized (this) {\r\n                if (ticket > 0) {\r\n                    System.out.println(Thread.currentThread().getName() + ": 卖票，票号为：" + ticket);\r\n                    ticket --;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["在继承Thread类创建多线程的方式中，可以考虑使用",(0,l.jsx)(r.code,{children:"类名.class"}),"、或者声明一个实现类的静态属性（该属性是一个实例）作为同步监视器，不可使用this"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:'class Window extends Thread {\r\n    // 票声明为static，所有线程共用同一个static变量\r\n    private static int ticket = 100;\r\n    // obj声明为static，作为一个锁，所有线程共用同一把锁\r\n    private static Object obj = new Object();\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            // 正确。使用实现类的对象静态属性作为同步锁\r\n            // synchronized (obj) {\r\n            // 正确。使用“实现类.class”为同步锁\r\n            synchronized (Window.class) {\r\n            // 错误。不可以用this\r\n            // synchronized (this) {\r\n                if (ticket > 0) {\r\n                    System.out.println(getName() + ": 卖票，票号为：" + ticket);\r\n                    ticket --;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"举例："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"在类中声明一个对象，用来作为同步锁"}),"\n",(0,l.jsxs)(r.li,{children:["使用",(0,l.jsx)(r.code,{children:"类名.class"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"需要被同步的代码：即操作共享数据的代码"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方式二：同步方法"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"同步方法仍然涉及到同步监视器，只是不需要显示声明"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"非静态的同步方法，同步监视器是this"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:'class Window4 implements Runnable {\r\n    // 此处可以不使用static。因为虽然开了3个窗口，但是实际上共用的是一个Window对象\r\n    private int ticket = 100;\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            show();\r\n        }\r\n    }\r\n\r\n\r\n    private synchronized void show() { // 同步监视器：this\r\n        if (ticket > 0) {\r\n            System.out.println(Thread.currentThread().getName() + ": 卖票，票号为：" + ticket);\r\n            ticket--;\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"静态的同步方法，同步监视器是类本身"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:'class Window3 extends Thread {\r\n    // 票声明为static，所有线程共用同一个static变量\r\n    private static int ticket = 100;\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            show();\r\n        }\r\n    }\r\n\r\n    private synchronized static void show() { // 同步监视器：Window3.class\r\n        if (ticket > 0) {\r\n            System.out.println(Thread.currentThread().getName() + ": 卖票，票号为：" + ticket);\r\n            ticket --;\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"方法三：Lock"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"jdk5.0新特性"}),"\n",(0,l.jsxs)(r.h3,{id:"88-单例设计模式之线程安全的懒汉式",children:["8.8 单例设计模式之线程安全的懒汉式",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#88-单例设计模式之线程安全的懒汉式",children:"#"})]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:"class Bank {\r\n    private static Bank instance = null;\r\n    // 私有化构造器\r\n    private Bank() {}\r\n\r\n    public static Bank getInstance() {\r\n        // 方式一：效率稍差\r\n//        synchronized (Bank.class) {\r\n//            if (null == instance) {\r\n//                instance = new Bank();\r\n//            }\r\n//        }\r\n        \r\n        // 方式二：效率较高\r\n        if (null == instance) {\r\n            synchronized (Bank.class) {\r\n                if (null == instance) {\r\n                    instance = new Bank();\r\n                }\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n}\n"})}),"\n",(0,l.jsxs)(r.h3,{id:"89-线程的死锁",children:["8.9 线程的死锁",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#89-线程的死锁",children:"#"})]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"死锁"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，这就造成了线程的死锁"}),"\n",(0,l.jsx)(r.li,{children:"出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续"}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"死锁产生的必要条件"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"互斥条件：任意一个时刻一个资源只能给一个进程使用"}),"\n",(0,l.jsx)(r.li,{children:"不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺"}),"\n",(0,l.jsx)(r.li,{children:"请求和保持条件：进程在申请新资源的同时，继续占用已经分配到的资源"}),"\n",(0,l.jsx)(r.li,{children:"循环等待条件：前一个进程占有后一个进程锁申请的资源，最后一个进程占用第一个进程所申请的资源"}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"处理死锁的方法"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"预防死锁"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"“互斥”条件是无法破坏的"}),"\n",(0,l.jsxs)(r.li,{children:["破坏“不可剥夺”条件：","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"方法一：如果占有某些资源的一个进程申请新的资源被拒绝，则该进程必须释放它最初占有的资源。如有必要，只可以再次请求这些资源和其他资源"}),"\n",(0,l.jsx)(r.li,{children:"方法二：如果一个进程请求当前被另一个进程占有的资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在两个进程优先级不同的条件下，方法二才能预防死锁"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["破坏“请求与保持”条件：","\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"方法一：创建进程时，系统要么满足它申请的所有资源，要么什么都不给。这就会所谓的“一次性分配”"}),"\n",(0,l.jsx)(r.li,{children:"方法二：要求每个进程申请新的资源时，释放他所占有的资源。"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(r.li,{children:"破坏“循环等待”条件：将系统中所有的资源编号，进程可以在任意时间提出资源申请，但所有申请必须按照资源的编号书序提出。"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"避免死锁"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"有序资源分配法：将系统中的资源统一编号，申请时必须按从小到大的顺序"}),"\n",(0,l.jsx)(r.li,{children:"专门的算法：如银行家算法"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"检测死锁：当死锁发生时，相关机构能够监测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"解除死锁："}),"\n",(0,l.jsx)(r.p,{children:"死锁解除的主要方法有："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"资源剥夺法：挂起某些死锁进程，并抢占他们的资源，将这些资源分配给其他的死锁进程。"}),"\n",(0,l.jsx)(r.p,{children:"但是，应该防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"撤销进程法：强制撤销部分甚至全部死锁进程，并剥夺他们的资源。"}),"\n",(0,l.jsx)(r.p,{children:"撤销的原则可以按照进程的优先级和撤销进程代价的高低进行。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"进程回退法：让一个或者多个进程回退到足以避免死锁的地步，进程回退时资源释放资源。"}),"\n",(0,l.jsx)(r.p,{children:"要求系统保持进程的历史信息，设置还原点。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"810-线程的通信",children:["8.10 线程的通信",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#810-线程的通信",children:"#"})]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"常用方法"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"以下方法是定义在Object类中的，不是Thread中"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["wait()","：使线程进入阻塞状态，并释放同步监视器"]}),"\n",(0,l.jsxs)(r.li,{children:["notify()","：唤醒被wait的一个线程（优先唤醒有优先级高的）"]}),"\n",(0,l.jsxs)(r.li,{children:["notifyAll()","：唤醒所有被wait的线程"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"说明"}),"\n"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"wait()、notify()、notifyAll()必须用在同步代码块或者同步方法中"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"wait()、notify()、notifyAll()的调用者必须是同步代码块或同步方法中的同步监视器。"}),"\n",(0,l.jsx)(r.p,{children:"否则会出现IllegalMonitorStateException异常"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"wait()、notify()、notifyAll()是定义在java.lang.Object中的"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"例子"}),"\n"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-java",children:'package com.tth.learn.java;\r\n\r\n/**\r\n * 线程通信的例子：使用两个线程打印1-100.线程1和线程2交替打印\r\n * @Author tth\r\n * @Date 2022/11/1 17:52\r\n */\r\npublic class CommunicationTest {\r\n    public static void main(String[] args) {\r\n        Number number = new Number();\r\n\r\n        Thread t1 = new Thread(number);\r\n        t1.setName("线程1");\r\n\r\n        Thread t2 = new Thread(number);\r\n        t2.setName("线程2");\r\n\r\n        t1.start();\r\n        t2.start();\r\n\r\n    }\r\n}\r\n\r\nclass Number implements Runnable {\r\n\r\n    private int num = 1;\r\n    private Object obj = new Object();\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            synchronized (obj) {\r\n                // 假如第一次进来的线程1。第一次notify()并没有唤醒任何线程。\r\n                // 待线程1执行完wait()后,待线程1进入阻塞状态\r\n                // 随后线程2进来。执行notify()，唤醒线程1\r\n                obj.notify();\r\n                if (num <= 100) {\r\n                    System.out.println(Thread.currentThread().getName()+"_"+num);\r\n                    num ++;\r\n                    try {\r\n                        // 阻塞当前线程\r\n                        obj.wait();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n'})})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),n.components);return r?(0,l.jsx)(r,{...n,children:(0,l.jsx)(c,{...n})}):c(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["tang%2Fjava2%2F08_%E5%A4%9A%E7%BA%BF%E7%A8%8B.md"]={toc:[{text:"8.1 基本概念",id:"81-基本概念",depth:3},{text:"8.2 线程的创建和使用",id:"82-线程的创建和使用",depth:3},{text:"8.3 Thread类中的方法",id:"83-thread类中的方法",depth:3},{text:"8.4 线程的调度",id:"84-线程的调度",depth:3},{text:"8.5 线程的分类",id:"85-线程的分类",depth:3},{text:"8.6 线程的生命周期",id:"86-线程的生命周期",depth:3},{text:"8.7 线程的同步",id:"87-线程的同步",depth:3},{text:"8.8 单例设计模式之线程安全的懒汉式",id:"88-单例设计模式之线程安全的懒汉式",depth:3},{text:"8.9 线程的死锁",id:"89-线程的死锁",depth:3},{text:"8.10 线程的通信",id:"810-线程的通信",depth:3}],title:"8 多线程",frontmatter:{}}}}]);