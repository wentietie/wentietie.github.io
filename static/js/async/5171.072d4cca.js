"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["5171"],{39969:function(e,n,r){r.r(n),r.d(n,{default:function(){return d}});var s=r(85893),l=r(50065);function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",pre:"pre",code:"code",strong:"strong",h3:"h3"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"11-java集合",children:["11 Java集合",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-java集合",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"111-概述",children:["11.1 概述",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#111-概述",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"数组在存储多个数据方面的特点"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"数组一旦初始化，长度就确定了"}),"\n",(0,s.jsx)(n.li,{children:"数组一旦定义好，其元素的类型也就确定了"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"数组在存储多个数据方面的缺点"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"数组一旦初始化，长度就不可修改了，无法实现扩容"}),"\n",(0,s.jsx)(n.li,{children:"数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便"}),"\n",(0,s.jsx)(n.li,{children:"获取数组中实际元素的个数的需求，数组中没有线程的属性或方法可用"}),"\n",(0,s.jsx)(n.li,{children:"数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"112-java集合框架",children:["11.2 Java集合框架",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#112-java集合框架",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Java集合可以分为Collection和Map两种体系："}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Collection接口：单列集合，用来存储一个一个的对象","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["List接口：存储的是元素有序、可重复的集合","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实现类：ArrayList、LinkedList、Vector"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Set接口：存储的是元素无序、不可重复的集合","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实现类：HashSet、LinkedHashSet、TreeSet"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Map接口：双列集合，保存具有映射关系“key-value对”的集合","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实现类：HashMap、LinkedHashMap、TreeMap、HashTable、Properties"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["集合Collection中存储的如果是自定义类的对象，需要自定义类重写的方法：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果Collection的实现类是List的子类，需要重写equals()"}),"\n",(0,s.jsx)(n.li,{children:"如果Collection的实现类是Set的子类HashSet、LinkedHashSet，需要重写equals()和hashCode()"}),"\n",(0,s.jsxs)(n.li,{children:["如果Collection的实现类是Set的子类TreeSet，需要提供排序方法。排序方法的提供有如下两种方法","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"放入TreeSet的元素的所在类实现Comparable接口，并重写compareTo()"}),"\n",(0,s.jsx)(n.li,{children:"创建Comparator实现类，在初始化TreeSet时作为参数传入"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"113-collection接口中的方法",children:["11.3 Collection接口中的方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#113-collection接口中的方法",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"add(Object o)： 将元素o添加到集合中"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"size()：获取集合中元素的个数"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"addAll(Collection c)：将集合c中的元素添加到当前集合中"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"isEmpty()：判断当前集合是否为空，即判断当前集合中的size()是否等于0"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"clear()：清空集合中的元素"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"contains(Object o)：判断当前集合是否包含元素o"}),"\n",(0,s.jsx)(n.p,{children:"比较时，调用的是元素o所对应的类的equals()方法"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class CollectionTest {\r\n    @Test\r\n    public  void test1() {\r\n        Collection coll = new ArrayList();\r\n        coll.add(123);\r\n        coll.add(new String("hello"));\r\n        coll.add(new Person("Jerry", 18));\r\n        coll.add(new Student("XiaoMing", 10, 80));\r\n\r\n        System.out.println(coll.contains(123)); // true\r\n        System.out.println(coll.contains("hello")); // true.String重写了equals()方法，比较的是内容\r\n        System.out.println(coll.contains(new Person("Jerry", 18))); // false，未重写equals()，比较的是地址值\r\n        System.out.println(coll.contains(new Student("XiaoMing", 10, 80))); // true。重写了equals()，比较的是内容\r\n    }\r\n}\r\n\r\nclass Person {\r\n    private String name;\r\n    private int age;\r\n	...\r\n}\r\nclass Student extends Person {\r\n    private int score;\r\n	...\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Student student = (Student) o;\r\n        return score == student.score && getName().equals(student.getName()) && getAge() == student.getAge();\r\n    }\r\n}\r\n\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"containsAll(Collection c)：判断c中的元素是否都在当前结合中"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"remove(Object o)：在当前集合中删除元素o，返回是否移除成功"}),"\n",(0,s.jsx)(n.p,{children:"需要调用元素o所对应的类的equals()"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"removeAll(Collection c)：在当前集合中删除集合c中所有元素"}),"\n",(0,s.jsx)(n.p,{children:"需要调用c中所有元素对应的类的equals()方法"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"retainAll(Collection c)：计算当前集合和集合c的交集（结果赋值给当前集合），返回值为boolean类型，即当前集合和集合c是否有交集"}),"\n",(0,s.jsx)(n.p,{children:"如果二者没有交集，当前集合被修改为[]，返回值为false"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"equals(Object o)：判断当前集合和o是否相等。"}),"\n",(0,s.jsx)(n.p,{children:"调用的是元素o锁对应的类中的equals()"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"hashCode()：返回当前对象的hash值"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"toArray()：集合 ---\x3e 数组"}),"\n",(0,s.jsx)(n.p,{children:"Arrays.asList(Object[] o)：数组 ---\x3e 集合"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'List list = Arrays.asList(new String[]{"AA", "BB", "CC"});\r\nSystem.out.println(list); // 输出[AA, BB, CC]\r\n\r\nList list1 = Arrays.asList(new int[]{1, 2, 3}); // 此处会把new int[]当做一个元素放到list1中\r\nSystem.out.println(list1); // 输出[[I@66cd51c3]\r\n\r\nList list2 = Arrays.asList({1, 2, 3});\r\nSystem.out.println(list2); // 输出[1, 2, 3]\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"iterator()：返回Iterator接口的实例，用于遍历集合元素"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"114-iterator迭代器接口",children:["11.4 Iterator迭代器接口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#114-iterator迭代器接口",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素"}),"\n",(0,s.jsxs)(n.li,{children:["GOF给迭代器模式的定义为","：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。",(0,s.jsx)(n.strong,{children:"迭代器模式，就是为容器而生"})]}),"\n",(0,s.jsx)(n.li,{children:"Collection接口继承了java.lang.Iterator接口，该接口有一个iterator()，所有实现了Collection接口的集合类都有一个iterator()， 用以返回一个实现了Iterator接口的对象"}),"\n",(0,s.jsx)(n.li,{children:"Iterator仅用于遍历集合"}),"\n",(0,s.jsxs)(n.li,{children:["集合对象每次调用iterator()都得到一个","全新的","迭代对象，","默认游标都在集合的第一个元素",(0,s.jsx)(n.strong,{children:"之前"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"常用方法"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"hasNext()：判断是否还有下一个元素"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"next()：获取下一个元素"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"指针下移"}),"\n",(0,s.jsx)(n.li,{children:"将下移后的集合位置上的元素返回"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"remove()：在遍历的时候，删除集合中的元素。"}),"\n",(0,s.jsx)(n.p,{children:"如果还未调用next()或者在上一次调用next()之后已经调用了remove()，再调用remove()，即连续两次调用remove()，会报IllegalStateException。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"举例"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// 遍历 \r\n@Test\r\npublic void test() {\r\n    Collection coll = new ArrayList();\r\n    coll.add(123);\r\n    coll.add(new String("hello"));\r\n    coll.add(new Person("Jerry", 18));\r\n    coll.add(new Student("XiaoMing", 10, 80));\r\n\r\n    Iterator iterator = coll.iterator();\r\n    while (iterator.hasNext()) {\r\n        System.out.println(iterator.next());\r\n    }\r\n}\r\n// 移除元素\r\n@Test\r\npublic void test2() {\r\n    Collection coll = new ArrayList();\r\n    coll.add(123);\r\n    coll.add(new String("hello"));\r\n    coll.add(new Person("Jerry", 18));\r\n    coll.add(new Student("XiaoMing", 10, 80));\r\n\r\n    Iterator iterator = coll.iterator();\r\n    while (iterator.hasNext()) {\r\n        Object o = iterator.next();\r\n        // 移除元素\r\n        if ("hello".equals(o)) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n\r\n    // 重新遍历\r\n    Iterator iterator1 = coll.iterator();\r\n    while (iterator1.hasNext()) {\r\n        System.out.println(iterator1.next());\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"115-list接口",children:["11.5 List接口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#115-list接口",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1151-arraylist源码分析",children:["11.5.1 ArrayList源码分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1151-arraylist源码分析",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"JDK7中的ArrayList"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"ArrayList list = new ArrayList(); // 底层创建了长度是10的Object[]数组elementData\r\n\r\nlist.add(123); // elementData[0] = new Integer(123)\r\n\r\n...\r\n\r\nlist.add(11); // 如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的容量的**1.5倍**，同时需要将原有数组中的数据复制到新的数组中。\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"JDK8中的ArrayList"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"ArrayList list = new ArrayList(); // 底层Object[] elementData初始化为{}，并没有创建长度为10的数组\r\n\r\nlist.add(123); // 第一次调用add()时，底层会创建长度为10的数组，并执行如下操作elementData[0] = new Integer(123)\r\n\r\n...\r\n\r\n // 后续操作与JDK7中无异\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"小结"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["JDK7中的ArrayList的对象创建类似于单例的饿汉式，JDK8中的ArrayList对象的创建类似于单例的懒汉式，",(0,s.jsx)(n.strong,{children:"延迟了数组的创建，节省内存"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1152-linkedlist源码分析",children:["11.5.2 LinkedList源码分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1152-linkedlist源码分析",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"LinkedList list = new LinkedList(); // 内部声明了Node类型的first和last属性\r\n\r\nlist.add(123); // 将123封装到Node中，创建Node对象\n"})}),"\n",(0,s.jsx)(n.p,{children:"其中Node的定义，体现了双向链表的说法。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"private static class Node<E> {\r\n    E item; // 当前元素的值\r\n    Node<E> next; // 指前指针\r\n    Node<E> prev; // 指后指针\r\n\r\n    Node(Node<E> prev, E element, Node<E> next) {\r\n        this.item = element;\r\n        this.next = next;\r\n        this.prev = prev;\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"1153-vector的源码分析",children:["11.5.3 Vector的源码分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1153-vector的源码分析",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"Vector vector = new Vector<>(); // JDK7和JDK8中通过Vector()创建对象时，都创建了长度为10的数组\r\n\r\n// 在扩容方面，默认扩容为原来的**2倍**。\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"1154-list接口中的方法",children:["11.5.4 List接口中的方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1154-list接口中的方法",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Collection接口中的API仍可用"}),"\n",(0,s.jsx)(n.li,{children:"void add(int index, Object ele)：在index位置插入ele元素"}),"\n",(0,s.jsx)(n.li,{children:"boolean addAll(int index, Collection eles)：在index位置开始将eles中的元素全部加进来"}),"\n",(0,s.jsx)(n.li,{children:"Object get(int index)：获取index位置的元素"}),"\n",(0,s.jsx)(n.li,{children:"int indexOf(Object ele)：获取元素ele在集合中首次出现的位置。如果不存在，返回-1"}),"\n",(0,s.jsx)(n.li,{children:"int lastindexOf(Object ele)：获取元素ele在集合中最后一次出现的位置。如果不存在，返回-1"}),"\n",(0,s.jsx)(n.li,{children:"Object remove(int index)：移除index位置的元素，并返回此元素"}),"\n",(0,s.jsx)(n.li,{children:"Object set(int index, Object ele)：将index位置的元素设置为ele"}),"\n",(0,s.jsx)(n.li,{children:"List subList(int fromIndex, int toIndex)：返回**[fromIndex, toIndex)**位置处的子集合，原集合没有变化"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"116-set接口",children:["11.6 Set接口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#116-set接口",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1161-概述",children:["11.6.1 概述",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1161-概述",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Set中没有额外定义方法，使用的都是Collection接口中的方法"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"分类"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["HashSet：作为Set接口的主要实现类；线程不安全的，可以存储null；底层是数组+链表的结构","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"LinkedHashSet：作为HashSet的子类，在遍历内部数据时，可以按照添加的顺序遍历"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"TreeSet：底层使用的是二叉树（红黑树）存储，放入TreeSet的元素，必须是同一个类的对象，可以按照添加对象的指定属性进行排序"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Set存储的无序性"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"以HashSet为例"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"无序性 $\\neq$ 随机性"}),"\n",(0,s.jsx)(n.li,{children:"存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Set存储的不可重复性"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"以HashSet为例"}),"\n",(0,s.jsx)(n.p,{children:"保证添加的元素按照equals()判断时，不能返回true，确保相同的元素只能添加一个。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Set中存储元素要想实现不可重复性，需要重新该元素对应类的equals()和hashCode()方法。"})}),"\n",(0,s.jsxs)(n.h3,{id:"1162-hashset",children:["11.6.2 HashSet",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1162-hashset",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"HashSet添加元素的过程"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"当向HashSet中添加元素a时，首先调用元素 a所在类的hashCode()，计算元素a的哈希值，接下来用此哈希值通过某种算法计算出在HashSet底层数组中的存放位置（即索引位置），然后判断此位置上是否应有元素："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["如果此位置上没有其他元素，则",(0,s.jsx)(n.strong,{children:"元素a添加成功"}),"；---情况1"]}),"\n",(0,s.jsxs)(n.li,{children:["如果此位置上有其他元素b（或者以链表形式存在的多个元素），则比较元素a与元素b的哈希值：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["如果hash值不相同，",(0,s.jsx)(n.strong,{children:"元素a添加成功"}),"；---情况2"]}),"\n",(0,s.jsxs)(n.li,{children:["如果hash值相同，进而需要调用元素a所在类的equals()：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["equals()返回true，",(0,s.jsx)(n.strong,{children:"元素a添加失败"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["equals()返回false，",(0,s.jsx)(n.strong,{children:"元素a添加成功"}),"；---情况3"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"对于添加成功的情况2和情况3而言，元素a与已经存在指定索引位置上的数据以链表的方式存储。"}),"\n",(0,s.jsx)(n.p,{children:"JDK7：元素a放到数组中，指向原来的元素"}),"\n",(0,s.jsx)(n.p,{children:"JDK8：原来的元素放在数组中，指向a元素"}),"\n",(0,s.jsx)(n.p,{children:"总结：7上8下"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"HashSet的特点"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"不能保证元素的顺序排列"}),"\n",(0,s.jsx)(n.li,{children:"HashSet不是线程安全的"}),"\n",(0,s.jsx)(n.li,{children:"集合元素可以是null"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"HashSet判断两个元素相等的标准"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"两个对象通过hashCode()比较相等，且两个对象的equals()返回值也相等"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"使用HashSet的主意事项"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode()，以实现对象相等规则。即“","相等的对象必须有相等的散列码（哈希值）","”"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"重写hashCode()的基本原则"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"在程序运行时，同一个对象多次调用hashCode()，应该返回相同的值"}),"\n",(0,s.jsx)(n.li,{children:"当两个对象的equals()返回true时，这两个对象的hasCode()的返回值也相等"}),"\n",(0,s.jsx)(n.li,{children:"对象中用作equals()方法比较的属性，都应该用来计算hash值"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1163-linkedhashset",children:["11.6.3 LinkedHashSet",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1163-linkedhashset",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个变量，用以记录当前数据的前一个数据和后一个数据。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"在遍历内部数据时，可以按照添加的顺序遍历。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["优点","：对于频繁的遍历操作，LinkedHashSet效率高于HashSet。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1164-treeset",children:["11.6.4 TreeSet",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1164-treeset",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"特点"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"底层是二叉树（红黑树）"}),"\n",(0,s.jsx)(n.li,{children:"可以按照添加对象的指定属性进行排序"}),"\n",(0,s.jsx)(n.li,{children:"有序，查询比list快"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注意事项"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"向TreeSet中添加的数据，要求是相同类的对象"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"向TreeSet中添加的数据前，需要定义TreeSet中元素的排序方式：自然排序或者定制排序"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"使用自然排序（实现Comparable接口）"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class TreeSetTest {\r\n    @Test\r\n    public void test1() {\r\n        TreeSet treeSet = new TreeSet();\r\n        treeSet.add(new User("Jack", 12));\r\n        treeSet.add(new User("Janny", 22));\r\n        treeSet.add(new User("Jery", 23));\r\n        treeSet.add(new User("Jey", 34));\r\n        treeSet.add(new User("Jane", 10));\r\n\r\n        Iterator iterator = treeSet.iterator();\r\n        while (iterator.hasNext()) {\r\n            System.out.println(iterator.next());\r\n        }\r\n    }\r\n}\r\n\r\nclass User implements Comparable{\r\n    private String name;\r\n    private int age;\r\n\r\n    ...\r\n\r\n    /**\r\n     * 按照名称有小到大排序。名称相同，按照年龄有小到大排\r\n     * @param o\r\n     * @return\r\n     */\r\n    @Override\r\n    public int compareTo(Object o) {\r\n        if (o instanceof User) {\r\n            User user = (User) o;\r\n            int compared = this.name.compareTo(user.getName());\r\n            if (compared == 0) {\r\n                compared = Integer.compare(this.age, user.age);\r\n            }\r\n            return compared;\r\n        }\r\n\r\n        throw new RuntimeException("输入的数据不匹配");\r\n    }\r\n\r\n    ...\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"使用定制排序（实现Comparator接口）"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class TreeSetTest {\r\n    @Test\r\n    public void test2() {\r\n        Comparator comparator = new Comparator() {\r\n            // 按照年龄由大到小排序\r\n            @Override\r\n            public int compare(Object o1, Object o2) {\r\n                if (o1 instanceof User && o2 instanceof User) {\r\n                    User user1 = (User) o1;\r\n                    User user2 = (User) o2;\r\n                    return -Integer.compare(user1.getAge(), user2.getAge());\r\n                }\r\n\r\n                throw new RuntimeException("输入的数据不匹配");\r\n            }\r\n        };\r\n\r\n        TreeSet treeSet = new TreeSet(comparator);\r\n        treeSet.add(new User("Jack", 12));\r\n        treeSet.add(new User("Janny", 22));\r\n        treeSet.add(new User("Jery", 23));\r\n        treeSet.add(new User("Jey", 34));\r\n        treeSet.add(new User("Jane", 10));\r\n\r\n        Iterator iterator = treeSet.iterator();\r\n        while (iterator.hasNext()) {\r\n            System.out.println(iterator.next());\r\n        }\r\n    }\r\n}\r\n\r\nclass User {\r\n    private String name;\r\n    private int age;\r\n	...\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"TreeSet中比较两个对象是否相同的标准"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"使用自然排序：比较两个对象是否相同，即为元素所在类的compareTo()返回值是否为0"}),"\n",(0,s.jsx)(n.li,{children:"使用定制排序：比较两个对象是否相同，即为创建的 Comparator实现类中compare()返回值是否是0"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"117-map接口",children:["11.7 Map接口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#117-map接口",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1171-概述",children:["11.7.1 概述",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1171-概述",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Map接口简介"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Map接口：存储双列数据，存储的是key-value键值对"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"HashMap类：主要实现类；线程不安全，效率比Hashtable高；可以存储值为null的key和value；底层：数组+链表（JDK7及之前）、数组+链表+红黑树（JDK8）"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"LinkedHashMap类：比HashMap多了一对“指针”，用来指向前一个和后一个元素，保证在遍历map元素时，可以按照添加的顺序实现遍历；对于频繁的遍历操作，LinkedHashMap效率比HashMap高"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"TreeMap类：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或者定制排序，要求key是同一个类创建的对象"}),"\n",(0,s.jsx)(n.p,{children:"​							底层使用的是红黑树"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Hashtable类：古老实现类；线程安全，效率比HashMap低；不可以存储值为null的key和value"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Properties类：常用来处理配置文件。key和value都是String类型"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Map中结构的理解"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"以HashMap为例"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Map中的key：无序的、不可重复的，使用Set存储所有的key；key所在的类要重写equals()和hashCode()；"}),"\n",(0,s.jsx)(n.li,{children:"Map中的value：无序的、可重复的，使用Collection存储所有的value；value所在的类需要重写equals()；"}),"\n",(0,s.jsx)(n.li,{children:"一个键值对构成一个Entry对象；"}),"\n",(0,s.jsx)(n.li,{children:"Map中的entry：无序的、不可重复的，使用Set存储所有的entry 。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1172-hashmap底层实现原理",children:["11.7.2 HashMap底层实现原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1172-hashmap底层实现原理",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"JDK7中HashMap实现原理"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"HashMap map = new HashMap();"}),"：实例化之后，底层创建了一个长度是16的一维数组Entry[] table"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"map.add(key1, value1) "}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先，调用key1所在类的hashCode()计算key1的哈希值，此哈希值经过某种算法计算后，得到Entry数组中的存放位置"}),"\n",(0,s.jsx)(n.li,{children:"如果此位置上的数据是空，此时key1-value1存放成功  ---\x3e情况1"}),"\n",(0,s.jsxs)(n.li,{children:["如果此位置上的数据不为空，意味着此位置上存在一个或多个数据（以链表形式存在），比较key1和已存在数据的哈希值：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果key1的哈希值与此位置上的数据的哈希值都不一样，此时key1-value1存放成功  ---\x3e情况2"}),"\n",(0,s.jsxs)(n.li,{children:["如果key1的哈希值与此位置上的某一个数据(key2,value2)的哈希值相同，则调用key1所在类的equals()方法进行比较：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果equals()返回false，此时key1-value1存放成功  ---\x3e情况3"}),"\n",(0,s.jsx)(n.li,{children:"如果equals()返回true，使用value1替换value2"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"补充：关于情况2和情况3，此时key1-value1和原来的数据以链表的形式存在，由key1-value1指向原数据"}),"\n",(0,s.jsxs)(n.li,{children:["关于扩容：在不断添加的过程中，会涉及到扩容问题。","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"扩容时间：当超出临界值（注意不是数组的长度），且要存放数据的位置非空时，进行扩容"}),"\n",(0,s.jsx)(n.li,{children:"默认扩容为原来的2倍，并将原有的数据复制过来"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"JDK8相较于JDK7在底层实现方面的不同"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"HashMap map = new HashMap();"}),"：底层没有创建长度为16的数组。且底层数组是Node[]，而非Entry"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"map.add(key1, value1) "}),"：如果是首次调用，会先创建长度为16的数组"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["JDK7底层结构只有",(0,s.jsx)(n.strong,{children:"数组+链表"}),"，JDK8中底层结构是",(0,s.jsx)(n.strong,{children:"数组+链表+红黑树"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["当数组的",(0,s.jsx)(n.strong,{children:"某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64"}),"时，此时",(0,s.jsx)(n.strong,{children:"此索引位置上"}),"的所有数据改为使用红黑树"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"HashMap中常用常量"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DEFAULT_INITIAL_CAPACITY"}),"：HashMap默认容量，16"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DEFAULT_LOAD_FACTOR"}),"：默认加载因子，0.75"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"threshold"}),"：扩容的临界值。threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TREEIFY_THRESHOLD"}),"：Bucket中链表长度大于该默认值时，转为红黑树，8"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MIN_TREEIFY_CAPACITY"}),"：Bucket中Node被树化时最小的hash表容量，64"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1173-linkedhashmap底层实现原理",children:["11.7.3 LinkedHashMap底层实现原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1173-linkedhashmap底层实现原理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"LinkedHashMap底层使用的结构与HashMap相同，唯一的区别是LinkedHashMap内部提供了Entry用来替换HashMap中的Node。"}),"\n",(0,s.jsx)(n.p,{children:"LinkedHashMap.Entry类中比HashMap.Node多了两个变量，用来记录当前元素的前一个和后一个元素，确保能够记录元素的添加顺序"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"static class Entry<K,V> extends HashMap.Node<K,V> {\r\n    Entry<K,V> before, after;\r\n    Entry(int hash, K key, V value, Node<K,V> next) {\r\n        super(hash, key, value, next);\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"1174-map接口中的方法",children:["11.7.4 Map接口中的方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1174-map接口中的方法",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"增删改"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Object put(Object key, Object value)：将key-value添加到（修改）当前map中"}),"\n",(0,s.jsx)(n.li,{children:"Object putAll(Map m)：将m中的key-value添加到当前map中"}),"\n",(0,s.jsx)(n.li,{children:"Object remove(Object key)：移除指定的key的key-value对，并返回对应的value"}),"\n",(0,s.jsx)(n.li,{children:"void clear()：清空当前map"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"查询"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Object get(Object key)：获取key对应的value"}),"\n",(0,s.jsx)(n.li,{children:"boolean containsKey(Object key)：判断是否包含指定的key"}),"\n",(0,s.jsx)(n.li,{children:"boolean containsValue(Object value)：判断是否包含指定的value"}),"\n",(0,s.jsx)(n.li,{children:"int size()：返回map中key-value对的个数"}),"\n",(0,s.jsx)(n.li,{children:"boolean isEmpty()：判断当前map是否为空"}),"\n",(0,s.jsx)(n.li,{children:"boolean equals(Object obj)：判断当前map和obj是否相等"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"遍历"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set keySet()：返回所有key构成的Set集合"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Collection values()：返回所有的value集合"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set entrySet()：返回所有的key-value对"}),"\n",(0,s.jsx)(n.p,{children:"entrySet()获得的集合中的元素都是Map.Entry，可以强转"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1175-treemap的使用",children:["11.7.5 TreeMap的使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1175-treemap的使用",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"向TreeMap中添加key-value，需要保证key是由同一个类创建的对象"}),"\n",(0,s.jsx)(n.li,{children:"因需要对key进行排序，因此要么key所在的类需要实现Comparable接口，要么在在创建TreeMap时将Comparator实现类作为参数传入"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"使用和TreeSet类似。"}),"\n",(0,s.jsxs)(n.h3,{id:"1176-properties",children:["11.7.6 Properties",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1176-properties",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Properties是Hashtable的子类，该对象用于处理属性文件"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Properties的key和value都是String类型"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"例子"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"jdbc.properties"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"name=唐天华\r\npassword=123456\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"PropertiesTest.java"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class PropertiesTest {\r\n    public static void main(String[] args) {\r\n        FileInputStream fis = null;\r\n        try {\r\n            Properties prop = new Properties();\r\n            fis = new FileInputStream("jdbc.properties");\r\n            // 加载流对应的文件\r\n            prop.load(fis);\r\n\r\n            // 获取配置文件中指定key对应的value值\r\n            String name = prop.getProperty("name");\r\n            String password = prop.getProperty("password");\r\n            System.out.println("name="+name+", password="+password);\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            if (fis != null) {\r\n                try {\r\n                    fis.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"118-collections工具类",children:["11.8 Collections工具类",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#118-collections工具类",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"排序相关"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"void reverse(List<?> list)"}),"：反转list中元素的顺序"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"void shuffle(List<?> list)"}),"：对list中的元素进行随机排序"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"void sort(List<T> list)"}),"：按照list中元素的自然顺序进行排序"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"void sort(List<T> list, Comparator<? super T> c)"}),"：根据指定的Comparator对list中的元素进行排序"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"void swap(List<?> list, int i, int j) "}),"：交换list中第i个和第j个元素的位置"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"T max(Collection<? extends T> coll)"}),"：根据元素的自然顺序，返回集合中的最大元素"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"T max(Collection<? extends T> coll, Comparator<? super T> comp)"}),"：根据指定的Comparator的指定顺序，返回集合中的最大元素"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"T min(Collection<? extends T> coll)"}),"：根据元素的自然顺序，返回集合中的最小元素"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"T min(Collection<? extends T> coll, Comparator<? super T> comp)"}),"：根据指定的Comparator的指定顺序，返回集合中的最小元素"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"int frequency(Collection<?> c, Object o)"}),"：返回指定集合中指定元素出现的次数"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"void copy(List<? super T> dest, List<? extends T> src)"}),"：将src中的内容赋值到的dest中"]}),"\n",(0,s.jsx)(n.p,{children:"使用此方法时，需要保证dest.size() >= src.size()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Test\r\n    public void test1() {\r\n        List list = new ArrayList();\r\n        list.add(11);\r\n        list.add(989);\r\n        list.add(454);\r\n        list.add(89);\r\n        list.add(23);\r\n\r\n        // 错误写法，会报java.lang.IndexOutOfBoundsException: Source does not fit in dest 异常\r\n//        List dest = new ArrayList();\r\n//        Collections.copy(dest, list);\r\n\r\n        // 正确写法\r\n        List dest = Arrays.asList(new Object[list.size()]);\r\n        Collections.copy(dest, list);\r\n        System.out.println(dest);\r\n    }\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"boolean replaceAll(List<T> list, T oldVal, T newVal)"}),"：用newVal替换list中的oldVal"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"同步控制"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Collections中提供了多个synchronizedXxx()，用来将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。synchronizedXxx()的返回结果即为线程安全的。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let d=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["tang%2Fjava2%2F11_Java%E9%9B%86%E5%90%88.md"]={toc:[{text:"11.1 概述",id:"111-概述",depth:2},{text:"11.2 Java集合框架",id:"112-java集合框架",depth:2},{text:"11.3 Collection接口中的方法",id:"113-collection接口中的方法",depth:2},{text:"11.4 Iterator迭代器接口",id:"114-iterator迭代器接口",depth:2},{text:"11.5 List接口",id:"115-list接口",depth:2},{text:"11.5.1 ArrayList源码分析",id:"1151-arraylist源码分析",depth:3},{text:"11.5.2 LinkedList源码分析",id:"1152-linkedlist源码分析",depth:3},{text:"11.5.3 Vector的源码分析",id:"1153-vector的源码分析",depth:3},{text:"11.5.4 List接口中的方法",id:"1154-list接口中的方法",depth:3},{text:"11.6 Set接口",id:"116-set接口",depth:2},{text:"11.6.1 概述",id:"1161-概述",depth:3},{text:"11.6.2 HashSet",id:"1162-hashset",depth:3},{text:"11.6.3 LinkedHashSet",id:"1163-linkedhashset",depth:3},{text:"11.6.4 TreeSet",id:"1164-treeset",depth:3},{text:"11.7 Map接口",id:"117-map接口",depth:2},{text:"11.7.1 概述",id:"1171-概述",depth:3},{text:"11.7.2 HashMap底层实现原理",id:"1172-hashmap底层实现原理",depth:3},{text:"11.7.3 LinkedHashMap底层实现原理",id:"1173-linkedhashmap底层实现原理",depth:3},{text:"11.7.4 Map接口中的方法",id:"1174-map接口中的方法",depth:3},{text:"11.7.5 TreeMap的使用",id:"1175-treemap的使用",depth:3},{text:"11.7.6 Properties",id:"1176-properties",depth:3},{text:"11.8 Collections工具类",id:"118-collections工具类",depth:2}],title:"11 Java集合",frontmatter:{}}}}]);