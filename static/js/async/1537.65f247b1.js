"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["1537"],{24868:function(e,r,s){s.r(r),s.d(r,{default:function(){return d}});var n=s(85893),t=s(50065);function a(e){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",div:"div"},(0,t.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.h1,{id:"计算属性",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#计算属性",children:"#"}),"计算属性"]}),"\n",(0,n.jsx)(r.p,{children:"模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。这种情况下，计算属性就会更加适合。"}),"\n",(0,n.jsxs)(r.h2,{id:"基础示例",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#基础示例",children:"#"}),"基础示例"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-vue",meta:"",children:"<template>\r\n  <p>Has published books:</p>\r\n  <span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>\r\n</template>\r\n<script setup>\r\nconst author = reactive({\r\n  name: 'John Doe',\r\n  books: [\r\n    'Vue 2 - Advanced Guide',\r\n    'Vue 3 - Basic Guide',\r\n    'Vue 4 - The Mystery'\r\n  ]\r\n})\r\n<\/script>\n"})}),"\n",(0,n.jsx)(r.p,{children:"这里的模板看起来有些复杂。更重要的是，如果在模板中需要不止一次这样的计算，这样的代码将在模板里重复好多遍。因此推荐使用计算属性来描述依赖响应式状态的复杂逻辑。"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-vue",meta:"",children:"<template>\r\n  <p>Has published books:</p>\r\n  <span>{{ publishedBooksMessage }}</span>\r\n</template>\r\n<script setup>\r\nimport { reactive, computed } from 'vue'\r\n\r\nconst author = reactive({\r\n  name: 'John Doe',\r\n  books: [\r\n    'Vue 2 - Advanced Guide',\r\n    'Vue 3 - Basic Guide',\r\n    'Vue 4 - The Mystery'\r\n  ]\r\n})\r\n\r\n// 一个计算属性 ref\r\nconst publishedBooksMessage = computed(() => {\r\n  return author.books.length > 0 ? 'Yes' : 'No'\r\n})\r\n<\/script>\n"})}),"\n",(0,n.jsx)(r.p,{children:"在这里定义了一个计算属性 publishedBooksMessage。computed() 方法默认接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。"}),"\n",(0,n.jsx)(r.p,{children:"Vue 的计算属性会自动追踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当 author.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。"}),"\n",(0,n.jsxs)(r.h2,{id:"可写计算属性",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#可写计算属性",children:"#"}),"可写计算属性"]}),"\n",(0,n.jsx)(r.p,{children:"计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建："}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-vue",meta:"",children:"<script setup>\r\nimport { ref, computed } from 'vue'\r\n\r\nconst firstName = ref('John')\r\nconst lastName = ref('Doe')\r\n\r\nconst fullName = computed({\r\n  // getter\r\n  get() {\r\n    return firstName.value + ' ' + lastName.value\r\n  },\r\n  // setter\r\n  set(newValue) {\r\n    // 注意：我们这里使用的是解构赋值语法\r\n    [firstName.value, lastName.value] = newValue.split(' ')\r\n  }\r\n})\r\n<\/script>\n"})}),"\n",(0,n.jsxs)(r.div,{className:"rspress-directive danger",children:[(0,n.jsx)(r.div,{className:"rspress-directive-title",children:"不要在 getter 中做异步请求或者更改 DOM！"}),(0,n.jsx)(r.div,{className:"rspress-directive-content",children:(0,n.jsx)(r.p,{children:"\n计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。"})})]}),"\n",(0,n.jsxs)(r.h2,{id:"计算属性缓存-vs-方法",children:[(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#计算属性缓存-vs-方法",children:"#"}),"计算属性缓存 vs 方法"]}),"\n",(0,n.jsx)(r.p,{children:"若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。"}),"\n",(0,n.jsx)(r.p,{children:"相比之下，方法总是会在重渲染发生时再次执行函数。"}),"\n",(0,n.jsx)(r.p,{children:"为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),e.components);return r?(0,n.jsx)(r,Object.assign({},e,{children:(0,n.jsx)(a,e)})):a(e)}let d=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["formwork%2Fvue3%2Freactive%2Fpart2.md"]={toc:[{id:"基础示例",text:"基础示例",depth:2},{id:"可写计算属性",text:"可写计算属性",depth:2},{id:"计算属性缓存-vs-方法",text:"计算属性缓存 vs 方法",depth:2}],title:"计算属性",headingTitle:"计算属性",frontmatter:{}}}}]);