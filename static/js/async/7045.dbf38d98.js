"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["7045"],{78225:function(e,n,r){r.r(n),r.d(n,{default:function(){return h}});var i=r(85893),a=r(50065);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h3:"h3",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"浏览器刷新过程",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器刷新过程",children:"#"}),"浏览器刷新过程"]}),"\n",(0,i.jsx)(n.p,{children:"浏览器刷新做的只是重新加载网页数据【强制刷新的区别只是不使用浏览器缓存下来的HTML、JS数据，所有本页面用到的HTML、JS都需要重新向服务器获取】，并重新解析生成 DOM 树，当然还同时会重新解释执行 JavaScript 代码，之后重新绘制页面，注册绑定事件，之前页面在活动的时候对 JavaScript 变量做的数据赋值数据都会消失。"}),"\n",(0,i.jsxs)(n.h3,{id:"相关浏览器事件",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#相关浏览器事件",children:"#"}),"相关浏览器事件"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"onbeforeunload：浏览器的刷新和关闭之前执行的方法"}),"\n",(0,i.jsx)(n.li,{children:"onunload：已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。"}),"\n",(0,i.jsx)(n.li,{children:"onload：资源已加载时被触发。"}),"\n"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(s,e)})):s(e)}let h=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["notes%2Fbrowser%2Frefresh.md"]={toc:[{id:"相关浏览器事件",text:"相关浏览器事件",depth:3}],title:"浏览器刷新过程",headingTitle:"浏览器刷新过程",frontmatter:{}}}}]);