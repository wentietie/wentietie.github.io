"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["4056"],{35389:function(e,r,n){n.r(r),n.d(r,{default:function(){return l}});var t=n(85893),i=n(50065);function c(e){let r=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",h2:"h2"},(0,i.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.h1,{id:"模板引用",children:["模板引用",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#模板引用",children:"#"})]}),"\n",(0,t.jsx)(r.p,{children:"虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute："}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-vue",children:"<template>\r\n  <input ref=\"input\" />\r\n</template>\r\n<script setup>\r\nimport { ref, onMounted } from 'vue'\r\n\r\n// 声明一个 ref 来存放该元素的引用\r\n// 必须和模板里的 ref 同名\r\nconst input = ref(null)\r\n\r\nonMounted(() => {\r\n  input.value.focus()\r\n})\r\n<\/script>\n"})}),"\n",(0,t.jsx)(r.p,{children:"使用步骤为："}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["在DOM元素或vue组件上使用ref属性，并为其赋值：",(0,t.jsx)(r.code,{children:'<input ref="input" />'}),"。"]}),"\n",(0,t.jsxs)(r.li,{children:["在script中使用ref声明一个变量，变量名需要与1中的ref的值相同。",(0,t.jsx)(r.code,{children:"const input = ref(null)"}),"."]}),"\n",(0,t.jsx)(r.li,{children:"在组件挂载之后使用ref声明的变量即可获取元素。"}),"\n"]}),"\n",(0,t.jsxs)(r.h2,{id:"v-for-中的模板引用",children:["v-for 中的模板引用",(0,t.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#v-for-中的模板引用",children:"#"})]}),"\n",(0,t.jsx)(r.p,{children:"当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素。"})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),e.components);return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}let l=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["formwork%2Fvue3%2Freactive%2Fpart10.md"]={toc:[{text:"v-for 中的模板引用",id:"v-for-中的模板引用",depth:2}],title:"模板引用",frontmatter:{}}}}]);