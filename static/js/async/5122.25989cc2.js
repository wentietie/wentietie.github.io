"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["5122"],{46463:function(r,e,n){n.r(e),n.d(e,{default:function(){return l}});var s=n(85893),t=n(50065);function a(r){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",ul:"ul",li:"li"},(0,t.ah)(),r.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"module-的语法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#module-的语法",children:"#"}),"Module 的语法"]}),"\n",(0,s.jsxs)(e.h2,{id:"概述",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"}),"概述"]}),"\n",(0,s.jsx)(e.p,{children:"在 ES6 之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。"}),"\n",(0,s.jsxs)(e.p,{children:["区别详见",(0,s.jsx)(e.a,{href:"/notes/JS/modules.html",children:"随笔笔记/js随笔"})]}),"\n",(0,s.jsx)(e.p,{children:"ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// CommonJS模块\r\nlet { stat, exists, readfile } = require('fs');\r\n// 等同于\r\nlet _fs = require('fs');\r\nlet stat = _fs.stat;\r\nlet exists = _fs.exists;\r\nlet readfile = _fs.readfile;\n"})}),"\n",(0,s.jsx)(e.p,{children:"上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（ _fs ），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。"}),"\n",(0,s.jsx)(e.p,{children:"ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"import { stat, exists, readFile } from 'fs';\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"严格模式",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#严格模式",children:"#"}),"严格模式"]}),"\n",(0,s.jsx)(e.p,{children:'ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 "use strict"; 。\r\n严格模式主要有以下限制。'}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"变量必须声明后再使用"}),"\n",(0,s.jsx)(e.li,{children:"函数的参数不能有同名属性，否则报错"}),"\n",(0,s.jsx)(e.li,{children:"不能使用 with 语句"}),"\n",(0,s.jsx)(e.li,{children:"不能对只读属性赋值，否则报错"}),"\n",(0,s.jsx)(e.li,{children:"不能使用前缀 0 表示八进制数，否则报错"}),"\n",(0,s.jsx)(e.li,{children:"不能删除不可删除的属性，否则报错"}),"\n",(0,s.jsx)(e.li,{children:"不能删除变量 delete prop ，会报错，只能删除属性 delete global[prop]"}),"\n",(0,s.jsx)(e.li,{children:"eval 不会在它的外层作用域引入变量"}),"\n",(0,s.jsx)(e.li,{children:"eval 和 arguments 不能被重新赋值"}),"\n",(0,s.jsx)(e.li,{children:"arguments 不会自动反映函数参数的变化"}),"\n",(0,s.jsx)(e.li,{children:"不能使用 arguments.callee"}),"\n",(0,s.jsx)(e.li,{children:"不能使用 arguments.caller"}),"\n",(0,s.jsx)(e.li,{children:"禁止 this 指向全局对象"}),"\n",(0,s.jsx)(e.li,{children:"不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈"}),"\n",(0,s.jsx)(e.li,{children:"增加了保留字（比如 protected 、 static 和 interface ）"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"export-命令",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#export-命令",children:"#"}),"export 命令"]}),"\n",(0,s.jsx)(e.p,{children:"模块功能主要由两个命令构成：export和import 。 export 命令用于规定模块的对外接口， import 命令用于输入其他模块提供的功能。\r\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。下面是一个 JS 文件，里面使用 export 命令输出变量。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// profile.js\r\nexport var firstName = 'Michael';\r\nexport var lastName = 'Jackson';\r\nexport var year = 1958;\r\n\r\n/**\r\n * 上面代码是 profile.js 文件，保存了用户信息。\r\n * ES6 将其视为一个模块，里面用 export 命令对外部输出了三个变量。\r\n * export 的写法，除了像上面这样，还有另外一种。\r\n */\r\n\r\n// profile.js\r\nvar firstName = 'Michael';\r\nvar lastName = 'Jackson';\r\nvar year = 1958;\r\nexport { firstName, lastName, year };\r\n\r\n//export 命令除了输出变量，还可以输出函数或类（class）。\r\nexport function multiply(x, y) {\r\n    return x * y;\r\n};\r\n\r\n/**\r\n * 上面代码对外输出一个函数 multiply 。\r\n * 通常情况下， export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。\r\n */\r\n\r\nfunction v1() { ... }\r\nfunction v2() { ... }\r\nexport {\r\n    v1 as streamV1,\r\n    v2 as streamV2,\r\n    v2 as streamLatestVersion\r\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"需要特别注意的是， export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 报错\r\nexport 1;\r\n// 报错\r\nvar m = 1;\r\nexport m;\r\n\r\n/**\r\n * 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量 m ，还是直接输出 1。 1 只是一个值，不是接口。正确的写法是下面这样。\r\n */\r\n\r\n// 写法一\r\nexport var m = 1;\r\n// 写法二\r\nvar m = 1;\r\nexport {m};\r\n// 写法三\r\nvar n = 1;\r\nexport {n as m};\r\n\r\n//同样的， function 和 class 的输出，也必须遵守这样的写法。\r\n// 报错\r\nfunction f() {}\r\nexport f;\r\n// 正确\r\nexport function f() {};\r\n// 正确\r\nfunction f() {}\r\nexport {f};\r\n\r\n//另外， export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\r\nexport var foo = 'bar';\r\nsetTimeout(() => foo = 'baz', 500);\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"import-命令",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#import-命令",children:"#"}),"import 命令"]}),"\n",(0,s.jsx)(e.p,{children:"使用export 命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// main.js\r\nimport { firstName, lastName, year } from './profile.js';\r\nfunction setName(element) {\r\n  element.textContent = firstName + ' ' + lastName;\r\n}\n"})})]})}function i(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),r.components);return e?(0,s.jsx)(e,Object.assign({},r,{children:(0,s.jsx)(a,r)})):a(r)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["JavaScript%2Fes6%2Fes6-17.md"]={toc:[{id:"概述",text:"概述",depth:2},{id:"严格模式",text:"严格模式",depth:2},{id:"export-命令",text:"export 命令",depth:2},{id:"import-命令",text:"import 命令",depth:2}],title:"Module 的语法",headingTitle:"Module 的语法",frontmatter:{}}}}]);