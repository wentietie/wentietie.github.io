"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["2329"],{51388:function(e,n,r){r.r(n),r.d(n,{default:function(){return d}});var s=r(85893),a=r(50065);function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",p:"p",pre:"pre",code:"code",ul:"ul",li:"li",ol:"ol",div:"div"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"set-与-map-数据结构",children:["Set 与 Map 数据结构",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set-与-map-数据结构",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"set",children:["Set",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"基本用法",children:["基本用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本用法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"ES6 提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。"}),"\n",(0,s.jsx)(n.p,{children:"Set 本身是一个构造函数，用来生成 Set 数据结构。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const s = new Set();\r\n// 通过 add() 方法向 Set 结构加入成员\r\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\r\nfor (let i of s) {\r\n    console.log(i);\r\n}\r\n// 2 3 5 4\r\n\r\n// Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\r\nconst set = new Set([1, 2, 3, 4, 4]);\r\n[...set]\r\n// [1, 2, 3, 4]\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"set-实例的属性和方法",children:["Set 实例的属性和方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set-实例的属性和方法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Set 结构的实例有以下属性。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set.prototype.constructor ：构造函数，默认就是 Set 函数。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set.prototype.size ：返回 Set 实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set.prototype.add(value) ：添加某个值，返回 Set 结构本身。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set.prototype.delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set.prototype.has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Set.prototype.clear() ：清除所有成员，没有返回值。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Array.from 方法可以将 Set 结构转为数组。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const items = new Set([1, 2, 3, 4, 5]);\r\nconst array = Array.from(items);\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"遍历操作",children:["遍历操作",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历操作",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Set 结构的实例有四个遍历方法，可以用于遍历成员。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Set.prototype.keys() ：返回键名的遍历器"}),"\n",(0,s.jsx)(n.li,{children:"Set.prototype.values() ：返回键值的遍历器"}),"\n",(0,s.jsx)(n.li,{children:"Set.prototype.entries() ：返回键值对的遍历器"}),"\n",(0,s.jsx)(n.li,{children:"Set.prototype.forEach() ：使用回调函数遍历每个成员"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"map",children:["Map",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#map",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"含义和基本用法",children:["含义和基本用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#含义和基本用法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。"}),"\n",(0,s.jsx)(n.p,{children:"为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map\r\n结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const m = new Map();\r\nconst o = {p: 'Hello World'};\r\nm.set(o, 'content')\r\nm.get(o) // \"content\"\r\nm.has(o) // true\r\nm.delete(o) // true\r\nm.has(o) // false\n"})}),"\n",(0,s.jsx)(n.p,{children:"作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const map = new Map([\r\n    ['name', '张三'],\r\n    ['title', 'Author']\r\n]);\r\nmap.size // 2\r\nmap.has('name') // true\r\nmap.get('name') // \"张三\"\r\nmap.has('title') // true\r\nmap.get('title') // \"Author\"\r\n\r\n\r\n// 如果对同一个键多次赋值，后面的值将覆盖前面的值。\r\n\r\nconst map = new Map();\r\nmap\r\n    .set(1, 'aaa')\r\n    .set(1, 'bbb');\r\nmap.get(1) // \"bbb\"\r\n// 上面代码对键 1 连续赋值两次，后一次的值覆盖前一次的值。\r\n\r\n// 如果读取一个未知的键，则返回 undefined 。\r\n\r\nnew Map().get('asfddfsasadf')\r\n// undefined\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"实例的属性和操作方法",children:["实例的属性和操作方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例的属性和操作方法",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"size 属性"}),"\n",(0,s.jsx)(n.p,{children:"size 属性返回 Map 结构的成员总数。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const map = new Map();\r\nmap.set('foo', true);\r\nmap.set('bar', false);\r\nmap.size // 2\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Map.prototype.set(key, value)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"set 方法设置键名 key 对应的键值为 value ，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const m = new Map();\r\nm.set('edition', 6)        // 键是字符串\r\nm.set(262, 'standard')     // 键是数值\r\nm.set(undefined, 'nah')    // 键是 undefined\r\n\r\n// set 方法返回的是当前的 Map 对象，因此可以采用链式写法。\r\nlet map = new Map()\r\n    .set(1, 'a')\r\n    .set(2, 'b')\r\n    .set(3, 'c');\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Map.prototype.get(key)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"get 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const m = new Map();\r\nconst hello = function () {\r\n    console.log('hello');\r\n};\r\nm.set(hello, 'Hello ES6!') // 键是函数\r\nm.get(hello)  // Hello ES6!\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"Map.prototype.has(key)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const m = new Map();\r\nm.set('edition', 6);\r\nm.set(262, 'standard');\r\nm.set(undefined, 'nah');\r\nm.has('edition')     // true\r\nm.has('years')       // false\r\nm.has(262)           // true\r\nm.has(undefined)     // true\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:"Map.prototype.delete(key)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"delete 方法删除某个键，返回 true 。如果删除失败，返回 false 。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const m = new Map();\r\nm.set(undefined, 'nah');\r\nm.has(undefined)     // true\r\nm.delete(undefined)\r\nm.has(undefined)       // false\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsx)(n.li,{children:"Map.prototype.clear()"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"clear 方法清除所有成员，没有返回值。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let map = new Map();\r\nmap.set('foo', true);\r\nmap.set('bar', false);\r\nmap.size // 2\r\nmap.clear()\r\nmap.size // 0\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"与其他数据结构的互相转换",children:["与其他数据结构的互相转换",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与其他数据结构的互相转换",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Map 转为数组"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（ ... ）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const myMap = new Map()\r\n    .set(true, 7)\r\n    .set({foo: 3}, ['abc']);\r\n[...myMap]\r\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"数组 转为 Map"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"将数组传入 Map 构造函数，就可以转为 Map。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"new Map([\r\n    [true, 7],\r\n    [{foo: 3}, ['abc']]\r\n])\r\n// Map {\r\n//   true => 7,\r\n//   Object {foo: 3} => ['abc']\r\n// }\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Map 转为对象"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"如果所有 Map 的键都是字符串，它可以无损地转为对象。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function strMapToObj(strMap) {\r\n    let obj = Object.create(null);\r\n    for (let [k, v] of strMap) {\r\n        obj[k] = v;\r\n    }\r\n    return obj;\r\n}\r\n\r\nconst myMap = new Map()\r\n    .set('yes', true)\r\n    .set('no', false);\r\nstrMapToObj(myMap)\r\n// { yes: true, no: false }\n"})}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。"}),(0,s.jsx)(n.div,{className:"rspress-directive-content"})]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:"Map 转为 JSON"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function strMapToJson(strMap) {\r\n    return JSON.stringify(strMapToObj(strMap));\r\n}\r\n\r\nlet myMap = new Map().set('yes', true).set('no', false);\r\nstrMapToJson(myMap)\r\n// '{\"yes\":true,\"no\":false}'\n"})}),"\n",(0,s.jsx)(n.p,{children:"另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function mapToArrayJson(map) {\r\n    return JSON.stringify([...map]);\r\n}\r\n\r\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\r\nmapToArrayJson(myMap)\r\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsx)(n.li,{children:"JSON 转为 Map"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"JSON 转为 Map，正常情况下，所有键名都是字符串。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function jsonToStrMap(jsonStr) {\r\n    return objToStrMap(JSON.parse(jsonStr));\r\n}\r\n\r\njsonToStrMap('{\"yes\": true, \"no\": false}')\r\n// Map {'yes' => true, 'no' => false}\n"})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["JavaScript%2Fes6%2Fes6-11.md"]={toc:[{text:"Set",id:"set",depth:2},{text:"基本用法",id:"基本用法",depth:3},{text:"Set 实例的属性和方法",id:"set-实例的属性和方法",depth:3},{text:"遍历操作",id:"遍历操作",depth:3},{text:"Map",id:"map",depth:2},{text:"含义和基本用法",id:"含义和基本用法",depth:3},{text:"实例的属性和操作方法",id:"实例的属性和操作方法",depth:3},{text:"与其他数据结构的互相转换",id:"与其他数据结构的互相转换",depth:3}],title:"Set 与 Map 数据结构",frontmatter:{}}}}]);