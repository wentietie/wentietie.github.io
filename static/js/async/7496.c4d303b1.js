"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["7496"],{23454:function(e,r,n){n.r(r),n.d(r,{default:function(){return i}});var p=n(85893),s=n(50065);function t(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",div:"div",h4:"h4"},(0,s.ah)(),e.components);return(0,p.jsxs)(p.Fragment,{children:[(0,p.jsxs)(r.h1,{id:"组件深入",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#组件深入",children:"#"}),"组件深入"]}),"\n",(0,p.jsxs)(r.h2,{id:"组件注册",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#组件注册",children:"#"}),"组件注册"]}),"\n",(0,p.jsxs)(r.h3,{id:"全局注册",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#全局注册",children:"#"}),"全局注册"]}),"\n",(0,p.jsx)(r.p,{children:"可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。"}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-js",meta:"",children:"import {createApp} from 'vue'\r\n\r\nconst app = createApp({})\r\n// js 对象形式\r\napp.component(\r\n// 注册的名字\r\n  'MyComponent',\r\n// 组件的实现\r\n  {\r\n    /* ... */\r\n  }\r\n)\r\n// 单文件形式\r\nimport MyComponent from './App.vue'\r\n\r\napp.component('MyComponent', MyComponent);\n"})}),"\n",(0,p.jsx)(r.p,{children:"app.component() 方法可以被链式调用："}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-js",meta:"",children:"app\r\n  .component('ComponentA', ComponentA)\r\n  .component('ComponentB', ComponentB)\r\n  .component('ComponentC', ComponentC)\n"})}),"\n",(0,p.jsxs)(r.h3,{id:"局部注册",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#局部注册",children:"#"}),"局部注册"]}),"\n",(0,p.jsx)(r.p,{children:"全局注册虽然很方便，但有以下几个问题："}),"\n",(0,p.jsxs)(r.ol,{children:["\n",(0,p.jsx)(r.li,{children:"全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的\r\nJS 文件中。"}),"\n",(0,p.jsx)(r.li,{children:"全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。"}),"\n"]}),"\n",(0,p.jsx)(r.p,{children:"相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对\r\ntree-shaking 更加友好。"}),"\n",(0,p.jsxs)(r.p,{children:["在使用 ",(0,p.jsx)(r.code,{children:"<script setup>"})," 的单文件组件中，导入的组件可以直接在模板中使用，无需注册："]}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-vue",meta:"",children:"\r\n<script setup>\r\nimport ComponentA from './ComponentA.vue'\r\n<\/script>\r\n\r\n<template>\r\n  <ComponentA/>\r\n</template>\n"})}),"\n",(0,p.jsxs)(r.p,{children:["如果没有使用 ",(0,p.jsx)(r.code,{children:"<script setup>"}),"，则需要使用 components 选项来显式注册："]}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-js",meta:"",children:"import ComponentA from './ComponentA.js'\r\n\r\nexport default {\r\n  components: {\r\n    ComponentA\r\n  },\r\n  setup() {\r\n// ...\r\n  }\r\n}\n"})}),"\n",(0,p.jsxs)(r.div,{className:"rspress-directive warning",children:[(0,p.jsx)(r.div,{className:"rspress-directive-title",children:"局部注册的组件在后代组件中并不可用。"}),(0,p.jsx)(r.div,{className:"rspress-directive-content",children:(0,p.jsx)(r.p,{})})]}),"\n",(0,p.jsxs)(r.h2,{id:"props",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#props",children:"#"}),"Props"]}),"\n",(0,p.jsxs)(r.h3,{id:"prop-的声明",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#prop-的声明",children:"#"}),"prop 的声明"]}),"\n",(0,p.jsx)(r.p,{children:"一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute."}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-vue",meta:"",children:"\x3c!-- 在使用 <script setup> 的单文件组件中，props 可以使用 defineProps() 宏来声明：--\x3e\r\n<script setup>\r\nconst props = defineProps(['foo'])\r\n\r\nconsole.log(props.foo)\r\n<\/script>\r\n\x3c!--在没有使用 <script setup> 的组件中，prop 可以使用 props 选项来声明：--\x3e\r\n<script>\r\nexport default {\r\n  props: ['foo'],\r\n  setup(props) {\r\n// setup() 接收 props 作为第一个参数\r\n    console.log(props.foo)\r\n  }\r\n}\r\n<\/script>\r\n\n"})}),"\n",(0,p.jsxs)(r.h4,{id:"除了使用字符串数组来声明-prop-外还可以使用对象的形式",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#除了使用字符串数组来声明-prop-外还可以使用对象的形式",children:"#"}),"除了使用字符串数组来声明 prop 外，还可以使用对象的形式"]}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-js",meta:"",children:"// 使用 <script setup>\r\ndefineProps({\r\n  title: String,\r\n  likes: Number\r\n})\r\n\r\n// 非 <script setup>\r\nexport default {\r\n  props: {\r\n    title: String,\r\n    likes: Number\r\n  }\r\n}\n"})}),"\n",(0,p.jsxs)(r.h3,{id:"传递-prop-的细节",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#传递-prop-的细节",children:"#"}),"传递 prop 的细节"]}),"\n",(0,p.jsxs)(r.h4,{id:"prop的名字格式",children:[(0,p.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#prop的名字格式",children:"#"}),"Prop的名字格式"]}),"\n",(0,p.jsx)(r.p,{children:"如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性\r\nkey 名时必须加上引号。"}),"\n",(0,p.jsx)(r.pre,{children:(0,p.jsx)(r.code,{className:"language-vue",meta:"",children:"\r\n<template>\r\n  <span>{{ greetingMessage }}</span>\r\n</template>\r\n<script>\r\ndefineProps({\r\n  greetingMessage: String\r\n})\r\n<\/script>\n"})})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,p.jsx)(r,Object.assign({},e,{children:(0,p.jsx)(t,e)})):t(e)}let i=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["formwork%2Fvue3%2Freactive%2Fpart12.md"]={toc:[{id:"组件注册",text:"组件注册",depth:2},{id:"全局注册",text:"全局注册",depth:3},{id:"局部注册",text:"局部注册",depth:3},{id:"props",text:"Props",depth:2},{id:"prop-的声明",text:"prop 的声明",depth:3},{id:"除了使用字符串数组来声明-prop-外还可以使用对象的形式",text:"除了使用字符串数组来声明 prop 外，还可以使用对象的形式",depth:4},{id:"传递-prop-的细节",text:"传递 prop 的细节",depth:3},{id:"prop的名字格式",text:"Prop的名字格式",depth:4}],title:"组件深入",headingTitle:"组件深入",frontmatter:{}}}}]);