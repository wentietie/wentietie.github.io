"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["7695"],{59295:function(n,e,i){i.r(e),i.d(e,{default:function(){return s}});var l=i(85893),r=i(50065);function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",ol:"ol"},(0,r.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"前端设计模式简介",children:[(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前端设计模式简介",children:"#"}),"前端设计模式简介"]}),"\n",(0,l.jsx)(e.p,{children:"设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。"}),"\n",(0,l.jsxs)(e.h2,{id:"原则",children:[(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#原则",children:"#"}),"原则"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"单一职责原则: 一个程序只做好一件事,如果功能过于复杂就拆分开，每个部分保持独立"}),"\n",(0,l.jsx)(e.li,{children:"开放/封闭原则: 对扩展开放，对修改封闭  增加需求时，扩展新代码，而非修改已有代码"}),"\n",(0,l.jsx)(e.li,{children:"里氏替换原则: 子类能覆盖父类  父类能出现的地方子类就能出现"}),"\n",(0,l.jsx)(e.li,{children:"接口隔离原则: 保持接口的单一独立 类似单一职责原则，这里更关注接口"}),"\n",(0,l.jsx)(e.li,{children:"依赖倒转原则: 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现"}),"\n",(0,l.jsx)(e.li,{children:"迪米特法则（最少知识原则）： 对外接口简单，当前类对其他类的知识越少越好。"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"创建型",children:[(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建型",children:"#"}),"创建型"]}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"工厂方法模式"}),"\n",(0,l.jsx)(e.li,{children:"抽象工厂模式"}),"\n",(0,l.jsx)(e.li,{children:"建造者模式"}),"\n",(0,l.jsx)(e.li,{children:"原型模式"}),"\n",(0,l.jsx)(e.li,{children:"单例模式"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"结构型",children:[(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#结构型",children:"#"}),"结构型"]}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"适配器模式"}),"\n",(0,l.jsx)(e.li,{children:"装饰器模式"}),"\n",(0,l.jsx)(e.li,{children:"代理模式"}),"\n",(0,l.jsx)(e.li,{children:"外观模式"}),"\n",(0,l.jsx)(e.li,{children:"桥接模式"}),"\n",(0,l.jsx)(e.li,{children:"组合模式"}),"\n",(0,l.jsx)(e.li,{children:"享元模式"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"行为型",children:[(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#行为型",children:"#"}),"行为型"]}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"策略模式"}),"\n",(0,l.jsx)(e.li,{children:"模板方法模式"}),"\n",(0,l.jsx)(e.li,{children:"观察者模式"}),"\n",(0,l.jsx)(e.li,{children:"迭代器模式"}),"\n",(0,l.jsx)(e.li,{children:"责任链模式"}),"\n",(0,l.jsx)(e.li,{children:"命令模式"}),"\n",(0,l.jsx)(e.li,{children:"备忘录模式"}),"\n",(0,l.jsx)(e.li,{children:"状态模式"}),"\n",(0,l.jsx)(e.li,{children:"访问者模式"}),"\n",(0,l.jsx)(e.li,{children:"中介者模式"}),"\n",(0,l.jsx)(e.li,{children:"解释器模式"}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,l.jsx)(e,Object.assign({},n,{children:(0,l.jsx)(h,n)})):h(n)}let s=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["JavaScript%2Fdesign%2Freadme.md"]={toc:[{id:"原则",text:"原则",depth:2},{id:"创建型",text:"创建型",depth:2},{id:"结构型",text:"结构型",depth:2},{id:"行为型",text:"行为型",depth:2}],title:"前端设计模式简介",headingTitle:"前端设计模式简介",frontmatter:{}}}}]);