"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["833"],{79842:function(n,r,e){e.r(r),e.d(r,{default:()=>d});var s=e("85893"),t=e("50065");let i=e.p+"static/image/16_stream.ef36146d.png";function l(n){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",blockquote:"blockquote",ul:"ul",li:"li",code:"code",strong:"strong",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h3:"h3",img:"img"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"16-java8新特性",children:["16 Java8新特性",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#16-java8新特性",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["Java8中最重要的两大改变：","Lambda表达式","、","Stream API"]}),"\n",(0,s.jsxs)(r.h2,{id:"161-接口新特性",children:["16.1 接口新特性",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#161-接口新特性",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"JDK8以后，接口既可以定义全局常量、抽象方法，也可以定义静态方法、默认方法。"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"定义静态方法（public static）：接口中定义的静态方法，只能通过接口来调用"}),"\n",(0,s.jsxs)(r.li,{children:["定义默认方法（public default）：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"可以通过实现类的对象，调用接口中的默认方法"}),"\n",(0,s.jsx)(r.li,{children:"实现类可以重写接口的默认方法"}),"\n",(0,s.jsxs)(r.li,{children:["如果子类（或实现类）继承的父类和实现的接口中，声明了同名、同参的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的方法 ---\x3e ","类优先原则"]}),"\n",(0,s.jsxs)(r.li,{children:["如果实现类实现了多个接口，且这多个接口中定义了同名、同参的默认方法，在实现类没有重写此方法的情况下，编译报错 ---\x3e ","接口冲突","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"如果想解决以上冲突，必须在实现类中重写此方法。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["如何在子类（或实现类）的方法中调用父类、接口中被重写的方法？","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["调用父类中声明的方法：",(0,s.jsx)(r.code,{children:"super.方法"})]}),"\n",(0,s.jsxs)(r.li,{children:["调用接口中默认的方法：",(0,s.jsx)(r.code,{children:"接口名.super.方法"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"162-新的日期时间api",children:["16.2 新的日期时间API",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#162-新的日期时间api",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["具体使用见",(0,s.jsx)(r.a,{href:"/tang/java/java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/09_Java%E5%B8%B8%E7%94%A8%E7%B1%BB.html#_9-2-2-jdk8%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api",children:"9.2.2 JDK8中新的日期时间API"}),"小节"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"JDK8新增的日期时间API"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"java.time.LocalDate：获取日期"}),"\n",(0,s.jsx)(r.li,{children:"java.time.LocalTime：获取时间"}),"\n",(0,s.jsx)(r.li,{children:"java.time.LocalDateTime：获取日期+时间"}),"\n",(0,s.jsx)(r.li,{children:"java.time.Instant：瞬时，等同于Date中的getTime()"}),"\n",(0,s.jsx)(r.li,{children:"java.time.format.DateTimeFormatter：时间格式化"}),"\n",(0,s.jsxs)(r.li,{children:["其他API：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"java.time.ZoneId：时区相关操作"}),"\n",(0,s.jsx)(r.li,{children:"java.time.ZonedDateTime：带时区的日期时间"}),"\n",(0,s.jsx)(r.li,{children:"java.time.Clock：使用时区提供对当前即时、日期、和时间的访问的时钟"}),"\n",(0,s.jsxs)(r.li,{children:["java.time.Duration：用来计算两个",(0,s.jsx)(r.strong,{children:"时间"}),"的间隔，可以获取秒级间隔，也可以获取纳秒级间隔"]}),"\n",(0,s.jsxs)(r.li,{children:["java.time.Period：用来计算两个",(0,s.jsx)(r.strong,{children:"日期"}),"的间隔"]}),"\n",(0,s.jsx)(r.li,{children:"java.time.temporal.TemporalAdjuster：时间校正器。如获取当前日期的下一个工作日等"}),"\n",(0,s.jsx)(r.li,{children:"java.time.temporal.TemporalAdjusters：该类通过静态方法提供了大量的TemporalAdjuster实现"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"163-注解新特性",children:["16.3 注解新特性",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#163-注解新特性",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["具体使用见",(0,s.jsx)(r.a,{href:"/tang/java/java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/10_%E6%9E%9A%E4%B8%BE_%E6%B3%A8%E8%A7%A3.html#_10-2-6-jdk8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E6%96%B0%E7%89%B9%E6%80%A7",children:"10.2.6 JDK8中注解新特性"}),"小节"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["可重复注解","：在一个类或者属性或其他结构上使用多次相同注解"]}),"\n",(0,s.jsxs)(r.li,{children:["类型注解","：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"JDK8之前，注解只能是在声明的地方使用；JDK8之后，注解可以应用在任何地方。"}),"\n",(0,s.jsxs)(r.li,{children:["JDK8之后，元注解@Target的参数类型ElementType枚举值多了两个：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如泛型声明）"}),"\n",(0,s.jsx)(r.li,{children:"ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"164-lambda表达式",children:["16.4 Lambda表达式",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#164-lambda表达式",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"格式"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"->"}),"：lambda操作符 或 箭头操作符"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"-> 左边"}),"：lambda形参列表，即接口中抽象方法的形参列表"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"-> 右边"}),"：lambda体，即重写的抽象方法的方法体"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"举例"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.code,{children:"(o1, o2) -> Interger.compare(o1,o2)"})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"lambda的使用"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"-> 左边"}),"：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"lambda形参列表的参数类型可以省略（类型推断）"}),"\n",(0,s.jsx)(r.li,{children:"如果lambda形参列表只有一个参数，其一对()可以省略"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"-> 右边"}),"：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"lambda体应该使用一对{}包裹"}),"\n",(0,s.jsx)(r.li,{children:"如果lambda体只有一条执行语句（可能是return语句），可以省略一对{}和return关键字（如果省略{}，return必须省略）"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"使用举例"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'@Test\r\npublic void test1() {\r\n    // 不使用lambda表达式\r\n    Consumer<String> con1 = new Consumer<String>() {\r\n        @Override\r\n        public void accept(String s) {\r\n            System.out.println(s);\r\n        }\r\n    };\r\n    con1.accept("辞暮尔尔，烟火年年");\r\n\r\n    System.out.println("****************************************");\r\n\r\n    // 使用lambda表达式：一个参数，可以省略形参的()；抽象方法中只有一句代码，可以省略方法体的{}\r\n    Consumer<String> con2 = s -> System.out.println(s);\r\n    con2.accept("辞暮尔尔，烟火年年");\r\n}\r\n\r\n@Test\r\npublic void test2() {\r\n    // 不使用lambda表达式\r\n    Comparator<Integer> com1 = new Comparator<Integer>() {\r\n        @Override\r\n        public int compare(Integer o1, Integer o2) {\r\n            return Integer.compare(o1, o2);\r\n        }\r\n    };\r\n    System.out.println(com1.compare(12, 13));\r\n\r\n    System.out.println("****************************************");\r\n\r\n    // 使用lambda表达式：两个参数，形参列表的()不可省；抽象方法中只有一句代码，可以省略{}和return\r\n    Comparator<Integer> com2 = (o1, o2) ->  Integer.compare(o1, o2);\r\n    System.out.println(com2.compare(2, 1));\r\n}\n'})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"lambda表达式的本质"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["接口的要求","：接口必须是函数式接口"]}),"\n",(0,s.jsx)(r.li,{children:"以前用匿名实现类表示的，现在都可以用Lambda表达式来写"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"165-函数式functional接口",children:["16.5 函数式(Functional)接口",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#165-函数式functional接口",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"如果一个接口中，只声明了一个(抽象)方法，那么这个接口就叫函数式接口。(接口中的方法都是抽象方法)"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["自定义函数式接口时，可以在接口上加上",(0,s.jsx)(r.code,{children:"@FunctionalInterface"}),"注解。这样可以检查它是否是一个函数式接口"]}),"\n",(0,s.jsx)(r.li,{children:"在java.util.function包下定义了Java8的丰富的函数式接口"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"Java内置四大核心函数式接口"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"函数式接口"}),"\n",(0,s.jsx)(r.th,{children:"参数类型"}),"\n",(0,s.jsx)(r.th,{children:"返回类型"}),"\n",(0,s.jsx)(r.th,{children:"用途"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"Consumer<T> 消费型接口"}),"\n",(0,s.jsx)(r.td,{children:"T"}),"\n",(0,s.jsx)(r.td,{children:"void"}),"\n",(0,s.jsx)(r.td,{children:"对类型为T的对象应用操作，包含方法：void accept(T t)"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"Supplier<T> 供给型接口"}),"\n",(0,s.jsx)(r.td,{children:"无"}),"\n",(0,s.jsx)(r.td,{children:"T"}),"\n",(0,s.jsx)(r.td,{children:"返回类型为T的对象，包含方法：T get()"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"Function<T, R> 函数型接口"}),"\n",(0,s.jsx)(r.td,{children:"T"}),"\n",(0,s.jsx)(r.td,{children:"R"}),"\n",(0,s.jsx)(r.td,{children:"对类型为T的对象应用操作，并返回R类型的结果，包含方法：R apply(T)"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"Predicate<T> 判定型接口"}),"\n",(0,s.jsx)(r.td,{children:"T"}),"\n",(0,s.jsx)(r.td,{children:"boolean"}),"\n",(0,s.jsx)(r.td,{children:"确定类型为T的对象是否满足约束，并返回boolean值，包含方法：boolean test(T t)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"166-方法引用与构造器引用",children:["16.6 方法引用与构造器引用",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#166-方法引用与构造器引用",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"1661-方法引用",children:["16.6.1 方法引用",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1661-方法引用",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用"}),"\n",(0,s.jsx)(r.li,{children:"方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法应用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖"}),"\n",(0,s.jsxs)(r.li,{children:["要求","：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致"]}),"\n",(0,s.jsxs)(r.li,{children:["格式","：使用操作符",(0,s.jsx)(r.code,{children:"::"}),"将类（或对象）与方法名分隔开来"]}),"\n",(0,s.jsxs)(r.li,{children:["三种主要使用情况","：(注意，::右侧都是方法名，不需要参数)","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"对象::实例方法名"}),"\n",(0,s.jsx)(r.li,{children:"类::静态方法名"}),"\n",(0,s.jsx)(r.li,{children:"类::非静态方法名"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"举例"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"情况一：对象 :: 实例方法"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * 情况一： 对象 :: 实例方法\r\n *\r\n * Consumer中的void accept(T t)\r\n * PrintStream中的void println(String x)\r\n */\r\n@Test\r\npublic void test1() {\r\n    // 原Lambda表达式写法\r\n    Consumer<String> con1 = str -> System.out.println(str);\r\n    con1.accept("帘外雨潺潺，春意阑珊。");\r\n\r\n    System.out.println("**************************************");\r\n\r\n    // 方法引用写法\r\n    PrintStream out = System.out;\r\n    Consumer<String> con2 = out :: println;\r\n    con2.accept("罗衾不耐五更寒。");\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"情况二：类 :: 静态方法"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * 情况二： 类 :: 静态方法\r\n *\r\n * Comparator中的int compare(T o1, T o2)\r\n * Integer中的int compareTo(Integer anotherInteger)\r\n */\r\n@Test\r\npublic void test2() {\r\n    // 原Lambda写法\r\n    Comparator<Integer> com1 = (o1, o2) -> Integer.compare(o1, o2);\r\n    System.out.println(com1.compare(12, 13));\r\n\r\n    System.out.println("**************************************");\r\n\r\n    // 方法引用写法\r\n    Comparator<Integer> com2 = Integer::compareTo;\r\n    System.out.println(com2.compare(12, 13));\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"情况三：类 :: 静态方法"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * 情况三： 类 :: 静态方法\r\n *\r\n * ① Comparator中的int compare(T t1, T t2)\r\n * ② String中的int t1.compareTo(t2)\r\n */\r\n@Test\r\npublic void test3() {\r\n    // 原Lambda写法\r\n    Comparator<String> com1 = (t1, t2) -> t1.compareTo(t2);\r\n    System.out.println(com1.compare("abc", "abd"));\r\n\r\n    System.out.println("**************************************");\r\n\r\n    // 方法引用写法\r\n    Comparator<String> com2 = String :: compareTo;\r\n    System.out.println(com2.compare("abc", "abm"));\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"1662-构造器引用",children:["16.6.2 构造器引用",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1662-构造器引用",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"和方法引用类似。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["使用场景：函数式接口的抽象方法的形参列表和构造器的形参列表一致",(0,s.jsx)(r.code,{children:"且"}),"抽象方法的返回值即为构造器所属的类的类型"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"使用举例"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * 空参构造器\r\n * Supplier<T>中的 T get()\r\n */\r\n@Test\r\npublic void test1() {\r\n    //\r\n    Supplier<Person> sup1 = () -> new Person();\r\n    System.out.println(sup1.get());\r\n\r\n    System.out.println("*******************************************");\r\n\r\n    Supplier<Person> sup2 = Person::new;\r\n    System.out.println(sup2.get());\r\n}\r\n\r\n/**\r\n * 含一个参数的构造器\r\n * Function<T, R>中的R apply(T t)\r\n */\r\n@Test\r\npublic void test2() {\r\n    Function<String, Person> fun1 = name -> new Person(name);\r\n    System.out.println(fun1.apply("Tom"));\r\n\r\n    System.out.println("*******************************************");\r\n\r\n    Function<String, Person> fun2 = Person::new;\r\n    System.out.println(fun2.apply("张三"));\r\n}\r\n\r\n/**\r\n * 含2个参数的构造器\r\n * BiFunction<T, U, R>中的R apply(T t, U u)\r\n */\r\n@Test\r\npublic void test3() {\r\n    BiFunction<String, Integer, Person> bi1 = (name, age) -> new Person(name, age);\r\n    System.out.println(bi1.apply("Steven", 18));\r\n\r\n    System.out.println("*******************************************");\r\n\r\n    BiFunction<String, Integer, Person> bi2 = Person::new;\r\n    System.out.println(bi2.apply("李四", 22));\r\n}\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"1663-数组引用",children:["16.6.3 数组引用",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1663-数组引用",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"可以将数组引用看做是一个特殊的类，写法与构造器引用一致"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"使用举例"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'@Test\r\npublic void test() {\r\n    Function<Integer, String[]> fun1 = length -> new String[length];\r\n    String[] arr1 = fun1.apply(5);\r\n    System.out.println(Arrays.toString(arr1));\r\n\r\n    System.out.println("************************************************");\r\n\r\n    Function<Integer, String[]> fun2 = String[] :: new;\r\n\r\n    String[] arr2 = fun2.apply(10);\r\n    System.out.println(Arrays.toString(arr2));\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"167-stream-api",children:["16.7 Stream API",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#167-stream-api",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"1671-概述",children:["16.7.1 概述",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1671-概述",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"Stream API(java.util.stream)把真正的函数式变成风格引入到Java中"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"可以使用Stream API对集合数据进行操作，如过滤、查询、排序等"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"为什么要用Stream API？"}),"\n",(0,s.jsx)(r.p,{children:"实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但是对于像MongoDB、Radis等NoSql中获取的数据需要在Java层面去处理。"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"Stream和Collection的区别"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Collection是一种静态的内存数据结构；Stream是有关计算的"}),"\n",(0,s.jsx)(r.li,{children:"Collection主要是面向内存，存储在内存中；Stream主要是面向CPU，通过CPU实现计算"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"注意："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Stream不会存储数据"}),"\n",(0,s.jsxs)(r.li,{children:["Stream不会改变源对象，会返回一个持有结果的新的Stream ---- ",(0,s.jsx)(r.code,{children:"Stream 的不可变性"})]}),"\n",(0,s.jsx)(r.li,{children:"Stream操作是延迟执行的。这意味着他们会等到结果的时候才执行"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"1672-stream的操作三个步骤",children:["16.7.2 Stream的操作三个步骤",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1672-stream的操作三个步骤",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"①创建Stream"}),"\n",(0,s.jsx)(r.p,{children:"一个数据源（如集合、数组），获取一个流"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"②中间操作"}),"\n",(0,s.jsx)(r.p,{children:"一个中间操作链，对数据源的数据进行处理"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"③终止操作（终端操作）"}),"\n",(0,s.jsx)(r.p,{children:"一旦执行终止操作，就执行中间操作链，并产生结果。之后不会再被使用"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(r.h3,{id:"1673-stream的实例化",children:["16.7.3 Stream的实例化",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1673-stream的实例化",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"通过集合实例化"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Stream<E> stream()"}),"：返回一个顺序流"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Stream<E> parallelStream()"}),"：返回一个并行流"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"通过数组实例化"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["调用Arrays 的",(0,s.jsx)(r.code,{children:"static <T> Stream<T> stream(T[] array)"}),"方法"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["通过Stream的",(0,s.jsx)(r.code,{children:"static<T> Stream<T> of(T... values)"}),"方法实例化"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"创建无限流 ---- 用于造数据"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["调用Stream的",(0,s.jsx)(r.code,{children:"static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)"}),"方法"]}),"\n",(0,s.jsxs)(r.li,{children:["调用Stream的",(0,s.jsx)(r.code,{children:"static<T> Stream<T> generate(Supplier<T> s)"}),"方法"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"举例说明"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * 通过集合实例化\r\n */\r\n@Test\r\npublic void test1() {\r\n    List<Person> persons = new ArrayList<Person>(){\r\n        { add(new Person(1001, "张1", 18, 5600)); }\r\n        { add(new Person(1002, "张2", 17, 7200)); }\r\n        { add(new Person(1003, "张3", 16, 3400)); }\r\n        { add(new Person(1004, "张4", 20, 8900)); }\r\n        { add(new Person(1005, "张5", 19, 5400)); }\r\n        { add(new Person(1006, "张6", 18, 5600)); }\r\n    };\r\n\r\n    // 创建顺序流\r\n    Stream<Person> stream = persons.stream();\r\n\r\n    // 创建并行流\r\n    Stream<Person> personStream = persons.parallelStream();\r\n}\r\n\r\n/**\r\n * 通过数组实例化\r\n */\r\n@Test\r\npublic void test2() {\r\n    Person[] arr = new Person[] {\r\n            new Person(1001, "张1", 18, 5600),\r\n            new Person(1002, "张2", 17, 7200),\r\n            new Person(1003, "张3", 16, 3400),\r\n            new Person(1004, "张4", 20, 8900),\r\n            new Person(1005, "张5", 19, 5400),\r\n            new Person(1006, "张6", 18, 5600)\r\n    };\r\n\r\n    Stream<Person> stream = Arrays.stream(arr);\r\n}\r\n\r\n/**\r\n * 通过Stream.of()实例化\r\n */\r\n@Test\r\npublic void test3() {\r\n    Stream<Person> stream = Stream.of(new Person(1001, "张1", 18, 5600),\r\n            new Person(1002, "张2", 17, 7200),\r\n            new Person(1003, "张3", 16, 3400),\r\n            new Person(1004, "张4", 20, 8900),\r\n            new Person(1005, "张5", 19, 5400),\r\n            new Person(1006, "张6", 18, 5600));\r\n\r\n}\r\n\r\n/**\r\n * 创建无限流---用来造数据\r\n */\r\n@Test\r\npublic void test4() {\r\n    // 获取前10个偶数\r\n    Stream<Integer> stream1 = Stream.iterate(0, t -> t + 2).limit(10);\r\n    stream1.forEach(System.out :: println);\r\n\r\n    System.out.println("********************************");\r\n\r\n    // 获取10个随机数\r\n    Stream<Double> stream2 = Stream.generate(Math::random).limit(10);\r\n    stream2.forEach(d -> System.out.println(d));\r\n} \n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"1674-stream的中间操作",children:["16.7.4 Stream的中间操作",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1674-stream的中间操作",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["多个","中间操作","可以连接起来行程一个","流水线","。除非流水线上触发终止操作，\r\n否则","中间操作不会执行任何的处理","！而是","在终止操作时一次性全部处理","。\r\n这称为“","惰性求值","”。"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"筛选与切片"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"filter(Predicate p)"}),"\n",(0,s.jsx)(r.td,{children:"接收Lambda，从流中排除某些元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"distinct()"}),"\n",(0,s.jsx)(r.td,{children:"筛选，通过流元素生成的hasCode()和equals()去除重复元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"limit(long maxSize)"}),"\n",(0,s.jsx)(r.td,{children:"截断流，使其元素不超过指定数量"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"ship(long n)"}),"\n",(0,s.jsx)(r.td,{children:"跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"映射"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"map(Function f)"}),"\n",(0,s.jsx)(r.td,{children:"接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"flatMap(Function f)"}),"\n",(0,s.jsx)(r.td,{children:"接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流。"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"mapToDouble(ToDoubleFunction f)与flatMapToDouble(ToDoubleFunction f)"}),"\n",(0,s.jsx)(r.td,{children:"接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"mapToInt(ToIntFunction f)与flatMapToInt(ToIntFunction f)"}),"\n",(0,s.jsx)(r.td,{children:"接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"mapToLong(ToLongFunction f)与flatMapToLong(ToLongFunction f)"}),"\n",(0,s.jsx)(r.td,{children:"接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"答"}),"：map(Function f)类似于List中的add()，flatMap(Function f)类似于List中的addAll()。"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"排序"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"sorted()"}),"\n",(0,s.jsx)(r.td,{children:"产生一个新流，其中按自然顺序排序"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"sorted(Comparator comparator)"}),"\n",(0,s.jsx)(r.td,{children:"产生一个新柳，其中按照自定义的Comparator实现定制排序"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"例子"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"测试类："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * @Author tth\r\n * @Date 2023/1/3 16:46\r\n */\r\npublic class StreamAPITest2 {\r\n\r\n    /**\r\n     * Stream的筛选与切片\r\n     */\r\n    @Test\r\n    public void test1() {\r\n        List<Person> persons = Person.getPersons();\r\n\r\n        // 练习：查询员工中薪资超过6000的员工，并打印\r\n        persons.stream().filter(p -> p.getSalary() > 6000).forEach(System.out :: println);\r\n\r\n        System.out.println("***********************************************************************");\r\n\r\n        // 练习：截断流，使其元素不超过指定元素\r\n        persons.stream().limit(3).forEach(System.out :: println);\r\n\r\n        System.out.println("***********************************************************************");\r\n\r\n        // 练习：跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补\r\n        persons.stream().skip(3).forEach(System.out :: println);\r\n\r\n        System.out.println("***********************************************************************");\r\n\r\n        // 练习：筛选，通过流元素生成的hasCode()和equals()去除重复元素\r\n        persons.stream().distinct().forEach(System.out :: println);\r\n    }\r\n\r\n    @Test\r\n    public void test2() {\r\n        List<Person> persons = Person.getPersons();\r\n\r\n        // 练习：获取员工姓名长度大于3的人员的姓名\r\n        persons.stream().filter(e -> e.getName().length()>3).map(Person::getName).forEach(System.out :: println);\r\n    }\r\n\r\n    /**\r\n     * <R> Stream<R> map(Function f) 和\r\n     */\r\n    @Test\r\n    public void test2_1() {\r\n        List<String> list = Arrays.asList("aa", "bb", "cc", "dd");\r\n        Stream<Stream<Character>> stream1 = list.stream().map(StreamAPITest2::fromStringToStream);\r\n        stream1.forEach(s -> {\r\n            s.forEach(System.out :: println);\r\n        });\r\n\r\n        System.out.println("********************************************");\r\n\r\n        Stream<Character> stream2 = list.stream().flatMap(StreamAPITest2::fromStringToStream);\r\n        stream2.forEach(System.out :: println);\r\n\r\n    }\r\n\r\n    /**\r\n     * 将字符串str中的多个字符构成的集合转换为Stream实例。\r\n     *  即将字符串str转成Stream实例\r\n     * @param str\r\n     * @return\r\n     */\r\n    public static Stream<Character> fromStringToStream(String str) {\r\n        ArrayList<Character> list = new ArrayList<>();\r\n        for(Character c : str.toCharArray()) {\r\n            list.add(c);\r\n        }\r\n        return list.stream();\r\n    }\r\n\r\n    @Test\r\n    public void test3() {\r\n        // 练习：通过sorted()实现自然排序\r\n        List<Integer> list = Arrays.asList(12, 3, 99, 10, 78, 67, 88);\r\n        list.stream().sorted().forEach(System.out :: println);\r\n\r\n        System.out.println("***********************************************************************");\r\n        \r\n        // 练习：通过sorted(Comparator comparator)实现定制排序\r\n        List<Person> persons = Person.getPersons();\r\n        persons.stream().sorted(((o1, o2) -> {\r\n            int compare = Integer.compare(o1.getAge(), o2.getAge());\r\n            if (compare != 0) {\r\n                return compare;\r\n            } else {\r\n                return Double.compare(o1.getSalary(), o2.getSalary());\r\n            }\r\n        })).forEach(System.out :: println);\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"实体类："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * @Author tth\r\n * @Date 2023/1/3 15:05\r\n */\r\npublic class Person {\r\n    private String name;\r\n    private Integer age;\r\n    private Integer id;\r\n    private double salary;\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Person(String name, Integer age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public Person(Integer id, String name, Integer age, double salary) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.id = id;\r\n        this.salary = salary;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public double getSalary() {\r\n        return salary;\r\n    }\r\n\r\n    public void setSalary(double salary) {\r\n        this.salary = salary;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return "Person{" +\r\n                "name=\'" + name + \'\\\'\' +\r\n                ", age=" + age +\r\n                ", id=" + id +\r\n                ", salary=" + salary +\r\n                \'}\';\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Person person = (Person) o;\r\n        return Double.compare(person.salary, salary) == 0 &&\r\n                name.equals(person.name) &&\r\n                age.equals(person.age) &&\r\n                id.equals(person.id);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(name, age, id, salary);\r\n    }\r\n\r\n    public static List<Person> getPersons() {\r\n        return new ArrayList<Person>(){\r\n            { add(new Person(1001, "张1", 18, 5600)); }\r\n            { add(new Person(1002, "张2强", 17, 7200)); }\r\n            { add(new Person(1003, "张3", 16, 3400)); }\r\n            { add(new Person(1004, "张4凭栏", 20, 8900)); }\r\n            { add(new Person(1005, "张5", 19, 5400)); }\r\n            { add(new Person(1005, "张5", 19, 5400)); }\r\n            { add(new Person(1006, "张6阑珊", 18, 7400)); }\r\n            { add(new Person(1006, "张6", 18, 2100)); }\r\n        };\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"1675-stream的终止操作",children:["16.7.5 Stream的终止操作",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1675-stream的终止操作",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"匹配与查找"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"allMatch(Predicate p)"}),"\n",(0,s.jsx)(r.td,{children:"检查是否匹配所有元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"anyMatch(Predicate p)"}),"\n",(0,s.jsx)(r.td,{children:"检查是否至少匹配一个元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"noneMatch()"}),"\n",(0,s.jsx)(r.td,{children:"检查是否没有匹配所有元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"findFirst()"}),"\n",(0,s.jsx)(r.td,{children:"返回第一个元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"findAny()"}),"\n",(0,s.jsx)(r.td,{children:"返回当前流中任意元素"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"count()"}),"\n",(0,s.jsx)(r.td,{children:"返回流中元素总数"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"max(Comparator c)"}),"\n",(0,s.jsx)(r.td,{children:"返回流中最大值"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"min(Comparator c)"}),"\n",(0,s.jsx)(r.td,{children:"返回流中最小值"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"forEach(Consumer c)"}),"\n",(0,s.jsx)(r.td,{children:"内部迭代（使用Collection接口需要用户去做迭代的方法，称为外部迭代。相反Stream API使用内部迭代）"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"规约"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"reduce(T iden, BinaryOperator b)"}),"\n",(0,s.jsx)(r.td,{children:"可以将流中元素反复结合起来，得到一个值。参数iden表示初始值。返回值类型为T"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"reduce(BinaryOperator b)"}),"\n",(0,s.jsx)(r.td,{children:"可以将流中元素反复结合起来，得到一个值。返回值类型为Optional<T>"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名"}),"\n",(0,s.jsxs)(r.p,{children:["如计算",(0,s.jsx)(r.code,{children:"List<Employee>"}),"中员工工资的总和"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"收集"}),"\n"]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"collect(Collector c)"}),"\n",(0,s.jsx)(r.td,{children:"将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Collector"}),"接口中方法的实现决定了如何对流执行收集的操作（如收集到List、Set、Map）。另外",(0,s.jsx)(r.code,{children:"Collectors"}),"实用类提供了很多静态方法，可以便捷的创建常见收集器实例，常见方法如下："]}),"\n",(0,s.jsxs)(r.table,{children:["\n",(0,s.jsxs)(r.thead,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.th,{children:"方法"}),"\n",(0,s.jsx)(r.th,{children:"返回值类型"}),"\n",(0,s.jsx)(r.th,{children:"作用"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.tbody,{children:["\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"toList()"}),"\n",(0,s.jsx)(r.td,{children:"List<T>"}),"\n",(0,s.jsx)(r.td,{children:"把流中元素收集到List"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"toSet()"}),"\n",(0,s.jsx)(r.td,{children:"Set<T>"}),"\n",(0,s.jsx)(r.td,{children:"把流中元素收集到Set"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"toCollection(Supplier collectionFactory)"}),"\n",(0,s.jsx)(r.td,{children:"Collection<T>"}),"\n",(0,s.jsx)(r.td,{children:"把流中元素收集到创建的集合"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"counting()"}),"\n",(0,s.jsx)(r.td,{children:"Long"}),"\n",(0,s.jsx)(r.td,{children:"计算流中元素的个数"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"summingInt(ToIntFunction mapper)"}),"\n",(0,s.jsx)(r.td,{children:"Integer"}),"\n",(0,s.jsx)(r.td,{children:"对流中元素的整数属性求和"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"averagingInt(ToIntFunction  mapper)"}),"\n",(0,s.jsx)(r.td,{children:"Double"}),"\n",(0,s.jsx)(r.td,{children:"对流中元素的整数属性求平均值"}),"\n"]}),"\n",(0,s.jsxs)(r.tr,{children:["\n",(0,s.jsx)(r.td,{children:"summarizingInt(ToIntFunction  mapper)"}),"\n",(0,s.jsx)(r.td,{children:"IntSummaryStatistics"}),"\n",(0,s.jsx)(r.td,{children:"收集流中Integer属性的统计值，如平均值"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"举例"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"测试类："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'/**\r\n * 测试Stream的终止操作\r\n * @Author tth\r\n * @Date 2023/1/4 10:31\r\n */\r\npublic class StreamAPITest3 {\r\n\r\n    /**\r\n     * 匹配与查找\r\n     */\r\n    @Test\r\n    public void test1() {\r\n        List<Person> persons = Person.getPersons();\r\n\r\n        // 练习：判断是否所有人员的年龄都不小于16岁\r\n        boolean allMatch = persons.stream().allMatch(p -> p.getAge() >= 16);\r\n        System.out.println(allMatch);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：判断是否存在人员的工资大于10000\r\n        boolean anyMatch = persons.stream().anyMatch(p -> p.getSalary() > 10000);\r\n        System.out.println(anyMatch);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：判断是否存在人员姓“诸葛”\r\n        // noneMatch：检查是否没有匹配的元素。如果有姓“诸葛”的，返回false；否则返回true\r\n        boolean noneMatch = persons.stream().noneMatch(p -> p.getName().startsWith("诸葛"));\r\n        System.out.println(noneMatch);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：返回第一个人员信息\r\n        // Optional类是用来处理空指针类型的。后边讲\r\n        Optional<Person> first = persons.stream().findFirst();\r\n        System.out.println(first);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：随机返回一个人员信息\r\n        // 注意：使用findAny()时，在获取Stream实例的时候，最好用List.parallelStream()，才会随机返回一个。使用List.stream()只能返回第一个\r\n        Optional<Person> any2 = persons.parallelStream().findAny();\r\n        System.out.println(any2);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：求人员列表中年龄在18岁以下的人员的个数\r\n        long count = persons.stream().filter(person -> person.getAge() < 18).count();\r\n        System.out.println(count);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：返回最高的工资\r\n        Optional<Double> max = persons.stream().map(person -> person.getSalary()).max(Double::compareTo);\r\n        System.out.println(max);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：返回最低工资的员工\r\n        Optional<Person> minSalaryPerson = persons.stream().min((p1, p2) -> Double.compare(p1.getSalary(), p2.getSalary()));\r\n        System.out.println(minSalaryPerson);\r\n\r\n        System.out.println("**************************************************************************");\r\n\r\n        // 练习：内部迭代\r\n        persons.stream().forEach(System.out :: println);\r\n    }\r\n\r\n    /**\r\n     * 规约\r\n     */\r\n    @Test\r\n    public void test2() {\r\n        // 练习1：计算1-10的自然数的值\r\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\r\n        Integer sum = list.stream().reduce(0, Integer::sum);\r\n        System.out.println(sum);\r\n\r\n        // 练习2：计算人员工资的总和\r\n        List<Person> persons = Person.getPersons();\r\n        Optional<Double> reduce = persons.stream().map(person -> person.getSalary()).reduce(Double::sum);\r\n        // 如果不知道Double.sum(double a, double b)方法，可以使用如下方法计算总和\r\n//        Optional<Double> reduce2 = persons.stream().map(person -> person.getSalary()).reduce((d1, d2) -> d1 + d2);\r\n        System.out.println(reduce);\r\n    }\r\n\r\n    /**\r\n     * 收集\r\n     */\r\n    @Test\r\n    public void test3() {\r\n        List<Person> persons = Person.getPersons();\r\n        // 练习： 查找工资大于6000的人员，结果返回一个List\r\n        List<Person> collect = persons.stream().filter(person -> person.getSalary() > 6000).collect(Collectors.toList());\r\n        System.out.println(collect);\r\n\r\n        System.out.println();\r\n\r\n        // 练习：查找工资大于6000的人员，结果返回一个Set\r\n        Set<Person> collect1 = persons.stream().filter(person -> person.getSalary() > 6000).collect(Collectors.toSet());\r\n        System.out.println(collect1);\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"实体类"}),"\n",(0,s.jsxs)(r.p,{children:["见",(0,s.jsx)(r.a,{href:"/tang/java/java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/16_Java8%E6%96%B0%E7%89%B9%E6%80%A7.html#_16-7-4-stream%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C",children:"16.7.4 中间操作"}),"中的实体类。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"168-optional类",children:["16.8 Optional类",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#168-optional类",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"概述"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Optional<T>"}),"类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。\r\n原来用null表示一个值不存在，现在Optional可以更好的表达这个概念，并且","可以避免空指针异常","。Optional中提供了很多方法，这样就不用显示进行空值j检测"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"Optional相关方法"}),"\n"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["创建Optional类对象","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Optional.of(T t)"}),"：创建一个Optional实例，t必须非空"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Optional.empty()"}),"：创建一个空的Optional实例"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Optional.ofNullable(T t)"}),"：t可以为空"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["判断Optional容器中是否包含对象","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"boolean isPresent()"}),"：判断是否包含对象"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"void ifPresent(Consumer c)"}),"：如果有值，就执行Consumer接口的实例代码，并且该值会作为参数传给它"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["获取Optional容器的对象","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"T get()"}),"：如果调用对象包含值，返回该值，否则抛异常"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"T orElse(T other)"}),"：如果有值将其返回，否则返回指定的other对象"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"T orElseGet(Supplier s)"}),"：如果有值将其返回，否则抛出由Supplier接口提供的异常"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"举例：Optional是如何避免空指针的"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"重要方法："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Optional<T> ofNullable(T value)"}),"：获取Optional实例"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"T orElse(T other)"}),"：或uOptiona实例的对象"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:'@Test\r\npublic void test2() {\r\n    Boy boy = null;\r\n    String girName = getGirName(boy);\r\n    System.out.println(girName);\r\n}\r\n\r\n/**\r\n * 返回boy中girl对象的名字\r\n *  Optional<T> ofNullable(T value) 与 T orElse(T other)的使用\r\n * @param boy\r\n * @return\r\n */\r\npublic String getGirName(Boy boy) {\r\n    // 如果使用下面语句，当boy为空或者boy中girl的属性为空时，都会报空指针异常\r\n    // return boy.getGirl().getName();\r\n\r\n    // 使用Optional避免空指针异常\r\n    Optional<Boy> boyOptional = Optional.ofNullable(boy);\r\n    // 此时boy1一定非空，且boy1中的girl也一定非空\r\n    Boy boy1 = boyOptional.orElse(new Boy(new Girl("迪丽热巴")));\r\n    return boy1.getGirl().getName();\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"169-try语句的优化",children:["16.9 try语句的优化",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#169-try语句的优化",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["Java8中可以实现","资源的自动关闭","，","要求执行后要关闭的资源必须在try的一对小括号中初始化","，否则编译不通过。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-java",children:"@Test\r\npublic void test2() {\r\n    // java8之前的写法\r\n    //        InputStreamReader reader = null;\r\n    //        try {\r\n    //            reader = new InputStreamReader(System.in);\r\n    //            char[] buff = new char[1024];\r\n    //            int len;\r\n    //            while ((len = reader.read(buff)) != -1) {\r\n    //                String str = new String(buff, 0, len);\r\n    //                System.out.println(str);\r\n    //            }\r\n    //        } catch (IOException e) {\r\n    //            e.printStackTrace();\r\n    //        } finally {\r\n    //            if (null != reader) {\r\n    //                try {\r\n    //                    reader.close();\r\n    //                } catch (IOException e) {\r\n    //                    e.printStackTrace();\r\n    //                }\r\n    //            }\r\n    //        }\r\n\r\n    // java8写法：资源的实例化必须写在try的()中\r\n    try(InputStreamReader reader = new InputStreamReader(System.in)) {\r\n        char[] buff = new char[1024];\r\n        int len;\r\n        while ((len = reader.read(buff)) != -1) {\r\n            String str = new String(buff, 0, len);\r\n            System.out.println(str);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"1610-其他新特性",children:["16.10 其他新特性",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1610-其他新特性",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"通用目标类型推断"}),"\n",(0,s.jsxs)(r.li,{children:["JDK的更新：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"集合的流式操作"}),"\n",(0,s.jsx)(r.li,{children:"并发"}),"\n",(0,s.jsx)(r.li,{children:"Arrays"}),"\n",(0,s.jsx)(r.li,{children:"Number和Math"}),"\n",(0,s.jsx)(r.li,{children:"IO/NIO的改进"}),"\n",(0,s.jsx)(r.li,{children:"Reflection获取形参名"}),"\n",(0,s.jsx)(r.li,{children:"String：join()"}),"\n",(0,s.jsx)(r.li,{children:"Files"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["新编译工具：","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"jjs"}),"\n",(0,s.jsx)(r.li,{children:"jdeps"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.li,{children:"JVM中Metaspace取代PermGen空间"}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),n.components);return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["tang%2Fjava2%2F16_Java8%E6%96%B0%E7%89%B9%E6%80%A7.md"]={toc:[{text:"16.1 接口新特性",id:"161-接口新特性",depth:2},{text:"16.2 新的日期时间API",id:"162-新的日期时间api",depth:2},{text:"16.3 注解新特性",id:"163-注解新特性",depth:2},{text:"16.4 Lambda表达式",id:"164-lambda表达式",depth:2},{text:"16.5 函数式(Functional)接口",id:"165-函数式functional接口",depth:2},{text:"16.6 方法引用与构造器引用",id:"166-方法引用与构造器引用",depth:2},{text:"16.6.1 方法引用",id:"1661-方法引用",depth:3},{text:"16.6.2 构造器引用",id:"1662-构造器引用",depth:3},{text:"16.6.3 数组引用",id:"1663-数组引用",depth:3},{text:"16.7 Stream API",id:"167-stream-api",depth:2},{text:"16.7.1 概述",id:"1671-概述",depth:3},{text:"16.7.2 Stream的操作三个步骤",id:"1672-stream的操作三个步骤",depth:3},{text:"16.7.3 Stream的实例化",id:"1673-stream的实例化",depth:3},{text:"16.7.4 Stream的中间操作",id:"1674-stream的中间操作",depth:3},{text:"16.7.5 Stream的终止操作",id:"1675-stream的终止操作",depth:3},{text:"16.8 Optional类",id:"168-optional类",depth:2},{text:"16.9 try语句的优化",id:"169-try语句的优化",depth:2},{text:"16.10 其他新特性",id:"1610-其他新特性",depth:2}],title:"16 Java8新特性",frontmatter:{}}}}]);