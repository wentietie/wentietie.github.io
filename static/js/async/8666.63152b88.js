"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["8666"],{7842:function(n,r,e){e.r(r),e.d(r,{default:()=>t});var i=e("85893"),s=e("50065");let l=e.p+"static/image/03_img4.9f4b5eeb.png",d=e.p+"static/image/03_img3.0747de59.png",h=e.p+"static/image/03_img5.e33ca47a.png";function c(n){let r=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",img:"img",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"3-java数组",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3-java数组",children:"#"}),"3 Java数组"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"数组的特点"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"有序性"}),"\n",(0,i.jsx)(r.li,{children:"存储空间连续"}),"\n",(0,i.jsx)(r.li,{children:"数组是引用类型变量"}),"\n",(0,i.jsx)(r.li,{children:"长度固定，不可更改，一旦初始化完成，数组长度就确定了"}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"31-一维数组",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#31-一维数组",children:"#"}),"3.1 一维数组"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"声明和初始化"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"静态初始化：数组的声明赋值操作同时进行"}),"\n",(0,i.jsx)(r.li,{children:"动态初始化：先声明，再进行赋值操作"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:'// 静态初始化\r\nString[] names = new String[]{"tom", "jan","steve"};\r\n// 其他正确写法\r\nString names2[] = new String[]{"tom", "jan","steve"};\r\nString[] names3 = {"tom", "jan","steve"};\r\n\r\n// 动态初始化\r\nint[] ages = new int[3];\r\nages[0] = 15;\r\nages[1] = 16;\r\nages[2] = 15;\n'})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"获取数组长度"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:'String[] names = new String[]{"tom", "jan","steve"};\r\nSystem.out.println(names.length); // 3\n'})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"数组的初始化值"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"数组元素是整型（byte、short、int、long）：0"}),"\n",(0,i.jsx)(r.li,{children:"数组元素是浮点型（float、double）：0.0"}),"\n",(0,i.jsxs)(r.li,{children:["数组元素是char型","：0或'\\u0000'，而非'0'"]}),"\n",(0,i.jsx)(r.li,{children:"数组元素是boolean型：false"}),"\n",(0,i.jsx)(r.li,{children:"数组元素为引用类型：null"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"关于数组的打印"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"打印char类型的数组变量："}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"char[] c = new char[]{'a', 'b', 'c'}; System.out.println(c)"}),"，结果输出为",(0,i.jsx)(r.code,{children:"abc"})]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"打印非char类型的数组变量："}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"int[] i = new int[]{1, 2, 3}; System.out.println(c)"}),"，结果输出为",(0,i.jsx)(r.code,{children:"地址值"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"println方法有个专门针对参数是char类型数组的重载。"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:l})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"内存解析"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"内存简化结构"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:l})}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"一维数组内存举例说明"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:d})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"32-多维数组",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#32-多维数组",children:"#"}),"3.2 多维数组"]}),"\n",(0,i.jsx)(r.p,{children:"以二维数组为例"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"理解"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["可以看成是一维数组array1又作为另外一个一维数组array2的元素而存在。","其实，从数组底层的运行机制来看，没有多维数组。"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"初始化"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"静态初始化"}),"\n",(0,i.jsx)(r.li,{children:"动态初始化"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:"// 静态初始化\r\nint[][] arr1 = new int[][]{{1,2,3},{4,5},{8,9,10}};\r\n// 其他正确写法\r\nint arr2[][] = new int[][]{{1,2,3},{4,5},{8,9,10}};\r\nint[] arr3[] = new int[][]{{1,2,3},{4,5},{8,9,10}};\r\nint[][] arr4 = {{1,2,3},{4,5},{8,9,10}};\r\n\r\n// 动态初始化\r\nString[][] arr5 = new String[3][2];//3行2列\r\nString[][] arr6 = new String[3][];\n"})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"获取指定位置的元素"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:"int[][] arr1 = new int[][]{{1,2,3},{4,5},{8,9,10}};\r\nSystem.out.println(arr1[0][1]); //输出2\n"})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"获取数组的长度"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:"int[][] arr1 = new int[][]{{1,2,3},{4,5},{8,9,10}};\r\nSystem.out.println(arr1.length); //输出3\n"})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"初始化值"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:"int[][] arr1 = new int[4][5];\r\nSystem.out.println(arr1[0]);//地址值\r\nSystem.out.println(arr1[1][1]);//0\r\n\r\nint[][] arr2 = new int[4][];\r\nSystem.out.println(arr2[0]);//null\r\nSystem.out.println(arr2[1][1]);//空指针异常\r\n\n"})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"内存解析"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:h})}),"\n",(0,i.jsxs)(r.h2,{id:"33-数组的常见算法",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#33-数组的常见算法",children:"#"}),"3.3 数组的常见算法"]}),"\n",(0,i.jsxs)(r.h3,{id:"331-复制",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#331-复制",children:"#"}),"3.3.1 复制"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:"int[] arr1 = {2,3,5,7,11};\r\nint[] arr2 = arr1; //这里只是地址值的赋值，arr2和arr1指向同一个地址\r\n// 数组的复制\r\nint[] arr3 = new int[arr1.length];\r\nfor(int i = 0; i < arr3.length; i++) {\r\n    arr3[i] = arr1[i];\r\n}\n"})}),"\n",(0,i.jsxs)(r.h3,{id:"332-反转",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#332-反转",children:"#"}),"3.3.2 反转"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:'/**\r\n* 数组反转 方法一\r\n*/\r\nprivate void reverse1() {\r\n    int[] arr1 = {2,3,5,7,11,13,17,19};\r\n    for (int i = 0; i < arr1.length / 2; i++) {\r\n        int temp = arr1[i];\r\n        arr1[i] = arr1[arr1.length - 1 - i];\r\n        arr1[arr1.length - 1 - i] = temp;\r\n    }\r\n    for (int i = 0; i < arr1.length; i++) {\r\n        System.out.print(arr1[i] + "\\t");\r\n    }\r\n}\r\n\r\n/**\r\n * 数组反转 方法二\r\n */\r\nprivate void reverse2() {\r\n    int[] arr1 = {2,3,5,7,11,13,17,19};\r\n    for (int i = 0, j = arr1.length - 1; i < j; i++, j--) {\r\n        int temp = arr1[i];\r\n        arr1[i] = arr1[j];\r\n        arr1[j] = temp;\r\n    }\r\n    for (int i = 0; i < arr1.length; i++) {\r\n        System.out.print(arr1[i] + "\\t");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(r.h3,{id:"333-线性查找",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#333-线性查找",children:"#"}),"3.3.3 线性查找"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"理解"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"从前往后依次查找。"}),"\n",(0,i.jsxs)(r.h3,{id:"334-二分法查找",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#334-二分法查找",children:"#"}),"3.3.4 二分法查找"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"前提"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"数组是按照由小到大或者由大到小的顺序存储的。"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:'/**\r\n* 二分查找\r\n* 本题中数组按由小到大的顺序进行存储\r\n*/\r\nprivate static void findWithBinary() {\r\n    int[] arr1 = {2,3,5,7,11,13,17,19};\r\n    int dest = 13;\r\n    boolean flag = false;\r\n    int head = 0, end = arr1.length - 1;\r\n\r\n    while (head <= end) {\r\n        int middle = (end + head) / 2;\r\n        if(arr1[middle] == dest) {\r\n            System.out.println("找到了指定元素，下标为："+middle);\r\n            flag =  true;\r\n            break;\r\n        } else if (arr1[middle] > dest) {\r\n            end = middle - 1;\r\n        } else {\r\n            head = middle + 1;\r\n        }\r\n    }\r\n\r\n    if (!flag) {\r\n        System.out.println("很遗憾，指定元素不存在哦");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(r.h3,{id:"335-排序算法概述",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#335-排序算法概述",children:"#"}),"3.3.5 排序算法概述"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"衡量排序算法的优劣"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["时间复杂度","：分析关键字的比较次数和记录的移动次数"]}),"\n",(0,i.jsxs)(r.li,{children:["空间复杂度","：分析算法中需要多少辅助内存"]}),"\n",(0,i.jsxs)(r.li,{children:["稳定性","：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种算法是稳定的"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"排序算法分类"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["内部排序","：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。"]}),"\n",(0,i.jsxs)(r.li,{children:["外部排序","：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器（如磁盘）等。外部排序最常见的算法有","多路归并排序","。可以认为外部排序是由多次内部排序组成的。"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"十大排序算法"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"选择排序"}),"\n",(0,i.jsx)(r.p,{children:"将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"简单选择排序"}),"\n",(0,i.jsx)(r.li,{children:"堆排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"交换排序"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"冒泡排序"}),"\n",(0,i.jsx)(r.li,{children:"快速排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"插入排序"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"直接插入排序"}),"\n",(0,i.jsx)(r.li,{children:"折半插入排序"}),"\n",(0,i.jsx)(r.li,{children:"希尔排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"归并排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"桶式排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"基数排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"算法5大特性"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["输入","：有0个或多个输入数据，这些输入必须有清楚的描述和定义"]}),"\n",(0,i.jsxs)(r.li,{children:["输出","：至少有1个或多个输出结果，不可以没有输出"]}),"\n",(0,i.jsxs)(r.li,{children:["有穷性（有限性）","：算法可以在有限的步骤之后会自动结束而不是无线循环，并且每一个步骤可以在可接受的时间内完成"]}),"\n",(0,i.jsxs)(r.li,{children:["确定性（明确性）","：算法中的每一步都有确定的含义，不会出现二义性"]}),"\n",(0,i.jsxs)(r.li,{children:["可行性（有效性）","：算法的每一步骤都是清楚且可行的，能让用户用纸笔计算而求出答案"]}),"\n"]}),"\n",(0,i.jsxs)(r.h3,{id:"336-简单选择排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#336-简单选择排序",children:"#"}),"3.3.6 简单选择排序"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"基本过程"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"在一组元素R[i]到R[n]中选择最小的元素"}),"\n",(0,i.jsx)(r.li,{children:"如果他不是这组元素中的第一个元素，则将其与该组元素中的第一个元素交换"}),"\n",(0,i.jsx)(r.li,{children:"除去具有最小关键字的元素，在剩下的元素中重复以上两步骤，直到元素只有一个为止"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["比较次数","：$(n-1)+(n-2)+...+2+1=n(n-1)/2$"]}),"\n",(0,i.jsx)(r.p,{children:"无论初始状况如何，在第i趟排序中选择最小元素的时候，都需要做$(n-i)$次比较"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["交换次数","："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最好情况：0次"}),"\n",(0,i.jsx)(r.p,{children:"序列恰好为正序时，需要交换0次"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最差情况：${(n-1)}$次"}),"\n",(0,i.jsx)(r.p,{children:"如将数组[${5,1,2,3,4}$]按照有小到大的顺序排列，需要移动4次"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["综上，简单选择排序的","时间复杂度为$O(n^{2})$"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"稳定性"}),"\n"]}),"\n","\n",(0,i.jsx)(r.p,{children:"由于在直接选择排序中存在不相邻元素的交换，因此它是一个不稳定的排序方法。"}),"\n",(0,i.jsx)(r.p,{children:"比如给定数组[$3,7,3',2,1$]，按照有小到大的顺序排列后的结果为[$1,2,3',3,7$]"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"示例代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:'int[] arr = {49,38,65,97,76,13,24,49};\r\n// 开始排序\r\n// 说明1：循环条件是 i < arr.length - 1，而不是i < arr.length的原因：最后一个数无需和自身进行比较、交换\r\nfor (int i = 0; i < arr.length - 1; i++) {\r\n    int index = i; // 记录最小值的下标\r\n    // 循环找到数组中的最小值对应的下标\r\n    for (int j = i + 1; j < arr.length; j++) {\r\n        if (arr[index] > arr[j]) {\r\n            index = j;\r\n        }\r\n    }\r\n    // 将最小值和无序数组中的第一个元素进行交换（当最小值下标和当前下标不相等的时候再交换）\r\n    if (i != index) {\r\n        int temp = arr[i];\r\n    	arr[i] = arr[index];\r\n    	arr[index] = temp;\r\n    }\r\n}\r\n// 排序完成\r\n// 打印\r\nfor (int i = 0; i < arr.length; i++) {\r\n    System.out.print(arr[i]+"\\t");\r\n}\n'})}),"\n",(0,i.jsxs)(r.h3,{id:"337-堆排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#337-堆排序",children:"#"}),"3.3.7 堆排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"338-冒泡排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#338-冒泡排序",children:"#"}),"3.3.8 冒泡排序"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"基本思想"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"对待排序序列从前往后，依次比较相邻元素排序码，如果逆序则交换，使排序码较大的元素逐渐从前往后移动。"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["比较次数","："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最好情况：$n-1$次"}),"\n",(0,i.jsx)(r.p,{children:"此时待排序序列恰好是按照要求的顺序进行排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$次"}),"\n",(0,i.jsx)(r.p,{children:"此时待排序序列恰好是按照要求的顺序的逆序进行排序"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["交换次数","："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最好情况：0次"}),"\n",(0,i.jsx)(r.p,{children:"此时待排序序列恰好是按照要求的顺序进行排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"稳定性"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"示例代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",meta:"",children:'int[] arr = {49,38,65,97,76,13,27,49};\r\n// 开始排序\r\n// 说明1：循环条件是 i < arr.length - 1，而不是i < arr.length的原因：最后一个数无需和自身进行比较、交换\r\nfor (int i = 0; i < arr.length - 1; i++) {\r\n    // 说明2：循环条件是arr.length - 1 - i的原因：每完成一次排序，最后（i+1）个数都已完成排序，不需要再进行比较、交换\r\n    for (int j = 0; j < arr.length - i - 1; j++) {\r\n        if (arr[j] > arr[j+1]) {\r\n            int temp = arr[j];\r\n            arr[j] = arr[j+1];\r\n            arr[j+1] = temp;\r\n        }\r\n    }\r\n}\r\n// 排序完成\r\n// 打印\r\nfor (int i = 0; i < arr.length; i++) {\r\n    System.out.print(arr[i]+"\\t");\r\n}\n'})}),"\n",(0,i.jsxs)(r.h3,{id:"339-快速排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#339-快速排序",children:"#"}),"3.3.9 快速排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"3310-插入排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3310-插入排序",children:"#"}),"3.3.10 插入排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"33101-直接插入排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#33101-直接插入排序",children:"#"}),"3.3.10.1 直接插入排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"33102-折半插入排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#33102-折半插入排序",children:"#"}),"3.3.10.2 折半插入排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"3312-希尔排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3312-希尔排序",children:"#"}),"3.3.12 希尔排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"3313-归并排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3313-归并排序",children:"#"}),"3.3.13 归并排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"3314-桶式排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3314-桶式排序",children:"#"}),"3.3.14 桶式排序"]}),"\n",(0,i.jsxs)(r.h3,{id:"3315-基数排序",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3315-基数排序",children:"#"}),"3.3.15 基数排序"]}),"\n",(0,i.jsxs)(r.h2,{id:"34-arrays工具类的使用",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#34-arrays工具类的使用",children:"#"}),"3.4 Arrays工具类的使用"]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"方法"}),(0,i.jsx)(r.th,{children:"作用"}),(0,i.jsx)(r.th,{children:"备注"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrays.equals(Object[] a, Object[] a2)"}),(0,i.jsx)(r.td,{children:"判读两个数组中的元素是否全相等"}),(0,i.jsx)(r.td,{children:"全相等，返回true"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrays.toString(Object[] a)"}),(0,i.jsx)(r.td,{children:"获取数组中的元素信息"}),(0,i.jsx)(r.td,{children:'数组元素之间用","分隔，用"[]"包裹'})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrays.fill(Object[] a, Object val)"}),(0,i.jsx)(r.td,{children:"将指定数值（val）填充到数组中"}),(0,i.jsx)(r.td,{children:"无返回值"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrays.sort(Object[] a)"}),(0,i.jsx)(r.td,{children:"对数组进行正序排序"}),(0,i.jsx)(r.td,{children:"排序完成后，原数组发生改变"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrays.sort(Object[] a, Comparator<? super T> c)"}),(0,i.jsx)(r.td,{children:"对数组排序，顺序由Comparator构造函数决定"}),(0,i.jsx)(r.td,{children:"基本数据类型不可使用该方法，但对应的封装类型可使用"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrays.binarySearch(int[] a, int key)"}),(0,i.jsx)(r.td,{children:"对排序后的数组进行二分法查找"}),(0,i.jsx)(r.td,{children:"数组必须是已排序好的；返回值小于0表示未找到"})]})]})]}),"\n",(0,i.jsxs)(r.h2,{id:"35-数组中的常见异常",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#35-数组中的常见异常",children:"#"}),"3.5 数组中的常见异常"]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"异常"}),(0,i.jsx)(r.th,{children:"描述"}),(0,i.jsx)(r.th,{children:"备注"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"ArrayIndexOutOfBoundsException"}),(0,i.jsx)(r.td,{children:"数组下标越界异常"}),(0,i.jsx)(r.td,{children:"下标小于0也叫数组下标越界"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"NullPointerException"}),(0,i.jsx)(r.td,{children:"空指针异常"}),(0,i.jsxs)(r.td,{children:["// 情况一：","int[] arr4 = {49,38,65,97,76,13,27,49};"," arr4 = null;"," System.out.println(arr4[1]); // 空指针异常","// 情况二：","int[][] arr = new int[4][]; ","System.out.println(arr[0][0]);// 空指针异常"]})]})]})]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),n.components);return r?(0,i.jsx)(r,Object.assign({},n,{children:(0,i.jsx)(c,n)})):c(n)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["tang%2Fjava2%2F03_Java%E6%95%B0%E7%BB%84.md"]={toc:[{id:"31-一维数组",text:"3.1 一维数组",depth:2},{id:"32-多维数组",text:"3.2 多维数组",depth:2},{id:"33-数组的常见算法",text:"3.3 数组的常见算法",depth:2},{id:"331-复制",text:"3.3.1 复制",depth:3},{id:"332-反转",text:"3.3.2 反转",depth:3},{id:"333-线性查找",text:"3.3.3 线性查找",depth:3},{id:"334-二分法查找",text:"3.3.4 二分法查找",depth:3},{id:"335-排序算法概述",text:"3.3.5 排序算法概述",depth:3},{id:"336-简单选择排序",text:"3.3.6 简单选择排序",depth:3},{id:"337-堆排序",text:"3.3.7 堆排序",depth:3},{id:"338-冒泡排序",text:"3.3.8 冒泡排序",depth:3},{id:"339-快速排序",text:"3.3.9 快速排序",depth:3},{id:"3310-插入排序",text:"3.3.10 插入排序",depth:3},{id:"33101-直接插入排序",text:"3.3.10.1 直接插入排序",depth:3},{id:"33102-折半插入排序",text:"3.3.10.2 折半插入排序",depth:3},{id:"3312-希尔排序",text:"3.3.12 希尔排序",depth:3},{id:"3313-归并排序",text:"3.3.13 归并排序",depth:3},{id:"3314-桶式排序",text:"3.3.14 桶式排序",depth:3},{id:"3315-基数排序",text:"3.3.15 基数排序",depth:3},{id:"34-arrays工具类的使用",text:"3.4 Arrays工具类的使用",depth:2},{id:"35-数组中的常见异常",text:"3.5 数组中的常见异常",depth:2}],title:"3 Java数组",headingTitle:"3 Java数组",frontmatter:{}}}}]);