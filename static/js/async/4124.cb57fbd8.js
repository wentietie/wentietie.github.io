"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["4124"],{41111:function(n,e,i){i.r(e),i.d(e,{default:()=>t});var s=i("85893"),r=i("50065");let l=i.p+"static/image/04_img2.15cabc3e.png",d=i.p+"static/image/04_img3.83d7d626.png",h=i.p+"static/image/04_img1.e26ed7ab.png";function c(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",img:"img",pre:"pre",code:"code",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",strong:"strong"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"4-面向对象编程上",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-面向对象编程上",children:"#"}),"4 面向对象编程（上）"]}),"\n",(0,s.jsxs)(e.h2,{id:"41-面向过程与面向对象",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#41-面向过程与面向对象",children:"#"}),"4.1 面向过程与面向对象"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"面向过程POP与面向对象OOP"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。"}),"\n",(0,s.jsx)(e.li,{children:"面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"面向对象三大特征"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"继承"}),"\n",(0,s.jsx)(e.li,{children:"封装"}),"\n",(0,s.jsx)(e.li,{children:"多态"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"42-内存解析",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#42-内存解析",children:"#"}),"4.2 内存解析"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:l})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["堆","：存放","对象实例"]}),"\n",(0,s.jsx)(e.p,{children:"所有的对象实例和数组都要在堆上分配（Java虚拟机规范中如此描述）"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["栈","：存放","局部变量","等。"]}),"\n",(0,s.jsx)(e.p,{children:"局部变量表存放了编译期可知长度的各种基本数据类型、对象引用类型（reference类型，值为对象在堆内的首地址）。方法执行完，自动释放。"}),"\n",(0,s.jsx)(e.p,{children:"通常所说的栈，是指虚拟机栈。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["方法区","：存放","已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码","等数据"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"43-属性和局部变量的对比",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#43-属性和局部变量的对比",children:"#"}),"4.3 属性和局部变量的对比"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"相同点"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"定义变量的格式相同：数据类型 变量名 = 变量值"}),"\n",(0,s.jsx)(e.li,{children:"都是先声明，后使用"}),"\n",(0,s.jsx)(e.li,{children:"变量都有其对应的作用域"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"不同点"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["在类中声明的位置不同","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"属性：直接定义在类的一对{}中"}),"\n",(0,s.jsx)(e.li,{children:"局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["关于权限修饰符的不同","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"属性：可以在声明属性时，指明其权限"}),"\n",(0,s.jsx)(e.li,{children:"局部变量：不可以使用权限修饰符"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["默认初始化值的问题","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["属性：类的属性，根据其类型，都有默认初始化值","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"整型（byte、short、int、long）：0"}),"\n",(0,s.jsx)(e.li,{children:"浮点型（float、double）：0.0"}),"\n",(0,s.jsx)(e.li,{children:"字符型（char）：0 或 '\\u0000'"}),"\n",(0,s.jsx)(e.li,{children:"布尔型（boolean）：false"}),"\n",(0,s.jsx)(e.li,{children:"引用数据类型：null"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"局部变量：没有初始化值"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["非static的变量/属性在内存中加载的位置不同","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"属性：存放在堆中"}),"\n",(0,s.jsx)(e.li,{children:"变量：存放在栈空间中"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"44-匿名对象",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#44-匿名对象",children:"#"}),"4.4 匿名对象"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"理解"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"new出来的对象没有显示的赋值给一个变量。如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'new Phone().sendEmail("我是通过匿名对象调用的");\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"特点"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"匿名对象只能使用一次。"}),"\n",(0,s.jsxs)(e.h2,{id:"45-方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#45-方法",children:"#"}),"4.5 方法"]}),"\n",(0,s.jsxs)(e.h3,{id:"451-方法的重载",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#451-方法的重载",children:"#"}),"4.5.1 方法的重载"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"同一个类中，允许有一个以上的同名方法，只要它们的参数类型或者参数个数不同即可。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:"class Test {\r\n    private void getSum(int i, int j){...}\r\n    private void getSum(int i, String s) {...}\r\n    private void getSum(String s, int i) {...}\r\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"452-可变个数的形参",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#452-可变个数的形参",children:"#"}),"4.5.2 可变个数的形参"]}),"\n","\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"具体使用"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["可变个数形参的格式： ",(0,s.jsx)(e.code,{children:"数据类型 ... 变量名"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"当调用可变个数形参的方法时，传入的参数个数可以是0个，1个，2个，..."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'public class Partise {\r\n\r\n    public static void main(String[] args) {\r\n        Partise partise = new Partise();\r\n        partise.show("hello"); // 输出show(String)。如果注释了show(String)方法，也不会报错，会去调用show(String ... strs)方法\r\n        partise.show("hello", "world"); // 输出show(String ... strs)\r\n        partise.show(); // 输出show(String ... strs)\r\n    }\r\n\r\n    public void show(String s) {\r\n        System.out.println("show(String)");\r\n    }\r\n\r\n    public void show(String ... strs) {\r\n        System.out.println("show(String ... strs)");\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"说明"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"可变个数形参的方法与本类中方法名相同、形参不同的方法之间构成重载。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"可变个数形参的方法与本类中方法名相同、形参类型也相同的数组之间不构成重载，二者不能共存。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:d})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["可变个数形参的方法中，","可变形参必须声明在末尾，且最多只能声明一个可变形参"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"453-方法形参的传递机制",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#453-方法形参的传递机制",children:"#"}),"4.5.3 方法形参的传递机制"]}),"\n","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["如果参数是","基本数据类型","，实参传递给形参的是实参的真实存储的","数据值","。"]}),"\n",(0,s.jsxs)(e.li,{children:["如果参数是","引用数据类型","，实参传递给形参的是实参存储数据的","地址值","（包含变量的数据类型）。"]}),"\n"]}),"\n","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'public class Practise {\r\n\r\n    public static void main(String[] args) {\r\n        Practise p = new Practise();\r\n        p.first();\r\n    }\r\n\r\n    public void first() {\r\n        int i = 5;\r\n        Value v  = new Value();\r\n        v.i = 25;\r\n        second(v, i);\r\n        System.out.println(v.i + " " +i); // 输出 20 5\r\n    }\r\n\r\n    public void second(Value v, int i) {\r\n        i = 0;\r\n        v.i = 20;\r\n        Value val = new Value();\r\n        v = val;\r\n        System.out.println(v.i + " " +i); // 输出 15 0\r\n    }\r\n\r\n    class Value {\r\n        int i = 15;\r\n    }\r\n    \r\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"454-递归方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#454-递归方法",children:"#"}),"4.5.4 递归方法"]}),"\n",(0,s.jsxs)(e.h2,{id:"46-oop特征一封装",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#46-oop特征一封装",children:"#"}),"4.6 OOP特征一：封装"]}),"\n",(0,s.jsxs)(e.h3,{id:"461-封装性的体现",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#461-封装性的体现",children:"#"}),"4.6.1 封装性的体现"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"属性私有化，同时提供公共的方法来获取和设置属性"}),"\n",(0,s.jsx)(e.li,{children:"不对外暴露私有方法"}),"\n",(0,s.jsx)(e.li,{children:"单例模式"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"462-权限修饰符",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#462-权限修饰符",children:"#"}),"4.6.2 权限修饰符"]}),"\n","\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"权限修饰符及其访问权限"}),"\n"]}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"修饰符"}),(0,s.jsx)(e.th,{children:"类内部"}),(0,s.jsx)(e.th,{children:"同一个包"}),(0,s.jsx)(e.th,{children:"不同包的子类"}),(0,s.jsx)(e.th,{children:"同一个工程"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"private"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{}),(0,s.jsx)(e.td,{}),(0,s.jsx)(e.td,{})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"（缺省）"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{}),(0,s.jsx)(e.td,{})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"protected"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"public"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{children:"✔"}),(0,s.jsx)(e.td,{children:"✔"})]})]})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"特别说明"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["class（外部类）的权限修饰符只可以用public和缺省","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"public类可以在任意地方被访问"}),"\n",(0,s.jsx)(e.li,{children:"缺省类只可以被同一个包内部的类访问"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"47-构造器",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#47-构造器",children:"#"}),"4.7 构造器"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"特点"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"名称和类相同"}),"\n",(0,s.jsx)(e.li,{children:"不声明返回值"}),"\n",(0,s.jsx)(e.li,{children:"不能被static、final、synchronized、abstract、native修饰"}),"\n",(0,s.jsx)(e.li,{children:"不能有return语句"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"说明"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"如果没有显示的定义，系统默认提供一个无参构造器（默认构造器的权限和类保持一致）"}),"\n",(0,s.jsxs)(e.li,{children:["语法：",(0,s.jsx)(e.code,{children:"权限修饰符 类名(形参列表){}"})]}),"\n",(0,s.jsx)(e.li,{children:"一个类中定义的多个构造器，彼此构成重载"}),"\n",(0,s.jsx)(e.li,{children:"一旦显示的定义了类的构造器没系统就不会再提供默认的构造器"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"作用"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"创建对象"}),"\n",(0,s.jsx)(e.li,{children:"给对象进行初始化"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"属性赋值的顺序"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"默认初始化 -> 显示初始化 -> 构造器中赋值 -> 通过“对象.方法”或“对象.属性”的方式赋值"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"通过this调用构造器"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["使用",(0,s.jsx)(e.code,{children:"this(形参列表)"}),"方式，调用本类中指定的其他构造器"]}),"\n",(0,s.jsxs)(e.li,{children:["构造器中不能通过",(0,s.jsx)(e.code,{children:"this(形参列表)"}),"方式调用自己"]}),"\n",(0,s.jsxs)(e.li,{children:["如果一个类中有n个构造器，则最多有n-1个构造器使用了",(0,s.jsx)(e.code,{children:"this(形参列表)"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"this(形参列表)"}),"必须","声明在构造器的首行"]}),"\n",(0,s.jsxs)(e.li,{children:["构造器内部，最多只能声明一个",(0,s.jsx)(e.code,{children:"this(形参列表)"}),"，来调用其他构造器"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"通过super调用构造器"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["在子类的构造器中通过",(0,s.jsx)(e.code,{children:"super(形参列表)"}),"显示调用父类的构造器"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"super(形参列表)"}),"的使用必须在子类构造器的首行"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"super(形参列表)"}),"与",(0,s.jsx)(e.code,{children:"this(形参列表)"}),"只能二选一，不可同时出现"]}),"\n",(0,s.jsxs)(e.li,{children:["在构造器首行，没有",(0,s.jsx)(e.code,{children:"super(形参列表)"}),"或",(0,s.jsx)(e.code,{children:"this(形参列表)"}),"，则默认调用的是",(0,s.jsx)(e.strong,{children:"父类中的空参构造器"})]}),"\n",(0,s.jsxs)(e.li,{children:["在类的多个构造器中，至少有一个类的构造器中使用了",(0,s.jsx)(e.code,{children:"super(形参列表)"}),"，调用父类构造器"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"48-javabean",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#48-javabean",children:"#"}),"4.8 JavaBean"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"定义"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"JavaBean是Java语言编写的可重用组件"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"JavaBean的特点"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"类是公共的"}),"\n",(0,s.jsx)(e.li,{children:"有一个无参的公共的构造器"}),"\n",(0,s.jsx)(e.li,{children:"有属性，且有对应的get、set方法"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"49-uml类图",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#49-uml类图",children:"#"}),"4.9 UML类图"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:h})}),"\n",(0,s.jsxs)(e.h2,{id:"410-package和import关键字",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#410-package和import关键字",children:"#"}),"4.10 package和import关键字"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"一些知识的补充"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["如果使用的类或接口是",(0,s.jsx)(e.code,{children:"java.lang"}),"包下定义的，或者是",(0,s.jsx)(e.code,{children:"本包"}),"下定义的，则可省略",(0,s.jsx)(e.code,{children:"import"}),"结构"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["import ",(0,s.jsx)(e.code,{children:"xxx.*"}),"时，只能导入本包下的全部结构。当使用",(0,s.jsx)(e.code,{children:"xxx子包"}),"下的结构时，仍需要import"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"import static"}),"导入指定类或接口中的静态结构（属性或方法）"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"举例："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",meta:"",children:'...\r\nimport static java.lang.System.*;\r\n...\r\npublic static void main(String[] args) {\r\n    out.println("Hello World！")\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(c,n)})):c(n)}let t=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["tang%2Fjava2%2F04_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{id:"41-面向过程与面向对象",text:"4.1 面向过程与面向对象",depth:2},{id:"42-内存解析",text:"4.2 内存解析",depth:2},{id:"43-属性和局部变量的对比",text:"4.3 属性和局部变量的对比",depth:2},{id:"44-匿名对象",text:"4.4 匿名对象",depth:2},{id:"45-方法",text:"4.5 方法",depth:2},{id:"451-方法的重载",text:"4.5.1 方法的重载",depth:3},{id:"452-可变个数的形参",text:"4.5.2 可变个数的形参",depth:3},{id:"453-方法形参的传递机制",text:"4.5.3 方法形参的传递机制",depth:3},{id:"454-递归方法",text:"4.5.4 递归方法",depth:3},{id:"46-oop特征一封装",text:"4.6 OOP特征一：封装",depth:2},{id:"461-封装性的体现",text:"4.6.1 封装性的体现",depth:3},{id:"462-权限修饰符",text:"4.6.2 权限修饰符",depth:3},{id:"47-构造器",text:"4.7 构造器",depth:2},{id:"48-javabean",text:"4.8 JavaBean",depth:2},{id:"49-uml类图",text:"4.9 UML类图",depth:2},{id:"410-package和import关键字",text:"4.10 package和import关键字",depth:2}],title:"4 面向对象编程（上）",headingTitle:"4 面向对象编程（上）",frontmatter:{}}}}]);