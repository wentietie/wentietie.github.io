"use strict";(self.webpackChunkmy_doc=self.webpackChunkmy_doc||[]).push([["2386"],{97233:function(n,r,e){e.r(r),e.d(r,{default:()=>j});var i=e("85893"),s=e("50065");let l=e.p+"static/image/image-20230110153153672.55d3f9e9.png",d=e.p+"static/image/image-20230109114138032.f5b7f074.png";function h(n){let r=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",ul:"ul",li:"li",h3:"h3",pre:"pre",code:"code",img:"img",strong:"strong"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"20-排序算法",children:["20 排序算法",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#20-排序算法",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"201-排序算法概述",children:["20.1 排序算法概述",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#201-排序算法概述",children:"#"})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"衡量排序算法的优劣"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["时间复杂度","：分析关键字的比较次数和记录的移动次数"]}),"\n",(0,i.jsxs)(r.li,{children:["空间复杂度","：分析算法中需要多少辅助内存"]}),"\n",(0,i.jsxs)(r.li,{children:["稳定性","：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种算法是稳定的"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"排序算法分类"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["内部排序","：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。"]}),"\n",(0,i.jsxs)(r.li,{children:["外部排序","：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器（如磁盘）等。外部排序最常见的算法有","多路归并排序","。可以认为外部排序是由多次内部排序组成的。"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"十大排序算法"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"选择排序"}),"\n",(0,i.jsx)(r.p,{children:"将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"简单选择排序"}),"\n",(0,i.jsx)(r.li,{children:"堆排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"交换排序"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"冒泡排序"}),"\n",(0,i.jsx)(r.li,{children:"快速排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"插入排序"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"直接插入排序"}),"\n",(0,i.jsx)(r.li,{children:"折半插入排序"}),"\n",(0,i.jsx)(r.li,{children:"希尔排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"归并排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"桶式排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"基数排序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"算法5大特性"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["输入","：有0个或多个输入数据，这些输入必须有清楚的描述和定义"]}),"\n",(0,i.jsxs)(r.li,{children:["输出","：至少有1个或多个输出结果，不可以没有输出"]}),"\n",(0,i.jsxs)(r.li,{children:["有穷性（有限性）","：算法可以在有限的步骤之后会自动结束而不是无线循环，并且每一个步骤可以在可接受的时间内完成"]}),"\n",(0,i.jsxs)(r.li,{children:["确定性（明确性）","：算法中的每一步都有确定的含义，不会出现二义性"]}),"\n",(0,i.jsxs)(r.li,{children:["可行性（有效性）","：算法的每一步骤都是清楚且可行的，能让用户用纸笔计算而求出答案"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"202-选择排序",children:["20.2 选择排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#202-选择排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h3,{id:"2021-简单选择排序",children:["20.2.1 简单选择排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2021-简单选择排序",children:"#"})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"基本过程"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"在一组元素R[i]到R[n]中选择最小的元素"}),"\n",(0,i.jsx)(r.li,{children:"如果他不是这组元素中的第一个元素，则将其与该组元素中的第一个元素交换"}),"\n",(0,i.jsx)(r.li,{children:"除去具有最小关键字的元素，在剩下的元素中重复以上两步骤，直到元素只有一个为止"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["比较次数","：$(n-1)+(n-2)+...+2+1=n(n-1)/2$"]}),"\n",(0,i.jsx)(r.p,{children:"无论初始状况如何，在第i趟排序中选择最小元素的时候，都需要做$(n-i)$次比较"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["交换次数","："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最好情况：0次"}),"\n",(0,i.jsx)(r.p,{children:"序列恰好为正序时，需要交换0次"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最差情况：${(n-1)}$次"}),"\n",(0,i.jsx)(r.p,{children:"如将数组[${5,1,2,3,4}$]按照有小到大的顺序排列，需要移动4次"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["综上，简单选择排序的","时间复杂度为$O(n^{2})$"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"稳定性"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"不稳定"}),"\n",(0,i.jsx)(r.p,{children:"由于在直接选择排序中存在不相邻元素的交换，因此它是一个不稳定的排序方法。"}),"\n",(0,i.jsx)(r.p,{children:"比如给定数组[$3,7,3',2,1$]，按照有小到大的顺序排列后的结果为[$1,2,3',3,7$]"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"示例代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:'int[] arr = {49,38,65,97,76,13,24,49};\r\n// 开始排序\r\n// 说明1：循环条件是 i < arr.length - 1，而不是i < arr.length的原因：最后一个数无需和自身进行比较、交换\r\nfor (int i = 0; i < arr.length - 1; i++) {\r\n    int index = i; // 记录最小值的下标\r\n    // 循环找到数组中的最小值对应的下标\r\n    for (int j = i + 1; j < arr.length; j++) {\r\n        if (arr[index] > arr[j]) {\r\n            index = j;\r\n        }\r\n    }\r\n    // 将最小值和无序数组中的第一个元素进行交换（当最小值下标和当前下标不相等的时候再交换）\r\n    if (i != index) {\r\n        int temp = arr[i];\r\n    	arr[i] = arr[index];\r\n    	arr[index] = temp;\r\n    }\r\n}\r\n// 排序完成\r\n// 打印\r\nfor (int i = 0; i < arr.length; i++) {\r\n    System.out.print(arr[i]+"\\t");\r\n}\n'})}),"\n",(0,i.jsxs)(r.h3,{id:"2022-堆排序",children:["20.2.2 堆排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2022-堆排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"203-交换排序",children:["20.3 交换排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#203-交换排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h3,{id:"2031-冒泡排序",children:["20.3.1 冒泡排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2031-冒泡排序",children:"#"})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"基本思想"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"对待排序序列从前往后，依次比较相邻元素排序码，如果逆序则交换，使排序码较大的元素逐渐从前往后移动。"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["比较次数","："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最好情况：$n-1$次"}),"\n",(0,i.jsx)(r.p,{children:"此时待排序序列恰好是按照要求的顺序进行排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$次"}),"\n",(0,i.jsx)(r.p,{children:"此时待排序序列恰好是按照要求的顺序的逆序进行排序"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["交换次数","："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最好情况：0次"}),"\n",(0,i.jsx)(r.p,{children:"此时待排序序列恰好是按照要求的顺序进行排序"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"最坏情况：$(n-1)+(n-2)+...+2+1=n(n-1)/2$"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"稳定性"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"示例代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:'int[] arr = {49,38,65,97,76,13,27,49};\r\n// 开始排序\r\n// 说明1：循环条件是 i < arr.length - 1，而不是i < arr.length的原因：最后一个数无需和自身进行比较、交换\r\nfor (int i = 0; i < arr.length - 1; i++) {\r\n    // 说明2：循环条件是arr.length - 1 - i的原因：每完成一次排序，最后（i+1）个数都已完成排序，不需要再进行比较、交换\r\n    for (int j = 0; j < arr.length - i - 1; j++) {\r\n        if (arr[j] > arr[j+1]) {\r\n            int temp = arr[j];\r\n            arr[j] = arr[j+1];\r\n            arr[j+1] = temp;\r\n        }\r\n    }\r\n}\r\n// 排序完成\r\n// 打印\r\nfor (int i = 0; i < arr.length; i++) {\r\n    System.out.print(arr[i]+"\\t");\r\n}\n'})}),"\n",(0,i.jsxs)(r.h3,{id:"2032-快速排序",children:["20.3.2 快速排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2032-快速排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"204-插入排序",children:["20.4 插入排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#204-插入排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h3,{id:"2041-直接插入排序",children:["20.4.1 直接插入排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2041-直接插入排序",children:"#"})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"基本过程"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"视R[m]为有序序列"}),"\n",(0,i.jsx)(r.li,{children:"比较R[m+1]和R[m]大小，如果R[m+1] >= R[m]，继续下一循环。否则，进入下一步。"}),"\n",(0,i.jsx)(r.li,{children:"如果R[m+1] < R[m]，比较R[m+1]与R[m]中的元素，将R[m+1]插入合适位置"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)("img",{src:d,alt:"image-20230109114138032"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["最好情况","：输入的数组已经排好序"]}),"\n",(0,i.jsx)(r.p,{children:"时间复杂度为$O(n)$"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["最坏情况","：输入的数组恰好是倒序排序"]}),"\n",(0,i.jsx)(r.p,{children:"时间复杂度为$O(n^{2})$"}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["平均情况","：数组A[1...j]中,一般元素大于A[j],一般元素小于A[j]，计算起来时间复杂度和最坏请款一致"]}),"\n",(0,i.jsx)(r.p,{children:"时间复杂度为$O(n^{2})$"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"稳定性"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"示例代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"/**\r\n * 插入排序--直接插入排序\r\n */\r\npublic void insertionSort(int[] arr) {\r\n    for (int i = 1; i < arr.length; i++) {\r\n        int temp = arr[i];\r\n        int j = i;\r\n        while (j > 0 && arr[j] < arr[j-1]) {\r\n            arr[j] = arr[j-1];\r\n            arr[j-1] = temp;\r\n            j--;\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(r.h3,{id:"2042-折半插入排序",children:["20.4.2 折半插入排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2042-折半插入排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h3,{id:"2043-希尔排序",children:["20.4.3 希尔排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2043-希尔排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"205-归并排序",children:["20.5 归并排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#205-归并排序",children:"#"})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"基本过程"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"分解"}),"：分解待排序的n个元素序列成各有n/2个元素的子序列"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"解决"}),"：使用归并排序递归的排列两个子列"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"合并"}),"：合并两个已排序的子列以产生已排序的答案"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析--合并步骤的时间复杂度"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)("img",{src:l,alt:"image-20230110153153672"})}),"\n",(0,i.jsxs)(r.p,{children:["合并步骤的时间复杂度：","O(n)"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"效率分析--归并排序时间复杂度"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["当归并排序",(0,i.jsx)(r.strong,{children:"一个元素"}),"（一个元素为最小输入）时需要的时间为常量时间。"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"当$n\\geq 1$时，分析运行时间如下："}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"分解"}),"：分解步骤仅仅计算子数组的中间位置，需要常量时间，因此D(n)=O(1)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"解决"}),"：递归算法中是递归的求解将原问题分为2个规模为n/2的子问题，即a=2，b=2"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"合并"}),"：在【效率分析--合并步骤的时间复杂度】中已知，合并所需的时间C(n)=O(n)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"综上，归并排序算法最坏情况下时间复杂度公式为"}),"\n",(0,i.jsx)(r.p,{children:"（注：分解时间D(n)=O(1)，可以忽略）\r\n$$\r\nT(n) =\r\n\\begin{cases}\r\nO(1), & \\text {$n\\leq 1$}\\\r\n2T(n/2)+O(n), & \\text {$n > 1$}\r\n\\end{cases}\r\n$$"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["经求解，","归并排序算法","最坏情况","下的时间复杂度为O(nlgn)"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"稳定性"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"示例代码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"/**\r\n * 归并排序\r\n * @param arr\r\n * @param start\r\n * @param end\r\n */\r\nprivate void mergeSort(int[] arr, int start, int end) {\r\n    if (start < end) {\r\n        int midd = (int) Math.floor((start + end) / 2);\r\n        mergeSort(arr, start, midd);\r\n        mergeSort(arr, midd + 1, end);\r\n        merge(arr, start, midd, end); // 合并\r\n    }\r\n}\r\n\r\n/**\r\n * 将两个有序数组合并成一个有序数组（使用哨兵的方式）\r\n * @param arr\r\n * @param start\r\n * @param midd\r\n * @param end\r\n */\r\nprivate void merge(int[] arr, int start, int midd, int end) {\r\n    int[] l = new int[midd - start + 2];\r\n    int[] r = new int[end - midd + 1];\r\n    for (int i = start; i <= midd; i++) {\r\n        l[i-start] = arr[i];\r\n    }\r\n    for (int i = midd + 1; i <= end ; i++) {\r\n        r[i-midd-1] = arr[i];\r\n    }\r\n    l[midd - start + 1] = Integer.MAX_VALUE; // 哨兵\r\n    r[end - midd] = Integer.MAX_VALUE; // 哨兵\r\n\r\n    int i = start, li = i - start, ri = li;\r\n    for (; i <= end; i++) {\r\n        if (l[li] <= r[ri]) {\r\n            arr[i] = l[li];\r\n            li++;\r\n        } else {\r\n            arr[i] = r[ri];\r\n            ri++;\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(r.h2,{id:"206-桶式排序",children:["20.6 桶式排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#206-桶式排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"207-基数排序",children:["20.7 基数排序",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#207-基数排序",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"208-算法设计",children:["20.8 算法设计",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#208-算法设计",children:"#"})]}),"\n",(0,i.jsxs)(r.h3,{id:"2081-分治模式",children:["20.8.1 分治模式",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2081-分治模式",children:"#"})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"使用场景"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"适用于递归算法中"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"思想"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"步骤"}),"\n"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"分解"}),"原问题为若干子问题，这些子问题都是原问题的规模较小的实例"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"解决"}),"这些子问题，递归的求解各个子问题。当子问题规模足够小时，可以直接求解"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"合并"}),"这些子问题的解成原问题的解、"]}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"分析分治算法的时间复杂度"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["当一个算法包含自身的递归调用时，可以使用",(0,i.jsx)(r.strong,{children:"递归方程"}),"或",(0,i.jsx)(r.strong,{children:"递归式"}),"来描述其运行时间，该方程根据在",(0,i.jsx)(r.strong,{children:"最小输入上的运行时间"}),"来描述在规模n问题上的总运行时间。然后，通过数学工具来求解递归式并给出算法性能的",(0,i.jsx)(r.strong,{children:"界"}),"。"]}),"\n",(0,i.jsx)(r.p,{children:"①假设T(n)是规模为n的一个问题的运行时间。"}),"\n",(0,i.jsx)(r.p,{children:"②如果问题足够小(假设对于常量c，n<=c)，则直接求解需要常量时间，记为O(1)。"}),"\n",(0,i.jsx)(r.p,{children:"③当问题比较大时，将原问题分解为a个子问题，每个子问题的规模是原问题的1/b，即子问题的规模为n/b。那么规模为n的问题的运行时间T(n)可以写成：T(n) =  a*T(n/b)。"}),"\n",(0,i.jsx)(r.p,{children:"④假设分解大问题为小问题所需时间为D(n)，小问题的解合并成大问题的解所需时间C(n)，那么，便可以得到递归式：\r\n$$\r\nT(n) =\r\n\\begin{cases}\r\nO(1), & \\text {$n\\leq c$}\\\r\naT(n/b)+D(n)+C(n), & \\text {$n > c$}\r\n\\end{cases}\r\n$$\r\n⑤对该递归式求解，即可得到该算法的时间复杂度"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),n.components);return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}let j=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["tang%2Fjava2%2F20_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md"]={toc:[{text:"20.1 排序算法概述",id:"201-排序算法概述",depth:2},{text:"20.2 选择排序",id:"202-选择排序",depth:2},{text:"20.2.1 简单选择排序",id:"2021-简单选择排序",depth:3},{text:"20.2.2 堆排序",id:"2022-堆排序",depth:3},{text:"20.3 交换排序",id:"203-交换排序",depth:2},{text:"20.3.1 冒泡排序",id:"2031-冒泡排序",depth:3},{text:"20.3.2 快速排序",id:"2032-快速排序",depth:3},{text:"20.4 插入排序",id:"204-插入排序",depth:2},{text:"20.4.1 直接插入排序",id:"2041-直接插入排序",depth:3},{text:"20.4.2 折半插入排序",id:"2042-折半插入排序",depth:3},{text:"20.4.3 希尔排序",id:"2043-希尔排序",depth:3},{text:"20.5 归并排序",id:"205-归并排序",depth:2},{text:"20.6 桶式排序",id:"206-桶式排序",depth:2},{text:"20.7 基数排序",id:"207-基数排序",depth:2},{text:"20.8 算法设计",id:"208-算法设计",depth:2},{text:"20.8.1 分治模式",id:"2081-分治模式",depth:3}],title:"20 排序算法",frontmatter:{}}}}]);