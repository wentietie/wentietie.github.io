import{_ as i,r as d,o as r,c,e as s,a,w as t,d as n,b as l}from"./app-CW2dCZSC.js";const p={},o=l(`<h1 id="_12-mysql中的数据类型" tabindex="-1"><a class="header-anchor" href="#_12-mysql中的数据类型"><span>12 MySQL中的数据类型</span></a></h1><h2 id="_12-1-概述" tabindex="-1"><a class="header-anchor" href="#_12-1-概述"><span>12.1 概述</span></a></h2><blockquote><p>MySQL中的数据类型分类</p></blockquote><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； <br>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td></tr></tbody></table><blockquote><p>常见数据类型的属性</p></blockquote><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可以包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许有NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET &#39;字符集&#39;</td><td>指定一个字符集</td></tr></tbody></table><h2 id="_12-2-整型" tabindex="-1"><a class="header-anchor" href="#_12-2-整型"><span>12.2 整型</span></a></h2><h3 id="_12-2-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-2-1-类型介绍"><span>12.2.1 类型介绍</span></a></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>字节</strong></th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><h3 id="_12-2-2-可选属性" tabindex="-1"><a class="header-anchor" href="#_12-2-2-可选属性"><span>12.2.2 可选属性</span></a></h3><ul><li><p><code>M</code>：表示显示宽度，需要配合<code>ZEROFILL</code>使用，表示当存储的数值不足M位时，用0进行填充</p><ul><li><p>如果设置了显示宽度，插入的数据超过了宽度范围，但是仍在当前类型的取值范围内，该数值不会被截断或插入失败，而是能够正常插入。如：</p><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">create table int_test1(</span>
<span class="line">	f1 int(3)</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入数据</span>
<span class="line">insert into int_test1(f1)</span>
<span class="line">values (1), (123), (1234); # 插入成功</span>
<span class="line"></span>
<span class="line"># 查询</span>
<span class="line">select * from int_test1;</span>
<span class="line"># 结果显示：</span>
<span class="line">+---------------|</span>
<span class="line">|      f1       |</span>
<span class="line">+---------------|</span>
<span class="line">|             1 |</span>
<span class="line">|           123 |</span>
<span class="line">|          1234 |---------- 超过宽度3位，不会被截断</span>
<span class="line">+---------------|</span>
<span class="line">3 rows in set (0.00 sec)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>从MySQL8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p></li></ul></li><li><p><code>UNSIGNED</code>：无符号类型（表示非负数）。</p><p>使用举例</p><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line">create table int_test2(</span>
<span class="line">	f1 int unsigned</span>
<span class="line">)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>ZEROFILL</code>：0填充，需要配合<code>M</code>属性使用，表示当不够<code>M</code>位时，用0在左侧填充。</p><p>如果指定了某列是ZEROFILL，<strong>MySQL会自动为当前列添加UNSIGNED属性</strong></p><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">create table int_test3(</span>
<span class="line">	f1 int(3) ZEROFILL</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入数据</span>
<span class="line">insert into int_test3(f1)</span>
<span class="line">values (1), (123), (1234); # 插入成功</span>
<span class="line"></span>
<span class="line"># 查询</span>
<span class="line">select * from int_test3;</span>
<span class="line"># 结果显示：</span>
<span class="line">+---------------|</span>
<span class="line">|      f1       |</span>
<span class="line">+---------------|</span>
<span class="line">|           001 |---------- 不足宽度3位，在最左边开始用0填充</span>
<span class="line">|           123 |</span>
<span class="line">|          1234 |---------- 超过宽度3位，不会被截断</span>
<span class="line">+---------------|</span>
<span class="line">3 rows in set (0.00 sec)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_12-2-3-使用场景" tabindex="-1"><a class="header-anchor" href="#_12-2-3-使用场景"><span>12.2.3 使用场景</span></a></h3><ul><li><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景</li><li><code>SMALLINT</code>：可以用于较小范围的统计数据</li><li><code>MEDIUMINT</code>：用于较大整数的计算</li><li><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑朝鲜问题，用的最多。比如商品的编号</li><li><code>BIGINT</code>：处理特别巨大的整数时用到。如双十一的交易量，大型门户网站的点击量，证券公司衍生产品持仓等</li></ul><p><code>小结</code>：在评估使用哪种整数类型的时候，需要考虑<strong>存储空间</strong>和<strong>可靠性</strong>的平衡问题。<strong>首先在确保数据不会超过取值范围的前提下，再去考虑如何节省内存空间</strong>。</p><h2 id="_12-3-浮点型" tabindex="-1"><a class="header-anchor" href="#_12-3-浮点型"><span>12.3 浮点型</span></a></h2><h3 id="_12-3-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-3-1-类型介绍"><span>12.3.1 类型介绍</span></a></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>字节数</strong></th><th>有符号取值范围</th><th>无符号取值范围</th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td><td>-3.402823466E+38～-1.175494351E-38，<br>0，<br>1.175494351E-38～3.402823466E+38</td><td>0，<br>1.175494351E-38～3.402823466E+38</td></tr><tr><td>DOUBLE</td><td>8</td><td>-1.7976931348623157E+308～-2.2250738585072014E-308，<br>0，<br>2.2250738585072014E-308~1.7976931348623157E+308</td><td>0，<br>2.2250738585072014E-308~1.7976931348623157E+308</td></tr></tbody></table>`,17),u=l(`<ul><li><p>除了FLOAT和DOUBLE之外，还有一种浮点类型--<code>REAL</code>。REAL默认为DOUBLE。如果把SQL模式设定位启用<code>REAL_AS_FLOAT</code>模式，REAL的默认值就变成了FLOAT。</p><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 启用REAL_AS_FLOAT模式</span>
<span class="line">SET sql_mode = &quot;REAL_AS_FLOAT&quot;;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>浮点数无符号数取值范围相当于有符号数取值范围的一半，即相当于有符号数取值范围中大于等于0的部分</strong>。这是因为在MySQL中存储浮点数的格式为：<code>符号（S）</code>、<code>尾数（M）</code>、<code>阶码（E）</code>，无论有没有符号，MySQL的浮点数在存储时都会保留出符号位。</p></li><li><p><strong>FLOAT和DOUBLE不用特意的声明为UNSIGNED</strong>，因为浮点数无符号数取值范围相当于有符号数取值范围的一半。</p></li></ul><h3 id="_12-3-2-数据精度说明" tabindex="-1"><a class="header-anchor" href="#_12-3-2-数据精度说明"><span>12.3.2 数据精度说明</span></a></h3><ul><li><p>MySQL允许使用<strong>非标准语法</strong>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）：<code> FLOAT(M,D)</code> 或<code>DOUBLE(M,D)</code>。这里，<strong>M称为精度</strong> ，<strong>D称为标度</strong> 。(M,D)中 <strong>M=整数位+小数位，D=小数位</strong>。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。</p></li><li><p>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示</p></li><li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p><ul><li><p>如果存储时，<strong>整数部分超出了范围，MySQL就会报错</strong>，不允许存这样的值</p></li><li><p>如果存储时，<strong>小数点部分若超出范围</strong>，就分以下情况：</p><ul><li><p><strong>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存</strong>。</p><p>例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</p></li><li><p><strong>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理</strong>。</p><p>如FLOAT(5,2)列内插入 999.995和-999.995都会报错。</p></li></ul></li></ul></li><li><p><strong>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。</p></li><li><p><strong>从MySQL 8.0.17开始，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了</strong>，将来也可能被移除。</p></li></ul><h3 id="_12-3-3-精度误差说明" tabindex="-1"><a class="header-anchor" href="#_12-3-3-精度误差说明"><span>12.3.3 精度误差说明</span></a></h3><p><strong>浮点数类型有个缺陷，就是不精准</strong>，详情见如下例子：</p><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_double2(</span>
<span class="line">f1 DOUBLE</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入数据</span>
<span class="line">INSERT INTO test_double2</span>
<span class="line">VALUES(0.47),(0.44),(0.19);</span>
<span class="line"></span>
<span class="line"># 查询以上数据的和</span>
<span class="line">mysql&gt; SELECT SUM(f1)</span>
<span class="line">-&gt; FROM test_double2;</span>
<span class="line"># 结果如下：</span>
<span class="line">+--------------------+</span>
<span class="line">| SUM(f1) |</span>
<span class="line">+--------------------+</span>
<span class="line">| 1.0999999999999999 |</span>
<span class="line">+--------------------+</span>
<span class="line">1 row in set (0.00 sec)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子中，对0.47、 0.44、 0.19三个数进行SUM()操作，结果返回1.0999999999999999，但是实际0.47 + 0.44 + 0.19 = 1.1，此时就产生了误差。</p><p>**为什么会存在这样的误差呢？**问题还是出在 MySQL 对浮点类型数据的存储方式上。 MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成1.001101×2^3。如 果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。</p><p>因此，在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等</strong>。同时，<strong>在一些对精确度要求较高的项目中，千万不要使用浮点数</strong>，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数 类型： <code>DECIMAL</code> 。</p><h2 id="_12-4-定点数" tabindex="-1"><a class="header-anchor" href="#_12-4-定点数"><span>12.4 定点数</span></a></h2><h3 id="_12-4-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-4-1-类型介绍"><span>12.4.1 类型介绍</span></a></h3><table><thead><tr><th>类型</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>DECIMAL(M,D)</td><td>M+2字节</td><td>有效范围由M和D决定。未指定M和D时，默认M=10，D=0</td></tr></tbody></table>`,12),v=l('<ul><li>DECIMAL(M,D)，M=整数位数+小数位数，D=小数位数。M取值范围是[0,65]，D取值范围是[0,30]，且D&lt;M。</li><li>DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。</li><li>定点数在MySQL内部是以<strong>字符串</strong>的形式进行存储，这就决定了它一定是精准的。</li><li>存储数值时： <ul><li>小数位不足会自动补0</li><li>首位数字为0自动忽略</li><li>整数超出存储范围会报错</li><li>小数超出会截断，发出警告，并按四舍五入处理</li></ul></li></ul><h3 id="_12-4-2-使用场景" tabindex="-1"><a class="header-anchor" href="#_12-4-2-使用场景"><span>12.4.2 使用场景</span></a></h3><p>在涉及对小数求和，特别是涉及到金额的时候，推荐使用DECIMAL。</p><h1 id="_12-5-位类型" tabindex="-1"><a class="header-anchor" href="#_12-5-位类型"><span>12.5 位类型</span></a></h1><h3 id="_12-5-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-5-1-类型介绍"><span>12.5.1 类型介绍</span></a></h3><table><thead><tr><th>类型</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>BIT(M)</td><td>约(M+7)/8个字节</td><td>M表示二进制的位数，取值范围是[1,64]。未指定M时，默认M=1</td></tr></tbody></table>',6),h=l(`<ul><li>BIT类型中存储的是二进制值</li></ul><h3 id="_12-5-2-使用" tabindex="-1"><a class="header-anchor" href="#_12-5-2-使用"><span>12.5.2 使用</span></a></h3><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_bit1(</span>
<span class="line">f1 BIT,		# 默认M为1，只能1位二进制数，转为十进制只能存储0和1，比1大时要报错</span>
<span class="line">f2 BIT(5),	# 能存储5位二进制数，转为十进制，最大能存储31，比31大时要报错</span>
<span class="line">f3 BIT(64)	# 能存储64位二进制数。且M最大只能是64</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入数据</span>
<span class="line">INSERT INTO test_bit1(f1) VALUES(1);</span>
<span class="line"></span>
<span class="line"># 插入数据报错：Data too long for column &#39;f1&#39; at row 1</span>
<span class="line">INSERT INTO test_bit1(f1) VALUES(2);</span>
<span class="line"></span>
<span class="line"># 插入数据</span>
<span class="line">INSERT INTO test_bit1(f2)VALUES(30);</span>
<span class="line"></span>
<span class="line"># 查询数据</span>
<span class="line">SELECT * FROM test_bit1;</span>
<span class="line"># 在cmd控制台中，用十六进制的数示</span>
<span class="line">+------------+------------+------------+</span>
<span class="line">| f1         | f2         | f3         |</span>
<span class="line">+------------+------------+------------+</span>
<span class="line">| 0x01       | NULL       | NULL       |</span>
<span class="line">| NULL       | 0x1E       | NULL       |</span>
<span class="line">+------------+------------+------------+</span>
<span class="line">2 rows in set (0.00 sec)</span>
<span class="line"></span>
<span class="line"># 查询数据，分别使用二进制、十六进制、十进制的数来显示</span>
<span class="line">mysql&gt; SELECT BIN(f2) &#39;二进制&#39;,HEX(f2) &#39;十六进制&#39;, f2+0 &#39;十进制&#39; FROM test_bit1;</span>
<span class="line">+-----------+--------------+-----------+</span>
<span class="line">| 二进制    | 十六进制     | 十进制    |</span>
<span class="line">+-----------+--------------+-----------+</span>
<span class="line">| NULL      | NULL         |      NULL |</span>
<span class="line">| 11110     | 1E           |        30 |</span>
<span class="line">+-----------+--------------+-----------+</span>
<span class="line">2 rows in set (0.00 sec)</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_12-6-日期与时间" tabindex="-1"><a class="header-anchor" href="#_12-6-日期与时间"><span>12.6 日期与时间</span></a></h1><h3 id="_12-6-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-6-1-类型介绍"><span>12.6.1 类型介绍</span></a></h3><table><thead><tr><th>类型</th><th>字节</th><th>描述</th><th>格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>1</td><td>年</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>3</td><td>时分秒</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>3</td><td>年月日</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>8</td><td>年月日时分秒</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>带时区的年月日时分秒</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table><h3 id="_12-6-2-year" tabindex="-1"><a class="header-anchor" href="#_12-6-2-year"><span>12.6.2 YEAR</span></a></h3>`,7),b=l('<ul><li>以<strong>4位</strong>字符串或数字格式表示，格式为<code>YYYY</code>，最小值为1901，最大值为2155</li><li>以<strong>2位</strong>字符串或数字格式表示，最小值为00，最大值为99 <ul><li>当取值为<code>01~69</code>，表示<code>2001~2069</code></li><li>当取值为<code>70~99</code>，表示<code>1970~1999</code></li><li>当取值为<strong>整数</strong>的<code>0</code>或者<code>00</code>，表示是<code>0000</code></li><li>当取值是<strong>字符串</strong><code>0</code>或者<code>00</code>，表示是<code>2000</code></li></ul></li></ul><h3 id="_12-6-3-time" tabindex="-1"><a class="header-anchor" href="#_12-6-3-time"><span>12.6.3 TIME</span></a></h3>',2),m=l('<ul><li><strong>使用带有冒号的字符串</strong>，如<code>D HH:MM:SS</code>、<code>HH:MM:SS</code>、<code>HH:MM</code>、<code>D HH:MM</code>、<code>D HH</code>、<code>SS</code>格式。其中D表示天，取值范围是[0,34]，插入时，D会被转化为小时</li><li><strong>使用不带冒号的字符串或者数字</strong>，如<code>HHMMSS</code>。 <ul><li>如果插入的字符串或者数字不合法，会将其转化为00:00:00存储</li><li>假如插入的是1210，存储后的时间是<strong>00:12:10</strong>，而不是12:10:00</li></ul></li><li>使用<code>CURRENT_TIME()</code> 、<code>CURTIME()</code>或者<code> NOW()</code>等，可以<strong>插入当前系统时间</strong></li></ul><h3 id="_12-6-4-date" tabindex="-1"><a class="header-anchor" href="#_12-6-4-date"><span>12.6.4 DATE</span></a></h3>',2),g=l('<ul><li><code>YYYY-MM-DD</code>或<code>YYYYMMDD</code>格式。最小取值1000-01-01，最大取值9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD</li><li><code>YY-MM-DD</code>或<code>YYMMDD</code>格式。 <ul><li>当年份(YY)取值为[00,69]，会被转化为[2000,2069]</li><li>当年份(YY)取值为[70,99]，会被转化为[1970,1999]</li></ul></li><li>使用<code>CURRENT_DATE()</code> 、<code>CURDATE()</code>或者<code> NOW()</code>等，可以<strong>插入当前系统日期</strong></li></ul><h3 id="_12-6-5-datetime" tabindex="-1"><a class="header-anchor" href="#_12-6-5-datetime"><span>12.6.5 DATETIME</span></a></h3>',2),E=l('<ul><li><code>YYYY-MM-DD HH:MM:SS</code>或<code>YYYYMMDDHHMMSS</code>格式。最小取值1000-01-01 00:00:00，最大取值9999-12-03 23:59:59</li><li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>等，可以<strong>插入系统的当前日期和 时间</strong>。</li></ul><h3 id="_12-6-6-timestamp" tabindex="-1"><a class="header-anchor" href="#_12-6-6-timestamp"><span>12.6.6 TIMESTAMP</span></a></h3>',2),_=l('<blockquote><p>TIMESTAMP VS DATETIME</p></blockquote><ul><li>TIMESTAMP只需要4个字节，存储的时间范围比DATETIME小很多。只能存储 “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫 作世界标准时间。</li><li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li><li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li><li>**使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。**而DATETIME不同时区显示的是同一时间。</li></ul><h2 id="_12-7-文本字符串类型" tabindex="-1"><a class="header-anchor" href="#_12-7-文本字符串类型"><span>12.7 文本字符串类型</span></a></h2><h3 id="_12-7-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-7-1-类型介绍"><span>12.7.1 类型介绍</span></a></h3><table><thead><tr><th>类型</th><th>长度范围</th><th>长度单位</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>[0, 255]</td><td>字符</td><td>M个字符</td></tr><tr><td>VARCHAR(M)</td><td>[0, 65535]</td><td>字节</td><td>MySQL4.0之前，M的单位是字节；<br><br>MySQL5.0之后，M的单位是字符。<br>最大的字符数需要通过编码来算，按照不超过行65535个字节</td></tr><tr><td>TINYTEXT</td><td>[0, 255]</td><td>字节</td><td>L+2个字节，最多能存255/3=85个UTF8编码的字符</td></tr><tr><td>TEXT</td><td>[0, 65535]</td><td>字节</td><td>L+2个字节，最多能存65535/3个UTF8编码的字符</td></tr><tr><td>MEDIUMTEXT</td><td>[0, 16777215]</td><td>字节</td><td>L+3个字节，最多能存16777215/3个UTF8编码的字符</td></tr><tr><td>LONGTEXT</td><td>[0, 4294967295]</td><td>字节</td><td>L+4个字节，最多能存4294967295/3个UTF8编码的字符</td></tr></tbody></table><h3 id="_12-7-2-char与varchar" tabindex="-1"><a class="header-anchor" href="#_12-7-2-char与varchar"><span>12.7.2 CHAR与VARCHAR</span></a></h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p><blockquote><p>CHAR类型</p></blockquote><ul><li>CHAR(M)是固定长度，一般需要先指定字符串的长度。如果不指定，默认长度是1个字符</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<strong>右侧填充空格</strong>已达到指定的长度。</li><li><strong>当检索时，CHAR类型的字段会去除尾部的空格。</strong></li><li>定义CHAR类型的字段时，声明的<strong>字段长度即为</strong>CHAR类型字段所占的存储空间的<strong>字符数</strong>。</li></ul><blockquote><p>VARCHAR类型</p></blockquote>',10),T=s("li",null,[s("p",null,[n("VARCHAR(M) 定义时，"),s("strong",null,"必须指定长度M"),n("，否则报错。")])],-1),M=s("li",null,[s("p",null,"MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。")],-1),L=s("li",null,[s("p",null,[s("strong",null,"检索VARCHAR类型的字段数据时，会保留数据尾部的空格"),n("。")])],-1),A=s("li",null,[s("p",null,"VARCHAR类型的字段所占用的存储空间为字符串实际长度加1或2个字节。")],-1),N=s("p",null,"虽然VARCHAR类型最大长度是65535个字节，但是真实存储的时候，并不能存这么多数据。VARCHAR的真实存储长度，需要按照如下规则计算：",-1),y=s("ul",null,[s("li",null,[s("p",null,[s("strong",null,"①一行记录的最大字节数不得超过65535字节"),n("；")])]),s("li",null,[s("p",null,[s("strong",null,"②VARCHAR本身需要1到2个字节来存储数据长度"),n("（如果列声明的长度超过255，则使用2个字节来存储长度，否则1个）；")])]),s("li",null,[s("p",null,[s("strong",null,"③VARCHAR字段允许为空时，NULL值标识需要1个字节"),n("。")])])],-1),I=l("<p>以MySQL8.0为例，以下表都使用 <strong>utf8mb4 编码，一个字符最大能占用 4 个字节</strong>。</p><ul><li><p>例子1：<code>CREATE TABLE t1 (name varchar(M) NULL) CHARSET=utf8mb4;</code>，其中M最大是多少？</p><p>M = (行最大字节数 - 数据的长度 - NULL标识) / utf8mb4 编码最大字节数</p><p>​ = (65535 - 2 - 1) / 4 = 16383</p><p>**结论：**M最大为16383</p></li><li><p>例子2：<code>CREATE TABLE t2 (name varchar(M) NOT NULL) CHARSET=utf8mb4;</code>，其中M最大是多少？</p><p>M = (行最大字节数 - 数据的长度) / utf8mb4 编码最大字节数</p><p>​ = (65535 - 2) / 4 = 16383.25</p><p>​ 对16383.25向下取整，得M=16383</p><p>**结论：**M最大为16383</p></li><li><p>例子3：<code>CREATE TABLE t3 (name varchar(M) NULL, age int) CHARSET=utf8mb4;</code>，其中M最大是多少？</p><p>M = (行最大字节数 - 数据的长度 - NULL标识 - int字段所占字节) / utf8mb4 编码最大字节数</p><p>​ = (65535 - 2 - 1 - 4) / 4 = 16382</p><p>**结论：**M最大为16382</p></li></ul>",2),R=l('<blockquote><p>CHAR 和 VARCHAR 的对比（MySQL5.0以上）</p></blockquote><table><thead><tr><th></th><th>char(M)</th><th>varchar(M)</th></tr></thead><tbody><tr><td>最大长度</td><td>M最大是255个字符</td><td>M最大值需要按照一定规则计算（见上）</td></tr><tr><td>是否定长</td><td>定长，不足的部分尾部用空格补齐</td><td>不定长，保留实际字符</td></tr><tr><td>空间使用</td><td>可能浪费</td><td>更加节省</td></tr><tr><td>查找效率</td><td>高</td><td>低</td></tr><tr><td>尾部空格</td><td>插入时会被忽略</td><td>可以正常插入</td></tr></tbody></table><blockquote><p>CHAR 和 VARCHAR 的适用场景：</p></blockquote><ul><li><p>存储很短的信息，建议使用char。如门牌号</p><p>假如使用varchar，还需要使用1个字节存储信息长度，得不偿失</p></li><li><p>存储固定长度的信息，建议使用char。如uuid</p></li><li><p>存储需要频繁改变的信息，建议使用char。</p><p>varchar每次存储都需要额外的计算长度等信息，如果频繁改变，需要很多的精力用于计算</p></li><li><p>考虑具体存储引擎中的情况：</p><ul><li><code>MyISAM</code>：<strong>最好使用char</strong>。这样使得整个表静态化，从而使数据检索更快，用空间换时间</li><li><code>MEMORY</code>：无论使用char和varchar，<strong>底层都是作为char类型处理的</strong></li><li><code>InnoDB</code>：建议使用varchar。InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列，所有数据行都是用指向数据列值的头指针，而且主要影响性能的因素是数据行使用的存储总量。由于char平均占用的空间多于varchar，所以<strong>处理简短并且固定长度的使用char，其他考虑varchar</strong>。这样节省空间，对磁盘I/O和数据存储总量比较好</li></ul></li></ul><blockquote><p>附：字符、字节、位之间的关系</p></blockquote><ul><li><p>**位：**数据存储的最小单位。每个二进制数字0或者1就是1个位；</p></li><li><p>**字节：**8个位构成一个字节；</p><p>即：1 byte (字节)= 8 bit(位)；</p><p>​ 1 KB = 1024 B(字节)；</p><p>​ 1 MB = 1024 KB; (2^10 B) ​ 1 GB = 1024 MB; (2^20 B) ​ 1 TB = 1024 GB; (2^30 B)</p></li><li><p><strong>字符：</strong></p><ul><li>a、A、中、+、*、の......均表示1个字符</li><li>一般 <strong>utf-8</strong> 编码下，一个<strong>汉字字符</strong>占用 <strong>3 个 字节</strong>；<strong>数字</strong>属于汉字，和汉字占用一样字节</li><li>一般 <strong>utf8mb4 ** 编码下，一个</strong>汉字字符**占用 <strong>4 个 字节</strong></li><li>一般 <strong>gbk</strong> 编码下，一个<strong>汉字字符</strong>占用 <strong>2 个 字节</strong></li></ul></li></ul><h3 id="_12-7-3-text类型" tabindex="-1"><a class="header-anchor" href="#_12-7-3-text类型"><span>12.7.3 TEXT类型</span></a></h3><ul><li>TEXT类型分为4种，分别为TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</li><li>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。与VARCHAR类型相同</li><li>由于实际存储的长度不确定，<strong>MySQL 不允许 TEXT 类型的字段做主键</strong></li><li>开发中的经验： <ul><li>TEXT文本类型，可以存比较大的文本段，<strong>搜索速度稍慢</strong>，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替</li><li>TEXT类型<strong>不用加默认值</strong>，加了也没用</li><li>text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以<strong>频繁使用的表不建议包含TEXT类型字段</strong>，建议单独分出去，单独用 一个表</li></ul></li></ul><h2 id="_12-8-enum类型" tabindex="-1"><a class="header-anchor" href="#_12-8-enum类型"><span>12.8 ENUM类型</span></a></h2><h3 id="_12-8-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-8-1-类型介绍"><span>12.8.1 类型介绍</span></a></h3><table><thead><tr><th>类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1&lt;=L&lt;=65535</td><td>1或2个字节</td></tr></tbody></table>',11),S=l(`<ul><li>ENUM类型的<strong>取值范围需要在定义字段时进行指定</strong>。</li><li>设置字段值时，ENUM 类型<strong>只允许从成员中选取单个值</strong>，不能一次选取多个值。</li><li>当ENUM类型包含1～255个成员时，需要1个字节的存储空间</li><li>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</li><li>ENUM类型的成员个数的上限为65535个。</li></ul><h3 id="_12-8-2-使用" tabindex="-1"><a class="header-anchor" href="#_12-8-2-使用"><span>12.8.2 使用</span></a></h3><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_enum(</span>
<span class="line">season ENUM(&#39;春&#39;,&#39;夏&#39;,&#39;秋&#39;,&#39;冬&#39;,&#39;unknow&#39;)</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入数据--成功</span>
<span class="line">INSERT INTO test_enum VALUES(&#39;春&#39;),(&#39;秋&#39;);</span>
<span class="line"></span>
<span class="line"># 允许按照角标的方式获取指定索引位置的枚举值</span>
<span class="line">INSERT INTO test_enum VALUES(&#39;1&#39;),(3);</span>
<span class="line"></span>
<span class="line"># 忽略大小写。最终插入的是大写还是小写，以定义字段时候的值为准</span>
<span class="line">INSERT INTO test_enum VALUES(&#39;UNKNOW&#39;);</span>
<span class="line"></span>
<span class="line"># 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的</span>
<span class="line">INSERT INTO test_enum VALUES(NULL);</span>
<span class="line"></span>
<span class="line"># 不允许插入不在定义时指定的字段。Data truncated for column &#39;season&#39; at row 1</span>
<span class="line">INSERT INTO test_enum VALUES(&#39;ab&#39;);</span>
<span class="line"></span>
<span class="line"># 只能插入单个值。Data truncated for column &#39;season&#39; at row 1</span>
<span class="line">INSERT INTO test_enum VALUES(&#39;春,秋&#39;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_12-9-set类型" tabindex="-1"><a class="header-anchor" href="#_12-9-set类型"><span>12.9 SET类型</span></a></h2><h3 id="_12-9-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-9-1-类型介绍"><span>12.9.1 类型介绍</span></a></h3><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8个字节</td></tr></tbody></table>`,7),f=l(`<ul><li>SET表示一个字符串对象，可以包含0个或多个成员，成员上线为64</li><li>SET存储多个成员时，成员之间用英文逗号隔开</li><li>SET类型在存储数据时成员个数越多，其占用的存储空间越大。</li></ul><h3 id="_12-9-2-使用" tabindex="-1"><a class="header-anchor" href="#_12-9-2-使用"><span>12.9.2 使用</span></a></h3><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_set(</span>
<span class="line">	s SET (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 可以插入0个或多个数据</span>
<span class="line">INSERT INTO test_set (s) VALUES (&#39;A&#39;), (&#39;A,B&#39;);</span>
<span class="line"># 插入时，忽略大小写。最终插入结果以定义的时候为准</span>
<span class="line">INSERT INTO test_set (s) VALUES (&#39;a&#39;)</span>
<span class="line"></span>
<span class="line">#插入重复的SET类型成员时，MySQL会自动删除重复的成员</span>
<span class="line">INSERT INTO test_set (s) VALUES (&#39;A,B,C,A&#39;);</span>
<span class="line"></span>
<span class="line">#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。Data truncated for column &#39;s&#39; at row 1</span>
<span class="line">INSERT INTO test_set (s) VALUES (&#39;A,B,C,D&#39;);</span>
<span class="line"></span>
<span class="line"># 当SET类型的字段没有声明为NOT NULL时，插入NULL也是有效的</span>
<span class="line">INSERT INTO test_set (s) VALUES (NULL);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_12-10-二进制字符串类型" tabindex="-1"><a class="header-anchor" href="#_12-10-二进制字符串类型"><span>12.10 二进制字符串类型</span></a></h2><h3 id="_12-10-1-类型介绍" tabindex="-1"><a class="header-anchor" href="#_12-10-1-类型介绍"><span>12.10.1 类型介绍</span></a></h3><ul><li>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数 据。</li><li>MySQL中支持的二进制字符串类型主要包括<code>BINARY</code>、<code>VARBINARY</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和<code> LONGBLOB</code>类型。</li></ul><h3 id="_12-10-2-binary与varbinary" tabindex="-1"><a class="header-anchor" href="#_12-10-2-binary与varbinary"><span>12.10.2 BINARY与VARBINARY</span></a></h3><blockquote><p>类型介绍</p></blockquote><table><thead><tr><th>类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;= M &lt;= 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;= M &lt;= 65535）</td><td>M+1个字节</td></tr></tbody></table>`,9),B=l(`<ul><li>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串</li><li>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数。如果未 指定(M)，表示只能存储 1个字节</li><li>BINARY(M)如果字段值不足(M)个字 节，将在右边填充&#39;\\0&#39;以补齐指定长度</li><li>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，<strong>总字节数不能超过行的字节长 度限制65535</strong>，另外<strong>还要考虑额外字节开销</strong>，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数</li><li>VARBINARY类型<strong>必须指定(M)</strong></li></ul><blockquote><p>使用</p></blockquote><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_binary1(</span>
<span class="line">	f1 BINARY,</span>
<span class="line">	f2 BINARY(3),</span>
<span class="line">#	f3 VARBINARY,</span>
<span class="line">	f4 VARBINARY(10)</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入成功</span>
<span class="line">INSERT INTO test_binary1(f1,f2) VALUES(&#39;a&#39;,&#39;a&#39;);</span>
<span class="line"></span>
<span class="line"># 插入成功，但是查询出来是乱码</span>
<span class="line">INSERT INTO test_binary1(f2) VALUES(&#39;一&#39;);</span>
<span class="line"></span>
<span class="line"># 插入成功</span>
<span class="line">INSERT INTO test_binary1(f2,f4) VALUES(&#39;ab&#39;,&#39;ab&#39;);</span>
<span class="line"></span>
<span class="line"># 在f2、f4插入&#39;ab&#39;时，对应的LENGTH(f2) = 3, LENGTH(f4) = 2</span>
<span class="line">SELECT LENGTH(f2), LENGTH(f4) FROM test_binary1;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_12-10-3-blob" tabindex="-1"><a class="header-anchor" href="#_12-10-3-blob"><span>12.10.3 BLOB</span></a></h3><blockquote><p>类型介绍</p></blockquote><table><thead><tr><th>类型</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4个字节</td></tr></tbody></table>`,6),O=l(`<ul><li>BLOB是一个<strong>二进制大对象</strong> ，可以容纳可变数量的数据。</li><li>BLOB类型可以存储一个二进制的大对象，比如<strong>图片</strong> 、<strong>音频</strong>和<strong>视频</strong>等</li><li>但是实际工作中，图片等一般都保存在服务器的磁盘上，数据库存储的是图片等的访问路径</li></ul><blockquote><p>使用</p></blockquote><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_blob1(</span>
<span class="line">    id INT,</span>
<span class="line">    img MEDIUMBLOB</span>
<span class="line">);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>TEXT和BLOB的使用注意事项</p></blockquote><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>① 在执行了大量的删除或更新操作的时候，删除text和blob类型的值会在数据表中留下很大的&quot;<code>空洞</code>&quot;，以后填入这些&quot;空洞&quot;的记录可能长度不同。为了提高性能，建议定期使用<code>OPTIMIZE TABLE</code>功能对这类表进行<strong>碎片整理</strong> 。</li><li>② 尽量<strong>避免检索大型的BLOB或TEXT值</strong>。如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code> 。</li><li>③ 把BLOB或TEXT列<strong>分离到单独的表</strong> 中。这样做的好处是：减少主表中的碎片 ，并且当主数据表上运行 SELECT * 查询的时候不会通过 网络传输大量的BLOB或TEXT值。</li></ul><h2 id="_12-11-json类型" tabindex="-1"><a class="header-anchor" href="#_12-11-json类型"><span>12.11 JSON类型</span></a></h2><blockquote><p>使用</p></blockquote><div class="language-mysql line-numbers-mode" data-highlighter="prismjs" data-ext="mysql" data-title="mysql"><pre class="language-mysql"><code><span class="line"># 创建表</span>
<span class="line">CREATE TABLE test_json (</span>
<span class="line">	f1 JSON</span>
<span class="line">);</span>
<span class="line"></span>
<span class="line"># 插入数据</span>
<span class="line">INSERT INTO test_json VALUES (&#39;{&quot;name&quot;: &quot;tth&quot;, &quot;age&quot;: 18, &quot;address&quot;: {&quot;province&quot;: &quot;山东&quot;, &quot;city&quot;: &quot;济南&quot;}}&#39;)</span>
<span class="line"># 查询</span>
<span class="line">SELECT * FROM test_json;</span>
<span class="line"></span>
<span class="line"># 查询json类型字段中的具体属性的值</span>
<span class="line"># 方法一：使用-&gt;</span>
<span class="line">SELECT f1 -&gt; &#39;$.name&#39; NAME, f1 -&gt; &#39;$.age&#39; age, f1 -&gt; &#39;$.address.province&#39; province, f1 -&gt;&#39;$.address.city&#39; city</span>
<span class="line">FROM test_json; # NAME、province、city中带有&quot;&quot;</span>
<span class="line"># 方法二：使用-&gt;&gt;</span>
<span class="line">SELECT f1 -&gt;&gt; &#39;$.name&#39; NAME, f1 -&gt;&gt; &#39;$.age&#39; age, f1 -&gt;&gt; &#39;$.address.province&#39; province, f1 -&gt;&gt;&#39;$.address.city&#39; city</span>
<span class="line">FROM test_json; # NAME、province、city中不带&quot;&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_12-12-空间类型" tabindex="-1"><a class="header-anchor" href="#_12-12-空间类型"><span>12.12 空间类型</span></a></h2><p>略</p><h2 id="_12-13-小结" tabindex="-1"><a class="header-anchor" href="#_12-13-小结"><span>12.13 小结</span></a></h2><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li>任何字段如果为非负数，必须是 UNSIGNED</li><li>【 <strong>强制</strong> 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 <ul><li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得 到不正确的结果。</li><li>如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。</li></ul></li><li>【 <strong>强制</strong> 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</li><li>【 <strong>强制</strong> 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大 于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul>`,14);function D(q,U){const e=d("front");return r(),c("div",null,[o,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),u,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),v,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),h,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("YEAR用来表示年份")]),_:1}),n("，在MySQL中有如下几种存储格式：")]),b,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("TIME用来表示时分秒")]),_:1}),n("，在MySQL中有如下几种存储格式：")]),m,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("DATE表示年月日")]),_:1}),n("，在MySQL中有如下几种存储格式：")]),g,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("DATETIME表示年月日 时分秒")]),_:1}),n("，在MySQL中有如下几种存储格式：")]),E,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("TIMESTAMP表示**带时区的**年月日 时分秒")]),_:1}),n("，存储格式与DATETIME相同。")]),_,s("ul",null,[T,M,L,A,s("li",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("VARCHAR最大存储长度的计算理论：")]),_:1}),N,y]),s("li",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("VARCHAR最大存储长度的计算例子：")]),_:1}),I])]),R,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),S,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),f,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),B,s("p",null,[a(e,{style:{background:"yellow"}},{default:t(()=>[n("说明：")]),_:1})]),O])}const C=i(p,[["render",D],["__file","12_MySQL中的数据类型.html.vue"]]),k=JSON.parse('{"path":"/static/tang/mysql/12_MySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","title":"12 MySQL中的数据类型","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"12.1 概述","slug":"_12-1-概述","link":"#_12-1-概述","children":[]},{"level":2,"title":"12.2 整型","slug":"_12-2-整型","link":"#_12-2-整型","children":[{"level":3,"title":"12.2.1 类型介绍","slug":"_12-2-1-类型介绍","link":"#_12-2-1-类型介绍","children":[]},{"level":3,"title":"12.2.2 可选属性","slug":"_12-2-2-可选属性","link":"#_12-2-2-可选属性","children":[]},{"level":3,"title":"12.2.3 使用场景","slug":"_12-2-3-使用场景","link":"#_12-2-3-使用场景","children":[]}]},{"level":2,"title":"12.3 浮点型","slug":"_12-3-浮点型","link":"#_12-3-浮点型","children":[{"level":3,"title":"12.3.1 类型介绍","slug":"_12-3-1-类型介绍","link":"#_12-3-1-类型介绍","children":[]},{"level":3,"title":"12.3.2 数据精度说明","slug":"_12-3-2-数据精度说明","link":"#_12-3-2-数据精度说明","children":[]},{"level":3,"title":"12.3.3 精度误差说明","slug":"_12-3-3-精度误差说明","link":"#_12-3-3-精度误差说明","children":[]}]},{"level":2,"title":"12.4 定点数","slug":"_12-4-定点数","link":"#_12-4-定点数","children":[{"level":3,"title":"12.4.1 类型介绍","slug":"_12-4-1-类型介绍","link":"#_12-4-1-类型介绍","children":[]},{"level":3,"title":"12.4.2 使用场景","slug":"_12-4-2-使用场景","link":"#_12-4-2-使用场景","children":[]},{"level":3,"title":"12.5.1 类型介绍","slug":"_12-5-1-类型介绍","link":"#_12-5-1-类型介绍","children":[]},{"level":3,"title":"12.5.2 使用","slug":"_12-5-2-使用","link":"#_12-5-2-使用","children":[]},{"level":3,"title":"12.6.1 类型介绍","slug":"_12-6-1-类型介绍","link":"#_12-6-1-类型介绍","children":[]},{"level":3,"title":"12.6.2 YEAR","slug":"_12-6-2-year","link":"#_12-6-2-year","children":[]},{"level":3,"title":"12.6.3 TIME","slug":"_12-6-3-time","link":"#_12-6-3-time","children":[]},{"level":3,"title":"12.6.4 DATE","slug":"_12-6-4-date","link":"#_12-6-4-date","children":[]},{"level":3,"title":"12.6.5 DATETIME","slug":"_12-6-5-datetime","link":"#_12-6-5-datetime","children":[]},{"level":3,"title":"12.6.6 TIMESTAMP","slug":"_12-6-6-timestamp","link":"#_12-6-6-timestamp","children":[]}]},{"level":2,"title":"12.7 文本字符串类型","slug":"_12-7-文本字符串类型","link":"#_12-7-文本字符串类型","children":[{"level":3,"title":"12.7.1 类型介绍","slug":"_12-7-1-类型介绍","link":"#_12-7-1-类型介绍","children":[]},{"level":3,"title":"12.7.2 CHAR与VARCHAR","slug":"_12-7-2-char与varchar","link":"#_12-7-2-char与varchar","children":[]},{"level":3,"title":"12.7.3 TEXT类型","slug":"_12-7-3-text类型","link":"#_12-7-3-text类型","children":[]}]},{"level":2,"title":"12.8 ENUM类型","slug":"_12-8-enum类型","link":"#_12-8-enum类型","children":[{"level":3,"title":"12.8.1 类型介绍","slug":"_12-8-1-类型介绍","link":"#_12-8-1-类型介绍","children":[]},{"level":3,"title":"12.8.2 使用","slug":"_12-8-2-使用","link":"#_12-8-2-使用","children":[]}]},{"level":2,"title":"12.9 SET类型","slug":"_12-9-set类型","link":"#_12-9-set类型","children":[{"level":3,"title":"12.9.1 类型介绍","slug":"_12-9-1-类型介绍","link":"#_12-9-1-类型介绍","children":[]},{"level":3,"title":"12.9.2 使用","slug":"_12-9-2-使用","link":"#_12-9-2-使用","children":[]}]},{"level":2,"title":"12.10 二进制字符串类型","slug":"_12-10-二进制字符串类型","link":"#_12-10-二进制字符串类型","children":[{"level":3,"title":"12.10.1 类型介绍","slug":"_12-10-1-类型介绍","link":"#_12-10-1-类型介绍","children":[]},{"level":3,"title":"12.10.2 BINARY与VARBINARY","slug":"_12-10-2-binary与varbinary","link":"#_12-10-2-binary与varbinary","children":[]},{"level":3,"title":"12.10.3 BLOB","slug":"_12-10-3-blob","link":"#_12-10-3-blob","children":[]}]},{"level":2,"title":"12.11 JSON类型","slug":"_12-11-json类型","link":"#_12-11-json类型","children":[]},{"level":2,"title":"12.12 空间类型","slug":"_12-12-空间类型","link":"#_12-12-空间类型","children":[]},{"level":2,"title":"12.13 小结","slug":"_12-13-小结","link":"#_12-13-小结","children":[]}],"git":{"updatedTime":1720499771000,"contributors":[{"name":"文铁铁~","email":"1179131421@qq.com","commits":1}]},"filePathRelative":"static/tang/mysql/12_MySQL中的数据类型.md"}');export{C as comp,k as data};
