# 14 视图

## 14.1 常见的数据库对象

| 对象                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| 表（TABLE）           | 表是存储数据的逻辑单元，以行和列的形式存在。列就是字段，行就是记录 |
| 数据字典              | 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员一般不可修改，只能查看 |
| 约束（CONSTRAINT）    | 执行数据校验的规则，用于保证数据的完整性                     |
| 视图（VIEW）          | 一个或者多个数据表里的数据的逻辑显示，视图本身并不存储数据   |
| 索引（INDEX）         | 用于提高查询性能，相当于书的目录                             |
| 存储过程（PROCEDURE） | 用于完成一次完整的业务处理，没有返回值。但可以通过传出参数将多个值传给调用环境 |
| 存储函数（FUNCTION）  | 用于完成一次特定的计算，具有一个返回值                       |
| 触发器（TRIGGER）     | 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理 |

## 14.2 视图概述

- 视图是一个**虚拟表**，本身**不存储数据**，占用很少的内存空间
- **视图建立在已有表的基础上**，视图赖以建立的表被称为**基表**
- 视图的创建和删除只影响视图本身，不影响对应的基表
- 针对视图中的数据做DML操作，会影响到对应的基表中的数据。反之亦然
- **视图的应用场景**：针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图
- **视图的优点**：简化查询; 控制数据的访问

## 14.3 创建视图

### 14.3.1 完整语法

```mysql
CREATE [OR REPLACE]
[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW 视图名称 [(字段列表)]
AS 
查询语句
[WITH [CASCADED|LOCAL] CHECK OPTION]
```

<p><front style="background: yellow">说明：</front></p>

- `OR REPLACE`：表示**如果没有就创建，如果有就修改**

- `ALGORITHM`（了解）：它表示**使用何种算法来处理视图**。是MySQL对标准SQL进行的功能扩展。

  ALGORITHM有如下3个值可选：

  - `MERGE`：会将引用视图的语句的文本与视图定义合并起来，使得视图定义的部分替换语句的相应部分

    例子如下：

    - ① 创建视图

      ```mysql
      CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) 
      AS
      SELECT c1, c2 FROM t WHERE c3 > 100;
      ```

    - ② 使用视图进行查询

      ```mysql
      SELECT * FROM v_merge WHERE vc1 < 100;
      ```

    - ③ 最终执行的语句实际为：

      ```mysql
      SELECT c1, c2 FROM t WHERE (c3 > 100) AND (c1 < 100);
      # 注意：where中的条件是由(select WHERE)和（view WHERE）组合起来的，重点注意二者分别用()包裹着，并且使用AND连接
      ```

  - `TEMPTABLE`，视图的结果将被置于临时表中，然后使用它执行语句

  - `UNDEFINED`，MySQL选择使用哪种算法。如果可能，它倾向于`MERGE`而不是`TEMPTABLE`，这是因为`MERGE`通常更有效，而且如果使用了临时表，视图是不可更新的。

  - 如果没有ALGORITHM子句，默认算法由系统变量`optimizer_switch`的`derived_merge`标志的值确定。

- `查询语句`：既可以在表的基础上创建视图，也可以在视图的基础上创建视图

- `WITH [CASCADED|LOCAL] CHECK OPTION`：**确保视图数据的一致性**。即当通过视图更新或插入基表的一行记录时，MySQL都会确保插入或更新操作符合视图的定义（即确保该记录符合创建视图时SELECT字句中的WHERE条件）

  - `CASCADED`：**默认值**。表示MySQL会以**递归**方式检查视图的规则以及基础视图的规则（）

  - `LOCAL`：**在MySQL 5.7.6之前**，仅检查当前视图的规则，而不检查基础视图的规则；**在MySQL 5.7.6之后**，将检查带有`WITH LOCAL CHECK OPTION`和`WITH CASCADED CHECK OPTION`选项的视图规则（只检查带有这两个选项的视图规则）。

  - 例子：

    ```mysql
    # 1.建表
    DROP TABLE IF EXISTS t1;
    
    CREATE TABLE t1 (
        c INT
    );
    
    # 2.基于t1表创建一个名为v1的视图，以选择值大于10的行。
    CREATE OR REPLACE VIEW v1 
    AS
        SELECT 
            c
        FROM
            t1
        WHERE
            c > 10; 
    				
    # 3. 插入成功
    INSERT INTO v1(c) VALUES (5); 
    
    # 4.基于v1视图创建v2视图。这次，我们添加一个WITH CASCADED CHECK OPTION条款。
    CREATE OR REPLACE VIEW v2 
    AS
        SELECT 
            c
        FROM
            v1 
    WITH CASCADED CHECK OPTION; 
    
    # 5.插入失败：CHECK OPTION failed 'dbtest14.v2' ----> 因为它创建了一个不符合v2视图定义的新行。
    INSERT INTO v2(c) VALUES (5); 
    
    # 6.基于v2创建一个名为v3的新视图
    CREATE OR REPLACE VIEW v3 
    AS
        SELECT 
            c
        FROM
            v2
        WHERE
            c < 20; 
    
    # 7.插入失败：CHECK OPTION failed 'dbtest14.v3' ----> 因为v3视图依赖于v2视图，而v2视图具有WITH CASCADED CHECK OPTION。
    INSERT INTO v3(c) VALUES (8); 
    # 插入成功：因为：
    # 							①v3视图定义时没有WITH CHECK OPTION选项，所以不会匹配33是否符合v3视图的定义；
    #								②v2视图定义时有WITH CASCADED CHECK OPTION选项，此时需要匹配33是否符合v2视图的定义，刚好33符合
    #						综上，33插入成功
    INSERT INTO v3(c) VALUES (33); 
    
    
    # 8.我们更改v2视图以使用WITH LOCAL CHECK OPTION替代。
    ALTER VIEW v2 AS
        SELECT 
            c
        FROM
            v1 
    WITH CASCADED CHECK OPTION; 
    
    # 9.插入与步骤5相同的记录，插入成功。
    # 	插入成功原因：因为v2视图没有任何规则。v2视图取决于v1视图。但是，v1视图未指定检查选项，因此MySQL会跳过检查v1视图中的规则。
    INSERT INTO v2(c) VALUES (5); 
    
    # 10. 插入与步骤5相同的记录，插入成功。
    INSERT INTO v3(c) VALUES (8); 
    ```

### 14.3.2 精简版语法

```mysql
CREATE VIEW 视图名
AS 
查询语句
```

- `查询语句`：既可以在表的基础上创建视图，也可以在视图的基础上创建视图

## 14.4 查看视图信息

> 查看数据库的表对象、视图对象

```mysql
SHOW TABLES;
```

> 看视图的结构

```mysql
DESC 视图名;
```

> 查看视图的属性信息（显示数据表的存储引擎、版本、数据行数和数据大小等）

```mysql
SHOW TABLE STATUS LIKE '视图名';
```

> 查看视图的详细定义信息

```mysql
SHOW CREATE VIEW 视图名;
```

## 14.5 更新视图中的数据

一般情况下，MySQL支持使用`INSERT`、`UPDATE`和`DELETE`语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。

但是，**在如下情况下，视图中的数据是不允许更新的**：

- 在定义视图时，指定了`ALGORITHM = TEMPTABLE`，该视图不支持*INSERT*和 *DELETE*操作
- 在定义视图时，指定了`WITH [CASCADED|LOCAL] CHECK OPTION`，且INSERT和UPDATE的记录不满足视图规则时，不能更新
- 视图中**不包含基表中所有被定义为NOT NULL且又未指定默认值的列**，该视图不支持*INSERT*操作
- 在定义视图的SELECT中使用了`JOIN联合查询`，该视图不支持 *INSERT*和 *DELETE*操作
- 在定义视图的SELECT语句后的**字段列表**中使用了`数学表达式`或`子查询`，该视图不支持*INSERT*操作，也不支持对使用了数学表达式和子查询的字段使用`UPDATE`操作
- 在定义视图的SELECT语句后的**字段列表**中使用了`DISTINCT`、`聚合函数`、`GROUP BY`、`HAVING`、`UNION`等
- 视图定义基于一个`不可更新视图`
- 常量视图

<p><front style="background: yellow">综上：</front>
虽然可以更新视图数据，但总的来说，视图作为`虚拟表`，主要用于`方便查询` ，不建议更新视图的数据。**对视图数据的更改，都是通过对实际数据表里数据的操作来完成的**。</p>

## 14.6 修改视图

> 使用CREATE OR REPLACE VIEW子句修改视图

```mysql
CREATE OR REPLACE VIEW 视图名
AS
查询语句
```

>使用ALTER VIEW子句修改视图

```mysql
ALTER VIEW 视图名
AS
查询语句
```

## 14.7 删除视图

```mysql
DROP VIEW IF EXISTS 视图名称[, 视图名称2, 视图名称3, ...];
```

<p><front style="background: yellow">说明：</front></p>

- 删除的是视图本身，而不会删除基表中的数据
- 假设视图c是基于视图a创建的，如果删除了视图a，会导致视图c查询失败，此时**需要手动删除视图c**。

## 14.8 视图的优缺点

### 14.8.1 视图的优点

- **操作简单**

  将常用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表结构、表与表之间的关联关系，只需要简单的操作视图即可，极大的简化了开发人员对数据库的操作

- **减少数据冗余**

  视图本身就是一条被保存起来的SELECT语句，本身不存储数据，从而减少了数据冗余

- **数据安全**

  用户不需要查询数据表，可以通过视图获取表中的数据。此外还可以限制用户对视图的操作权限，以保证数据的安全

- **适应灵活多变的需求**

  当业务系统的需求发生变化后，如果需要改动表的结构，此时工作量比较大。如果借助视图，则能减少改动的工作量

- **能够分解复杂的查询逻辑**

  数据库中如果存在复杂的逻辑查询，则可以将问题分解，创建多个视图获取数据，在将创建的多个视图结合起来，完成复杂的逻辑查询

### 14.8.2 视图的缺点

- **维护比较困难，可读性不好**

  如果在实际数据表的基础上创建了视图，一旦基表的结构变更，必须及时对相关视图进行维护，特别是嵌套的视图，维护变得比较复杂，可读性不好，容易变成系统的潜在隐患。且创建视图的SQL查询可能会对字段重命名，也可能是包含复杂的逻辑，这些都会增加维护的成本。

### 14.8.3 视图的使用场景

针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图
