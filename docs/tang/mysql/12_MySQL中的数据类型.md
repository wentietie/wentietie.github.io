# 12 MySQL中的数据类型

## 12.1 概述

> MySQL中的数据类型分类

| 类型             | 类型举例                                                     |
| ---------------- | ------------------------------------------------------------ |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT         |
| 浮点类型         | FLOAT、DOUBLE                                                |
| 定点类型         | DECIMAL                                                      |
| 位类型           | BIT                                                          |
| 日期时间类型     | YEAR、TIME、DATE、DATETIME、TIMESTAMP                        |
| 文本字符串类型   | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT          |
| 枚举类型         | ENUM                                                         |
| 集合类型         | SET                                                          |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB      |
| JSON类型         | JSON对象、JSON数组                                           |
| 空间数据类型     | 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； <br>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION |

> 常见数据类型的属性

| MySQL关键字            | 含义                     |
| ---------------------- | ------------------------ |
| NULL                   | 数据列可以包含NULL值     |
| NOT NULL               | 数据列不允许有NULL值     |
| DEFAULT                | 默认值                   |
| PRIMARY KEY            | 主键                     |
| AUTO_INCREMENT         | 自动递增，适用于整数类型 |
| UNSIGNED               | 无符号                   |
| CHARACTER SET '字符集' | 指定一个字符集           |

## 12.2 整型

### 12.2.1 类型介绍

| **类型**     | **字节** | 有符号数取值范围                         | 无符号数取值范围       |
| ------------ | -------- | ---------------------------------------- | ---------------------- |
| TINYINT      | 1        | -128~127                                 | 0~255                  |
| SMALLINT     | 2        | -32768~32767                             | 0~65535                |
| MEDIUMINT    | 3        | -8388608~8388607                         | 0~16777215             |
| INT、INTEGER | 4        | -2147483648~2147483647                   | 0~4294967295           |
| BIGINT       | 8        | -9223372036854775808~9223372036854775807 | 0~18446744073709551615 |

### 12.2.2 可选属性

- `M`：表示显示宽度，需要配合`ZEROFILL`使用，表示当存储的数值不足M位时，用0进行填充

  - 如果设置了显示宽度，插入的数据超过了宽度范围，但是仍在当前类型的取值范围内，该数值不会被截断或插入失败，而是能够正常插入。如：

    ```mysql
    # 创建表
    create table int_test1(
    	f1 int(3)
    );
    
    # 插入数据
    insert into int_test1(f1)
    values (1), (123), (1234); # 插入成功
    
    # 查询
    select * from int_test1;
    # 结果显示：
    +---------------|
    |      f1       |
    +---------------|
    |             1 |
    |           123 |
    |          1234 |---------- 超过宽度3位，不会被截断
    +---------------|
    3 rows in set (0.00 sec)
    ```

  - **从MySQL8.0.17开始，整数数据类型不推荐使用显示宽度属性。**

- `UNSIGNED`：无符号类型（表示非负数）。

  使用举例

  ```mysql
  create table int_test2(
  	f1 int unsigned
  )
  ```

- `ZEROFILL`：0填充，需要配合`M`属性使用，表示当不够`M`位时，用0在左侧填充。

  如果指定了某列是ZEROFILL，**MySQL会自动为当前列添加UNSIGNED属性**

  ```mysql
  # 创建表
  create table int_test3(
  	f1 int(3) ZEROFILL
  );
  
  # 插入数据
  insert into int_test3(f1)
  values (1), (123), (1234); # 插入成功
  
  # 查询
  select * from int_test3;
  # 结果显示：
  +---------------|
  |      f1       |
  +---------------|
  |           001 |---------- 不足宽度3位，在最左边开始用0填充
  |           123 |
  |          1234 |---------- 超过宽度3位，不会被截断
  +---------------|
  3 rows in set (0.00 sec)
  ```

### 12.2.3 使用场景

- `TINYINT`：一般用于枚举数据，比如系统设定取值范围很小且固定的场景
- `SMALLINT`：可以用于较小范围的统计数据
- `MEDIUMINT`：用于较大整数的计算
- `INT、INTEGER`：取值范围足够大，一般情况下不用考虑朝鲜问题，用的最多。比如商品的编号
- `BIGINT`：处理特别巨大的整数时用到。如双十一的交易量，大型门户网站的点击量，证券公司衍生产品持仓等

`小结`：在评估使用哪种整数类型的时候，需要考虑**存储空间**和**可靠性**的平衡问题。**首先在确保数据不会超过取值范围的前提下，再去考虑如何节省内存空间**。

## 12.3 浮点型

### 12.3.1 类型介绍

| **类型** | **字节数** | 有符号取值范围                                               | 无符号取值范围                                          |
| -------- | ---------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| FLOAT    | 4          | -3.402823466E+38～-1.175494351E-38，<br>0，<br>1.175494351E-38～3.402823466E+38 | 0，<br>1.175494351E-38～3.402823466E+38                 |
| DOUBLE   | 8          | -1.7976931348623157E+308～-2.2250738585072014E-308，<br>0，<br>2.2250738585072014E-308~1.7976931348623157E+308 | 0，<br/>2.2250738585072014E-308~1.7976931348623157E+308 |

<p><front style="background: yellow">说明：</front></p>

- 除了FLOAT和DOUBLE之外，还有一种浮点类型--`REAL`。REAL默认为DOUBLE。如果把SQL模式设定位启用`REAL_AS_FLOAT`模式，REAL的默认值就变成了FLOAT。

  ```mysql
  # 启用REAL_AS_FLOAT模式
  SET sql_mode = "REAL_AS_FLOAT";
  ```

- **浮点数无符号数取值范围相当于有符号数取值范围的一半，即相当于有符号数取值范围中大于等于0的部分**。这是因为在MySQL中存储浮点数的格式为：`符号（S）`、`尾数（M）`、`阶码（E）`，无论有没有符号，MySQL的浮点数在存储时都会保留出符号位。

- **FLOAT和DOUBLE不用特意的声明为UNSIGNED**，因为浮点数无符号数取值范围相当于有符号数取值范围的一半。

### 12.3.2 数据精度说明

- MySQL允许使用**非标准语法**（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）：` FLOAT(M,D)` 或` DOUBLE(M,D) `。这里，**M称为精度** ，**D称为标度** 。(M,D)中 **M=整数位+小数位，D=小数位**。 D<=M<=255，0<=D<=30。

- FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示

- 不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：

  - 如果存储时，**整数部分超出了范围，MySQL就会报错**，不允许存这样的值 

  - 如果存储时，**小数点部分若超出范围**，就分以下情况： 

    - **若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存**。

      例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。 

    - **若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理**。

      如FLOAT(5,2)列内插入 999.995和-999.995都会报错。 

- **从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用**，将来可能被移除。

- **从MySQL 8.0.17开始，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了**，将来也可能被移除。

### 12.3.3 精度误差说明

**浮点数类型有个缺陷，就是不精准**，详情见如下例子：

```mysql
# 创建表
CREATE TABLE test_double2(
f1 DOUBLE
);

# 插入数据
INSERT INTO test_double2
VALUES(0.47),(0.44),(0.19);

# 查询以上数据的和
mysql> SELECT SUM(f1)
-> FROM test_double2;
# 结果如下：
+--------------------+
| SUM(f1) |
+--------------------+
| 1.0999999999999999 |
+--------------------+
1 row in set (0.00 sec)
```

例子中，对0.47、 0.44、 0.19三个数进行SUM()操作，结果返回1.0999999999999999，但是实际0.47 +  0.44 + 0.19 = 1.1，此时就产生了误差。

**为什么会存在这样的误差呢？**问题还是出在 MySQL 对浮点类型数据的存储方式上。 MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成1.001101×2^3。如 果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。

因此，在编程中，如果用到浮点数，要特别注意误差问题，**因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等**。同时，**在一些对精确度要求较高的项目中，千万不要使用浮点数**，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数 类型： `DECIMAL` 。

## 12.4 定点数

### 12.4.1 类型介绍

| 类型         | 字节数  | 说明                                            |
| ------------ | ------- | ----------------------------------------------- |
| DECIMAL(M,D) | M+2字节 | 有效范围由M和D决定。未指定M和D时，默认M=10，D=0 |

<p><front style="background: yellow">说明：</front></p>

- DECIMAL(M,D)，M=整数位数+小数位数，D=小数位数。M取值范围是[0,65]，D取值范围是[0,30]，且D<M。
- DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。
- 定点数在MySQL内部是以**字符串**的形式进行存储，这就决定了它一定是精准的。
- 存储数值时：
  - 小数位不足会自动补0
  - 首位数字为0自动忽略
  - 整数超出存储范围会报错
  - 小数超出会截断，发出警告，并按四舍五入处理

### 12.4.2 使用场景

在涉及对小数求和，特别是涉及到金额的时候，推荐使用DECIMAL。

# 12.5 位类型

### 12.5.1 类型介绍

| 类型   | 字节数          | 说明                                                    |
| ------ | --------------- | ------------------------------------------------------- |
| BIT(M) | 约(M+7)/8个字节 | M表示二进制的位数，取值范围是[1,64]。未指定M时，默认M=1 |

<p><front style="background: yellow">说明：</front></p>

- BIT类型中存储的是二进制值

### 12.5.2 使用

```mysql
# 创建表
CREATE TABLE test_bit1(
f1 BIT,		# 默认M为1，只能1位二进制数，转为十进制只能存储0和1，比1大时要报错
f2 BIT(5),	# 能存储5位二进制数，转为十进制，最大能存储31，比31大时要报错
f3 BIT(64)	# 能存储64位二进制数。且M最大只能是64
);

# 插入数据
INSERT INTO test_bit1(f1) VALUES(1);

# 插入数据报错：Data too long for column 'f1' at row 1
INSERT INTO test_bit1(f1) VALUES(2);

# 插入数据
INSERT INTO test_bit1(f2)VALUES(30);

# 查询数据
SELECT * FROM test_bit1;
# 在cmd控制台中，用十六进制的数示
+------------+------------+------------+
| f1         | f2         | f3         |
+------------+------------+------------+
| 0x01       | NULL       | NULL       |
| NULL       | 0x1E       | NULL       |
+------------+------------+------------+
2 rows in set (0.00 sec)

# 查询数据，分别使用二进制、十六进制、十进制的数来显示
mysql> SELECT BIN(f2) '二进制',HEX(f2) '十六进制', f2+0 '十进制' FROM test_bit1;
+-----------+--------------+-----------+
| 二进制    | 十六进制     | 十进制    |
+-----------+--------------+-----------+
| NULL      | NULL         |      NULL |
| 11110     | 1E           |        30 |
+-----------+--------------+-----------+
2 rows in set (0.00 sec)

```

# 12.6 日期与时间

### 12.6.1 类型介绍

| 类型      | 字节 | 描述                 | 格式                | 最小值                  | 最大值                 |
| --------- | ---- | -------------------- | ------------------- | ----------------------- | ---------------------- |
| YEAR      | 1    | 年                   | YYYY或YY            | 1901                    | 2155                   |
| TIME      | 3    | 时分秒               | HH:MM:SS            | -838:59:59              | 838:59:59              |
| DATE      | 3    | 年月日               | YYYY-MM-DD          | 1000-01-01              | 9999-12-03             |
| DATETIME  | 8    | 年月日时分秒         | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00     | 9999-12-31 23:59:59    |
| TIMESTAMP | 4    | 带时区的年月日时分秒 | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:00 UTC | 2038-01-19 03:14:07UTC |

### 12.6.2 YEAR

<p><front style="background: yellow">YEAR用来表示年份</front>，在MySQL中有如下几种存储格式：</p>

- 以**4位**字符串或数字格式表示，格式为`YYYY`，最小值为1901，最大值为2155
- 以**2位**字符串或数字格式表示，最小值为00，最大值为99
  - 当取值为`01~69`，表示`2001~2069`
  - 当取值为`70~99`，表示`1970~1999`
  - 当取值为**整数**的`0`或者`00`，表示是`0000`
  - 当取值是**字符串**`0`或者`00`，表示是`2000`

### 12.6.3 TIME

<p><front style="background: yellow">TIME用来表示时分秒</front>，在MySQL中有如下几种存储格式：</p>

- **使用带有冒号的字符串**，如`D HH:MM:SS`、`HH:MM:SS`、`HH:MM`、`D HH:MM`、`D HH`、`SS`格式。其中D表示天，取值范围是[0,34]，插入时，D会被转化为小时
- **使用不带冒号的字符串或者数字**，如`HHMMSS`。
  - 如果插入的字符串或者数字不合法，会将其转化为00:00:00存储
  - 假如插入的是1210，存储后的时间是**00:12:10**，而不是12:10:00
- 使用`CURRENT_TIME()` 、`CURTIME()`或者` NOW()`等，可以**插入当前系统时间**

### 12.6.4 DATE

<p><front style="background: yellow">DATE表示年月日</front>，在MySQL中有如下几种存储格式：</p>

- `YYYY-MM-DD`或`YYYYMMDD`格式。最小取值1000-01-01，最大取值9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD
- `YY-MM-DD`或`YYMMDD`格式。
  - 当年份(YY)取值为[00,69]，会被转化为[2000,2069]
  - 当年份(YY)取值为[70,99]，会被转化为[1970,1999]
- 使用`CURRENT_DATE()` 、`CURDATE()`或者` NOW()`等，可以**插入当前系统日期**

### 12.6.5 DATETIME

<p><front style="background: yellow">DATETIME表示年月日 时分秒</front>，在MySQL中有如下几种存储格式：</p>

- `YYYY-MM-DD HH:MM:SS`或`YYYYMMDDHHMMSS`格式。最小取值1000-01-01 00:00:00，最大取值9999-12-03 23:59:59
- 使用函数`CURRENT_TIMESTAMP()`和`NOW()`等，可以**插入系统的当前日期和 时间**。

### 12.6.6 TIMESTAMP

<p><front style="background: yellow">TIMESTAMP表示**带时区的**年月日 时分秒</front>，存储格式与DATETIME相同。</p>

> TIMESTAMP VS DATETIME

- TIMESTAMP只需要4个字节，存储的时间范围比DATETIME小很多。只能存储 “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫 作世界标准时间。
- 底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。
- 两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。
- **使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。**而DATETIME不同时区显示的是同一时间。

## 12.7 文本字符串类型

### 12.7.1 类型介绍

| 类型       | 长度范围        | 长度单位 | 占用的存储空间                                               |
| ---------- | --------------- | -------- | ------------------------------------------------------------ |
| CHAR(M)    | [0, 255]        | 字符     | M个字符                                                      |
| VARCHAR(M) | [0, 65535]      | 字节     | MySQL4.0之前，M的单位是字节；<br><br/>MySQL5.0之后，M的单位是字符。<br/>最大的字符数需要通过编码来算，按照不超过行65535个字节 |
| TINYTEXT   | [0, 255]        | 字节     | L+2个字节，最多能存255/3=85个UTF8编码的字符                  |
| TEXT       | [0, 65535]      | 字节     | L+2个字节，最多能存65535/3个UTF8编码的字符                   |
| MEDIUMTEXT | [0, 16777215]   | 字节     | L+3个字节，最多能存16777215/3个UTF8编码的字符                |
| LONGTEXT   | [0, 4294967295] | 字节     | L+4个字节，最多能存4294967295/3个UTF8编码的字符              |

### 12.7.2 CHAR与VARCHAR

CHAR和VARCHAR类型都可以存储比较短的字符串。

> CHAR类型

- CHAR(M)是固定长度，一般需要先指定字符串的长度。如果不指定，默认长度是1个字符
- 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在**右侧填充空格**已达到指定的长度。
- **当检索时，CHAR类型的字段会去除尾部的空格。**
- 定义CHAR类型的字段时，声明的**字段长度即为**CHAR类型字段所占的存储空间的**字符数**。

> VARCHAR类型

- VARCHAR(M) 定义时，**必须指定长度M**，否则报错。

- MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。

- **检索VARCHAR类型的字段数据时，会保留数据尾部的空格**。

- VARCHAR类型的字段所占用的存储空间为字符串实际长度加1或2个字节。

- <front style="background: yellow">VARCHAR最大存储长度的计算理论：</front>

  虽然VARCHAR类型最大长度是65535个字节，但是真实存储的时候，并不能存这么多数据。VARCHAR的真实存储长度，需要按照如下规则计算：

  - **①一行记录的最大字节数不得超过65535字节**；

  - **②VARCHAR本身需要1到2个字节来存储数据长度**（如果列声明的长度超过255，则使用2个字节来存储长度，否则1个）；

  - **③VARCHAR字段允许为空时，NULL值标识需要1个字节**。

- <front style="background: yellow">VARCHAR最大存储长度的计算例子：</front>

  以MySQL8.0为例，以下表都使用 **utf8mb4 编码，一个字符最大能占用 4 个字节**。

  - 例子1：`CREATE TABLE t1 (name varchar(M) NULL) CHARSET=utf8mb4;`，其中M最大是多少？

    M = (行最大字节数 -  数据的长度 - NULL标识) / utf8mb4 编码最大字节数

    ​	 = (65535 - 2 - 1) / 4 = 16383

    **结论：**M最大为16383

  - 例子2：`CREATE TABLE t2 (name varchar(M) NOT NULL) CHARSET=utf8mb4;`，其中M最大是多少？

    M = (行最大字节数 -  数据的长度) / utf8mb4 编码最大字节数

    ​	 = (65535 - 2) / 4 = 16383.25

    ​	对16383.25向下取整，得M=16383

    **结论：**M最大为16383

  - 例子3：`CREATE TABLE t3 (name varchar(M) NULL, age int) CHARSET=utf8mb4;`，其中M最大是多少？

    M = (行最大字节数 -  数据的长度 - NULL标识 - int字段所占字节) / utf8mb4 编码最大字节数

    ​	 = (65535 - 2 - 1 - 4) / 4 = 16382 

    **结论：**M最大为16382 

> CHAR 和 VARCHAR 的对比（MySQL5.0以上）

|          | char(M)                        | varchar(M)                          |
| -------- | ------------------------------ | ----------------------------------- |
| 最大长度 | M最大是255个字符               | M最大值需要按照一定规则计算（见上） |
| 是否定长 | 定长，不足的部分尾部用空格补齐 | 不定长，保留实际字符                |
| 空间使用 | 可能浪费                       | 更加节省                            |
| 查找效率 | 高                             | 低                                  |
| 尾部空格 | 插入时会被忽略                 | 可以正常插入                        |

> CHAR 和 VARCHAR 的适用场景：

- 存储很短的信息，建议使用char。如门牌号

  假如使用varchar，还需要使用1个字节存储信息长度，得不偿失

- 存储固定长度的信息，建议使用char。如uuid

- 存储需要频繁改变的信息，建议使用char。

  varchar每次存储都需要额外的计算长度等信息，如果频繁改变，需要很多的精力用于计算

- 考虑具体存储引擎中的情况：

  - `MyISAM`：**最好使用char**。这样使得整个表静态化，从而使数据检索更快，用空间换时间
  - `MEMORY`：无论使用char和varchar，**底层都是作为char类型处理的**
  - `InnoDB`：建议使用varchar。InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列，所有数据行都是用指向数据列值的头指针，而且主要影响性能的因素是数据行使用的存储总量。由于char平均占用的空间多于varchar，所以**处理简短并且固定长度的使用char，其他考虑varchar**。这样节省空间，对磁盘I/O和数据存储总量比较好

> 附：字符、字节、位之间的关系

- **位：**数据存储的最小单位。每个二进制数字0或者1就是1个位；

- **字节：**8个位构成一个字节；

  即：1 byte (字节)= 8 bit(位)；

  ​		1 KB = 1024 B(字节)；

  ​		1 MB = 1024 KB;  (2^10 B)
  ​		1 GB = 1024 MB; (2^20 B)
  ​		1 TB = 1024 GB;  (2^30 B)

- **字符：**

  - a、A、中、+、*、の......均表示1个字符
  - 一般 **utf-8** 编码下，一个**汉字字符**占用 **3 个 字节**；**数字**属于汉字，和汉字占用一样字节
  - 一般 **utf8mb4 ** 编码下，一个**汉字字符**占用 **4 个 字节**
  - 一般 **gbk** 编码下，一个**汉字字符**占用 **2 个 字节**

### 12.7.3 TEXT类型

- TEXT类型分为4种，分别为TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT
- 在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。与VARCHAR类型相同
- 由于实际存储的长度不确定，**MySQL 不允许 TEXT 类型的字段做主键**
- 开发中的经验：
  - TEXT文本类型，可以存比较大的文本段，**搜索速度稍慢**，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替
  - TEXT类型**不用加默认值**，加了也没用
  - text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以**频繁使用的表不建议包含TEXT类型字段**，建议单独分出去，单独用 一个表

## 12.8 ENUM类型

### 12.8.1 类型介绍

| 类型 | 长度 | 长度范围    | 占用的存储空间 |
| ---- | ---- | ----------- | -------------- |
| ENUM | L    | 1<=L<=65535 | 1或2个字节     |

<p><front style="background: yellow">说明：</front></p>

- ENUM类型的**取值范围需要在定义字段时进行指定**。
- 设置字段值时，ENUM 类型**只允许从成员中选取单个值**，不能一次选取多个值。
- 当ENUM类型包含1～255个成员时，需要1个字节的存储空间
- 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。
- ENUM类型的成员个数的上限为65535个。

### 12.8.2 使用

```mysql
# 创建表
CREATE TABLE test_enum(
season ENUM('春','夏','秋','冬','unknow')
);

# 插入数据--成功
INSERT INTO test_enum VALUES('春'),('秋');

# 允许按照角标的方式获取指定索引位置的枚举值
INSERT INTO test_enum VALUES('1'),(3);

# 忽略大小写。最终插入的是大写还是小写，以定义字段时候的值为准
INSERT INTO test_enum VALUES('UNKNOW');

# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
INSERT INTO test_enum VALUES(NULL);

# 不允许插入不在定义时指定的字段。Data truncated for column 'season' at row 1
INSERT INTO test_enum VALUES('ab');

# 只能插入单个值。Data truncated for column 'season' at row 1
INSERT INTO test_enum VALUES('春,秋');
```

## 12.9 SET类型

### 12.9.1 类型介绍

当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L表示实际成员个数） | 占用的存储空间 |
| --------------------------------- | -------------- |
| 1 <= L <= 8                       | 1个字节        |
| 9 <= L <= 16                      | 2个字节        |
| 17 <= L <= 24                     | 3个字节        |
| 25 <= L <= 32                     | 4个字节        |
| 33 <= L <= 64                     | 8个字节        |

<p><front style="background: yellow">说明：</front></p>

- SET表示一个字符串对象，可以包含0个或多个成员，成员上线为64
- SET存储多个成员时，成员之间用英文逗号隔开
- SET类型在存储数据时成员个数越多，其占用的存储空间越大。

### 12.9.2 使用

```mysql
# 创建表
CREATE TABLE test_set(
	s SET ('A', 'B', 'C')
);

# 可以插入0个或多个数据
INSERT INTO test_set (s) VALUES ('A'), ('A,B');
# 插入时，忽略大小写。最终插入结果以定义的时候为准
INSERT INTO test_set (s) VALUES ('a')

#插入重复的SET类型成员时，MySQL会自动删除重复的成员
INSERT INTO test_set (s) VALUES ('A,B,C,A');

#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。Data truncated for column 's' at row 1
INSERT INTO test_set (s) VALUES ('A,B,C,D');

# 当SET类型的字段没有声明为NOT NULL时，插入NULL也是有效的
INSERT INTO test_set (s) VALUES (NULL);
```

## 12.10 二进制字符串类型

### 12.10.1 类型介绍

- MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数 据。
- MySQL中支持的二进制字符串类型主要包括`BINARY`、`VARBINARY`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和` LONGBLOB`类型。

### 12.10.2 BINARY与VARBINARY

> 类型介绍

| 类型         | 特点     | 值的长度             | 占用空间  |
| ------------ | -------- | -------------------- | --------- |
| BINARY(M)    | 固定长度 | M （0 <= M <= 255）  | M个字节   |
| VARBINARY(M) | 可变长度 | M（0 <= M <= 65535） | M+1个字节 |

<p><front style="background: yellow">说明：</front></p>

- BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串
- BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数。如果未 指定(M)，表示只能存储 1个字节
- BINARY(M)如果字段值不足(M)个字 节，将在右边填充'\0'以补齐指定长度
- VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，**总字节数不能超过行的字节长 度限制65535**，另外**还要考虑额外字节开销**，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数
- VARBINARY类型**必须指定(M)** 

> 使用

```mysql
# 创建表
CREATE TABLE test_binary1(
	f1 BINARY,
	f2 BINARY(3),
#	f3 VARBINARY,
	f4 VARBINARY(10)
);

# 插入成功
INSERT INTO test_binary1(f1,f2) VALUES('a','a');

# 插入成功，但是查询出来是乱码
INSERT INTO test_binary1(f2) VALUES('一');

# 插入成功
INSERT INTO test_binary1(f2,f4) VALUES('ab','ab');

# 在f2、f4插入'ab'时，对应的LENGTH(f2) = 3, LENGTH(f4) = 2
SELECT LENGTH(f2), LENGTH(f4) FROM test_binary1;
```

### 12.10.3 BLOB

> 类型介绍

| 类型       | 长度范围                          | 占用空间     |
| ---------- | --------------------------------- | ------------ |
| TINYBLOB   | 0 <= L <= 255                     | L + 1 个字节 |
| BLOB       | 0 <= L <= 65535（相当于64KB）     | L + 2 个字节 |
| MEDIUMBLOB | 0 <= L <= 16777215 （相当于16MB） | L + 3 个字节 |
| LONGBLOB   | 0 <= L <= 4294967295（相当于4GB） | L + 4个字节  |

<p><front style="background: yellow">说明：</front></p>

- BLOB是一个**二进制大对象** ，可以容纳可变数量的数据。
- BLOB类型可以存储一个二进制的大对象，比如**图片** 、**音频**和**视频**等
- 但是实际工作中，图片等一般都保存在服务器的磁盘上，数据库存储的是图片等的访问路径

> 使用

```mysql
# 创建表
CREATE TABLE test_blob1(
    id INT,
    img MEDIUMBLOB
);
```

> TEXT和BLOB的使用注意事项

在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。

-  ① 在执行了大量的删除或更新操作的时候，删除text和blob类型的值会在数据表中留下很大的"`空洞`"，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用`OPTIMIZE TABLE`功能对这类表进行**碎片整理** 。 
-  ② 尽量**避免检索大型的BLOB或TEXT值**。如果需要对大文本字段进行模糊查询，MySQL 提供了`前缀索引` 。
-  ③ 把BLOB或TEXT列**分离到单独的表** 中。这样做的好处是：减少主表中的碎片 ，并且当主数据表上运行 SELECT * 查询的时候不会通过 网络传输大量的BLOB或TEXT值。

## 12.11 JSON类型

> 使用

```mysql
# 创建表
CREATE TABLE test_json (
	f1 JSON
);

# 插入数据
INSERT INTO test_json VALUES ('{"name": "tth", "age": 18, "address": {"province": "山东", "city": "济南"}}')
# 查询
SELECT * FROM test_json;

# 查询json类型字段中的具体属性的值
# 方法一：使用->
SELECT f1 -> '$.name' NAME, f1 -> '$.age' age, f1 -> '$.address.province' province, f1 ->'$.address.city' city
FROM test_json; # NAME、province、city中带有""
# 方法二：使用->>
SELECT f1 ->> '$.name' NAME, f1 ->> '$.age' age, f1 ->> '$.address.province' province, f1 ->>'$.address.city' city
FROM test_json; # NAME、province、city中不带""
```

## 12.12 空间类型

略

## 12.13 小结

**阿里巴巴《Java开发手册》之MySQL数据库：**

- 任何字段如果为非负数，必须是 UNSIGNED 
- 【 **强制** 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。
  -  说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得 到不正确的结果。
  -  如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。 
- 【 **强制** 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。 
- 【 **强制** 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大 于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
